import { g as Mg, a as Yn, c as ka } from "../chunks/_commonjsHelpers.BVfed4GL.js";
import { r as lx, C as cx, R as hx } from "../chunks/image.BtlPhXJa.js";
import { c as dx } from "../chunks/component.styles.BLcT4bOa.js";
import { c as fx } from "../chunks/custom-element.X6y1saJZ.js";
import { w as ds } from "../chunks/watch.ChG-_stu.js";
import { i as px, x as Rv } from "../chunks/lit-element.DRlPF2me.js";
import { n as fs } from "../chunks/property.CtZ87in4.js";
import { r as Qn } from "../chunks/state.-o_YRGMi.js";
import { e as nh } from "../chunks/query.BNveAlQo.js";
import { r as vx } from "../chunks/query-async.DsOC4YLE.js";
import { e as mx } from "../chunks/class-map.Cn0czwWq.js";
import { n as Iv } from "../chunks/when.CDK1Tt5Y.js";
import gx from "./icon.js";
import yx from "./resize-observer.js";
import _x from "./skeleton.js";
import bx from "./space.js";
import xx from "./tooltip.js";
import { INACTIVITY_TIMEOUT as Ax, AUTOPLAY_TIMEOUT as Tx } from "./video.constants.js";
function He(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Us(e, t) {
  return Us = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Us(e, t);
}
function Se(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Us(e, t);
}
const Ex = {}, wx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Ex
}, Symbol.toStringTag, { value: "Module" })), Sx = /* @__PURE__ */ Mg(wx);
var Ov = typeof ka < "u" ? ka : typeof window < "u" ? window : {}, Cx = Sx, tu;
typeof document < "u" ? tu = document : (tu = Ov["__GLOBAL_DOCUMENT_CACHE@4"], tu || (tu = Ov["__GLOBAL_DOCUMENT_CACHE@4"] = Cx));
var Dg = tu;
const Te = /* @__PURE__ */ Yn(Dg);
var iu;
typeof window < "u" ? iu = window : typeof ka < "u" ? iu = ka : typeof self < "u" ? iu = self : iu = {};
var ah = iu;
const W = /* @__PURE__ */ Yn(ah);
Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52));
Number.isInteger === void 0 && (Number.isInteger = function(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
});
Math.sign === void 0 && (Math.sign = function(e) {
  return e < 0 ? -1 : e > 0 ? 1 : +e;
});
"name" in Function.prototype || Object.defineProperty(Function.prototype, "name", {
  get: function() {
    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
  }
});
Object.assign === void 0 && function() {
  Object.assign = function(e) {
    if (e == null)
      throw new TypeError("Cannot convert undefined or null to object");
    for (var t = Object(e), i = 1; i < arguments.length; i++) {
      var n = arguments[i];
      if (n != null)
        for (var r in n)
          Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  };
}();
function Kn() {
}
Object.assign(Kn.prototype, {
  addEventListener: function(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    var i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  },
  hasEventListener: function(e, t) {
    if (this._listeners === void 0) return !1;
    var i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  },
  removeEventListener: function(e, t) {
    if (this._listeners !== void 0) {
      var i = this._listeners, n = i[e];
      if (n !== void 0) {
        var r = n.indexOf(t);
        r !== -1 && n.splice(r, 1);
      }
    }
  },
  dispatchEvent: function(e) {
    if (this._listeners !== void 0) {
      var t = this._listeners, i = t[e.type];
      if (i !== void 0) {
        e.target = this;
        for (var n = i.slice(0), r = 0, a = n.length; r < a; r++)
          n[r].call(this, e);
      }
    }
  }
});
var Pg = "93", Mx = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, Lg = 0, Ed = 1, Rg = 2, Dx = 3, Px = 0, Lx = 1, Rx = 0, Tf = 1, Ig = 2, _l = 0, Ti = 1, Io = 2, Ef = 1, Ix = 2, sh = 0, wf = 1, ps = 2, oc = 0, bl = 1, Sf = 2, Cf = 3, Mf = 4, Df = 5, Pf = 100, Og = 101, kg = 102, wd = 103, Sd = 104, Bg = 200, Fg = 201, Ng = 202, Ug = 203, Lf = 204, Rf = 205, jg = 206, Gg = 207, Vg = 208, Hg = 209, zg = 210, Wg = 0, qg = 1, Xg = 2, uc = 3, Yg = 4, Qg = 5, Kg = 6, Zg = 7, xl = 0, Jg = 1, $g = 2, $l = 0, If = 1, e0 = 2, t0 = 3, i0 = 4, oh = 300, uh = 301, lc = 302, Of = 303, cc = 304, kf = 305, lh = 306, ch = 307, In = 1e3, Er = 1001, Va = 1002, wr = 1003, hh = 1004, dh = 1005, Gi = 1006, Bf = 1007, Al = 1008, fh = 1009, r0 = 1010, n0 = 1011, vu = 1012, a0 = 1013, Ff = 1014, js = 1015, ph = 1016, s0 = 1017, o0 = 1018, u0 = 1019, mu = 1020, l0 = 1021, Ha = 1022, gn = 1023, c0 = 1024, h0 = 1025, Ox = gn, Ba = 1026, Gs = 1027, Cd = 33776, Md = 33777, Dd = 33778, Pd = 33779, Ld = 35840, Rd = 35841, Id = 35842, Od = 35843, d0 = 36196, f0 = 37808, p0 = 37809, v0 = 37810, m0 = 37811, g0 = 37812, y0 = 37813, _0 = 37814, b0 = 37815, x0 = 37816, A0 = 37817, T0 = 37818, E0 = 37819, w0 = 37820, S0 = 37821, C0 = 2200, M0 = 2201, D0 = 2202, gu = 2300, uu = 2301, ec = 2302, za = 2400, Ra = 2401, yu = 2402, Nf = 0, P0 = 1, L0 = 2, _u = 3e3, R0 = 3001, Uf = 3007, I0 = 3002, kx = 3003, O0 = 3004, k0 = 3005, B0 = 3006, F0 = 3200, N0 = 3201, gt = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    for (var e = [], t = 0; t < 256; t++)
      e[t] = (t < 16 ? "0" : "") + t.toString(16);
    return function() {
      var n = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0, a = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0, o = e[n & 255] + e[n >> 8 & 255] + e[n >> 16 & 255] + e[n >> 24 & 255] + "-" + e[r & 255] + e[r >> 8 & 255] + "-" + e[r >> 16 & 15 | 64] + e[r >> 24 & 255] + "-" + e[a & 63 | 128] + e[a >> 8 & 255] + "-" + e[a >> 16 & 255] + e[a >> 24 & 255] + e[s & 255] + e[s >> 8 & 255] + e[s >> 16 & 255] + e[s >> 24 & 255];
      return o.toUpperCase();
    };
  }(),
  clamp: function(e, t, i) {
    return Math.max(t, Math.min(i, e));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function(e, t) {
    return (e % t + t) % t;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function(e, t, i, n, r) {
    return n + (e - t) * (r - n) / (i - t);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function(e, t, i) {
    return (1 - i) * e + i * t;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function(e, t, i) {
    return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t), e * e * (3 - 2 * e));
  },
  smootherstep: function(e, t, i) {
    return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t), e * e * e * (e * (e * 6 - 15) + 10));
  },
  // Random integer from <low, high> interval
  randInt: function(e, t) {
    return e + Math.floor(Math.random() * (t - e + 1));
  },
  // Random float from <low, high> interval
  randFloat: function(e, t) {
    return e + Math.random() * (t - e);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function(e) {
    return e * (0.5 - Math.random());
  },
  degToRad: function(e) {
    return e * gt.DEG2RAD;
  },
  radToDeg: function(e) {
    return e * gt.RAD2DEG;
  },
  isPowerOfTwo: function(e) {
    return (e & e - 1) === 0 && e !== 0;
  },
  ceilPowerOfTwo: function(e) {
    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
  },
  floorPowerOfTwo: function(e) {
    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
  }
};
function ue(e, t) {
  this.x = e || 0, this.y = t || 0;
}
Object.defineProperties(ue.prototype, {
  width: {
    get: function() {
      return this.x;
    },
    set: function(e) {
      this.x = e;
    }
  },
  height: {
    get: function() {
      return this.y;
    },
    set: function(e) {
      this.y = e;
    }
  }
});
Object.assign(ue.prototype, {
  isVector2: !0,
  set: function(e, t) {
    return this.x = e, this.y = t, this;
  },
  setScalar: function(e) {
    return this.x = e, this.y = e, this;
  },
  setX: function(e) {
    return this.x = e, this;
  },
  setY: function(e) {
    return this.y = e, this;
  },
  setComponent: function(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  },
  getComponent: function(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y);
  },
  copy: function(e) {
    return this.x = e.x, this.y = e.y, this;
  },
  add: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this);
  },
  addScalar: function(e) {
    return this.x += e, this.y += e, this;
  },
  addVectors: function(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  },
  addScaledVector: function(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  },
  sub: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this);
  },
  subScalar: function(e) {
    return this.x -= e, this.y -= e, this;
  },
  subVectors: function(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  },
  multiply: function(e) {
    return this.x *= e.x, this.y *= e.y, this;
  },
  multiplyScalar: function(e) {
    return this.x *= e, this.y *= e, this;
  },
  divide: function(e) {
    return this.x /= e.x, this.y /= e.y, this;
  },
  divideScalar: function(e) {
    return this.multiplyScalar(1 / e);
  },
  applyMatrix3: function(e) {
    var t = this.x, i = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
  },
  min: function(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  },
  max: function(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  },
  clamp: function(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  },
  clampScalar: function() {
    var e = new ue(), t = new ue();
    return function(n, r) {
      return e.set(n, n), t.set(r, r), this.clamp(e, t);
    };
  }(),
  clampLength: function(e, t) {
    var i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this;
  },
  dot: function(e) {
    return this.x * e.x + this.y * e.y;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  angle: function() {
    var e = Math.atan2(this.y, this.x);
    return e < 0 && (e += 2 * Math.PI), e;
  },
  distanceTo: function(e) {
    return Math.sqrt(this.distanceToSquared(e));
  },
  distanceToSquared: function(e) {
    var t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  },
  manhattanDistanceTo: function(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  },
  setLength: function(e) {
    return this.normalize().multiplyScalar(e);
  },
  lerp: function(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  },
  lerpVectors: function(e, t, i) {
    return this.subVectors(t, e).multiplyScalar(i).add(e);
  },
  equals: function(e) {
    return e.x === this.x && e.y === this.y;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e;
  },
  fromBufferAttribute: function(e, t, i) {
    return i !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this;
  },
  rotateAround: function(e, t) {
    var i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
    return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this;
  }
});
function at() {
  this.elements = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(at.prototype, {
  isMatrix4: !0,
  set: function(e, t, i, n, r, a, s, o, u, l, c, h, d, f, p, _) {
    var m = this.elements;
    return m[0] = e, m[4] = t, m[8] = i, m[12] = n, m[1] = r, m[5] = a, m[9] = s, m[13] = o, m[2] = u, m[6] = l, m[10] = c, m[14] = h, m[3] = d, m[7] = f, m[11] = p, m[15] = _, this;
  },
  identity: function() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  clone: function() {
    return new at().fromArray(this.elements);
  },
  copy: function(e) {
    var t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  },
  copyPosition: function(e) {
    var t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  },
  extractBasis: function(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  },
  makeBasis: function(e, t, i) {
    return this.set(
      e.x,
      t.x,
      i.x,
      0,
      e.y,
      t.y,
      i.y,
      0,
      e.z,
      t.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  extractRotation: function() {
    var e = new H();
    return function(i) {
      var n = this.elements, r = i.elements, a = 1 / e.setFromMatrixColumn(i, 0).length(), s = 1 / e.setFromMatrixColumn(i, 1).length(), o = 1 / e.setFromMatrixColumn(i, 2).length();
      return n[0] = r[0] * a, n[1] = r[1] * a, n[2] = r[2] * a, n[3] = 0, n[4] = r[4] * s, n[5] = r[5] * s, n[6] = r[6] * s, n[7] = 0, n[8] = r[8] * o, n[9] = r[9] * o, n[10] = r[10] * o, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
    };
  }(),
  makeRotationFromEuler: function(e) {
    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    var t = this.elements, i = e.x, n = e.y, r = e.z, a = Math.cos(i), s = Math.sin(i), o = Math.cos(n), u = Math.sin(n), l = Math.cos(r), c = Math.sin(r);
    if (e.order === "XYZ") {
      var h = a * l, d = a * c, f = s * l, p = s * c;
      t[0] = o * l, t[4] = -o * c, t[8] = u, t[1] = d + f * u, t[5] = h - p * u, t[9] = -s * o, t[2] = p - h * u, t[6] = f + d * u, t[10] = a * o;
    } else if (e.order === "YXZ") {
      var _ = o * l, m = o * c, x = u * l, E = u * c;
      t[0] = _ + E * s, t[4] = x * s - m, t[8] = a * u, t[1] = a * c, t[5] = a * l, t[9] = -s, t[2] = m * s - x, t[6] = E + _ * s, t[10] = a * o;
    } else if (e.order === "ZXY") {
      var _ = o * l, m = o * c, x = u * l, E = u * c;
      t[0] = _ - E * s, t[4] = -a * c, t[8] = x + m * s, t[1] = m + x * s, t[5] = a * l, t[9] = E - _ * s, t[2] = -a * u, t[6] = s, t[10] = a * o;
    } else if (e.order === "ZYX") {
      var h = a * l, d = a * c, f = s * l, p = s * c;
      t[0] = o * l, t[4] = f * u - d, t[8] = h * u + p, t[1] = o * c, t[5] = p * u + h, t[9] = d * u - f, t[2] = -u, t[6] = s * o, t[10] = a * o;
    } else if (e.order === "YZX") {
      var M = a * o, C = a * u, R = s * o, k = s * u;
      t[0] = o * l, t[4] = k - M * c, t[8] = R * c + C, t[1] = c, t[5] = a * l, t[9] = -s * l, t[2] = -u * l, t[6] = C * c + R, t[10] = M - k * c;
    } else if (e.order === "XZY") {
      var M = a * o, C = a * u, R = s * o, k = s * u;
      t[0] = o * l, t[4] = -c, t[8] = u * l, t[1] = M * c + k, t[5] = a * l, t[9] = C * c - R, t[2] = R * c - C, t[6] = s * l, t[10] = k * c + M;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  },
  makeRotationFromQuaternion: function() {
    var e = new H(0, 0, 0), t = new H(1, 1, 1);
    return function(n) {
      return this.compose(e, n, t);
    };
  }(),
  lookAt: function() {
    var e = new H(), t = new H(), i = new H();
    return function(r, a, s) {
      var o = this.elements;
      return i.subVectors(r, a), i.lengthSq() === 0 && (i.z = 1), i.normalize(), e.crossVectors(s, i), e.lengthSq() === 0 && (Math.abs(s.z) === 1 ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), e.crossVectors(s, i)), e.normalize(), t.crossVectors(i, e), o[0] = e.x, o[4] = t.x, o[8] = i.x, o[1] = e.y, o[5] = t.y, o[9] = i.y, o[2] = e.z, o[6] = t.z, o[10] = i.z, this;
    };
  }(),
  multiply: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e);
  },
  premultiply: function(e) {
    return this.multiplyMatrices(e, this);
  },
  multiplyMatrices: function(e, t) {
    var i = e.elements, n = t.elements, r = this.elements, a = i[0], s = i[4], o = i[8], u = i[12], l = i[1], c = i[5], h = i[9], d = i[13], f = i[2], p = i[6], _ = i[10], m = i[14], x = i[3], E = i[7], M = i[11], C = i[15], R = n[0], k = n[4], F = n[8], B = n[12], I = n[1], V = n[5], Q = n[9], ee = n[13], oe = n[2], fe = n[6], he = n[10], de = n[14], G = n[3], j = n[7], se = n[11], ie = n[15];
    return r[0] = a * R + s * I + o * oe + u * G, r[4] = a * k + s * V + o * fe + u * j, r[8] = a * F + s * Q + o * he + u * se, r[12] = a * B + s * ee + o * de + u * ie, r[1] = l * R + c * I + h * oe + d * G, r[5] = l * k + c * V + h * fe + d * j, r[9] = l * F + c * Q + h * he + d * se, r[13] = l * B + c * ee + h * de + d * ie, r[2] = f * R + p * I + _ * oe + m * G, r[6] = f * k + p * V + _ * fe + m * j, r[10] = f * F + p * Q + _ * he + m * se, r[14] = f * B + p * ee + _ * de + m * ie, r[3] = x * R + E * I + M * oe + C * G, r[7] = x * k + E * V + M * fe + C * j, r[11] = x * F + E * Q + M * he + C * se, r[15] = x * B + E * ee + M * de + C * ie, this;
  },
  multiplyScalar: function(e) {
    var t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  },
  applyToBufferAttribute: function() {
    var e = new H();
    return function(i) {
      for (var n = 0, r = i.count; n < r; n++)
        e.x = i.getX(n), e.y = i.getY(n), e.z = i.getZ(n), e.applyMatrix4(this), i.setXYZ(n, e.x, e.y, e.z);
      return i;
    };
  }(),
  determinant: function() {
    var e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], a = e[1], s = e[5], o = e[9], u = e[13], l = e[2], c = e[6], h = e[10], d = e[14], f = e[3], p = e[7], _ = e[11], m = e[15];
    return f * (+r * o * c - n * u * c - r * s * h + i * u * h + n * s * d - i * o * d) + p * (+t * o * d - t * u * h + r * a * h - n * a * d + n * u * l - r * o * l) + _ * (+t * u * c - t * s * d - r * a * c + i * a * d + r * s * l - i * u * l) + m * (-n * s * l - t * o * c + t * s * h + n * a * c - i * a * h + i * o * l);
  },
  transpose: function() {
    var e = this.elements, t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  },
  setPosition: function(e) {
    var t = this.elements;
    return t[12] = e.x, t[13] = e.y, t[14] = e.z, this;
  },
  getInverse: function(e, t) {
    var i = this.elements, n = e.elements, r = n[0], a = n[1], s = n[2], o = n[3], u = n[4], l = n[5], c = n[6], h = n[7], d = n[8], f = n[9], p = n[10], _ = n[11], m = n[12], x = n[13], E = n[14], M = n[15], C = f * E * h - x * p * h + x * c * _ - l * E * _ - f * c * M + l * p * M, R = m * p * h - d * E * h - m * c * _ + u * E * _ + d * c * M - u * p * M, k = d * x * h - m * f * h + m * l * _ - u * x * _ - d * l * M + u * f * M, F = m * f * c - d * x * c - m * l * p + u * x * p + d * l * E - u * f * E, B = r * C + a * R + s * k + o * F;
    if (B === 0) {
      var I = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
      if (t === !0)
        throw new Error(I);
      return console.warn(I), this.identity();
    }
    var V = 1 / B;
    return i[0] = C * V, i[1] = (x * p * o - f * E * o - x * s * _ + a * E * _ + f * s * M - a * p * M) * V, i[2] = (l * E * o - x * c * o + x * s * h - a * E * h - l * s * M + a * c * M) * V, i[3] = (f * c * o - l * p * o - f * s * h + a * p * h + l * s * _ - a * c * _) * V, i[4] = R * V, i[5] = (d * E * o - m * p * o + m * s * _ - r * E * _ - d * s * M + r * p * M) * V, i[6] = (m * c * o - u * E * o - m * s * h + r * E * h + u * s * M - r * c * M) * V, i[7] = (u * p * o - d * c * o + d * s * h - r * p * h - u * s * _ + r * c * _) * V, i[8] = k * V, i[9] = (m * f * o - d * x * o - m * a * _ + r * x * _ + d * a * M - r * f * M) * V, i[10] = (u * x * o - m * l * o + m * a * h - r * x * h - u * a * M + r * l * M) * V, i[11] = (d * l * o - u * f * o - d * a * h + r * f * h + u * a * _ - r * l * _) * V, i[12] = F * V, i[13] = (d * x * s - m * f * s + m * a * p - r * x * p - d * a * E + r * f * E) * V, i[14] = (m * l * s - u * x * s - m * a * c + r * x * c + u * a * E - r * l * E) * V, i[15] = (u * f * s - d * l * s + d * a * c - r * f * c - u * a * p + r * l * p) * V, this;
  },
  scale: function(e) {
    var t = this.elements, i = e.x, n = e.y, r = e.z;
    return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this;
  },
  getMaxScaleOnAxis: function() {
    var e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, n));
  },
  makeTranslation: function(e, t, i) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationX: function(e) {
    var t = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationY: function(e) {
    var t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationZ: function(e) {
    var t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationAxis: function(e, t) {
    var i = Math.cos(t), n = Math.sin(t), r = 1 - i, a = e.x, s = e.y, o = e.z, u = r * a, l = r * s;
    return this.set(
      u * a + i,
      u * s - n * o,
      u * o + n * s,
      0,
      u * s + n * o,
      l * s + i,
      l * o - n * a,
      0,
      u * o - n * s,
      l * o + n * a,
      r * o * o + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeScale: function(e, t, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeShear: function(e, t, i) {
    return this.set(
      1,
      t,
      i,
      0,
      e,
      1,
      i,
      0,
      e,
      t,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  compose: function(e, t, i) {
    var n = this.elements, r = t._x, a = t._y, s = t._z, o = t._w, u = r + r, l = a + a, c = s + s, h = r * u, d = r * l, f = r * c, p = a * l, _ = a * c, m = s * c, x = o * u, E = o * l, M = o * c, C = i.x, R = i.y, k = i.z;
    return n[0] = (1 - (p + m)) * C, n[1] = (d + M) * C, n[2] = (f - E) * C, n[3] = 0, n[4] = (d - M) * R, n[5] = (1 - (h + m)) * R, n[6] = (_ + x) * R, n[7] = 0, n[8] = (f + E) * k, n[9] = (_ - x) * k, n[10] = (1 - (h + p)) * k, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  },
  decompose: function() {
    var e = new H(), t = new at();
    return function(n, r, a) {
      var s = this.elements, o = e.set(s[0], s[1], s[2]).length(), u = e.set(s[4], s[5], s[6]).length(), l = e.set(s[8], s[9], s[10]).length(), c = this.determinant();
      c < 0 && (o = -o), n.x = s[12], n.y = s[13], n.z = s[14], t.copy(this);
      var h = 1 / o, d = 1 / u, f = 1 / l;
      return t.elements[0] *= h, t.elements[1] *= h, t.elements[2] *= h, t.elements[4] *= d, t.elements[5] *= d, t.elements[6] *= d, t.elements[8] *= f, t.elements[9] *= f, t.elements[10] *= f, r.setFromRotationMatrix(t), a.x = o, a.y = u, a.z = l, this;
    };
  }(),
  makePerspective: function(e, t, i, n, r, a) {
    a === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    var s = this.elements, o = 2 * r / (t - e), u = 2 * r / (i - n), l = (t + e) / (t - e), c = (i + n) / (i - n), h = -(a + r) / (a - r), d = -2 * a * r / (a - r);
    return s[0] = o, s[4] = 0, s[8] = l, s[12] = 0, s[1] = 0, s[5] = u, s[9] = c, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this;
  },
  makeOrthographic: function(e, t, i, n, r, a) {
    var s = this.elements, o = 1 / (t - e), u = 1 / (i - n), l = 1 / (a - r), c = (t + e) * o, h = (i + n) * u, d = (a + r) * l;
    return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -c, s[1] = 0, s[5] = 2 * u, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = -2 * l, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this;
  },
  equals: function(e) {
    for (var t = this.elements, i = e.elements, n = 0; n < 16; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  },
  fromArray: function(e, t) {
    t === void 0 && (t = 0);
    for (var i = 0; i < 16; i++)
      this.elements[i] = e[i + t];
    return this;
  },
  toArray: function(e, t) {
    e === void 0 && (e = []), t === void 0 && (t = 0);
    var i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
});
function _i(e, t, i, n) {
  this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = n !== void 0 ? n : 1;
}
Object.assign(_i, {
  slerp: function(e, t, i, n) {
    return i.copy(e).slerp(t, n);
  },
  slerpFlat: function(e, t, i, n, r, a, s) {
    var o = i[n + 0], u = i[n + 1], l = i[n + 2], c = i[n + 3], h = r[a + 0], d = r[a + 1], f = r[a + 2], p = r[a + 3];
    if (c !== p || o !== h || u !== d || l !== f) {
      var _ = 1 - s, m = o * h + u * d + l * f + c * p, x = m >= 0 ? 1 : -1, E = 1 - m * m;
      if (E > Number.EPSILON) {
        var M = Math.sqrt(E), C = Math.atan2(M, m * x);
        _ = Math.sin(_ * C) / M, s = Math.sin(s * C) / M;
      }
      var R = s * x;
      if (o = o * _ + h * R, u = u * _ + d * R, l = l * _ + f * R, c = c * _ + p * R, _ === 1 - s) {
        var k = 1 / Math.sqrt(o * o + u * u + l * l + c * c);
        o *= k, u *= k, l *= k, c *= k;
      }
    }
    e[t] = o, e[t + 1] = u, e[t + 2] = l, e[t + 3] = c;
  }
});
Object.defineProperties(_i.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(e) {
      this._x = e, this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(e) {
      this._y = e, this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(e) {
      this._z = e, this.onChangeCallback();
    }
  },
  w: {
    get: function() {
      return this._w;
    },
    set: function(e) {
      this._w = e, this.onChangeCallback();
    }
  }
});
Object.assign(_i.prototype, {
  set: function(e, t, i, n) {
    return this._x = e, this._y = t, this._z = i, this._w = n, this.onChangeCallback(), this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this;
  },
  setFromEuler: function(e, t) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    var i = e._x, n = e._y, r = e._z, a = e.order, s = Math.cos, o = Math.sin, u = s(i / 2), l = s(n / 2), c = s(r / 2), h = o(i / 2), d = o(n / 2), f = o(r / 2);
    return a === "XYZ" ? (this._x = h * l * c + u * d * f, this._y = u * d * c - h * l * f, this._z = u * l * f + h * d * c, this._w = u * l * c - h * d * f) : a === "YXZ" ? (this._x = h * l * c + u * d * f, this._y = u * d * c - h * l * f, this._z = u * l * f - h * d * c, this._w = u * l * c + h * d * f) : a === "ZXY" ? (this._x = h * l * c - u * d * f, this._y = u * d * c + h * l * f, this._z = u * l * f + h * d * c, this._w = u * l * c - h * d * f) : a === "ZYX" ? (this._x = h * l * c - u * d * f, this._y = u * d * c + h * l * f, this._z = u * l * f - h * d * c, this._w = u * l * c + h * d * f) : a === "YZX" ? (this._x = h * l * c + u * d * f, this._y = u * d * c + h * l * f, this._z = u * l * f - h * d * c, this._w = u * l * c - h * d * f) : a === "XZY" && (this._x = h * l * c - u * d * f, this._y = u * d * c - h * l * f, this._z = u * l * f + h * d * c, this._w = u * l * c + h * d * f), t !== !1 && this.onChangeCallback(), this;
  },
  setFromAxisAngle: function(e, t) {
    var i = t / 2, n = Math.sin(i);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this.onChangeCallback(), this;
  },
  setFromRotationMatrix: function(e) {
    var t = e.elements, i = t[0], n = t[4], r = t[8], a = t[1], s = t[5], o = t[9], u = t[2], l = t[6], c = t[10], h = i + s + c, d;
    return h > 0 ? (d = 0.5 / Math.sqrt(h + 1), this._w = 0.25 / d, this._x = (l - o) * d, this._y = (r - u) * d, this._z = (a - n) * d) : i > s && i > c ? (d = 2 * Math.sqrt(1 + i - s - c), this._w = (l - o) / d, this._x = 0.25 * d, this._y = (n + a) / d, this._z = (r + u) / d) : s > c ? (d = 2 * Math.sqrt(1 + s - i - c), this._w = (r - u) / d, this._x = (n + a) / d, this._y = 0.25 * d, this._z = (o + l) / d) : (d = 2 * Math.sqrt(1 + c - i - s), this._w = (a - n) / d, this._x = (r + u) / d, this._y = (o + l) / d, this._z = 0.25 * d), this.onChangeCallback(), this;
  },
  setFromUnitVectors: function() {
    var e = new H(), t, i = 1e-6;
    return function(r, a) {
      return e === void 0 && (e = new H()), t = r.dot(a) + 1, t < i ? (t = 0, Math.abs(r.x) > Math.abs(r.z) ? e.set(-r.y, r.x, 0) : e.set(0, -r.z, r.y)) : e.crossVectors(r, a), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize();
    };
  }(),
  inverse: function() {
    return this.conjugate();
  },
  conjugate: function() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
  },
  dot: function(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  },
  lengthSq: function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function() {
    var e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this;
  },
  multiply: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e);
  },
  premultiply: function(e) {
    return this.multiplyQuaternions(e, this);
  },
  multiplyQuaternions: function(e, t) {
    var i = e._x, n = e._y, r = e._z, a = e._w, s = t._x, o = t._y, u = t._z, l = t._w;
    return this._x = i * l + a * s + n * u - r * o, this._y = n * l + a * o + r * s - i * u, this._z = r * l + a * u + i * o - n * s, this._w = a * l - i * s - n * o - r * u, this.onChangeCallback(), this;
  },
  slerp: function(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    var i = this._x, n = this._y, r = this._z, a = this._w, s = a * e._w + i * e._x + n * e._y + r * e._z;
    if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1)
      return this._w = a, this._x = i, this._y = n, this._z = r, this;
    var o = Math.sqrt(1 - s * s);
    if (Math.abs(o) < 1e-3)
      return this._w = 0.5 * (a + this._w), this._x = 0.5 * (i + this._x), this._y = 0.5 * (n + this._y), this._z = 0.5 * (r + this._z), this;
    var u = Math.atan2(o, s), l = Math.sin((1 - t) * u) / o, c = Math.sin(t * u) / o;
    return this._w = a * l + this._w * c, this._x = i * l + this._x * c, this._y = n * l + this._y * c, this._z = r * l + this._z * c, this.onChangeCallback(), this;
  },
  equals: function(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  },
  onChange: function(e) {
    return this.onChangeCallback = e, this;
  },
  onChangeCallback: function() {
  }
});
function H(e, t, i) {
  this.x = e || 0, this.y = t || 0, this.z = i || 0;
}
Object.assign(H.prototype, {
  isVector3: !0,
  set: function(e, t, i) {
    return this.x = e, this.y = t, this.z = i, this;
  },
  setScalar: function(e) {
    return this.x = e, this.y = e, this.z = e, this;
  },
  setX: function(e) {
    return this.x = e, this;
  },
  setY: function(e) {
    return this.y = e, this;
  },
  setZ: function(e) {
    return this.z = e, this;
  },
  setComponent: function(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  },
  getComponent: function(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  },
  add: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this);
  },
  addScalar: function(e) {
    return this.x += e, this.y += e, this.z += e, this;
  },
  addVectors: function(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  },
  addScaledVector: function(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  },
  sub: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
  },
  subScalar: function(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  },
  subVectors: function(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  },
  multiply: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
  },
  multiplyScalar: function(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  },
  multiplyVectors: function(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  },
  applyEuler: function() {
    var e = new _i();
    return function(i) {
      return i && i.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(e.setFromEuler(i));
    };
  }(),
  applyAxisAngle: function() {
    var e = new _i();
    return function(i, n) {
      return this.applyQuaternion(e.setFromAxisAngle(i, n));
    };
  }(),
  applyMatrix3: function(e) {
    var t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this;
  },
  applyMatrix4: function(e) {
    var t = this.x, i = this.y, n = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
    return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a, this;
  },
  applyQuaternion: function(e) {
    var t = this.x, i = this.y, n = this.z, r = e.x, a = e.y, s = e.z, o = e.w, u = o * t + a * n - s * i, l = o * i + s * t - r * n, c = o * n + r * i - a * t, h = -r * t - a * i - s * n;
    return this.x = u * o + h * -r + l * -s - c * -a, this.y = l * o + h * -a + c * -r - u * -s, this.z = c * o + h * -s + u * -a - l * -r, this;
  },
  project: function() {
    var e = new at();
    return function(i) {
      return e.multiplyMatrices(i.projectionMatrix, e.getInverse(i.matrixWorld)), this.applyMatrix4(e);
    };
  }(),
  unproject: function() {
    var e = new at();
    return function(i) {
      return e.multiplyMatrices(i.matrixWorld, e.getInverse(i.projectionMatrix)), this.applyMatrix4(e);
    };
  }(),
  transformDirection: function(e) {
    var t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize();
  },
  divide: function(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  },
  divideScalar: function(e) {
    return this.multiplyScalar(1 / e);
  },
  min: function(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  },
  max: function(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  },
  clamp: function(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  },
  clampScalar: function() {
    var e = new H(), t = new H();
    return function(n, r) {
      return e.set(n, n, n), t.set(r, r, r), this.clamp(e, t);
    };
  }(),
  clampLength: function(e, t) {
    var i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  },
  dot: function(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  },
  // TODO lengthSquared?
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(e) {
    return this.normalize().multiplyScalar(e);
  },
  lerp: function(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  },
  lerpVectors: function(e, t, i) {
    return this.subVectors(t, e).multiplyScalar(i).add(e);
  },
  cross: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e);
  },
  crossVectors: function(e, t) {
    var i = e.x, n = e.y, r = e.z, a = t.x, s = t.y, o = t.z;
    return this.x = n * o - r * s, this.y = r * a - i * o, this.z = i * s - n * a, this;
  },
  projectOnVector: function(e) {
    var t = e.dot(this) / e.lengthSq();
    return this.copy(e).multiplyScalar(t);
  },
  projectOnPlane: function() {
    var e = new H();
    return function(i) {
      return e.copy(this).projectOnVector(i), this.sub(e);
    };
  }(),
  reflect: function() {
    var e = new H();
    return function(i) {
      return this.sub(e.copy(i).multiplyScalar(2 * this.dot(i)));
    };
  }(),
  angleTo: function(e) {
    var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
    return Math.acos(gt.clamp(t, -1, 1));
  },
  distanceTo: function(e) {
    return Math.sqrt(this.distanceToSquared(e));
  },
  distanceToSquared: function(e) {
    var t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
    return t * t + i * i + n * n;
  },
  manhattanDistanceTo: function(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  },
  setFromSpherical: function(e) {
    var t = Math.sin(e.phi) * e.radius;
    return this.x = t * Math.sin(e.theta), this.y = Math.cos(e.phi) * e.radius, this.z = t * Math.cos(e.theta), this;
  },
  setFromCylindrical: function(e) {
    return this.x = e.radius * Math.sin(e.theta), this.y = e.y, this.z = e.radius * Math.cos(e.theta), this;
  },
  setFromMatrixPosition: function(e) {
    var t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  },
  setFromMatrixScale: function(e) {
    var t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = n, this;
  },
  setFromMatrixColumn: function(e, t) {
    return this.fromArray(e.elements, t * 4);
  },
  equals: function(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  },
  fromBufferAttribute: function(e, t, i) {
    return i !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
});
function wi() {
  this.elements = [
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(wi.prototype, {
  isMatrix3: !0,
  set: function(e, t, i, n, r, a, s, o, u) {
    var l = this.elements;
    return l[0] = e, l[1] = n, l[2] = s, l[3] = t, l[4] = r, l[5] = o, l[6] = i, l[7] = a, l[8] = u, this;
  },
  identity: function() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  },
  clone: function() {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function(e) {
    var t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  },
  setFromMatrix4: function(e) {
    var t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  },
  applyToBufferAttribute: function() {
    var e = new H();
    return function(i) {
      for (var n = 0, r = i.count; n < r; n++)
        e.x = i.getX(n), e.y = i.getY(n), e.z = i.getZ(n), e.applyMatrix3(this), i.setXYZ(n, e.x, e.y, e.z);
      return i;
    };
  }(),
  multiply: function(e) {
    return this.multiplyMatrices(this, e);
  },
  premultiply: function(e) {
    return this.multiplyMatrices(e, this);
  },
  multiplyMatrices: function(e, t) {
    var i = e.elements, n = t.elements, r = this.elements, a = i[0], s = i[3], o = i[6], u = i[1], l = i[4], c = i[7], h = i[2], d = i[5], f = i[8], p = n[0], _ = n[3], m = n[6], x = n[1], E = n[4], M = n[7], C = n[2], R = n[5], k = n[8];
    return r[0] = a * p + s * x + o * C, r[3] = a * _ + s * E + o * R, r[6] = a * m + s * M + o * k, r[1] = u * p + l * x + c * C, r[4] = u * _ + l * E + c * R, r[7] = u * m + l * M + c * k, r[2] = h * p + d * x + f * C, r[5] = h * _ + d * E + f * R, r[8] = h * m + d * M + f * k, this;
  },
  multiplyScalar: function(e) {
    var t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  },
  determinant: function() {
    var e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], s = e[5], o = e[6], u = e[7], l = e[8];
    return t * a * l - t * s * u - i * r * l + i * s * o + n * r * u - n * a * o;
  },
  getInverse: function(e, t) {
    e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
    var i = e.elements, n = this.elements, r = i[0], a = i[1], s = i[2], o = i[3], u = i[4], l = i[5], c = i[6], h = i[7], d = i[8], f = d * u - l * h, p = l * c - d * o, _ = h * o - u * c, m = r * f + a * p + s * _;
    if (m === 0) {
      var x = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
      if (t === !0)
        throw new Error(x);
      return console.warn(x), this.identity();
    }
    var E = 1 / m;
    return n[0] = f * E, n[1] = (s * h - d * a) * E, n[2] = (l * a - s * u) * E, n[3] = p * E, n[4] = (d * r - s * c) * E, n[5] = (s * o - l * r) * E, n[6] = _ * E, n[7] = (a * c - h * r) * E, n[8] = (u * r - a * o) * E, this;
  },
  transpose: function() {
    var e, t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  },
  getNormalMatrix: function(e) {
    return this.setFromMatrix4(e).getInverse(this).transpose();
  },
  transposeIntoArray: function(e) {
    var t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  },
  setUvTransform: function(e, t, i, n, r, a, s) {
    var o = Math.cos(r), u = Math.sin(r);
    this.set(
      i * o,
      i * u,
      -i * (o * a + u * s) + a + e,
      -n * u,
      n * o,
      -n * (-u * a + o * s) + s + t,
      0,
      0,
      1
    );
  },
  scale: function(e, t) {
    var i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this;
  },
  rotate: function(e) {
    var t = Math.cos(e), i = Math.sin(e), n = this.elements, r = n[0], a = n[3], s = n[6], o = n[1], u = n[4], l = n[7];
    return n[0] = t * r + i * o, n[3] = t * a + i * u, n[6] = t * s + i * l, n[1] = -i * r + t * o, n[4] = -i * a + t * u, n[7] = -i * s + t * l, this;
  },
  translate: function(e, t) {
    var i = this.elements;
    return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this;
  },
  equals: function(e) {
    for (var t = this.elements, i = e.elements, n = 0; n < 9; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  },
  fromArray: function(e, t) {
    t === void 0 && (t = 0);
    for (var i = 0; i < 9; i++)
      this.elements[i] = e[i + t];
    return this;
  },
  toArray: function(e, t) {
    e === void 0 && (e = []), t === void 0 && (t = 0);
    var i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
});
var Bx = 0;
function ri(e, t, i, n, r, a, s, o, u, l) {
  Object.defineProperty(this, "id", { value: Bx++ }), this.uuid = gt.generateUUID(), this.name = "", this.image = e !== void 0 ? e : ri.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = t !== void 0 ? t : ri.DEFAULT_MAPPING, this.wrapS = i !== void 0 ? i : Er, this.wrapT = n !== void 0 ? n : Er, this.magFilter = r !== void 0 ? r : Gi, this.minFilter = a !== void 0 ? a : Al, this.anisotropy = u !== void 0 ? u : 1, this.format = s !== void 0 ? s : gn, this.type = o !== void 0 ? o : fh, this.offset = new ue(0, 0), this.repeat = new ue(1, 1), this.center = new ue(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new wi(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = l !== void 0 ? l : _u, this.version = 0, this.onUpdate = null;
}
ri.DEFAULT_IMAGE = void 0;
ri.DEFAULT_MAPPING = oh;
ri.prototype = Object.assign(Object.create(Kn.prototype), {
  constructor: ri,
  isTexture: !0,
  updateMatrix: function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this;
  },
  toJSON: function(e) {
    var t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    function i(a) {
      var s;
      if (a instanceof HTMLCanvasElement)
        s = a;
      else {
        s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), s.width = a.width, s.height = a.height;
        var o = s.getContext("2d");
        a instanceof ImageData ? o.putImageData(a, 0, 0) : o.drawImage(a, 0, 0, a.width, a.height);
      }
      return s.width > 2048 || s.height > 2048 ? s.toDataURL("image/jpeg", 0.6) : s.toDataURL("image/png");
    }
    var n = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY
    };
    if (this.image !== void 0) {
      var r = this.image;
      r.uuid === void 0 && (r.uuid = gt.generateUUID()), !t && e.images[r.uuid] === void 0 && (e.images[r.uuid] = {
        uuid: r.uuid,
        url: i(r)
      }), n.image = r.uuid;
    }
    return t || (e.textures[this.uuid] = n), n;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  },
  transformUv: function(e) {
    if (this.mapping === oh) {
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
        switch (this.wrapS) {
          case In:
            e.x = e.x - Math.floor(e.x);
            break;
          case Er:
            e.x = e.x < 0 ? 0 : 1;
            break;
          case Va:
            Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
            break;
        }
      if (e.y < 0 || e.y > 1)
        switch (this.wrapT) {
          case In:
            e.y = e.y - Math.floor(e.y);
            break;
          case Er:
            e.y = e.y < 0 ? 0 : 1;
            break;
          case Va:
            Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
            break;
        }
      this.flipY && (e.y = 1 - e.y);
    }
  }
});
Object.defineProperty(ri.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
function Ft(e, t, i, n) {
  this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = n !== void 0 ? n : 1;
}
Object.assign(Ft.prototype, {
  isVector4: !0,
  set: function(e, t, i, n) {
    return this.x = e, this.y = t, this.z = i, this.w = n, this;
  },
  setScalar: function(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  },
  setX: function(e) {
    return this.x = e, this;
  },
  setY: function(e) {
    return this.y = e, this;
  },
  setZ: function(e) {
    return this.z = e, this;
  },
  setW: function(e) {
    return this.w = e, this;
  },
  setComponent: function(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  },
  getComponent: function(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  },
  add: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this);
  },
  addScalar: function(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  },
  addVectors: function(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  },
  addScaledVector: function(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  },
  sub: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this);
  },
  subScalar: function(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  },
  subVectors: function(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  },
  multiplyScalar: function(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  },
  applyMatrix4: function(e) {
    var t = this.x, i = this.y, n = this.z, r = this.w, a = e.elements;
    return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r, this;
  },
  divideScalar: function(e) {
    return this.multiplyScalar(1 / e);
  },
  setAxisAngleFromQuaternion: function(e) {
    this.w = 2 * Math.acos(e.w);
    var t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  },
  setAxisAngleFromRotationMatrix: function(e) {
    var t, i, n, r, a = 0.01, s = 0.1, o = e.elements, u = o[0], l = o[4], c = o[8], h = o[1], d = o[5], f = o[9], p = o[2], _ = o[6], m = o[10];
    if (Math.abs(l - h) < a && Math.abs(c - p) < a && Math.abs(f - _) < a) {
      if (Math.abs(l + h) < s && Math.abs(c + p) < s && Math.abs(f + _) < s && Math.abs(u + d + m - 3) < s)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      var x = (u + 1) / 2, E = (d + 1) / 2, M = (m + 1) / 2, C = (l + h) / 4, R = (c + p) / 4, k = (f + _) / 4;
      return x > E && x > M ? x < a ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(x), n = C / i, r = R / i) : E > M ? E < a ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(E), i = C / n, r = k / n) : M < a ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(M), i = R / r, n = k / r), this.set(i, n, r, t), this;
    }
    var F = Math.sqrt((_ - f) * (_ - f) + (c - p) * (c - p) + (h - l) * (h - l));
    return Math.abs(F) < 1e-3 && (F = 1), this.x = (_ - f) / F, this.y = (c - p) / F, this.z = (h - l) / F, this.w = Math.acos((u + d + m - 1) / 2), this;
  },
  min: function(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  },
  max: function(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  },
  clamp: function(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  },
  clampScalar: /* @__PURE__ */ function() {
    var e, t;
    return function(n, r) {
      return e === void 0 && (e = new Ft(), t = new Ft()), e.set(n, n, n, n), t.set(r, r, r, r), this.clamp(e, t);
    };
  }(),
  clampLength: function(e, t) {
    var i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  },
  dot: function(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(e) {
    return this.normalize().multiplyScalar(e);
  },
  lerp: function(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  },
  lerpVectors: function(e, t, i) {
    return this.subVectors(t, e).multiplyScalar(i).add(e);
  },
  equals: function(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  },
  fromBufferAttribute: function(e, t, i) {
    return i !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
});
function Wa(e, t, i) {
  this.width = e, this.height = t, this.scissor = new Ft(0, 0, e, t), this.scissorTest = !1, this.viewport = new Ft(0, 0, e, t), i = i || {}, i.minFilter === void 0 && (i.minFilter = Gi), this.texture = new ri(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !0, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !0, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null;
}
Wa.prototype = Object.assign(Object.create(Kn.prototype), {
  constructor: Wa,
  isWebGLRenderTarget: !0,
  setSize: function(e, t) {
    (this.width !== e || this.height !== t) && (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function Vs(e, t, i) {
  Wa.call(this, e, t, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0;
}
Vs.prototype = Object.create(Wa.prototype);
Vs.prototype.constructor = Vs;
Vs.prototype.isWebGLRenderTargetCube = !0;
function qa(e, t, i, n, r, a, s, o, u, l, c, h) {
  ri.call(this, null, a, s, o, u, l, n, r, c, h), this.image = { data: e, width: t, height: i }, this.magFilter = u !== void 0 ? u : wr, this.minFilter = l !== void 0 ? l : wr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
}
qa.prototype = Object.create(ri.prototype);
qa.prototype.constructor = qa;
qa.prototype.isDataTexture = !0;
function Gn(e, t) {
  this.min = e !== void 0 ? e : new H(1 / 0, 1 / 0, 1 / 0), this.max = t !== void 0 ? t : new H(-1 / 0, -1 / 0, -1 / 0);
}
Object.assign(Gn.prototype, {
  isBox3: !0,
  set: function(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  },
  setFromArray: function(e) {
    for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, u = e.length; o < u; o += 3) {
      var l = e[o], c = e[o + 1], h = e[o + 2];
      l < t && (t = l), c < i && (i = c), h < n && (n = h), l > r && (r = l), c > a && (a = c), h > s && (s = h);
    }
    return this.min.set(t, i, n), this.max.set(r, a, s), this;
  },
  setFromBufferAttribute: function(e) {
    for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, u = e.count; o < u; o++) {
      var l = e.getX(o), c = e.getY(o), h = e.getZ(o);
      l < t && (t = l), c < i && (i = c), h < n && (n = h), l > r && (r = l), c > a && (a = c), h > s && (s = h);
    }
    return this.min.set(t, i, n), this.max.set(r, a, s), this;
  },
  setFromPoints: function(e) {
    this.makeEmpty();
    for (var t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  },
  setFromCenterAndSize: function() {
    var e = new H();
    return function(i, n) {
      var r = e.copy(n).multiplyScalar(0.5);
      return this.min.copy(i).sub(r), this.max.copy(i).add(r), this;
    };
  }(),
  setFromObject: function(e) {
    return this.makeEmpty(), this.expandByObject(e);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  },
  makeEmpty: function() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new H()), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), e = new H()), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  },
  expandByPoint: function(e) {
    return this.min.min(e), this.max.max(e), this;
  },
  expandByVector: function(e) {
    return this.min.sub(e), this.max.add(e), this;
  },
  expandByScalar: function(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  },
  expandByObject: function() {
    var e, t, i, n = new H();
    function r(a) {
      var s = a.geometry;
      if (s !== void 0) {
        if (s.isGeometry) {
          var o = s.vertices;
          for (t = 0, i = o.length; t < i; t++)
            n.copy(o[t]), n.applyMatrix4(a.matrixWorld), e.expandByPoint(n);
        } else if (s.isBufferGeometry) {
          var u = s.attributes.position;
          if (u !== void 0)
            for (t = 0, i = u.count; t < i; t++)
              n.fromBufferAttribute(u, t).applyMatrix4(a.matrixWorld), e.expandByPoint(n);
        }
      }
    }
    return function(s) {
      return e = this, s.updateMatrixWorld(!0), s.traverse(r), this;
    };
  }(),
  containsPoint: function(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  },
  containsBox: function(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  },
  getParameter: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new H()), t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  },
  intersectsBox: function(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  },
  intersectsSphere: function() {
    var e = new H();
    return function(i) {
      return this.clampPoint(i.center, e), e.distanceToSquared(i.center) <= i.radius * i.radius;
    };
  }(),
  intersectsPlane: function(e) {
    var t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= e.constant && i >= e.constant;
  },
  intersectsTriangle: function() {
    var e = new H(), t = new H(), i = new H(), n = new H(), r = new H(), a = new H(), s = new H(), o = new H(), u = new H(), l = new H();
    function c(h) {
      var d, f;
      for (d = 0, f = h.length - 3; d <= f; d += 3) {
        s.fromArray(h, d);
        var p = u.x * Math.abs(s.x) + u.y * Math.abs(s.y) + u.z * Math.abs(s.z), _ = e.dot(s), m = t.dot(s), x = i.dot(s);
        if (Math.max(-Math.max(_, m, x), Math.min(_, m, x)) > p)
          return !1;
      }
      return !0;
    }
    return function(d) {
      if (this.isEmpty())
        return !1;
      this.getCenter(o), u.subVectors(this.max, o), e.subVectors(d.a, o), t.subVectors(d.b, o), i.subVectors(d.c, o), n.subVectors(t, e), r.subVectors(i, t), a.subVectors(e, i);
      var f = [
        0,
        -n.z,
        n.y,
        0,
        -r.z,
        r.y,
        0,
        -a.z,
        a.y,
        n.z,
        0,
        -n.x,
        r.z,
        0,
        -r.x,
        a.z,
        0,
        -a.x,
        -n.y,
        n.x,
        0,
        -r.y,
        r.x,
        0,
        -a.y,
        a.x,
        0
      ];
      return !c(f) || (f = [1, 0, 0, 0, 1, 0, 0, 0, 1], !c(f)) ? !1 : (l.crossVectors(n, r), f = [l.x, l.y, l.z], c(f));
    };
  }(),
  clampPoint: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new H()), t.copy(e).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var e = new H();
    return function(i) {
      var n = e.copy(i).clamp(this.min, this.max);
      return n.sub(i).length();
    };
  }(),
  getBoundingSphere: function() {
    var e = new H();
    return function(i) {
      return i === void 0 && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), i = new qr()), this.getCenter(i.center), i.radius = this.getSize(e).length() * 0.5, i;
    };
  }(),
  intersect: function(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  },
  union: function(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  },
  applyMatrix4: function(e) {
    if (this.isEmpty()) return this;
    var t = e.elements, i = t[0] * this.min.x, n = t[1] * this.min.x, r = t[2] * this.min.x, a = t[0] * this.max.x, s = t[1] * this.max.x, o = t[2] * this.max.x, u = t[4] * this.min.y, l = t[5] * this.min.y, c = t[6] * this.min.y, h = t[4] * this.max.y, d = t[5] * this.max.y, f = t[6] * this.max.y, p = t[8] * this.min.z, _ = t[9] * this.min.z, m = t[10] * this.min.z, x = t[8] * this.max.z, E = t[9] * this.max.z, M = t[10] * this.max.z;
    return this.min.x = Math.min(i, a) + Math.min(u, h) + Math.min(p, x) + t[12], this.min.y = Math.min(n, s) + Math.min(l, d) + Math.min(_, E) + t[13], this.min.z = Math.min(r, o) + Math.min(c, f) + Math.min(m, M) + t[14], this.max.x = Math.max(i, a) + Math.max(u, h) + Math.max(p, x) + t[12], this.max.y = Math.max(n, s) + Math.max(l, d) + Math.max(_, E) + t[13], this.max.z = Math.max(r, o) + Math.max(c, f) + Math.max(m, M) + t[14], this;
  },
  translate: function(e) {
    return this.min.add(e), this.max.add(e), this;
  },
  equals: function(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
});
function qr(e, t) {
  this.center = e !== void 0 ? e : new H(), this.radius = t !== void 0 ? t : 0;
}
Object.assign(qr.prototype, {
  set: function(e, t) {
    return this.center.copy(e), this.radius = t, this;
  },
  setFromPoints: function() {
    var e = new Gn();
    return function(i, n) {
      var r = this.center;
      n !== void 0 ? r.copy(n) : e.setFromPoints(i).getCenter(r);
      for (var a = 0, s = 0, o = i.length; s < o; s++)
        a = Math.max(a, r.distanceToSquared(i[s]));
      return this.radius = Math.sqrt(a), this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  },
  empty: function() {
    return this.radius <= 0;
  },
  containsPoint: function(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function(e) {
    return e.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function(e) {
    var t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  },
  intersectsBox: function(e) {
    return e.intersectsSphere(this);
  },
  intersectsPlane: function(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function(e, t) {
    var i = this.center.distanceToSquared(e);
    return t === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new H()), t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  },
  getBoundingBox: function(e) {
    return e === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new Gn()), e.set(this.center, this.center), e.expandByScalar(this.radius), e;
  },
  applyMatrix4: function(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  },
  translate: function(e) {
    return this.center.add(e), this;
  },
  equals: function(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
});
function Gr(e, t) {
  this.normal = e !== void 0 ? e : new H(1, 0, 0), this.constant = t !== void 0 ? t : 0;
}
Object.assign(Gr.prototype, {
  set: function(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  },
  setComponents: function(e, t, i, n) {
    return this.normal.set(e, t, i), this.constant = n, this;
  },
  setFromNormalAndCoplanarPoint: function(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  },
  setFromCoplanarPoints: function() {
    var e = new H(), t = new H();
    return function(n, r, a) {
      var s = e.subVectors(a, r).cross(t.subVectors(n, r)).normalize();
      return this.setFromNormalAndCoplanarPoint(s, n), this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  },
  normalize: function() {
    var e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  },
  negate: function() {
    return this.constant *= -1, this.normal.negate(), this;
  },
  distanceToPoint: function(e) {
    return this.normal.dot(e) + this.constant;
  },
  distanceToSphere: function(e) {
    return this.distanceToPoint(e.center) - e.radius;
  },
  projectPoint: function(e, t) {
    return t === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new H()), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  },
  intersectLine: function() {
    var e = new H();
    return function(i, n) {
      n === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new H());
      var r = i.delta(e), a = this.normal.dot(r);
      if (a === 0)
        return this.distanceToPoint(i.start) === 0 ? n.copy(i.start) : void 0;
      var s = -(i.start.dot(this.normal) + this.constant) / a;
      if (!(s < 0 || s > 1))
        return n.copy(r).multiplyScalar(s).add(i.start);
    };
  }(),
  intersectsLine: function(e) {
    var t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  },
  intersectsBox: function(e) {
    return e.intersectsPlane(this);
  },
  intersectsSphere: function(e) {
    return e.intersectsPlane(this);
  },
  coplanarPoint: function(e) {
    return e === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new H()), e.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function() {
    var e = new H(), t = new wi();
    return function(n, r) {
      var a = r || t.getNormalMatrix(n), s = this.coplanarPoint(e).applyMatrix4(n), o = this.normal.applyMatrix3(a).normalize();
      return this.constant = -s.dot(o), this;
    };
  }(),
  translate: function(e) {
    return this.constant -= e.dot(this.normal), this;
  },
  equals: function(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
});
function vh(e, t, i, n, r, a) {
  this.planes = [
    e !== void 0 ? e : new Gr(),
    t !== void 0 ? t : new Gr(),
    i !== void 0 ? i : new Gr(),
    n !== void 0 ? n : new Gr(),
    r !== void 0 ? r : new Gr(),
    a !== void 0 ? a : new Gr()
  ];
}
Object.assign(vh.prototype, {
  set: function(e, t, i, n, r, a) {
    var s = this.planes;
    return s[0].copy(e), s[1].copy(t), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(a), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    for (var t = this.planes, i = 0; i < 6; i++)
      t[i].copy(e.planes[i]);
    return this;
  },
  setFromMatrix: function(e) {
    var t = this.planes, i = e.elements, n = i[0], r = i[1], a = i[2], s = i[3], o = i[4], u = i[5], l = i[6], c = i[7], h = i[8], d = i[9], f = i[10], p = i[11], _ = i[12], m = i[13], x = i[14], E = i[15];
    return t[0].setComponents(s - n, c - o, p - h, E - _).normalize(), t[1].setComponents(s + n, c + o, p + h, E + _).normalize(), t[2].setComponents(s + r, c + u, p + d, E + m).normalize(), t[3].setComponents(s - r, c - u, p - d, E - m).normalize(), t[4].setComponents(s - a, c - l, p - f, E - x).normalize(), t[5].setComponents(s + a, c + l, p + f, E + x).normalize(), this;
  },
  intersectsObject: function() {
    var e = new qr();
    return function(i) {
      var n = i.geometry;
      return n.boundingSphere === null && n.computeBoundingSphere(), e.copy(n.boundingSphere).applyMatrix4(i.matrixWorld), this.intersectsSphere(e);
    };
  }(),
  intersectsSprite: function() {
    var e = new qr();
    return function(i) {
      return e.center.set(0, 0, 0), e.radius = 0.7071067811865476, e.applyMatrix4(i.matrixWorld), this.intersectsSphere(e);
    };
  }(),
  intersectsSphere: function(e) {
    for (var t = this.planes, i = e.center, n = -e.radius, r = 0; r < 6; r++) {
      var a = t[r].distanceToPoint(i);
      if (a < n)
        return !1;
    }
    return !0;
  },
  intersectsBox: function() {
    var e = new H(), t = new H();
    return function(n) {
      for (var r = this.planes, a = 0; a < 6; a++) {
        var s = r[a];
        e.x = s.normal.x > 0 ? n.min.x : n.max.x, t.x = s.normal.x > 0 ? n.max.x : n.min.x, e.y = s.normal.y > 0 ? n.min.y : n.max.y, t.y = s.normal.y > 0 ? n.max.y : n.min.y, e.z = s.normal.z > 0 ? n.min.z : n.max.z, t.z = s.normal.z > 0 ? n.max.z : n.min.z;
        var o = s.distanceToPoint(e), u = s.distanceToPoint(t);
        if (o < 0 && u < 0)
          return !1;
      }
      return !0;
    };
  }(),
  containsPoint: function(e) {
    for (var t = this.planes, i = 0; i < 6; i++)
      if (t[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
});
var Fx = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif
`, Nx = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif
`, Ux = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif
`, jx = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( PHYSICAL )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif
`, Gx = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Vx = `
vec3 transformed = vec3( position );
`, Hx = `
vec3 objectNormal = vec3( normal );
`, zx = `float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	if( decayExponent > 0.0 ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		return distanceFalloff * maxDistanceCutoffFactor;
#else
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
#endif
	}
	return 1.0;
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
	return specularColor * AB.x + AB.y;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
`, Wx = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif
`, qx = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
	}
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;
		}
		if ( clipped ) discard;
	#endif
#endif
`, Xx = `#if NUM_CLIPPING_PLANES > 0
	#if ! defined( PHYSICAL ) && ! defined( PHONG )
		varying vec3 vViewPosition;
	#endif
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif
`, Yx = `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
	varying vec3 vViewPosition;
#endif
`, Qx = `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
	vViewPosition = - mvPosition.xyz;
#endif
`, Kx = `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`, Zx = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif
`, Jx = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`, $x = `#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`, eA = `#define PI 3.14159265359
#define PI2 6.28318530718
#define PI_HALF 1.5707963267949
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
`, tA = `#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_textureSize (1024.0)
int getFaceFromDirection(vec3 direction) {
	vec3 absDirection = abs(direction);
	int face = -1;
	if( absDirection.x > absDirection.z ) {
		if(absDirection.x > absDirection.y )
			face = direction.x > 0.0 ? 0 : 3;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	else {
		if(absDirection.z > absDirection.y )
			face = direction.z > 0.0 ? 2 : 5;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	return face;
}
#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)
#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))
vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {
	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);
	float dxRoughness = dFdx(roughness);
	float dyRoughness = dFdy(roughness);
	vec3 dx = dFdx( vec * scale * dxRoughness );
	vec3 dy = dFdy( vec * scale * dyRoughness );
	float d = max( dot( dx, dx ), dot( dy, dy ) );
	d = clamp(d, 1.0, cubeUV_rangeClamp);
	float mipLevel = 0.5 * log2(d);
	return vec2(floor(mipLevel), fract(mipLevel));
}
#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)
#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)
vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {
	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;
	float a = 16.0 * cubeUV_rcpTextureSize;
	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );
	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;
	float powScale = exp2_packed.x * exp2_packed.y;
	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;
	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;
	bool bRes = mipLevel == 0.0;
	scale =  bRes && (scale < a) ? a : scale;
	vec3 r;
	vec2 offset;
	int face = getFaceFromDirection(direction);
	float rcpPowScale = 1.0 / powScale;
	if( face == 0) {
		r = vec3(direction.x, -direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 1) {
		r = vec3(direction.y, direction.x, direction.z);
		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 2) {
		r = vec3(direction.z, direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 3) {
		r = vec3(direction.x, direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else if( face == 4) {
		r = vec3(direction.y, direction.x, -direction.z);
		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else {
		r = vec3(direction.z, -direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	r = normalize(r);
	float texelOffset = 0.5 * cubeUV_rcpTextureSize;
	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;
	vec2 base = offset + vec2( texelOffset );
	return base + s * ( scale - 2.0 * texelOffset );
}
#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)
vec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {
	float roughnessVal = roughness* cubeUV_maxLods3;
	float r1 = floor(roughnessVal);
	float r2 = r1 + 1.0;
	float t = fract(roughnessVal);
	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);
	float s = mipInfo.y;
	float level0 = mipInfo.x;
	float level1 = level0 + 1.0;
	level1 = level1 > 5.0 ? 5.0 : level1;
	level0 += min( floor( s + 0.5 ), 5.0 );
	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);
	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));
	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);
	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));
	vec4 result = mix(color10, color20, t);
	return vec4(result.rgb, 1.0);
}
#endif
`, iA = `vec3 transformedNormal = normalMatrix * objectNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
`, rA = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif
`, nA = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );
#endif
`, aA = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif
`, sA = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif
`, oA = `  gl_FragColor = linearToOutputTexel( gl_FragColor );
`, uA = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.x, max( value.g, value.b ) );
	float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M            = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.x, max( value.g, value.b ) );
	float D      = max( maxRange / maxRGB, 1.0 );
	D            = min( floor( D ) / 255.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
	Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract(Le);
	vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
	return vec4( max(vRGB, 0.0), 1.0 );
}
`, lA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToVertex, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		vec2 sampleUV;
		reflectVec = normalize( reflectVec );
		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
		vec4 envColor = texture2D( envMap, sampleUV );
	#elif defined( ENVMAP_TYPE_SPHERE )
		reflectVec = normalize( reflectVec );
		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	envColor = envMapTexelToLinear( envColor );
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif
`, cA = `#if defined( USE_ENVMAP ) || defined( PHYSICAL )
	uniform float reflectivity;
	uniform float envMapIntensity;
#endif
#ifdef USE_ENVMAP
	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
		varying vec3 vWorldPosition;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif
`, hA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif
`, dA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif
`, fA = `
#ifdef USE_FOG
fogDepth = -mvPosition.z;
#endif`, pA = `#ifdef USE_FOG
  varying float fogDepth;
#endif
`, vA = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif
`, mA = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif
`, gA = `#ifdef TOON
	uniform sampler2D gradientMap;
	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
		float dotNL = dot( normal, lightDirection );
		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
		#ifdef USE_GRADIENTMAP
			return texture2D( gradientMap, coord ).rgb;
		#else
			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
		#endif
	}
#endif
`, yA = `#ifdef USE_LIGHTMAP
	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
#endif
`, _A = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, bA = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
#endif
`, xA = `uniform vec3 ambientLightColor;
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
		float shadowCameraNear;
		float shadowCameraFar;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif
`, AA = `#if defined( USE_ENVMAP ) && defined( PHYSICAL )
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
		#else
			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV;
			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_SPHERE )
			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif
`, TA = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`, EA = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	#ifdef TOON
		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#else
		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		vec3 irradiance = dotNL * directLight.color;
	#endif
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)
`, wA = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
#ifdef STANDARD
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
#endif
`, SA = `struct PhysicalMaterial {
	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;
	#ifndef STANDARD
		float clearCoat;
		float clearCoatRoughness;
	#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifndef STANDARD
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	#ifndef STANDARD
		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	#ifndef STANDARD
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		float dotNL = dotNV;
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
	#ifndef STANDARD
		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}
`, CA = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = normalize( vViewPosition );
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
#endif
#if defined( RE_IndirectDiffuse )
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearCoatRadiance = vec3( 0.0 );
#endif
`, MA = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )
		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );
	#ifndef STANDARD
		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );
	#endif
#endif
`, DA = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );
#endif
`, PA = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, LA = `#ifdef USE_LOGDEPTHBUF
	uniform float logDepthBufFC;
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
	#endif
#endif
`, RA = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
	#endif
	uniform float logDepthBufFC;
#endif`, IA = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
	#else
		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
		gl_Position.z *= gl_Position.w;
	#endif
#endif
`, OA = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif
`, kA = `#ifdef USE_MAP
	uniform sampler2D map;
#endif
`, BA = `#ifdef USE_MAP
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
`, FA = `#ifdef USE_MAP
	uniform mat3 uvTransform;
	uniform sampler2D map;
#endif
`, NA = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif
`, UA = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, jA = `#ifdef USE_MORPHNORMALS
	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif
`, GA = `#ifdef USE_MORPHTARGETS
	#ifndef USE_MORPHNORMALS
	uniform float morphTargetInfluences[ 8 ];
	#else
	uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`, VA = `#ifdef USE_MORPHTARGETS
	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
	#endif
#endif
`, HA = `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
#endif
`, zA = `#ifdef USE_NORMALMAP
	normal = perturbNormal2Arb( -vViewPosition, normal );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif
`, WA = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
		mapN.xy *= normalScale;
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif
`, qA = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`, XA = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif
`, YA = `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
gl_Position = projectionMatrix * mvPosition;
`, QA = `#if defined( DITHERING )
  gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif
`, KA = `#if defined( DITHERING )
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif
`, ZA = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif
`, JA = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, $A = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {
		const vec2 offset = vec2( 0.0, 1.0 );
		vec2 texelSize = vec2( 1.0 ) / size;
		vec2 centroidUV = floor( uv * size + 0.5 ) / size;
		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );
		vec2 f = fract( uv * size + 0.5 );
		float a = mix( lb, lt, f.y );
		float b = mix( rb, rt, f.y );
		float c = mix( a, b, f.x );
		return c;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif
`, eT = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
#endif
`, tT = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;
	}
	#endif
#endif
`, iT = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#endif
	#endif
	return shadow;
}
`, rT = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, nT = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif
`, aT = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif
`, sT = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif
`, oT = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, uT = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, lT = `#if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif
`, cT = `#ifndef saturate
	#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
`, hT = `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
#endif`, dT = `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
`, fT = `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, pT = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, vT = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
#endif`, mT = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = uv2;
#endif`, gT = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
#endif
`, yT = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldPosition;
void main() {
	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );
	gl_FragColor.a *= opacity;
}
`, _T = `varying vec3 vWorldPosition;
#include <common>
void main() {
	vWorldPosition = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}
`, bT = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );
	#endif
}
`, xT = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
}
`, AT = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}
`, TT = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}
`, ET = `uniform sampler2D tEquirect;
varying vec3 vWorldPosition;
#include <common>
void main() {
	vec3 direction = normalize( vWorldPosition );
	vec2 sampleUV;
	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;
	gl_FragColor = texture2D( tEquirect, sampleUV );
}
`, wT = `varying vec3 vWorldPosition;
#include <common>
void main() {
	vWorldPosition = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}
`, ST = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`, CT = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	vLineDistance = scale * lineDistance;
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`, MT = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`, DT = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`, PT = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_pars_maps>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`, LT = `#define LAMBERT
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_pars_maps>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`, RT = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_pars_maps>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`, IT = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`, OT = `#define PHYSICAL
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifndef STANDARD
	uniform float clearCoat;
	uniform float clearCoatRoughness;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <lights_pars_begin>
#include <lights_pars_maps>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`, kT = `#define PHYSICAL
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`, BT = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}
`, FT = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}
`, NT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <packing>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`, UT = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#ifdef USE_SIZEATTENUATION
		gl_PointSize = size * ( scale / - mvPosition.z );
	#else
		gl_PointSize = size;
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}
`, jT = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <fog_fragment>
}
`, GT = `#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`, Ot = {
  alphamap_fragment: Fx,
  alphamap_pars_fragment: Nx,
  alphatest_fragment: Ux,
  aomap_fragment: jx,
  aomap_pars_fragment: Gx,
  begin_vertex: Vx,
  beginnormal_vertex: Hx,
  bsdfs: zx,
  bumpmap_pars_fragment: Wx,
  clipping_planes_fragment: qx,
  clipping_planes_pars_fragment: Xx,
  clipping_planes_pars_vertex: Yx,
  clipping_planes_vertex: Qx,
  color_fragment: Kx,
  color_pars_fragment: Zx,
  color_pars_vertex: Jx,
  color_vertex: $x,
  common: eA,
  cube_uv_reflection_fragment: tA,
  defaultnormal_vertex: iA,
  displacementmap_pars_vertex: rA,
  displacementmap_vertex: nA,
  emissivemap_fragment: aA,
  emissivemap_pars_fragment: sA,
  encodings_fragment: oA,
  encodings_pars_fragment: uA,
  envmap_fragment: lA,
  envmap_pars_fragment: cA,
  envmap_pars_vertex: hA,
  envmap_vertex: dA,
  fog_vertex: fA,
  fog_pars_vertex: pA,
  fog_fragment: vA,
  fog_pars_fragment: mA,
  gradientmap_pars_fragment: gA,
  lightmap_fragment: yA,
  lightmap_pars_fragment: _A,
  lights_lambert_vertex: bA,
  lights_pars_begin: xA,
  lights_pars_maps: AA,
  lights_phong_fragment: TA,
  lights_phong_pars_fragment: EA,
  lights_physical_fragment: wA,
  lights_physical_pars_fragment: SA,
  lights_fragment_begin: CA,
  lights_fragment_maps: MA,
  lights_fragment_end: DA,
  logdepthbuf_fragment: PA,
  logdepthbuf_pars_fragment: LA,
  logdepthbuf_pars_vertex: RA,
  logdepthbuf_vertex: IA,
  map_fragment: OA,
  map_pars_fragment: kA,
  map_particle_fragment: BA,
  map_particle_pars_fragment: FA,
  metalnessmap_fragment: NA,
  metalnessmap_pars_fragment: UA,
  morphnormal_vertex: jA,
  morphtarget_pars_vertex: GA,
  morphtarget_vertex: VA,
  normal_fragment_begin: HA,
  normal_fragment_maps: zA,
  normalmap_pars_fragment: WA,
  packing: qA,
  premultiplied_alpha_fragment: XA,
  project_vertex: YA,
  dithering_fragment: QA,
  dithering_pars_fragment: KA,
  roughnessmap_fragment: ZA,
  roughnessmap_pars_fragment: JA,
  shadowmap_pars_fragment: $A,
  shadowmap_pars_vertex: eT,
  shadowmap_vertex: tT,
  shadowmask_pars_fragment: iT,
  skinbase_vertex: rT,
  skinning_pars_vertex: nT,
  skinning_vertex: aT,
  skinnormal_vertex: sT,
  specularmap_fragment: oT,
  specularmap_pars_fragment: uT,
  tonemapping_fragment: lT,
  tonemapping_pars_fragment: cT,
  uv_pars_fragment: hT,
  uv_pars_vertex: dT,
  uv_vertex: fT,
  uv2_pars_fragment: pT,
  uv2_pars_vertex: vT,
  uv2_vertex: mT,
  worldpos_vertex: gT,
  cube_frag: yT,
  cube_vert: _T,
  depth_frag: bT,
  depth_vert: xT,
  distanceRGBA_frag: AT,
  distanceRGBA_vert: TT,
  equirect_frag: ET,
  equirect_vert: wT,
  linedashed_frag: ST,
  linedashed_vert: CT,
  meshbasic_frag: MT,
  meshbasic_vert: DT,
  meshlambert_frag: PT,
  meshlambert_vert: LT,
  meshphong_frag: RT,
  meshphong_vert: IT,
  meshphysical_frag: OT,
  meshphysical_vert: kT,
  normal_frag: BT,
  normal_vert: FT,
  points_frag: NT,
  points_vert: UT,
  shadow_frag: jT,
  shadow_vert: GT
}, sr = {
  merge: function(e) {
    for (var t = {}, i = 0; i < e.length; i++) {
      var n = this.clone(e[i]);
      for (var r in n)
        t[r] = n[r];
    }
    return t;
  },
  clone: function(e) {
    var t = {};
    for (var i in e) {
      t[i] = {};
      for (var n in e[i]) {
        var r = e[i][n];
        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r;
      }
    }
    return t;
  }
}, VT = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
function We(e, t, i) {
  return t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i);
}
Object.assign(We.prototype, {
  isColor: !0,
  r: 1,
  g: 1,
  b: 1,
  set: function(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  },
  setScalar: function(e) {
    return this.r = e, this.g = e, this.b = e, this;
  },
  setHex: function(e) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
  },
  setRGB: function(e, t, i) {
    return this.r = e, this.g = t, this.b = i, this;
  },
  setHSL: /* @__PURE__ */ function() {
    function e(t, i, n) {
      return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (i - t) * 6 * n : n < 1 / 2 ? i : n < 2 / 3 ? t + (i - t) * 6 * (2 / 3 - n) : t;
    }
    return function(i, n, r) {
      if (i = gt.euclideanModulo(i, 1), n = gt.clamp(n, 0, 1), r = gt.clamp(r, 0, 1), n === 0)
        this.r = this.g = this.b = r;
      else {
        var a = r <= 0.5 ? r * (1 + n) : r + n - r * n, s = 2 * r - a;
        this.r = e(s, a, i + 1 / 3), this.g = e(s, a, i), this.b = e(s, a, i - 1 / 3);
      }
      return this;
    };
  }(),
  setStyle: function(e) {
    function t(h) {
      h !== void 0 && parseFloat(h) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    var i;
    if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
      var n, r = i[1], a = i[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
            return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]), this;
          if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
            return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]), this;
          break;
        case "hsl":
        case "hsla":
          if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
            var s = parseFloat(n[1]) / 360, o = parseInt(n[2], 10) / 100, u = parseInt(n[3], 10) / 100;
            return t(n[5]), this.setHSL(s, o, u);
          }
          break;
      }
    } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
      var l = i[1], c = l.length;
      if (c === 3)
        return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
      if (c === 6)
        return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this;
    }
    if (e && e.length > 0) {
      var l = VT[e];
      l !== void 0 ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + e);
    }
    return this;
  },
  clone: function() {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  },
  copyGammaToLinear: function(e, t) {
    return t === void 0 && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this;
  },
  copyLinearToGamma: function(e, t) {
    t === void 0 && (t = 2);
    var i = t > 0 ? 1 / t : 1;
    return this.r = Math.pow(e.r, i), this.g = Math.pow(e.g, i), this.b = Math.pow(e.b, i), this;
  },
  convertGammaToLinear: function(e) {
    return this.copyGammaToLinear(this, e), this;
  },
  convertLinearToGamma: function(e) {
    return this.copyLinearToGamma(this, e), this;
  },
  getHex: function() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function(e) {
    e === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 });
    var t = this.r, i = this.g, n = this.b, r = Math.max(t, i, n), a = Math.min(t, i, n), s, o, u = (a + r) / 2;
    if (a === r)
      s = 0, o = 0;
    else {
      var l = r - a;
      switch (o = u <= 0.5 ? l / (r + a) : l / (2 - r - a), r) {
        case t:
          s = (i - n) / l + (i < n ? 6 : 0);
          break;
        case i:
          s = (n - t) / l + 2;
          break;
        case n:
          s = (t - i) / l + 4;
          break;
      }
      s /= 6;
    }
    return e.h = s, e.s = o, e.l = u, e;
  },
  getStyle: function() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  },
  offsetHSL: /* @__PURE__ */ function() {
    var e = {};
    return function(t, i, n) {
      return this.getHSL(e), e.h += t, e.s += i, e.l += n, this.setHSL(e.h, e.s, e.l), this;
    };
  }(),
  add: function(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  },
  addColors: function(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  },
  addScalar: function(e) {
    return this.r += e, this.g += e, this.b += e, this;
  },
  sub: function(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  },
  multiply: function(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  },
  multiplyScalar: function(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  },
  lerp: function(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  },
  equals: function(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  },
  toJSON: function() {
    return this.getHex();
  }
});
var Xe = {
  common: {
    diffuse: { value: new We(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new wi() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new ue(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new We(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } }
  },
  points: {
    diffuse: { value: new We(15658734) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    uvTransform: { value: new wi() }
  }
}, Fa = {
  basic: {
    uniforms: sr.merge([
      Xe.common,
      Xe.specularmap,
      Xe.envmap,
      Xe.aomap,
      Xe.lightmap,
      Xe.fog
    ]),
    vertexShader: Ot.meshbasic_vert,
    fragmentShader: Ot.meshbasic_frag
  },
  lambert: {
    uniforms: sr.merge([
      Xe.common,
      Xe.specularmap,
      Xe.envmap,
      Xe.aomap,
      Xe.lightmap,
      Xe.emissivemap,
      Xe.fog,
      Xe.lights,
      {
        emissive: { value: new We(0) }
      }
    ]),
    vertexShader: Ot.meshlambert_vert,
    fragmentShader: Ot.meshlambert_frag
  },
  phong: {
    uniforms: sr.merge([
      Xe.common,
      Xe.specularmap,
      Xe.envmap,
      Xe.aomap,
      Xe.lightmap,
      Xe.emissivemap,
      Xe.bumpmap,
      Xe.normalmap,
      Xe.displacementmap,
      Xe.gradientmap,
      Xe.fog,
      Xe.lights,
      {
        emissive: { value: new We(0) },
        specular: { value: new We(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Ot.meshphong_vert,
    fragmentShader: Ot.meshphong_frag
  },
  standard: {
    uniforms: sr.merge([
      Xe.common,
      Xe.envmap,
      Xe.aomap,
      Xe.lightmap,
      Xe.emissivemap,
      Xe.bumpmap,
      Xe.normalmap,
      Xe.displacementmap,
      Xe.roughnessmap,
      Xe.metalnessmap,
      Xe.fog,
      Xe.lights,
      {
        emissive: { value: new We(0) },
        roughness: { value: 0.5 },
        metalness: { value: 0.5 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: Ot.meshphysical_vert,
    fragmentShader: Ot.meshphysical_frag
  },
  points: {
    uniforms: sr.merge([
      Xe.points,
      Xe.fog
    ]),
    vertexShader: Ot.points_vert,
    fragmentShader: Ot.points_frag
  },
  dashed: {
    uniforms: sr.merge([
      Xe.common,
      Xe.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Ot.linedashed_vert,
    fragmentShader: Ot.linedashed_frag
  },
  depth: {
    uniforms: sr.merge([
      Xe.common,
      Xe.displacementmap
    ]),
    vertexShader: Ot.depth_vert,
    fragmentShader: Ot.depth_frag
  },
  normal: {
    uniforms: sr.merge([
      Xe.common,
      Xe.bumpmap,
      Xe.normalmap,
      Xe.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ot.normal_vert,
    fragmentShader: Ot.normal_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Ot.cube_vert,
    fragmentShader: Ot.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Ot.equirect_vert,
    fragmentShader: Ot.equirect_frag
  },
  distanceRGBA: {
    uniforms: sr.merge([
      Xe.common,
      Xe.displacementmap,
      {
        referencePosition: { value: new H() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Ot.distanceRGBA_vert,
    fragmentShader: Ot.distanceRGBA_frag
  },
  shadow: {
    uniforms: sr.merge([
      Xe.lights,
      Xe.fog,
      {
        color: { value: new We(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ot.shadow_vert,
    fragmentShader: Ot.shadow_frag
  }
};
Fa.physical = {
  uniforms: sr.merge([
    Fa.standard.uniforms,
    {
      clearCoat: { value: 0 },
      clearCoatRoughness: { value: 0 }
    }
  ]),
  vertexShader: Ot.meshphysical_vert,
  fragmentShader: Ot.meshphysical_frag
};
function jf() {
  var e = null, t = !1, i = null;
  function n(r, a) {
    t !== !1 && (i(r, a), e.requestAnimationFrame(n));
  }
  return {
    start: function() {
      t !== !0 && i !== null && (e.requestAnimationFrame(n), t = !0);
    },
    stop: function() {
      t = !1;
    },
    setAnimationLoop: function(r) {
      i = r;
    },
    setContext: function(r) {
      e = r;
    }
  };
}
function HT(e) {
  var t = /* @__PURE__ */ new WeakMap();
  function i(o, u) {
    var l = o.array, c = o.dynamic ? e.DYNAMIC_DRAW : e.STATIC_DRAW, h = e.createBuffer();
    e.bindBuffer(u, h), e.bufferData(u, l, c), o.onUploadCallback();
    var d = e.FLOAT;
    return l instanceof Float32Array ? d = e.FLOAT : l instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : l instanceof Uint16Array ? d = e.UNSIGNED_SHORT : l instanceof Int16Array ? d = e.SHORT : l instanceof Uint32Array ? d = e.UNSIGNED_INT : l instanceof Int32Array ? d = e.INT : l instanceof Int8Array ? d = e.BYTE : l instanceof Uint8Array && (d = e.UNSIGNED_BYTE), {
      buffer: h,
      type: d,
      bytesPerElement: l.BYTES_PER_ELEMENT,
      version: o.version
    };
  }
  function n(o, u, l) {
    var c = u.array, h = u.updateRange;
    e.bindBuffer(l, o), u.dynamic === !1 ? e.bufferData(l, c, e.STATIC_DRAW) : h.count === -1 ? e.bufferSubData(l, 0, c) : h.count === 0 ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(
      l,
      h.offset * c.BYTES_PER_ELEMENT,
      c.subarray(h.offset, h.offset + h.count)
    ), h.count = -1);
  }
  function r(o) {
    return o.isInterleavedBufferAttribute && (o = o.data), t.get(o);
  }
  function a(o) {
    o.isInterleavedBufferAttribute && (o = o.data);
    var u = t.get(o);
    u && (e.deleteBuffer(u.buffer), t.delete(o));
  }
  function s(o, u) {
    o.isInterleavedBufferAttribute && (o = o.data);
    var l = t.get(o);
    l === void 0 ? t.set(o, i(o, u)) : l.version < o.version && (n(l.buffer, o, u), l.version = o.version);
  }
  return {
    get: r,
    remove: a,
    update: s
  };
}
function vs(e, t, i, n) {
  this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || vs.DefaultOrder;
}
vs.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
vs.DefaultOrder = "XYZ";
Object.defineProperties(vs.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(e) {
      this._x = e, this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(e) {
      this._y = e, this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(e) {
      this._z = e, this.onChangeCallback();
    }
  },
  order: {
    get: function() {
      return this._order;
    },
    set: function(e) {
      this._order = e, this.onChangeCallback();
    }
  }
});
Object.assign(vs.prototype, {
  isEuler: !0,
  set: function(e, t, i, n) {
    return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this.onChangeCallback(), this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this;
  },
  setFromRotationMatrix: function(e, t, i) {
    var n = gt.clamp, r = e.elements, a = r[0], s = r[4], o = r[8], u = r[1], l = r[5], c = r[9], h = r[2], d = r[6], f = r[10];
    return t = t || this._order, t === "XYZ" ? (this._y = Math.asin(n(o, -1, 1)), Math.abs(o) < 0.99999 ? (this._x = Math.atan2(-c, f), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(d, l), this._z = 0)) : t === "YXZ" ? (this._x = Math.asin(-n(c, -1, 1)), Math.abs(c) < 0.99999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(u, l)) : (this._y = Math.atan2(-h, a), this._z = 0)) : t === "ZXY" ? (this._x = Math.asin(n(d, -1, 1)), Math.abs(d) < 0.99999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(u, a))) : t === "ZYX" ? (this._y = Math.asin(-n(h, -1, 1)), Math.abs(h) < 0.99999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-s, l))) : t === "YZX" ? (this._z = Math.asin(n(u, -1, 1)), Math.abs(u) < 0.99999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(o, f))) : t === "XZY" ? (this._z = Math.asin(-n(s, -1, 1)), Math.abs(s) < 0.99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(o, a)) : (this._x = Math.atan2(-c, f), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, i !== !1 && this.onChangeCallback(), this;
  },
  setFromQuaternion: function() {
    var e = new at();
    return function(i, n, r) {
      return e.makeRotationFromQuaternion(i), this.setFromRotationMatrix(e, n, r);
    };
  }(),
  setFromVector3: function(e, t) {
    return this.set(e.x, e.y, e.z, t || this._order);
  },
  reorder: function() {
    var e = new _i();
    return function(i) {
      return e.setFromEuler(this), this.setFromQuaternion(e, i);
    };
  }(),
  equals: function(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  },
  fromArray: function(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this.onChangeCallback(), this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  },
  toVector3: function(e) {
    return e ? e.set(this._x, this._y, this._z) : new H(this._x, this._y, this._z);
  },
  onChange: function(e) {
    return this.onChangeCallback = e, this;
  },
  onChangeCallback: function() {
  }
});
function Gf() {
  this.mask = 1;
}
Object.assign(Gf.prototype, {
  set: function(e) {
    this.mask = 1 << e | 0;
  },
  enable: function(e) {
    this.mask |= 1 << e | 0;
  },
  toggle: function(e) {
    this.mask ^= 1 << e | 0;
  },
  disable: function(e) {
    this.mask &= ~(1 << e | 0);
  },
  test: function(e) {
    return (this.mask & e.mask) !== 0;
  }
});
var zT = 0;
function Fe() {
  Object.defineProperty(this, "id", { value: zT++ }), this.uuid = gt.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Fe.DefaultUp.clone();
  var e = new H(), t = new vs(), i = new _i(), n = new H(1, 1, 1);
  function r() {
    i.setFromEuler(t, !1);
  }
  function a() {
    t.setFromQuaternion(i, void 0, !1);
  }
  t.onChange(r), i.onChange(a), Object.defineProperties(this, {
    position: {
      enumerable: !0,
      value: e
    },
    rotation: {
      enumerable: !0,
      value: t
    },
    quaternion: {
      enumerable: !0,
      value: i
    },
    scale: {
      enumerable: !0,
      value: n
    },
    modelViewMatrix: {
      value: new at()
    },
    normalMatrix: {
      value: new wi()
    }
  }), this.matrix = new at(), this.matrixWorld = new at(), this.matrixAutoUpdate = Fe.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Gf(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
}
Fe.DefaultUp = new H(0, 1, 0);
Fe.DefaultMatrixAutoUpdate = !0;
Fe.prototype = Object.assign(Object.create(Kn.prototype), {
  constructor: Fe,
  isObject3D: !0,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix: function(e) {
    this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(e) {
    return this.quaternion.premultiply(e), this;
  },
  setRotationFromAxisAngle: function(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  },
  setRotationFromEuler: function(e) {
    this.quaternion.setFromEuler(e, !0);
  },
  setRotationFromMatrix: function(e) {
    this.quaternion.setFromRotationMatrix(e);
  },
  setRotationFromQuaternion: function(e) {
    this.quaternion.copy(e);
  },
  rotateOnAxis: function() {
    var e = new _i();
    return function(i, n) {
      return e.setFromAxisAngle(i, n), this.quaternion.multiply(e), this;
    };
  }(),
  rotateOnWorldAxis: function() {
    var e = new _i();
    return function(i, n) {
      return e.setFromAxisAngle(i, n), this.quaternion.premultiply(e), this;
    };
  }(),
  rotateX: function() {
    var e = new H(1, 0, 0);
    return function(i) {
      return this.rotateOnAxis(e, i);
    };
  }(),
  rotateY: function() {
    var e = new H(0, 1, 0);
    return function(i) {
      return this.rotateOnAxis(e, i);
    };
  }(),
  rotateZ: function() {
    var e = new H(0, 0, 1);
    return function(i) {
      return this.rotateOnAxis(e, i);
    };
  }(),
  translateOnAxis: function() {
    var e = new H();
    return function(i, n) {
      return e.copy(i).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this;
    };
  }(),
  translateX: function() {
    var e = new H(1, 0, 0);
    return function(i) {
      return this.translateOnAxis(e, i);
    };
  }(),
  translateY: function() {
    var e = new H(0, 1, 0);
    return function(i) {
      return this.translateOnAxis(e, i);
    };
  }(),
  translateZ: function() {
    var e = new H(0, 0, 1);
    return function(i) {
      return this.translateOnAxis(e, i);
    };
  }(),
  localToWorld: function(e) {
    return e.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function() {
    var e = new at();
    return function(i) {
      return i.applyMatrix4(e.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function() {
    var e = new at(), t = new H();
    return function(n, r, a) {
      n.isVector3 ? t.copy(n) : t.set(n, r, a), this.isCamera ? e.lookAt(this.position, t, this.up) : e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e);
    };
  }(),
  add: function(e) {
    if (arguments.length > 1) {
      for (var t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, e.dispatchEvent({ type: "added" }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  },
  remove: function(e) {
    if (arguments.length > 1) {
      for (var t = 0; t < arguments.length; t++)
        this.remove(arguments[t]);
      return this;
    }
    var i = this.children.indexOf(e);
    return i !== -1 && (e.parent = null, e.dispatchEvent({ type: "removed" }), this.children.splice(i, 1)), this;
  },
  getObjectById: function(e) {
    return this.getObjectByProperty("id", e);
  },
  getObjectByName: function(e) {
    return this.getObjectByProperty("name", e);
  },
  getObjectByProperty: function(e, t) {
    if (this[e] === t) return this;
    for (var i = 0, n = this.children.length; i < n; i++) {
      var r = this.children[i], a = r.getObjectByProperty(e, t);
      if (a !== void 0)
        return a;
    }
  },
  getWorldPosition: function(e) {
    return e === void 0 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new H()), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function() {
    var e = new H(), t = new H();
    return function(n) {
      return n === void 0 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), n = new _i()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, n, t), n;
    };
  }(),
  getWorldScale: function() {
    var e = new H(), t = new _i();
    return function(n) {
      return n === void 0 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n = new H()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, n), n;
    };
  }(),
  getWorldDirection: function() {
    var e = new _i();
    return function(i) {
      return i === void 0 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), i = new H()), this.getWorldQuaternion(e), i.set(0, 0, 1).applyQuaternion(e);
    };
  }(),
  raycast: function() {
  },
  traverse: function(e) {
    e(this);
    for (var t = this.children, i = 0, n = t.length; i < n; i++)
      t[i].traverse(e);
  },
  traverseVisible: function(e) {
    if (this.visible !== !1) {
      e(this);
      for (var t = this.children, i = 0, n = t.length; i < n; i++)
        t[i].traverseVisible(e);
    }
  },
  traverseAncestors: function(e) {
    var t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    for (var t = this.children, i = 0, n = t.length; i < n; i++)
      t[i].updateMatrixWorld(e);
  },
  toJSON: function(e) {
    var t = e === void 0 || typeof e == "string", i = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {}
    }, i.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    var n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), n.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1);
    function r(m, x) {
      return m[x.uuid] === void 0 && (m[x.uuid] = x.toJSON(e)), x.uuid;
    }
    if (this.geometry !== void 0) {
      n.geometry = r(e.geometries, this.geometry);
      var a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        var s = a.shapes;
        if (Array.isArray(s))
          for (var o = 0, u = s.length; o < u; o++) {
            var l = s[o];
            r(e.shapes, l);
          }
        else
          r(e.shapes, s);
      }
    }
    if (this.material !== void 0)
      if (Array.isArray(this.material)) {
        for (var c = [], o = 0, u = this.material.length; o < u; o++)
          c.push(r(e.materials, this.material[o]));
        n.material = c;
      } else
        n.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (var o = 0; o < this.children.length; o++)
        n.children.push(this.children[o].toJSON(e).object);
    }
    if (t) {
      var h = _(e.geometries), d = _(e.materials), f = _(e.textures), p = _(e.images), s = _(e.shapes);
      h.length > 0 && (i.geometries = h), d.length > 0 && (i.materials = d), f.length > 0 && (i.textures = f), p.length > 0 && (i.images = p), s.length > 0 && (i.shapes = s);
    }
    return i.object = n, i;
    function _(m) {
      var x = [];
      for (var E in m) {
        var M = m[E];
        delete M.metadata, x.push(M);
      }
      return x;
    }
  },
  clone: function(e) {
    return new this.constructor().copy(this, e);
  },
  copy: function(e, t) {
    if (t === void 0 && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (var i = 0; i < e.children.length; i++) {
        var n = e.children[i];
        this.add(n.clone());
      }
    return this;
  }
});
function yn() {
  Fe.call(this), this.type = "Camera", this.matrixWorldInverse = new at(), this.projectionMatrix = new at();
}
yn.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: yn,
  isCamera: !0,
  copy: function(e, t) {
    return Fe.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this;
  },
  getWorldDirection: function() {
    var e = new _i();
    return function(i) {
      return i === void 0 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), i = new H()), this.getWorldQuaternion(e), i.set(0, 0, -1).applyQuaternion(e);
    };
  }(),
  updateMatrixWorld: function(e) {
    Fe.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function Hs(e, t, i, n, r, a) {
  yn.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r !== void 0 ? r : 0.1, this.far = a !== void 0 ? a : 2e3, this.updateProjectionMatrix();
}
Hs.prototype = Object.assign(Object.create(yn.prototype), {
  constructor: Hs,
  isOrthographicCamera: !0,
  copy: function(e, t) {
    return yn.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  },
  setViewOffset: function(e, t, i, n, r, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, r = i - e, a = i + e, s = n + t, o = n - t;
    if (this.view !== null && this.view.enabled) {
      var u = this.zoom / (this.view.width / this.view.fullWidth), l = this.zoom / (this.view.height / this.view.fullHeight), c = (this.right - this.left) / this.view.width, h = (this.top - this.bottom) / this.view.height;
      r += c * (this.view.offsetX / u), a = r + c * (this.view.width / u), s -= h * (this.view.offsetY / l), o = s - h * (this.view.height / l);
    }
    this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far);
  },
  toJSON: function(e) {
    var t = Fe.prototype.toJSON.call(this, e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
});
function Bn(e, t, i, n, r, a) {
  this.a = e, this.b = t, this.c = i, this.normal = n && n.isVector3 ? n : new H(), this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new We(), this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = a !== void 0 ? a : 0;
}
Object.assign(Bn.prototype, {
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
    for (var t = 0, i = e.vertexNormals.length; t < i; t++)
      this.vertexNormals[t] = e.vertexNormals[t].clone();
    for (var t = 0, i = e.vertexColors.length; t < i; t++)
      this.vertexColors[t] = e.vertexColors[t].clone();
    return this;
  }
});
var WT = 0;
function tt() {
  Object.defineProperty(this, "id", { value: WT += 2 }), this.uuid = gt.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
tt.prototype = Object.assign(Object.create(Kn.prototype), {
  constructor: tt,
  isGeometry: !0,
  applyMatrix: function(e) {
    for (var t = new wi().getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) {
      var r = this.vertices[i];
      r.applyMatrix4(e);
    }
    for (var i = 0, n = this.faces.length; i < n; i++) {
      var a = this.faces[i];
      a.normal.applyMatrix3(t).normalize();
      for (var s = 0, o = a.vertexNormals.length; s < o; s++)
        a.vertexNormals[s].applyMatrix3(t).normalize();
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
  },
  rotateX: function() {
    var e = new at();
    return function(i) {
      return e.makeRotationX(i), this.applyMatrix(e), this;
    };
  }(),
  rotateY: function() {
    var e = new at();
    return function(i) {
      return e.makeRotationY(i), this.applyMatrix(e), this;
    };
  }(),
  rotateZ: function() {
    var e = new at();
    return function(i) {
      return e.makeRotationZ(i), this.applyMatrix(e), this;
    };
  }(),
  translate: function() {
    var e = new at();
    return function(i, n, r) {
      return e.makeTranslation(i, n, r), this.applyMatrix(e), this;
    };
  }(),
  scale: function() {
    var e = new at();
    return function(i, n, r) {
      return e.makeScale(i, n, r), this.applyMatrix(e), this;
    };
  }(),
  lookAt: function() {
    var e = new Fe();
    return function(i) {
      e.lookAt(i), e.updateMatrix(), this.applyMatrix(e.matrix);
    };
  }(),
  fromBufferGeometry: function(e) {
    var t = this, i = e.index !== null ? e.index.array : void 0, n = e.attributes, r = n.position.array, a = n.normal !== void 0 ? n.normal.array : void 0, s = n.color !== void 0 ? n.color.array : void 0, o = n.uv !== void 0 ? n.uv.array : void 0, u = n.uv2 !== void 0 ? n.uv2.array : void 0;
    u !== void 0 && (this.faceVertexUvs[1] = []);
    for (var l = [], c = [], h = [], d = 0, f = 0; d < r.length; d += 3, f += 2)
      t.vertices.push(new H(r[d], r[d + 1], r[d + 2])), a !== void 0 && l.push(new H(a[d], a[d + 1], a[d + 2])), s !== void 0 && t.colors.push(new We(s[d], s[d + 1], s[d + 2])), o !== void 0 && c.push(new ue(o[f], o[f + 1])), u !== void 0 && h.push(new ue(u[f], u[f + 1]));
    function p(C, R, k, F) {
      var B = a !== void 0 ? [l[C].clone(), l[R].clone(), l[k].clone()] : [], I = s !== void 0 ? [t.colors[C].clone(), t.colors[R].clone(), t.colors[k].clone()] : [], V = new Bn(C, R, k, B, I, F);
      t.faces.push(V), o !== void 0 && t.faceVertexUvs[0].push([c[C].clone(), c[R].clone(), c[k].clone()]), u !== void 0 && t.faceVertexUvs[1].push([h[C].clone(), h[R].clone(), h[k].clone()]);
    }
    var _ = e.groups;
    if (_.length > 0)
      for (var d = 0; d < _.length; d++)
        for (var m = _[d], x = m.start, E = m.count, f = x, M = x + E; f < M; f += 3)
          i !== void 0 ? p(i[f], i[f + 1], i[f + 2], m.materialIndex) : p(f, f + 1, f + 2, m.materialIndex);
    else if (i !== void 0)
      for (var d = 0; d < i.length; d += 3)
        p(i[d], i[d + 1], i[d + 2]);
    else
      for (var d = 0; d < r.length / 3; d += 3)
        p(d, d + 1, d + 2);
    return this.computeFaceNormals(), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  },
  center: function() {
    var e = new H();
    return function() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this;
    };
  }(),
  normalize: function() {
    this.computeBoundingSphere();
    var e = this.boundingSphere.center, t = this.boundingSphere.radius, i = t === 0 ? 1 : 1 / t, n = new at();
    return n.set(
      i,
      0,
      0,
      -i * e.x,
      0,
      i,
      0,
      -i * e.y,
      0,
      0,
      i,
      -i * e.z,
      0,
      0,
      0,
      1
    ), this.applyMatrix(n), this;
  },
  computeFaceNormals: function() {
    for (var e = new H(), t = new H(), i = 0, n = this.faces.length; i < n; i++) {
      var r = this.faces[i], a = this.vertices[r.a], s = this.vertices[r.b], o = this.vertices[r.c];
      e.subVectors(o, s), t.subVectors(a, s), e.cross(t), e.normalize(), r.normal.copy(e);
    }
  },
  computeVertexNormals: function(e) {
    e === void 0 && (e = !0);
    var t, i, n, r, a, s;
    for (s = new Array(this.vertices.length), t = 0, i = this.vertices.length; t < i; t++)
      s[t] = new H();
    if (e) {
      var o, u, l, c = new H(), h = new H();
      for (n = 0, r = this.faces.length; n < r; n++)
        a = this.faces[n], o = this.vertices[a.a], u = this.vertices[a.b], l = this.vertices[a.c], c.subVectors(l, u), h.subVectors(o, u), c.cross(h), s[a.a].add(c), s[a.b].add(c), s[a.c].add(c);
    } else
      for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++)
        a = this.faces[n], s[a.a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal);
    for (t = 0, i = this.vertices.length; t < i; t++)
      s[t].normalize();
    for (n = 0, r = this.faces.length; n < r; n++) {
      a = this.faces[n];
      var d = a.vertexNormals;
      d.length === 3 ? (d[0].copy(s[a.a]), d[1].copy(s[a.b]), d[2].copy(s[a.c])) : (d[0] = s[a.a].clone(), d[1] = s[a.b].clone(), d[2] = s[a.c].clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeFlatVertexNormals: function() {
    var e, t, i;
    for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
      i = this.faces[e];
      var n = i.vertexNormals;
      n.length === 3 ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeMorphNormals: function() {
    var e, t, i, n, r;
    for (i = 0, n = this.faces.length; i < n; i++)
      for (r = this.faces[i], r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; e < t; e++)
        r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
    var a = new tt();
    for (a.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        var s = this.morphNormals[e].faceNormals, o = this.morphNormals[e].vertexNormals, l, c;
        for (i = 0, n = this.faces.length; i < n; i++)
          l = new H(), c = { a: new H(), b: new H(), c: new H() }, s.push(l), o.push(c);
      }
      var u = this.morphNormals[e];
      a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals();
      var l, c;
      for (i = 0, n = this.faces.length; i < n; i++)
        r = this.faces[i], l = u.faceNormals[i], c = u.vertexNormals[i], l.copy(r.normal), c.a.copy(r.vertexNormals[0]), c.b.copy(r.vertexNormals[1]), c.c.copy(r.vertexNormals[2]);
    }
    for (i = 0, n = this.faces.length; i < n; i++)
      r = this.faces[i], r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals;
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new Gn()), this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new qr()), this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function(e, t, i) {
    if (!(e && e.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
      return;
    }
    var n, r = this.vertices.length, a = this.vertices, s = e.vertices, o = this.faces, u = e.faces, l = this.faceVertexUvs[0], c = e.faceVertexUvs[0], h = this.colors, d = e.colors;
    i === void 0 && (i = 0), t !== void 0 && (n = new wi().getNormalMatrix(t));
    for (var f = 0, p = s.length; f < p; f++) {
      var _ = s[f], m = _.clone();
      t !== void 0 && m.applyMatrix4(t), a.push(m);
    }
    for (var f = 0, p = d.length; f < p; f++)
      h.push(d[f].clone());
    for (f = 0, p = u.length; f < p; f++) {
      var x = u[f], E, M, C, R = x.vertexNormals, k = x.vertexColors;
      E = new Bn(x.a + r, x.b + r, x.c + r), E.normal.copy(x.normal), n !== void 0 && E.normal.applyMatrix3(n).normalize();
      for (var F = 0, B = R.length; F < B; F++)
        M = R[F].clone(), n !== void 0 && M.applyMatrix3(n).normalize(), E.vertexNormals.push(M);
      E.color.copy(x.color);
      for (var F = 0, B = k.length; F < B; F++)
        C = k[F], E.vertexColors.push(C.clone());
      E.materialIndex = x.materialIndex + i, o.push(E);
    }
    for (f = 0, p = c.length; f < p; f++) {
      var I = c[f], V = [];
      if (I !== void 0) {
        for (var F = 0, B = I.length; F < B; F++)
          V.push(I[F].clone());
        l.push(V);
      }
    }
  },
  mergeMesh: function(e) {
    if (!(e && e.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e);
      return;
    }
    e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix);
  },
  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function() {
    var e = {}, t = [], i = [], n, r, a = 4, s = Math.pow(10, a), o, u, l, c, h, d;
    for (o = 0, u = this.vertices.length; o < u; o++)
      n = this.vertices[o], r = Math.round(n.x * s) + "_" + Math.round(n.y * s) + "_" + Math.round(n.z * s), e[r] === void 0 ? (e[r] = o, t.push(this.vertices[o]), i[o] = t.length - 1) : i[o] = i[e[r]];
    var f = [];
    for (o = 0, u = this.faces.length; o < u; o++) {
      l = this.faces[o], l.a = i[l.a], l.b = i[l.b], l.c = i[l.c], c = [l.a, l.b, l.c];
      for (var p = 0; p < 3; p++)
        if (c[p] === c[(p + 1) % 3]) {
          f.push(o);
          break;
        }
    }
    for (o = f.length - 1; o >= 0; o--) {
      var _ = f[o];
      for (this.faces.splice(_, 1), h = 0, d = this.faceVertexUvs.length; h < d; h++)
        this.faceVertexUvs[h].splice(_, 1);
    }
    var m = this.vertices.length - t.length;
    return this.vertices = t, m;
  },
  setFromPoints: function(e) {
    this.vertices = [];
    for (var t = 0, i = e.length; t < i; t++) {
      var n = e[t];
      this.vertices.push(new H(n.x, n.y, n.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function() {
    for (var e = this.faces, t = e.length, i = 0; i < t; i++)
      e[i]._id = i;
    function n(l, c) {
      return l.materialIndex - c.materialIndex;
    }
    e.sort(n);
    var r = this.faceVertexUvs[0], a = this.faceVertexUvs[1], s, o;
    r && r.length === t && (s = []), a && a.length === t && (o = []);
    for (var i = 0; i < t; i++) {
      var u = e[i]._id;
      s && s.push(r[u]), o && o.push(a[u]);
    }
    s && (this.faceVertexUvs[0] = s), o && (this.faceVertexUvs[1] = o);
  },
  toJSON: function() {
    var e = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), this.parameters !== void 0) {
      var t = this.parameters;
      for (var i in t)
        t[i] !== void 0 && (e[i] = t[i]);
      return e;
    }
    for (var n = [], r = 0; r < this.vertices.length; r++) {
      var a = this.vertices[r];
      n.push(a.x, a.y, a.z);
    }
    for (var s = [], o = [], u = {}, l = [], c = {}, h = [], d = {}, r = 0; r < this.faces.length; r++) {
      var f = this.faces[r], p = !0, _ = !1, m = this.faceVertexUvs[0][r] !== void 0, x = f.normal.length() > 0, E = f.vertexNormals.length > 0, M = f.color.r !== 1 || f.color.g !== 1 || f.color.b !== 1, C = f.vertexColors.length > 0, R = 0;
      if (R = I(R, 0, 0), R = I(R, 1, p), R = I(R, 2, _), R = I(R, 3, m), R = I(R, 4, x), R = I(R, 5, E), R = I(R, 6, M), R = I(R, 7, C), s.push(R), s.push(f.a, f.b, f.c), s.push(f.materialIndex), m) {
        var k = this.faceVertexUvs[0][r];
        s.push(
          ee(k[0]),
          ee(k[1]),
          ee(k[2])
        );
      }
      if (x && s.push(V(f.normal)), E) {
        var F = f.vertexNormals;
        s.push(
          V(F[0]),
          V(F[1]),
          V(F[2])
        );
      }
      if (M && s.push(Q(f.color)), C) {
        var B = f.vertexColors;
        s.push(
          Q(B[0]),
          Q(B[1]),
          Q(B[2])
        );
      }
    }
    function I(oe, fe, he) {
      return he ? oe | 1 << fe : oe & ~(1 << fe);
    }
    function V(oe) {
      var fe = oe.x.toString() + oe.y.toString() + oe.z.toString();
      return u[fe] !== void 0 || (u[fe] = o.length / 3, o.push(oe.x, oe.y, oe.z)), u[fe];
    }
    function Q(oe) {
      var fe = oe.r.toString() + oe.g.toString() + oe.b.toString();
      return c[fe] !== void 0 || (c[fe] = l.length, l.push(oe.getHex())), c[fe];
    }
    function ee(oe) {
      var fe = oe.x.toString() + oe.y.toString();
      return d[fe] !== void 0 || (d[fe] = h.length / 2, h.push(oe.x, oe.y)), d[fe];
    }
    return e.data = {}, e.data.vertices = n, e.data.normals = o, l.length > 0 && (e.data.colors = l), h.length > 0 && (e.data.uvs = [h]), e.data.faces = s, e;
  },
  clone: function() {
    return new tt().copy(this);
  },
  copy: function(e) {
    var t, i, n, r, a, s;
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
    var o = e.vertices;
    for (t = 0, i = o.length; t < i; t++)
      this.vertices.push(o[t].clone());
    var u = e.colors;
    for (t = 0, i = u.length; t < i; t++)
      this.colors.push(u[t].clone());
    var l = e.faces;
    for (t = 0, i = l.length; t < i; t++)
      this.faces.push(l[t].clone());
    for (t = 0, i = e.faceVertexUvs.length; t < i; t++) {
      var c = e.faceVertexUvs[t];
      for (this.faceVertexUvs[t] === void 0 && (this.faceVertexUvs[t] = []), n = 0, r = c.length; n < r; n++) {
        var h = c[n], d = [];
        for (a = 0, s = h.length; a < s; a++) {
          var f = h[a];
          d.push(f.clone());
        }
        this.faceVertexUvs[t].push(d);
      }
    }
    var p = e.morphTargets;
    for (t = 0, i = p.length; t < i; t++) {
      var _ = {};
      if (_.name = p[t].name, p[t].vertices !== void 0)
        for (_.vertices = [], n = 0, r = p[t].vertices.length; n < r; n++)
          _.vertices.push(p[t].vertices[n].clone());
      if (p[t].normals !== void 0)
        for (_.normals = [], n = 0, r = p[t].normals.length; n < r; n++)
          _.normals.push(p[t].normals[n].clone());
      this.morphTargets.push(_);
    }
    var m = e.morphNormals;
    for (t = 0, i = m.length; t < i; t++) {
      var x = {};
      if (m[t].vertexNormals !== void 0)
        for (x.vertexNormals = [], n = 0, r = m[t].vertexNormals.length; n < r; n++) {
          var E = m[t].vertexNormals[n], M = {};
          M.a = E.a.clone(), M.b = E.b.clone(), M.c = E.c.clone(), x.vertexNormals.push(M);
        }
      if (m[t].faceNormals !== void 0)
        for (x.faceNormals = [], n = 0, r = m[t].faceNormals.length; n < r; n++)
          x.faceNormals.push(m[t].faceNormals[n].clone());
      this.morphNormals.push(x);
    }
    var C = e.skinWeights;
    for (t = 0, i = C.length; t < i; t++)
      this.skinWeights.push(C[t].clone());
    var R = e.skinIndices;
    for (t = 0, i = R.length; t < i; t++)
      this.skinIndices.push(R[t].clone());
    var k = e.lineDistances;
    for (t = 0, i = k.length; t < i; t++)
      this.lineDistances.push(k[t]);
    var F = e.boundingBox;
    F !== null && (this.boundingBox = F.clone());
    var B = e.boundingSphere;
    return B !== null && (this.boundingSphere = B.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function pt(e, t, i) {
  if (Array.isArray(e))
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i === !0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
Object.defineProperty(pt.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
Object.assign(pt.prototype, {
  isBufferAttribute: !0,
  onUploadCallback: function() {
  },
  setArray: function(e) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    return this.count = e !== void 0 ? e.length / this.itemSize : 0, this.array = e, this;
  },
  setDynamic: function(e) {
    return this.dynamic = e, this;
  },
  copy: function(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this;
  },
  copyAt: function(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (var n = 0, r = this.itemSize; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  },
  copyArray: function(e) {
    return this.array.set(e), this;
  },
  copyColorsArray: function(e) {
    for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
      var a = e[n];
      a === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), a = new We()), t[i++] = a.r, t[i++] = a.g, t[i++] = a.b;
    }
    return this;
  },
  copyVector2sArray: function(e) {
    for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
      var a = e[n];
      a === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), a = new ue()), t[i++] = a.x, t[i++] = a.y;
    }
    return this;
  },
  copyVector3sArray: function(e) {
    for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
      var a = e[n];
      a === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new H()), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z;
    }
    return this;
  },
  copyVector4sArray: function(e) {
    for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
      var a = e[n];
      a === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), a = new Ft()), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z, t[i++] = a.w;
    }
    return this;
  },
  set: function(e, t) {
    return t === void 0 && (t = 0), this.array.set(e, t), this;
  },
  getX: function(e) {
    return this.array[e * this.itemSize];
  },
  setX: function(e, t) {
    return this.array[e * this.itemSize] = t, this;
  },
  getY: function(e) {
    return this.array[e * this.itemSize + 1];
  },
  setY: function(e, t) {
    return this.array[e * this.itemSize + 1] = t, this;
  },
  getZ: function(e) {
    return this.array[e * this.itemSize + 2];
  },
  setZ: function(e, t) {
    return this.array[e * this.itemSize + 2] = t, this;
  },
  getW: function(e) {
    return this.array[e * this.itemSize + 3];
  },
  setW: function(e, t) {
    return this.array[e * this.itemSize + 3] = t, this;
  },
  setXY: function(e, t, i) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this;
  },
  setXYZ: function(e, t, i, n) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this;
  },
  setXYZW: function(e, t, i, n, r) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this;
  },
  onUpload: function(e) {
    return this.onUploadCallback = e, this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
});
function bu(e, t, i) {
  pt.call(this, new Int8Array(e), t, i);
}
bu.prototype = Object.create(pt.prototype);
bu.prototype.constructor = bu;
function xu(e, t, i) {
  pt.call(this, new Uint8Array(e), t, i);
}
xu.prototype = Object.create(pt.prototype);
xu.prototype.constructor = xu;
function Au(e, t, i) {
  pt.call(this, new Uint8ClampedArray(e), t, i);
}
Au.prototype = Object.create(pt.prototype);
Au.prototype.constructor = Au;
function Tu(e, t, i) {
  pt.call(this, new Int16Array(e), t, i);
}
Tu.prototype = Object.create(pt.prototype);
Tu.prototype.constructor = Tu;
function Xa(e, t, i) {
  pt.call(this, new Uint16Array(e), t, i);
}
Xa.prototype = Object.create(pt.prototype);
Xa.prototype.constructor = Xa;
function Eu(e, t, i) {
  pt.call(this, new Int32Array(e), t, i);
}
Eu.prototype = Object.create(pt.prototype);
Eu.prototype.constructor = Eu;
function Ya(e, t, i) {
  pt.call(this, new Uint32Array(e), t, i);
}
Ya.prototype = Object.create(pt.prototype);
Ya.prototype.constructor = Ya;
function ke(e, t, i) {
  pt.call(this, new Float32Array(e), t, i);
}
ke.prototype = Object.create(pt.prototype);
ke.prototype.constructor = ke;
function wu(e, t, i) {
  pt.call(this, new Float64Array(e), t, i);
}
wu.prototype = Object.create(pt.prototype);
wu.prototype.constructor = wu;
function U0() {
  this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
Object.assign(U0.prototype, {
  computeGroups: function(e) {
    for (var t, i = [], n = void 0, r = e.faces, a = 0; a < r.length; a++) {
      var s = r[a];
      s.materialIndex !== n && (n = s.materialIndex, t !== void 0 && (t.count = a * 3 - t.start, i.push(t)), t = {
        start: a * 3,
        materialIndex: n
      });
    }
    t !== void 0 && (t.count = a * 3 - t.start, i.push(t)), this.groups = i;
  },
  fromGeometry: function(e) {
    var t = e.faces, i = e.vertices, n = e.faceVertexUvs, r = n[0] && n[0].length > 0, a = n[1] && n[1].length > 0, s = e.morphTargets, o = s.length, u;
    if (o > 0) {
      u = [];
      for (var l = 0; l < o; l++)
        u[l] = [];
      this.morphTargets.position = u;
    }
    var c = e.morphNormals, h = c.length, d;
    if (h > 0) {
      d = [];
      for (var l = 0; l < h; l++)
        d[l] = [];
      this.morphTargets.normal = d;
    }
    var f = e.skinIndices, p = e.skinWeights, _ = f.length === i.length, m = p.length === i.length;
    t.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (var l = 0; l < t.length; l++) {
      var x = t[l];
      this.vertices.push(i[x.a], i[x.b], i[x.c]);
      var E = x.vertexNormals;
      if (E.length === 3)
        this.normals.push(E[0], E[1], E[2]);
      else {
        var M = x.normal;
        this.normals.push(M, M, M);
      }
      var C = x.vertexColors;
      if (C.length === 3)
        this.colors.push(C[0], C[1], C[2]);
      else {
        var R = x.color;
        this.colors.push(R, R, R);
      }
      if (r === !0) {
        var k = n[0][l];
        k !== void 0 ? this.uvs.push(k[0], k[1], k[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new ue(), new ue(), new ue()));
      }
      if (a === !0) {
        var k = n[1][l];
        k !== void 0 ? this.uvs2.push(k[0], k[1], k[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new ue(), new ue(), new ue()));
      }
      for (var F = 0; F < o; F++) {
        var B = s[F].vertices;
        u[F].push(B[x.a], B[x.b], B[x.c]);
      }
      for (var F = 0; F < h; F++) {
        var I = c[F].vertexNormals[l];
        d[F].push(I.a, I.b, I.c);
      }
      _ && this.skinIndices.push(f[x.a], f[x.b], f[x.c]), m && this.skinWeights.push(p[x.a], p[x.b], p[x.c]);
    }
    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this;
  }
});
function j0(e) {
  if (e.length === 0) return -1 / 0;
  for (var t = e[0], i = 1, n = e.length; i < n; ++i)
    e[i] > t && (t = e[i]);
  return t;
}
var qT = 1;
function je() {
  Object.defineProperty(this, "id", { value: qT += 2 }), this.uuid = gt.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
}
je.prototype = Object.assign(Object.create(Kn.prototype), {
  constructor: je,
  isBufferGeometry: !0,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(e) {
    Array.isArray(e) ? this.index = new (j0(e) > 65535 ? Ya : Xa)(e, 1) : this.index = e;
  },
  addAttribute: function(e, t) {
    return !(t && t.isBufferAttribute) && !(t && t.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new pt(arguments[1], arguments[2]))) : e === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this);
  },
  getAttribute: function(e) {
    return this.attributes[e];
  },
  removeAttribute: function(e) {
    return delete this.attributes[e], this;
  },
  addGroup: function(e, t, i) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: i !== void 0 ? i : 0
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  },
  applyMatrix: function(e) {
    var t = this.attributes.position;
    t !== void 0 && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
    var i = this.attributes.normal;
    if (i !== void 0) {
      var n = new wi().getNormalMatrix(e);
      n.applyToBufferAttribute(i), i.needsUpdate = !0;
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  },
  rotateX: function() {
    var e = new at();
    return function(i) {
      return e.makeRotationX(i), this.applyMatrix(e), this;
    };
  }(),
  rotateY: function() {
    var e = new at();
    return function(i) {
      return e.makeRotationY(i), this.applyMatrix(e), this;
    };
  }(),
  rotateZ: function() {
    var e = new at();
    return function(i) {
      return e.makeRotationZ(i), this.applyMatrix(e), this;
    };
  }(),
  translate: function() {
    var e = new at();
    return function(i, n, r) {
      return e.makeTranslation(i, n, r), this.applyMatrix(e), this;
    };
  }(),
  scale: function() {
    var e = new at();
    return function(i, n, r) {
      return e.makeScale(i, n, r), this.applyMatrix(e), this;
    };
  }(),
  lookAt: function() {
    var e = new Fe();
    return function(i) {
      e.lookAt(i), e.updateMatrix(), this.applyMatrix(e.matrix);
    };
  }(),
  center: function() {
    var e = new H();
    return function() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this;
    };
  }(),
  setFromObject: function(e) {
    var t = e.geometry;
    if (e.isPoints || e.isLine) {
      var i = new ke(t.vertices.length * 3, 3), n = new ke(t.colors.length * 3, 3);
      if (this.addAttribute("position", i.copyVector3sArray(t.vertices)), this.addAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
        var r = new ke(t.lineDistances.length, 1);
        this.addAttribute("lineDistance", r.copyArray(t.lineDistances));
      }
      t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone());
    } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
    return this;
  },
  setFromPoints: function(e) {
    for (var t = [], i = 0, n = e.length; i < n; i++) {
      var r = e[i];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.addAttribute("position", new ke(t, 3)), this;
  },
  updateFromObject: function(e) {
    var t = e.geometry;
    if (e.isMesh) {
      var i = t.__directGeometry;
      if (t.elementsNeedUpdate === !0 && (i = void 0, t.elementsNeedUpdate = !1), i === void 0)
        return this.fromGeometry(t);
      i.verticesNeedUpdate = t.verticesNeedUpdate, i.normalsNeedUpdate = t.normalsNeedUpdate, i.colorsNeedUpdate = t.colorsNeedUpdate, i.uvsNeedUpdate = t.uvsNeedUpdate, i.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = i;
    }
    var n;
    return t.verticesNeedUpdate === !0 && (n = this.attributes.position, n !== void 0 && (n.copyVector3sArray(t.vertices), n.needsUpdate = !0), t.verticesNeedUpdate = !1), t.normalsNeedUpdate === !0 && (n = this.attributes.normal, n !== void 0 && (n.copyVector3sArray(t.normals), n.needsUpdate = !0), t.normalsNeedUpdate = !1), t.colorsNeedUpdate === !0 && (n = this.attributes.color, n !== void 0 && (n.copyColorsArray(t.colors), n.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (n = this.attributes.uv, n !== void 0 && (n.copyVector2sArray(t.uvs), n.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (n = this.attributes.lineDistance, n !== void 0 && (n.copyArray(t.lineDistances), n.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this;
  },
  fromGeometry: function(e) {
    return e.__directGeometry = new U0().fromGeometry(e), this.fromDirectGeometry(e.__directGeometry);
  },
  fromDirectGeometry: function(e) {
    var t = new Float32Array(e.vertices.length * 3);
    if (this.addAttribute("position", new pt(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
      var i = new Float32Array(e.normals.length * 3);
      this.addAttribute("normal", new pt(i, 3).copyVector3sArray(e.normals));
    }
    if (e.colors.length > 0) {
      var n = new Float32Array(e.colors.length * 3);
      this.addAttribute("color", new pt(n, 3).copyColorsArray(e.colors));
    }
    if (e.uvs.length > 0) {
      var r = new Float32Array(e.uvs.length * 2);
      this.addAttribute("uv", new pt(r, 2).copyVector2sArray(e.uvs));
    }
    if (e.uvs2.length > 0) {
      var a = new Float32Array(e.uvs2.length * 2);
      this.addAttribute("uv2", new pt(a, 2).copyVector2sArray(e.uvs2));
    }
    this.groups = e.groups;
    for (var s in e.morphTargets) {
      for (var o = [], u = e.morphTargets[s], l = 0, c = u.length; l < c; l++) {
        var h = u[l], d = new ke(h.length * 3, 3);
        o.push(d.copyVector3sArray(h));
      }
      this.morphAttributes[s] = o;
    }
    if (e.skinIndices.length > 0) {
      var f = new ke(e.skinIndices.length * 4, 4);
      this.addAttribute("skinIndex", f.copyVector4sArray(e.skinIndices));
    }
    if (e.skinWeights.length > 0) {
      var p = new ke(e.skinWeights.length * 4, 4);
      this.addAttribute("skinWeight", p.copyVector4sArray(e.skinWeights));
    }
    return e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), this;
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new Gn());
    var e = this.attributes.position;
    e !== void 0 ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  },
  computeBoundingSphere: function() {
    var e = new Gn(), t = new H();
    return function() {
      this.boundingSphere === null && (this.boundingSphere = new qr());
      var n = this.attributes.position;
      if (n) {
        var r = this.boundingSphere.center;
        e.setFromBufferAttribute(n), e.getCenter(r);
        for (var a = 0, s = 0, o = n.count; s < o; s++)
          t.x = n.getX(s), t.y = n.getY(s), t.z = n.getZ(s), a = Math.max(a, r.distanceToSquared(t));
        this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    };
  }(),
  computeFaceNormals: function() {
  },
  computeVertexNormals: function() {
    var e = this.index, t = this.attributes, i = this.groups;
    if (t.position) {
      var n = t.position.array;
      if (t.normal === void 0)
        this.addAttribute("normal", new pt(new Float32Array(n.length), 3));
      else
        for (var r = t.normal.array, a = 0, s = r.length; a < s; a++)
          r[a] = 0;
      var o = t.normal.array, u, l, c, h = new H(), d = new H(), f = new H(), p = new H(), _ = new H();
      if (e) {
        var m = e.array;
        i.length === 0 && this.addGroup(0, m.length);
        for (var x = 0, E = i.length; x < E; ++x)
          for (var M = i[x], C = M.start, R = M.count, a = C, s = C + R; a < s; a += 3)
            u = m[a + 0] * 3, l = m[a + 1] * 3, c = m[a + 2] * 3, h.fromArray(n, u), d.fromArray(n, l), f.fromArray(n, c), p.subVectors(f, d), _.subVectors(h, d), p.cross(_), o[u] += p.x, o[u + 1] += p.y, o[u + 2] += p.z, o[l] += p.x, o[l + 1] += p.y, o[l + 2] += p.z, o[c] += p.x, o[c + 1] += p.y, o[c + 2] += p.z;
      } else
        for (var a = 0, s = n.length; a < s; a += 9)
          h.fromArray(n, a), d.fromArray(n, a + 3), f.fromArray(n, a + 6), p.subVectors(f, d), _.subVectors(h, d), p.cross(_), o[a] = p.x, o[a + 1] = p.y, o[a + 2] = p.z, o[a + 3] = p.x, o[a + 4] = p.y, o[a + 5] = p.z, o[a + 6] = p.x, o[a + 7] = p.y, o[a + 8] = p.z;
      this.normalizeNormals(), t.normal.needsUpdate = !0;
    }
  },
  merge: function(e, t) {
    if (!(e && e.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
      return;
    }
    t === void 0 && (t = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    var i = this.attributes;
    for (var n in i)
      if (e.attributes[n] !== void 0)
        for (var r = i[n], a = r.array, s = e.attributes[n], o = s.array, u = s.itemSize, l = 0, c = u * t; l < o.length; l++, c++)
          a[c] = o[l];
    return this;
  },
  normalizeNormals: function() {
    var e = new H();
    return function() {
      for (var i = this.attributes.normal, n = 0, r = i.count; n < r; n++)
        e.x = i.getX(n), e.y = i.getY(n), e.z = i.getZ(n), e.normalize(), i.setXYZ(n, e.x, e.y, e.z);
    };
  }(),
  toNonIndexed: function() {
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    var e = new je(), t = this.index.array, i = this.attributes;
    for (var n in i) {
      for (var r = i[n], a = r.array, s = r.itemSize, o = new a.constructor(t.length * s), u = 0, l = 0, c = 0, h = t.length; c < h; c++) {
        u = t[c] * s;
        for (var d = 0; d < s; d++)
          o[l++] = a[u++];
      }
      e.addAttribute(n, new pt(o, s));
    }
    for (var f = this.groups, c = 0, h = f.length; c < h; c++) {
      var p = f[c];
      e.addGroup(p.start, p.count, p.materialIndex);
    }
    return e;
  },
  toJSON: function() {
    var e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      var t = this.parameters;
      for (var i in t)
        t[i] !== void 0 && (e[i] = t[i]);
      return e;
    }
    e.data = { attributes: {} };
    var n = this.index;
    if (n !== null) {
      var r = Array.prototype.slice.call(n.array);
      e.data.index = {
        type: n.array.constructor.name,
        array: r
      };
    }
    var a = this.attributes;
    for (var i in a) {
      var s = a[i], r = Array.prototype.slice.call(s.array);
      e.data.attributes[i] = {
        itemSize: s.itemSize,
        type: s.array.constructor.name,
        array: r,
        normalized: s.normalized
      };
    }
    var o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    var u = this.boundingSphere;
    return u !== null && (e.data.boundingSphere = {
      center: u.center.toArray(),
      radius: u.radius
    }), e;
  },
  clone: function() {
    return new je().copy(this);
  },
  copy: function(e) {
    var t, i, n;
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
    var r = e.index;
    r !== null && this.setIndex(r.clone());
    var a = e.attributes;
    for (t in a) {
      var s = a[t];
      this.addAttribute(t, s.clone());
    }
    var o = e.morphAttributes;
    for (t in o) {
      var u = [], l = o[t];
      for (i = 0, n = l.length; i < n; i++)
        u.push(l[i].clone());
      this.morphAttributes[t] = u;
    }
    var c = e.groups;
    for (i = 0, n = c.length; i < n; i++) {
      var h = c[i];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    var d = e.boundingBox;
    d !== null && (this.boundingBox = d.clone());
    var f = e.boundingSphere;
    return f !== null && (this.boundingSphere = f.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function la(e, t, i, n, r, a) {
  tt.call(this), this.type = "BoxGeometry", this.parameters = {
    width: e,
    height: t,
    depth: i,
    widthSegments: n,
    heightSegments: r,
    depthSegments: a
  }, this.fromBufferGeometry(new Qa(e, t, i, n, r, a)), this.mergeVertices();
}
la.prototype = Object.create(tt.prototype);
la.prototype.constructor = la;
function Qa(e, t, i, n, r, a) {
  je.call(this), this.type = "BoxBufferGeometry", this.parameters = {
    width: e,
    height: t,
    depth: i,
    widthSegments: n,
    heightSegments: r,
    depthSegments: a
  };
  var s = this;
  e = e || 1, t = t || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1;
  var o = [], u = [], l = [], c = [], h = 0, d = 0;
  f("z", "y", "x", -1, -1, i, t, e, a, r, 0), f("z", "y", "x", 1, -1, i, t, -e, a, r, 1), f("x", "z", "y", 1, 1, e, i, t, n, a, 2), f("x", "z", "y", 1, -1, e, i, -t, n, a, 3), f("x", "y", "z", 1, -1, e, t, i, n, r, 4), f("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(o), this.addAttribute("position", new ke(u, 3)), this.addAttribute("normal", new ke(l, 3)), this.addAttribute("uv", new ke(c, 2));
  function f(p, _, m, x, E, M, C, R, k, F, B) {
    var I = M / k, V = C / F, Q = M / 2, ee = C / 2, oe = R / 2, fe = k + 1, he = F + 1, de = 0, G = 0, j, se, ie = new H();
    for (se = 0; se < he; se++) {
      var Ce = se * V - ee;
      for (j = 0; j < fe; j++) {
        var K = j * I - Q;
        ie[p] = K * x, ie[_] = Ce * E, ie[m] = oe, u.push(ie.x, ie.y, ie.z), ie[p] = 0, ie[_] = 0, ie[m] = R > 0 ? 1 : -1, l.push(ie.x, ie.y, ie.z), c.push(j / k), c.push(1 - se / F), de += 1;
      }
    }
    for (se = 0; se < F; se++)
      for (j = 0; j < k; j++) {
        var xe = h + j + fe * se, pe = h + j + fe * (se + 1), Re = h + (j + 1) + fe * (se + 1), _e = h + (j + 1) + fe * se;
        o.push(xe, pe, _e), o.push(pe, Re, _e), G += 6;
      }
    s.addGroup(d, G, B), d += G, h += de;
  }
}
Qa.prototype = Object.create(je.prototype);
Qa.prototype.constructor = Qa;
function Su(e, t, i, n) {
  tt.call(this), this.type = "PlaneGeometry", this.parameters = {
    width: e,
    height: t,
    widthSegments: i,
    heightSegments: n
  }, this.fromBufferGeometry(new Ka(e, t, i, n)), this.mergeVertices();
}
Su.prototype = Object.create(tt.prototype);
Su.prototype.constructor = Su;
function Ka(e, t, i, n) {
  je.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
    width: e,
    height: t,
    widthSegments: i,
    heightSegments: n
  }, e = e || 1, t = t || 1;
  var r = e / 2, a = t / 2, s = Math.floor(i) || 1, o = Math.floor(n) || 1, u = s + 1, l = o + 1, c = e / s, h = t / o, d, f, p = [], _ = [], m = [], x = [];
  for (f = 0; f < l; f++) {
    var E = f * h - a;
    for (d = 0; d < u; d++) {
      var M = d * c - r;
      _.push(M, -E, 0), m.push(0, 0, 1), x.push(d / s), x.push(1 - f / o);
    }
  }
  for (f = 0; f < o; f++)
    for (d = 0; d < s; d++) {
      var C = d + u * f, R = d + u * (f + 1), k = d + 1 + u * (f + 1), F = d + 1 + u * f;
      p.push(C, R, F), p.push(R, k, F);
    }
  this.setIndex(p), this.addAttribute("position", new ke(_, 3)), this.addAttribute("normal", new ke(m, 3)), this.addAttribute("uv", new ke(x, 2));
}
Ka.prototype = Object.create(je.prototype);
Ka.prototype.constructor = Ka;
var XT = 0;
function dt() {
  Object.defineProperty(this, "id", { value: XT++ }), this.uuid = gt.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = bl, this.side = _l, this.flatShading = !1, this.vertexColors = sh, this.opacity = 1, this.transparent = !1, this.blendSrc = Lf, this.blendDst = Rf, this.blendEquation = Pf, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = uc, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0;
}
dt.prototype = Object.assign(Object.create(Kn.prototype), {
  constructor: dt,
  isMaterial: !0,
  onBeforeCompile: function() {
  },
  setValues: function(e) {
    if (e !== void 0)
      for (var t in e) {
        var i = e[t];
        if (i === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        if (t === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === Ef;
          continue;
        }
        var n = this[t];
        if (n === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : t === "overdraw" ? this[t] = Number(i) : this[t] = i;
      }
  },
  toJSON: function(e) {
    var t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    var i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearCoat !== void 0 && (i.clearCoat = this.clearCoat), this.clearCoatRoughness !== void 0 && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, i.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.size !== void 0 && (i.size = this.size), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== bl && (i.blending = this.blending), this.flatShading === !0 && (i.flatShading = this.flatShading), this.side !== _l && (i.side = this.side), this.vertexColors !== sh && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, this.rotation !== 0 && (i.rotation = this.rotation), this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (i.morphTargets = !0), this.skinning === !0 && (i.skinning = !0), this.visible === !1 && (i.visible = !1), JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData);
    function n(s) {
      var o = [];
      for (var u in s) {
        var l = s[u];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      var r = n(e.textures), a = n(e.images);
      r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a);
    }
    return i;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.overdraw = e.overdraw, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
    var t = e.clippingPlanes, i = null;
    if (t !== null) {
      var n = t.length;
      i = new Array(n);
      for (var r = 0; r !== n; ++r)
        i[r] = t[r].clone();
    }
    return this.clippingPlanes = i, this.shadowSide = e.shadowSide, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function Ei(e) {
  dt.call(this), this.type = "MeshBasicMaterial", this.color = new We(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = xl, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e);
}
Ei.prototype = Object.create(dt.prototype);
Ei.prototype.constructor = Ei;
Ei.prototype.isMeshBasicMaterial = !0;
Ei.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this;
};
function Mr(e) {
  dt.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
    derivatives: !1,
    // set to use derivatives
    fragDepth: !1,
    // set to use fragment depth values
    drawBuffers: !1,
    // set to use draw buffers
    shaderTextureLOD: !1
    // set to use shader texture LOD
  }, this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
}
Mr.prototype = Object.create(dt.prototype);
Mr.prototype.constructor = Mr;
Mr.prototype.isShaderMaterial = !0;
Mr.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = sr.clone(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this;
};
Mr.prototype.toJSON = function(e) {
  var t = dt.prototype.toJSON.call(this, e);
  return t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t;
};
function ms(e, t) {
  this.origin = e !== void 0 ? e : new H(), this.direction = t !== void 0 ? t : new H();
}
Object.assign(ms.prototype, {
  set: function(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  },
  at: function(e, t) {
    return t === void 0 && (console.warn("THREE.Ray: .at() target is now required"), t = new H()), t.copy(this.direction).multiplyScalar(e).add(this.origin);
  },
  lookAt: function(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  },
  recast: function() {
    var e = new H();
    return function(i) {
      return this.origin.copy(this.at(i, e)), this;
    };
  }(),
  closestPointToPoint: function(e, t) {
    t === void 0 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new H()), t.subVectors(e, this.origin);
    var i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin);
  },
  distanceToPoint: function(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  },
  distanceSqToPoint: function() {
    var e = new H();
    return function(i) {
      var n = e.subVectors(i, this.origin).dot(this.direction);
      return n < 0 ? this.origin.distanceToSquared(i) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceToSquared(i));
    };
  }(),
  distanceSqToSegment: function() {
    var e = new H(), t = new H(), i = new H();
    return function(r, a, s, o) {
      e.copy(r).add(a).multiplyScalar(0.5), t.copy(a).sub(r).normalize(), i.copy(this.origin).sub(e);
      var u = r.distanceTo(a) * 0.5, l = -this.direction.dot(t), c = i.dot(this.direction), h = -i.dot(t), d = i.lengthSq(), f = Math.abs(1 - l * l), p, _, m, x;
      if (f > 0)
        if (p = l * h - c, _ = l * c - h, x = u * f, p >= 0)
          if (_ >= -x)
            if (_ <= x) {
              var E = 1 / f;
              p *= E, _ *= E, m = p * (p + l * _ + 2 * c) + _ * (l * p + _ + 2 * h) + d;
            } else
              _ = u, p = Math.max(0, -(l * _ + c)), m = -p * p + _ * (_ + 2 * h) + d;
          else
            _ = -u, p = Math.max(0, -(l * _ + c)), m = -p * p + _ * (_ + 2 * h) + d;
        else
          _ <= -x ? (p = Math.max(0, -(-l * u + c)), _ = p > 0 ? -u : Math.min(Math.max(-u, -h), u), m = -p * p + _ * (_ + 2 * h) + d) : _ <= x ? (p = 0, _ = Math.min(Math.max(-u, -h), u), m = _ * (_ + 2 * h) + d) : (p = Math.max(0, -(l * u + c)), _ = p > 0 ? u : Math.min(Math.max(-u, -h), u), m = -p * p + _ * (_ + 2 * h) + d);
      else
        _ = l > 0 ? -u : u, p = Math.max(0, -(l * _ + c)), m = -p * p + _ * (_ + 2 * h) + d;
      return s && s.copy(this.direction).multiplyScalar(p).add(this.origin), o && o.copy(t).multiplyScalar(_).add(e), m;
    };
  }(),
  intersectSphere: function() {
    var e = new H();
    return function(i, n) {
      e.subVectors(i.center, this.origin);
      var r = e.dot(this.direction), a = e.dot(e) - r * r, s = i.radius * i.radius;
      if (a > s) return null;
      var o = Math.sqrt(s - a), u = r - o, l = r + o;
      return u < 0 && l < 0 ? null : u < 0 ? this.at(l, n) : this.at(u, n);
    };
  }(),
  intersectsSphere: function(e) {
    return this.distanceToPoint(e.center) <= e.radius;
  },
  distanceToPlane: function(e) {
    var t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    var i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  },
  intersectPlane: function(e, t) {
    var i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  },
  intersectsPlane: function(e) {
    var t = e.distanceToPoint(this.origin);
    if (t === 0)
      return !0;
    var i = e.normal.dot(this.direction);
    return i * t < 0;
  },
  intersectBox: function(e, t) {
    var i, n, r, a, s, o, u = 1 / this.direction.x, l = 1 / this.direction.y, c = 1 / this.direction.z, h = this.origin;
    return u >= 0 ? (i = (e.min.x - h.x) * u, n = (e.max.x - h.x) * u) : (i = (e.max.x - h.x) * u, n = (e.min.x - h.x) * u), l >= 0 ? (r = (e.min.y - h.y) * l, a = (e.max.y - h.y) * l) : (r = (e.max.y - h.y) * l, a = (e.min.y - h.y) * l), i > a || r > n || ((r > i || i !== i) && (i = r), (a < n || n !== n) && (n = a), c >= 0 ? (s = (e.min.z - h.z) * c, o = (e.max.z - h.z) * c) : (s = (e.max.z - h.z) * c, o = (e.min.z - h.z) * c), i > o || s > n) || ((s > i || i !== i) && (i = s), (o < n || n !== n) && (n = o), n < 0) ? null : this.at(i >= 0 ? i : n, t);
  },
  intersectsBox: function() {
    var e = new H();
    return function(i) {
      return this.intersectBox(i, e) !== null;
    };
  }(),
  intersectTriangle: function() {
    var e = new H(), t = new H(), i = new H(), n = new H();
    return function(a, s, o, u, l) {
      t.subVectors(s, a), i.subVectors(o, a), n.crossVectors(t, i);
      var c = this.direction.dot(n), h;
      if (c > 0) {
        if (u) return null;
        h = 1;
      } else if (c < 0)
        h = -1, c = -c;
      else
        return null;
      e.subVectors(this.origin, a);
      var d = h * this.direction.dot(i.crossVectors(e, i));
      if (d < 0)
        return null;
      var f = h * this.direction.dot(t.cross(e));
      if (f < 0 || d + f > c)
        return null;
      var p = -h * e.dot(n);
      return p < 0 ? null : this.at(p / c, l);
    };
  }(),
  applyMatrix4: function(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  },
  equals: function(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
});
function ks(e, t) {
  this.start = e !== void 0 ? e : new H(), this.end = t !== void 0 ? t : new H();
}
Object.assign(ks.prototype, {
  set: function(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  },
  getCenter: function(e) {
    return e === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new H()), e.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function(e) {
    return e === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), e = new H()), e.subVectors(this.end, this.start);
  },
  distanceSq: function() {
    return this.start.distanceToSquared(this.end);
  },
  distance: function() {
    return this.start.distanceTo(this.end);
  },
  at: function(e, t) {
    return t === void 0 && (console.warn("THREE.Line3: .at() target is now required"), t = new H()), this.delta(t).multiplyScalar(e).add(this.start);
  },
  closestPointToPointParameter: function() {
    var e = new H(), t = new H();
    return function(n, r) {
      e.subVectors(n, this.start), t.subVectors(this.end, this.start);
      var a = t.dot(t), s = t.dot(e), o = s / a;
      return r && (o = gt.clamp(o, 0, 1)), o;
    };
  }(),
  closestPointToPoint: function(e, t, i) {
    var n = this.closestPointToPointParameter(e, t);
    return i === void 0 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new H()), this.delta(i).multiplyScalar(n).add(this.start);
  },
  applyMatrix4: function(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  },
  equals: function(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
});
function Sr(e, t, i) {
  this.a = e !== void 0 ? e : new H(), this.b = t !== void 0 ? t : new H(), this.c = i !== void 0 ? i : new H();
}
Object.assign(Sr, {
  getNormal: function() {
    var e = new H();
    return function(i, n, r, a) {
      a === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), a = new H()), a.subVectors(r, n), e.subVectors(i, n), a.cross(e);
      var s = a.lengthSq();
      return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0);
    };
  }(),
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord: function() {
    var e = new H(), t = new H(), i = new H();
    return function(r, a, s, o, u) {
      e.subVectors(o, a), t.subVectors(s, a), i.subVectors(r, a);
      var l = e.dot(e), c = e.dot(t), h = e.dot(i), d = t.dot(t), f = t.dot(i), p = l * d - c * c;
      if (u === void 0 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), u = new H()), p === 0)
        return u.set(-2, -1, -1);
      var _ = 1 / p, m = (d * h - c * f) * _, x = (l * f - c * h) * _;
      return u.set(1 - m - x, x, m);
    };
  }(),
  containsPoint: function() {
    var e = new H();
    return function(i, n, r, a) {
      return Sr.getBarycoord(i, n, r, a, e), e.x >= 0 && e.y >= 0 && e.x + e.y <= 1;
    };
  }()
});
Object.assign(Sr.prototype, {
  set: function(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  },
  setFromPointsAndIndices: function(e, t, i, n) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  },
  getArea: function() {
    var e = new H(), t = new H();
    return function() {
      return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), e.cross(t).length() * 0.5;
    };
  }(),
  getMidpoint: function(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new H()), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function(e) {
    return Sr.getNormal(this.a, this.b, this.c, e);
  },
  getPlane: function(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new H()), e.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function(e, t) {
    return Sr.getBarycoord(e, this.a, this.b, this.c, t);
  },
  containsPoint: function(e) {
    return Sr.containsPoint(e, this.a, this.b, this.c);
  },
  intersectsBox: function(e) {
    return e.intersectsTriangle(this);
  },
  closestPointToPoint: function() {
    var e = new Gr(), t = [new ks(), new ks(), new ks()], i = new H(), n = new H();
    return function(a, s) {
      s === void 0 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), s = new H());
      var o = 1 / 0;
      if (e.setFromCoplanarPoints(this.a, this.b, this.c), e.projectPoint(a, i), this.containsPoint(i) === !0)
        s.copy(i);
      else {
        t[0].set(this.a, this.b), t[1].set(this.b, this.c), t[2].set(this.c, this.a);
        for (var u = 0; u < t.length; u++) {
          t[u].closestPointToPoint(i, !0, n);
          var l = i.distanceToSquared(n);
          l < o && (o = l, s.copy(n));
        }
      }
      return s;
    };
  }(),
  equals: function(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
});
function fi(e, t) {
  Fe.call(this), this.type = "Mesh", this.geometry = e !== void 0 ? e : new je(), this.material = t !== void 0 ? t : new Ei({ color: Math.random() * 16777215 }), this.drawMode = Nf, this.updateMorphTargets();
}
fi.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: fi,
  isMesh: !0,
  setDrawMode: function(e) {
    this.drawMode = e;
  },
  copy: function(e) {
    return Fe.prototype.copy.call(this, e), this.drawMode = e.drawMode, e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this;
  },
  updateMorphTargets: function() {
    var e = this.geometry, t, i, n;
    if (e.isBufferGeometry) {
      var r = e.morphAttributes, a = Object.keys(r);
      if (a.length > 0) {
        var s = r[a[0]];
        if (s !== void 0)
          for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, i = s.length; t < i; t++)
            n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
      }
    } else {
      var o = e.morphTargets;
      if (o !== void 0 && o.length > 0)
        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, i = o.length; t < i; t++)
          n = o[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
    }
  },
  raycast: function() {
    var e = new at(), t = new ms(), i = new qr(), n = new H(), r = new H(), a = new H(), s = new H(), o = new H(), u = new H(), l = new ue(), c = new ue(), h = new ue(), d = new H(), f = new H(), p = new H();
    function _(E, M, C, R, k, F, B) {
      return Sr.getBarycoord(E, M, C, R, d), k.multiplyScalar(d.x), F.multiplyScalar(d.y), B.multiplyScalar(d.z), k.add(F).add(B), k.clone();
    }
    function m(E, M, C, R, k, F, B, I) {
      var V;
      if (M.side === Ti ? V = R.intersectTriangle(B, F, k, !0, I) : V = R.intersectTriangle(k, F, B, M.side !== Io, I), V === null) return null;
      p.copy(I), p.applyMatrix4(E.matrixWorld);
      var Q = C.ray.origin.distanceTo(p);
      return Q < C.near || Q > C.far ? null : {
        distance: Q,
        point: p.clone(),
        object: E
      };
    }
    function x(E, M, C, R, k, F, B, I) {
      n.fromBufferAttribute(R, F), r.fromBufferAttribute(R, B), a.fromBufferAttribute(R, I);
      var V = m(E, E.material, M, C, n, r, a, f);
      if (V) {
        k && (l.fromBufferAttribute(k, F), c.fromBufferAttribute(k, B), h.fromBufferAttribute(k, I), V.uv = _(f, n, r, a, l, c, h));
        var Q = new Bn(F, B, I);
        Sr.getNormal(n, r, a, Q.normal), V.face = Q;
      }
      return V;
    }
    return function(M, C) {
      var R = this.geometry, k = this.material, F = this.matrixWorld;
      if (k !== void 0 && (R.boundingSphere === null && R.computeBoundingSphere(), i.copy(R.boundingSphere), i.applyMatrix4(F), M.ray.intersectsSphere(i) !== !1 && (e.getInverse(F), t.copy(M.ray).applyMatrix4(e), !(R.boundingBox !== null && t.intersectsBox(R.boundingBox) === !1)))) {
        var B;
        if (R.isBufferGeometry) {
          var I, V, Q, ee = R.index, oe = R.attributes.position, fe = R.attributes.uv, he, de;
          if (ee !== null)
            for (he = 0, de = ee.count; he < de; he += 3)
              I = ee.getX(he), V = ee.getX(he + 1), Q = ee.getX(he + 2), B = x(this, M, t, oe, fe, I, V, Q), B && (B.faceIndex = Math.floor(he / 3), C.push(B));
          else if (oe !== void 0)
            for (he = 0, de = oe.count; he < de; he += 3)
              I = he, V = he + 1, Q = he + 2, B = x(this, M, t, oe, fe, I, V, Q), B && (B.faceIndex = Math.floor(he / 3), C.push(B));
        } else if (R.isGeometry) {
          var G, j, se, ie = Array.isArray(k), Ce = R.vertices, K = R.faces, xe, pe = R.faceVertexUvs[0];
          pe.length > 0 && (xe = pe);
          for (var Re = 0, _e = K.length; Re < _e; Re++) {
            var Le = K[Re], Ve = ie ? k[Le.materialIndex] : k;
            if (Ve !== void 0) {
              if (G = Ce[Le.a], j = Ce[Le.b], se = Ce[Le.c], Ve.morphTargets === !0) {
                var ft = R.morphTargets, Ee = this.morphTargetInfluences;
                n.set(0, 0, 0), r.set(0, 0, 0), a.set(0, 0, 0);
                for (var ct = 0, kt = ft.length; ct < kt; ct++) {
                  var Mt = Ee[ct];
                  if (Mt !== 0) {
                    var Vt = ft[ct].vertices;
                    n.addScaledVector(s.subVectors(Vt[Le.a], G), Mt), r.addScaledVector(o.subVectors(Vt[Le.b], j), Mt), a.addScaledVector(u.subVectors(Vt[Le.c], se), Mt);
                  }
                }
                n.add(G), r.add(j), a.add(se), G = n, j = r, se = a;
              }
              if (B = m(this, Ve, M, t, G, j, se, f), B) {
                if (xe && xe[Re]) {
                  var yt = xe[Re];
                  l.copy(yt[0]), c.copy(yt[1]), h.copy(yt[2]), B.uv = _(f, G, j, se, l, c, h);
                }
                B.face = Le, B.faceIndex = Re, C.push(B);
              }
            }
          }
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function YT(e, t, i, n) {
  var r = new We(0), a = 0, s, o, u;
  function l(h, d, f, p) {
    var _ = d.background;
    _ === null ? c(r, a) : _ && _.isColor && (c(_, 1), p = !0), (e.autoClear || p) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), _ && _.isCubeTexture ? (u === void 0 && (u = new fi(
      new Qa(1, 1, 1),
      new Mr({
        uniforms: Fa.cube.uniforms,
        vertexShader: Fa.cube.vertexShader,
        fragmentShader: Fa.cube.fragmentShader,
        side: Ti,
        depthTest: !0,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.removeAttribute("normal"), u.geometry.removeAttribute("uv"), u.onBeforeRender = function(m, x, E) {
      this.matrixWorld.copyPosition(E.matrixWorld);
    }, i.update(u)), u.material.uniforms.tCube.value = _, h.push(u, u.geometry, u.material, 0, null)) : _ && _.isTexture && (s === void 0 && (s = new Hs(-1, 1, 1, -1, 0, 1), o = new fi(
      new Ka(2, 2),
      new Ei({ depthTest: !1, depthWrite: !1, fog: !1 })
    ), i.update(o)), o.material.map = _, e.renderBufferDirect(s, null, o.geometry, o.material, o, null));
  }
  function c(h, d) {
    t.buffers.color.setClear(h.r, h.g, h.b, d, n);
  }
  return {
    getClearColor: function() {
      return r;
    },
    setClearColor: function(h, d) {
      r.set(h), a = d !== void 0 ? d : 1, c(r, a);
    },
    getClearAlpha: function() {
      return a;
    },
    setClearAlpha: function(h) {
      a = h, c(r, a);
    },
    render: l
  };
}
function QT(e, t, i) {
  var n;
  function r(o) {
    n = o;
  }
  function a(o, u) {
    e.drawArrays(n, o, u), i.update(u, n);
  }
  function s(o, u, l) {
    var c = t.get("ANGLE_instanced_arrays");
    if (c === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    c.drawArraysInstancedANGLE(n, u, l, o.maxInstancedCount), i.update(l, n, o.maxInstancedCount);
  }
  this.setMode = r, this.render = a, this.renderInstances = s;
}
function KT(e, t, i) {
  var n;
  function r() {
    if (n !== void 0) return n;
    var C = t.get("EXT_texture_filter_anisotropic");
    return C !== null ? n = e.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : n = 0, n;
  }
  function a(C) {
    if (C === "highp") {
      if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
        return "highp";
      C = "mediump";
    }
    return C === "mediump" && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  var s = i.precision !== void 0 ? i.precision : "highp", o = a(s);
  o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o);
  var u = i.logarithmicDepthBuffer === !0, l = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), c = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS), h = e.getParameter(e.MAX_TEXTURE_SIZE), d = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), f = e.getParameter(e.MAX_VERTEX_ATTRIBS), p = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), _ = e.getParameter(e.MAX_VARYING_VECTORS), m = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), x = c > 0, E = !!t.get("OES_texture_float"), M = x && E;
  return {
    getMaxAnisotropy: r,
    getMaxPrecision: a,
    precision: s,
    logarithmicDepthBuffer: u,
    maxTextures: l,
    maxVertexTextures: c,
    maxTextureSize: h,
    maxCubemapSize: d,
    maxAttributes: f,
    maxVertexUniforms: p,
    maxVaryings: _,
    maxFragmentUniforms: m,
    vertexTextures: x,
    floatFragmentTextures: E,
    floatVertexTextures: M
  };
}
function ZT() {
  var e = this, t = null, i = 0, n = !1, r = !1, a = new Gr(), s = new wi(), o = { value: null, needsUpdate: !1 };
  this.uniform = o, this.numPlanes = 0, this.numIntersection = 0, this.init = function(c, h, d) {
    var f = c.length !== 0 || h || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || n;
    return n = h, t = l(c, d, 0), i = c.length, f;
  }, this.beginShadows = function() {
    r = !0, l(null);
  }, this.endShadows = function() {
    r = !1, u();
  }, this.setState = function(c, h, d, f, p, _) {
    if (!n || c === null || c.length === 0 || r && !d)
      r ? l(null) : u();
    else {
      var m = r ? 0 : i, x = m * 4, E = p.clippingState || null;
      o.value = E, E = l(c, f, x, _);
      for (var M = 0; M !== x; ++M)
        E[M] = t[M];
      p.clippingState = E, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += m;
    }
  };
  function u() {
    o.value !== t && (o.value = t, o.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function l(c, h, d, f) {
    var p = c !== null ? c.length : 0, _ = null;
    if (p !== 0) {
      if (_ = o.value, f !== !0 || _ === null) {
        var m = d + p * 4, x = h.matrixWorldInverse;
        s.getNormalMatrix(x), (_ === null || _.length < m) && (_ = new Float32Array(m));
        for (var E = 0, M = d; E !== p; ++E, M += 4)
          a.copy(c[E]).applyMatrix4(x, s), a.normal.toArray(_, M), _[M + 3] = a.constant;
      }
      o.value = _, o.needsUpdate = !0;
    }
    return e.numPlanes = p, _;
  }
}
function JT(e) {
  var t = {};
  return {
    get: function(i) {
      if (t[i] !== void 0)
        return t[i];
      var n;
      switch (i) {
        case "WEBGL_depth_texture":
          n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          n = e.getExtension(i);
      }
      return n === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), t[i] = n, n;
    }
  };
}
function $T(e, t, i) {
  var n = {}, r = {};
  function a(l) {
    var c = l.target, h = n[c.id];
    h.index !== null && t.remove(h.index);
    for (var d in h.attributes)
      t.remove(h.attributes[d]);
    c.removeEventListener("dispose", a), delete n[c.id];
    var f = r[c.id];
    f && (t.remove(f), delete r[c.id]), f = r[h.id], f && (t.remove(f), delete r[h.id]), i.memory.geometries--;
  }
  function s(l, c) {
    var h = n[c.id];
    return h || (c.addEventListener("dispose", a), c.isBufferGeometry ? h = c : c.isGeometry && (c._bufferGeometry === void 0 && (c._bufferGeometry = new je().setFromObject(l)), h = c._bufferGeometry), n[c.id] = h, i.memory.geometries++, h);
  }
  function o(l) {
    var c = l.index, h = l.attributes;
    c !== null && t.update(c, e.ELEMENT_ARRAY_BUFFER);
    for (var d in h)
      t.update(h[d], e.ARRAY_BUFFER);
    var f = l.morphAttributes;
    for (var d in f)
      for (var p = f[d], _ = 0, m = p.length; _ < m; _++)
        t.update(p[_], e.ARRAY_BUFFER);
  }
  function u(l) {
    var c = r[l.id];
    if (c) return c;
    var h = [], d = l.index, f = l.attributes;
    if (d !== null)
      for (var p = d.array, _ = 0, m = p.length; _ < m; _ += 3) {
        var x = p[_ + 0], E = p[_ + 1], M = p[_ + 2];
        h.push(x, E, E, M, M, x);
      }
    else
      for (var p = f.position.array, _ = 0, m = p.length / 3 - 1; _ < m; _ += 3) {
        var x = _ + 0, E = _ + 1, M = _ + 2;
        h.push(x, E, E, M, M, x);
      }
    return c = new (j0(h) > 65535 ? Ya : Xa)(h, 1), t.update(c, e.ELEMENT_ARRAY_BUFFER), r[l.id] = c, c;
  }
  return {
    get: s,
    update: o,
    getWireframeAttribute: u
  };
}
function e2(e, t, i) {
  var n;
  function r(c) {
    n = c;
  }
  var a, s;
  function o(c) {
    a = c.type, s = c.bytesPerElement;
  }
  function u(c, h) {
    e.drawElements(n, h, a, c * s), i.update(h, n);
  }
  function l(c, h, d) {
    var f = t.get("ANGLE_instanced_arrays");
    if (f === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    f.drawElementsInstancedANGLE(n, d, a, h * s, c.maxInstancedCount), i.update(d, n, c.maxInstancedCount);
  }
  this.setMode = r, this.setIndex = o, this.render = u, this.renderInstances = l;
}
function t2(e) {
  var t = {
    geometries: 0,
    textures: 0
  }, i = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(a, s, o) {
    switch (o = o || 1, i.calls++, s) {
      case e.TRIANGLES:
        i.triangles += o * (a / 3);
        break;
      case e.TRIANGLE_STRIP:
      case e.TRIANGLE_FAN:
        i.triangles += o * (a - 2);
        break;
      case e.LINES:
        i.lines += o * (a / 2);
        break;
      case e.LINE_STRIP:
        i.lines += o * (a - 1);
        break;
      case e.LINE_LOOP:
        i.lines += o * a;
        break;
      case e.POINTS:
        i.points += o * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
        break;
    }
  }
  function r() {
    i.frame++, i.calls = 0, i.triangles = 0, i.points = 0, i.lines = 0;
  }
  return {
    memory: t,
    render: i,
    programs: null,
    autoReset: !0,
    reset: r,
    update: n
  };
}
function i2(e, t) {
  return Math.abs(t[1]) - Math.abs(e[1]);
}
function r2(e) {
  var t = {}, i = new Float32Array(8);
  function n(r, a, s, o) {
    var u = r.morphTargetInfluences, l = u.length, c = t[a.id];
    if (c === void 0) {
      c = [];
      for (var h = 0; h < l; h++)
        c[h] = [h, 0];
      t[a.id] = c;
    }
    for (var d = s.morphTargets && a.morphAttributes.position, f = s.morphNormals && a.morphAttributes.normal, h = 0; h < l; h++) {
      var p = c[h];
      p[1] !== 0 && (d && a.removeAttribute("morphTarget" + h), f && a.removeAttribute("morphNormal" + h));
    }
    for (var h = 0; h < l; h++) {
      var p = c[h];
      p[0] = h, p[1] = u[h];
    }
    c.sort(i2);
    for (var h = 0; h < 8; h++) {
      var p = c[h];
      if (p) {
        var _ = p[0], m = p[1];
        if (m) {
          d && a.addAttribute("morphTarget" + h, d[_]), f && a.addAttribute("morphNormal" + h, f[_]), i[h] = m;
          continue;
        }
      }
      i[h] = 0;
    }
    o.getUniforms().setValue(e, "morphTargetInfluences", i);
  }
  return {
    update: n
  };
}
function n2(e, t) {
  var i = {};
  function n(a) {
    var s = t.render.frame, o = a.geometry, u = e.get(a, o);
    return i[u.id] !== s && (o.isGeometry && u.updateFromObject(a), e.update(u), i[u.id] = s), u;
  }
  function r() {
    i = {};
  }
  return {
    update: n,
    dispose: r
  };
}
function ca(e, t, i, n, r, a, s, o, u, l) {
  e = e !== void 0 ? e : [], t = t !== void 0 ? t : uh, ri.call(this, e, t, i, n, r, a, s, o, u, l), this.flipY = !1;
}
ca.prototype = Object.create(ri.prototype);
ca.prototype.constructor = ca;
ca.prototype.isCubeTexture = !0;
Object.defineProperty(ca.prototype, "images", {
  get: function() {
    return this.image;
  },
  set: function(e) {
    this.image = e;
  }
});
var G0 = new ri(), V0 = new ca();
function H0() {
  this.seq = [], this.map = {};
}
var kv = [], Bv = [], Fv = new Float32Array(16), Nv = new Float32Array(9), Uv = new Float32Array(4);
function Oo(e, t, i) {
  var n = e[0];
  if (n <= 0 || n > 0) return e;
  var r = t * i, a = kv[r];
  if (a === void 0 && (a = new Float32Array(r), kv[r] = a), t !== 0) {
    n.toArray(a, 0);
    for (var s = 1, o = 0; s !== t; ++s)
      o += i, e[s].toArray(a, o);
  }
  return a;
}
function li(e, t) {
  if (e.length !== t.length) return !1;
  for (var i = 0, n = e.length; i < n; i++)
    if (e[i] !== t[i]) return !1;
  return !0;
}
function Fi(e, t) {
  for (var i = 0, n = t.length; i < n; i++)
    e[i] = t[i];
}
function z0(e, t) {
  var i = Bv[t];
  i === void 0 && (i = new Int32Array(t), Bv[t] = i);
  for (var n = 0; n !== t; ++n)
    i[n] = e.allocTextureUnit();
  return i;
}
function a2(e, t) {
  var i = this.cache;
  i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t);
}
function s2(e, t) {
  var i = this.cache;
  i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t);
}
function o2(e, t) {
  var i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y);
  else {
    if (li(i, t)) return;
    e.uniform2fv(this.addr, t), Fi(i, t);
  }
}
function u2(e, t) {
  var i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z);
  else if (t.r !== void 0)
    (i[0] !== t.r || i[1] !== t.g || i[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b);
  else {
    if (li(i, t)) return;
    e.uniform3fv(this.addr, t), Fi(i, t);
  }
}
function l2(e, t) {
  var i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w);
  else {
    if (li(i, t)) return;
    e.uniform4fv(this.addr, t), Fi(i, t);
  }
}
function c2(e, t) {
  var i = this.cache, n = t.elements;
  if (n === void 0) {
    if (li(i, t)) return;
    e.uniformMatrix2fv(this.addr, !1, t), Fi(i, t);
  } else {
    if (li(i, n)) return;
    Uv.set(n), e.uniformMatrix2fv(this.addr, !1, Uv), Fi(i, n);
  }
}
function h2(e, t) {
  var i = this.cache, n = t.elements;
  if (n === void 0) {
    if (li(i, t)) return;
    e.uniformMatrix3fv(this.addr, !1, t), Fi(i, t);
  } else {
    if (li(i, n)) return;
    Nv.set(n), e.uniformMatrix3fv(this.addr, !1, Nv), Fi(i, n);
  }
}
function d2(e, t) {
  var i = this.cache, n = t.elements;
  if (n === void 0) {
    if (li(i, t)) return;
    e.uniformMatrix4fv(this.addr, !1, t), Fi(i, t);
  } else {
    if (li(i, n)) return;
    Fv.set(n), e.uniformMatrix4fv(this.addr, !1, Fv), Fi(i, n);
  }
}
function f2(e, t, i) {
  var n = this.cache, r = i.allocTextureUnit();
  n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(t || G0, r);
}
function p2(e, t, i) {
  var n = this.cache, r = i.allocTextureUnit();
  n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(t || V0, r);
}
function W0(e, t) {
  var i = this.cache;
  li(i, t) || (e.uniform2iv(this.addr, t), Fi(i, t));
}
function q0(e, t) {
  var i = this.cache;
  li(i, t) || (e.uniform3iv(this.addr, t), Fi(i, t));
}
function X0(e, t) {
  var i = this.cache;
  li(i, t) || (e.uniform4iv(this.addr, t), Fi(i, t));
}
function v2(e) {
  switch (e) {
    case 5126:
      return a2;
    case 35664:
      return o2;
    case 35665:
      return u2;
    case 35666:
      return l2;
    case 35674:
      return c2;
    case 35675:
      return h2;
    case 35676:
      return d2;
    case 35678:
    case 36198:
      return f2;
    case 35680:
      return p2;
    case 5124:
    case 35670:
      return s2;
    case 35667:
    case 35671:
      return W0;
    case 35668:
    case 35672:
      return q0;
    case 35669:
    case 35673:
      return X0;
  }
}
function m2(e, t) {
  var i = this.cache;
  li(i, t) || (e.uniform1fv(this.addr, t), Fi(i, t));
}
function g2(e, t) {
  var i = this.cache;
  li(i, t) || (e.uniform1iv(this.addr, t), Fi(i, t));
}
function y2(e, t) {
  var i = this.cache, n = Oo(t, this.size, 2);
  li(i, n) || (e.uniform2fv(this.addr, n), this.updateCache(n));
}
function _2(e, t) {
  var i = this.cache, n = Oo(t, this.size, 3);
  li(i, n) || (e.uniform3fv(this.addr, n), this.updateCache(n));
}
function b2(e, t) {
  var i = this.cache, n = Oo(t, this.size, 4);
  li(i, n) || (e.uniform4fv(this.addr, n), this.updateCache(n));
}
function x2(e, t) {
  var i = this.cache, n = Oo(t, this.size, 4);
  li(i, n) || (e.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n));
}
function A2(e, t) {
  var i = this.cache, n = Oo(t, this.size, 9);
  li(i, n) || (e.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n));
}
function T2(e, t) {
  var i = this.cache, n = Oo(t, this.size, 16);
  li(i, n) || (e.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n));
}
function E2(e, t, i) {
  var n = this.cache, r = t.length, a = z0(i, r);
  li(n, a) === !1 && (e.uniform1iv(this.addr, a), Fi(n, a));
  for (var s = 0; s !== r; ++s)
    i.setTexture2D(t[s] || G0, a[s]);
}
function w2(e, t, i) {
  var n = this.cache, r = t.length, a = z0(i, r);
  li(n, a) === !1 && (e.uniform1iv(this.addr, a), Fi(n, a));
  for (var s = 0; s !== r; ++s)
    i.setTextureCube(t[s] || V0, a[s]);
}
function S2(e) {
  switch (e) {
    case 5126:
      return m2;
    case 35664:
      return y2;
    case 35665:
      return _2;
    case 35666:
      return b2;
    case 35674:
      return x2;
    case 35675:
      return A2;
    case 35676:
      return T2;
    case 35678:
      return E2;
    case 35680:
      return w2;
    case 5124:
    case 35670:
      return g2;
    case 35667:
    case 35671:
      return W0;
    case 35668:
    case 35672:
      return q0;
    case 35669:
    case 35673:
      return X0;
  }
}
function C2(e, t, i) {
  this.id = e, this.addr = i, this.cache = [], this.setValue = v2(t.type);
}
function Y0(e, t, i) {
  this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = S2(t.type);
}
Y0.prototype.updateCache = function(e) {
  var t = this.cache;
  e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Fi(t, e);
};
function Q0(e) {
  this.id = e, H0.call(this);
}
Q0.prototype.setValue = function(e, t) {
  for (var i = this.seq, n = 0, r = i.length; n !== r; ++n) {
    var a = i[n];
    a.setValue(e, t[a.id]);
  }
};
var qh = /([\w\d_]+)(\])?(\[|\.)?/g;
function jv(e, t) {
  e.seq.push(t), e.map[t.id] = t;
}
function M2(e, t, i) {
  var n = e.name, r = n.length;
  for (qh.lastIndex = 0; ; ) {
    var a = qh.exec(n), s = qh.lastIndex, o = a[1], u = a[2] === "]", l = a[3];
    if (u && (o = o | 0), l === void 0 || l === "[" && s + 2 === r) {
      jv(i, l === void 0 ? new C2(o, e, t) : new Y0(o, e, t));
      break;
    } else {
      var c = i.map, h = c[o];
      h === void 0 && (h = new Q0(o), jv(i, h)), i = h;
    }
  }
}
function oa(e, t, i) {
  H0.call(this), this.renderer = i;
  for (var n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), r = 0; r < n; ++r) {
    var a = e.getActiveUniform(t, r), s = e.getUniformLocation(t, a.name);
    M2(a, s, this);
  }
}
oa.prototype.setValue = function(e, t, i) {
  var n = this.map[t];
  n !== void 0 && n.setValue(e, i, this.renderer);
};
oa.prototype.setOptional = function(e, t, i) {
  var n = t[i];
  n !== void 0 && this.setValue(e, i, n);
};
oa.upload = function(e, t, i, n) {
  for (var r = 0, a = t.length; r !== a; ++r) {
    var s = t[r], o = i[s.id];
    o.needsUpdate !== !1 && s.setValue(e, o.value, n);
  }
};
oa.seqWithValue = function(e, t) {
  for (var i = [], n = 0, r = e.length; n !== r; ++n) {
    var a = e[n];
    a.id in t && i.push(a);
  }
  return i;
};
function D2(e) {
  for (var t = e.split(`
`), i = 0; i < t.length; i++)
    t[i] = i + 1 + ": " + t[i];
  return t.join(`
`);
}
function Gv(e, t, i) {
  var n = e.createShader(t);
  return e.shaderSource(n, i), e.compileShader(n), e.getShaderParameter(n, e.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), e.getShaderInfoLog(n) !== "" && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t === e.VERTEX_SHADER ? "vertex" : "fragment", e.getShaderInfoLog(n), D2(i)), n;
}
var P2 = 0;
function K0(e) {
  switch (e) {
    case _u:
      return ["Linear", "( value )"];
    case R0:
      return ["sRGB", "( value )"];
    case I0:
      return ["RGBE", "( value )"];
    case O0:
      return ["RGBM", "( value, 7.0 )"];
    case k0:
      return ["RGBM", "( value, 16.0 )"];
    case B0:
      return ["RGBD", "( value, 256.0 )"];
    case Uf:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    default:
      throw new Error("unsupported encoding: " + e);
  }
}
function Xh(e, t) {
  var i = K0(t);
  return "vec4 " + e + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }";
}
function L2(e, t) {
  var i = K0(t);
  return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }";
}
function R2(e, t) {
  var i;
  switch (t) {
    case If:
      i = "Linear";
      break;
    case e0:
      i = "Reinhard";
      break;
    case t0:
      i = "Uncharted2";
      break;
    case i0:
      i = "OptimizedCineon";
      break;
    default:
      throw new Error("unsupported toneMapping: " + t);
  }
  return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }";
}
function I2(e, t, i) {
  e = e || {};
  var n = [
    e.derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
    (e.fragDepth || t.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
    e.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
    (e.shaderTextureLOD || t.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return n.filter(ru).join(`
`);
}
function O2(e) {
  var t = [];
  for (var i in e) {
    var n = e[i];
    n !== !1 && t.push("#define " + i + " " + n);
  }
  return t.join(`
`);
}
function k2(e, t) {
  for (var i = {}, n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), r = 0; r < n; r++) {
    var a = e.getActiveAttrib(t, r), s = a.name;
    i[s] = e.getAttribLocation(t, s);
  }
  return i;
}
function ru(e) {
  return e !== "";
}
function Vv(e, t) {
  return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights);
}
function Hv(e, t) {
  return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
function kd(e) {
  var t = /^[ \t]*#include +<([\w\d.]+)>/gm;
  function i(n, r) {
    var a = Ot[r];
    if (a === void 0)
      throw new Error("Can not resolve #include <" + r + ">");
    return kd(a);
  }
  return e.replace(t, i);
}
function zv(e) {
  var t = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  function i(n, r, a, s) {
    for (var o = "", u = parseInt(r); u < parseInt(a); u++)
      o += s.replace(/\[ i \]/g, "[ " + u + " ]");
    return o;
  }
  return e.replace(t, i);
}
function B2(e, t, i, n, r, a) {
  var s = e.context, o = n.defines, u = r.vertexShader, l = r.fragmentShader, c = "SHADOWMAP_TYPE_BASIC";
  a.shadowMapType === Tf ? c = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === Ig && (c = "SHADOWMAP_TYPE_PCF_SOFT");
  var h = "ENVMAP_TYPE_CUBE", d = "ENVMAP_MODE_REFLECTION", f = "ENVMAP_BLENDING_MULTIPLY";
  if (a.envMap) {
    switch (n.envMap.mapping) {
      case uh:
      case lc:
        h = "ENVMAP_TYPE_CUBE";
        break;
      case lh:
      case ch:
        h = "ENVMAP_TYPE_CUBE_UV";
        break;
      case Of:
      case cc:
        h = "ENVMAP_TYPE_EQUIREC";
        break;
      case kf:
        h = "ENVMAP_TYPE_SPHERE";
        break;
    }
    switch (n.envMap.mapping) {
      case lc:
      case cc:
        d = "ENVMAP_MODE_REFRACTION";
        break;
    }
    switch (n.combine) {
      case xl:
        f = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Jg:
        f = "ENVMAP_BLENDING_MIX";
        break;
      case $g:
        f = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  var p = e.gammaFactor > 0 ? e.gammaFactor : 1, _ = I2(n.extensions, a, t), m = O2(o), x = s.createProgram(), E, M;
  n.isRawShaderMaterial ? (E = [
    m
  ].filter(ru).join(`
`), E.length > 0 && (E += `
`), M = [
    _,
    m
  ].filter(ru).join(`
`), M.length > 0 && (M += `
`)) : (E = [
    "precision " + a.precision + " float;",
    "precision " + a.precision + " int;",
    "#define SHADER_NAME " + r.name,
    m,
    a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    "#define GAMMA_FACTOR " + p,
    "#define MAX_BONES " + a.maxBones,
    a.useFog && a.fog ? "#define USE_FOG" : "",
    a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
    a.map ? "#define USE_MAP" : "",
    a.envMap ? "#define USE_ENVMAP" : "",
    a.envMap ? "#define " + d : "",
    a.lightMap ? "#define USE_LIGHTMAP" : "",
    a.aoMap ? "#define USE_AOMAP" : "",
    a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    a.bumpMap ? "#define USE_BUMPMAP" : "",
    a.normalMap ? "#define USE_NORMALMAP" : "",
    a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    a.specularMap ? "#define USE_SPECULARMAP" : "",
    a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    a.metalnessMap ? "#define USE_METALNESSMAP" : "",
    a.alphaMap ? "#define USE_ALPHAMAP" : "",
    a.vertexColors ? "#define USE_COLOR" : "",
    a.flatShading ? "#define FLAT_SHADED" : "",
    a.skinning ? "#define USE_SKINNING" : "",
    a.useVertexTexture ? "#define BONE_TEXTURE" : "",
    a.morphTargets ? "#define USE_MORPHTARGETS" : "",
    a.morphNormals && a.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    a.doubleSided ? "#define DOUBLE_SIDED" : "",
    a.flipSided ? "#define FLIP_SIDED" : "",
    a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    a.shadowMapEnabled ? "#define " + c : "",
    a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    a.logarithmicDepthBuffer && t.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_COLOR",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_MORPHTARGETS",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(ru).join(`
`), M = [
    _,
    "precision " + a.precision + " float;",
    "precision " + a.precision + " int;",
    "#define SHADER_NAME " + r.name,
    m,
    a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "",
    // add '.0' if integer
    "#define GAMMA_FACTOR " + p,
    a.useFog && a.fog ? "#define USE_FOG" : "",
    a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
    a.map ? "#define USE_MAP" : "",
    a.envMap ? "#define USE_ENVMAP" : "",
    a.envMap ? "#define " + h : "",
    a.envMap ? "#define " + d : "",
    a.envMap ? "#define " + f : "",
    a.lightMap ? "#define USE_LIGHTMAP" : "",
    a.aoMap ? "#define USE_AOMAP" : "",
    a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    a.bumpMap ? "#define USE_BUMPMAP" : "",
    a.normalMap ? "#define USE_NORMALMAP" : "",
    a.specularMap ? "#define USE_SPECULARMAP" : "",
    a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    a.metalnessMap ? "#define USE_METALNESSMAP" : "",
    a.alphaMap ? "#define USE_ALPHAMAP" : "",
    a.vertexColors ? "#define USE_COLOR" : "",
    a.gradientMap ? "#define USE_GRADIENTMAP" : "",
    a.flatShading ? "#define FLAT_SHADED" : "",
    a.doubleSided ? "#define DOUBLE_SIDED" : "",
    a.flipSided ? "#define FLIP_SIDED" : "",
    a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    a.shadowMapEnabled ? "#define " + c : "",
    a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    a.logarithmicDepthBuffer && t.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "",
    a.envMap && t.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    a.toneMapping !== $l ? "#define TONE_MAPPING" : "",
    a.toneMapping !== $l ? Ot.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    a.toneMapping !== $l ? R2("toneMapping", a.toneMapping) : "",
    a.dithering ? "#define DITHERING" : "",
    a.outputEncoding || a.mapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? Ot.encodings_pars_fragment : "",
    // this code is required here because it is used by the various encoding/decoding function defined below
    a.mapEncoding ? Xh("mapTexelToLinear", a.mapEncoding) : "",
    a.envMapEncoding ? Xh("envMapTexelToLinear", a.envMapEncoding) : "",
    a.emissiveMapEncoding ? Xh("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "",
    a.outputEncoding ? L2("linearToOutputTexel", a.outputEncoding) : "",
    a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(ru).join(`
`)), u = kd(u), u = Vv(u, a), u = Hv(u, a), l = kd(l), l = Vv(l, a), l = Hv(l, a), u = zv(u), l = zv(l);
  var C = E + u, R = M + l, k = Gv(s, s.VERTEX_SHADER, C), F = Gv(s, s.FRAGMENT_SHADER, R);
  s.attachShader(x, k), s.attachShader(x, F), n.index0AttributeName !== void 0 ? s.bindAttribLocation(x, 0, n.index0AttributeName) : a.morphTargets === !0 && s.bindAttribLocation(x, 0, "position"), s.linkProgram(x);
  var B = s.getProgramInfoLog(x).trim(), I = s.getShaderInfoLog(k).trim(), V = s.getShaderInfoLog(F).trim(), Q = !0, ee = !0;
  s.getProgramParameter(x, s.LINK_STATUS) === !1 ? (Q = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "gl.VALIDATE_STATUS", s.getProgramParameter(x, s.VALIDATE_STATUS), "gl.getProgramInfoLog", B, I, V)) : B !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", B) : (I === "" || V === "") && (ee = !1), ee && (this.diagnostics = {
    runnable: Q,
    material: n,
    programLog: B,
    vertexShader: {
      log: I,
      prefix: E
    },
    fragmentShader: {
      log: V,
      prefix: M
    }
  }), s.deleteShader(k), s.deleteShader(F);
  var oe;
  this.getUniforms = function() {
    return oe === void 0 && (oe = new oa(s, x, e)), oe;
  };
  var fe;
  return this.getAttributes = function() {
    return fe === void 0 && (fe = k2(s, x)), fe;
  }, this.destroy = function() {
    s.deleteProgram(x), this.program = void 0;
  }, Object.defineProperties(this, {
    uniforms: {
      get: function() {
        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
      }
    },
    attributes: {
      get: function() {
        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes();
      }
    }
  }), this.name = r.name, this.id = P2++, this.code = i, this.usedTimes = 1, this.program = x, this.vertexShader = k, this.fragmentShader = F, this;
}
function F2(e, t, i) {
  var n = [], r = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "phong",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow"
  }, a = [
    "precision",
    "supportsVertexTextures",
    "map",
    "mapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "lightMap",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "fog",
    "useFog",
    "fogExp",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering"
  ];
  function s(u) {
    var l = u.skeleton, c = l.bones;
    if (i.floatVertexTextures)
      return 1024;
    var h = i.maxVertexUniforms, d = Math.floor((h - 20) / 4), f = Math.min(d, c.length);
    return f < c.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + c.length + " bones. This GPU supports " + f + "."), 0) : f;
  }
  function o(u, l) {
    var c;
    return u ? u.isTexture ? c = u.encoding : u.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = u.texture.encoding) : c = _u, c === _u && l && (c = Uf), c;
  }
  this.getParameters = function(u, l, c, h, d, f, p) {
    var _ = r[u.type], m = p.isSkinnedMesh ? s(p) : 0, x = i.precision;
    u.precision !== null && (x = i.getMaxPrecision(u.precision), x !== u.precision && console.warn("THREE.WebGLProgram.getParameters:", u.precision, "not supported, using", x, "instead."));
    var E = e.getRenderTarget(), M = {
      shaderID: _,
      precision: x,
      supportsVertexTextures: i.vertexTextures,
      outputEncoding: o(E ? E.texture : null, e.gammaOutput),
      map: !!u.map,
      mapEncoding: o(u.map, e.gammaInput),
      envMap: !!u.envMap,
      envMapMode: u.envMap && u.envMap.mapping,
      envMapEncoding: o(u.envMap, e.gammaInput),
      envMapCubeUV: !!u.envMap && (u.envMap.mapping === lh || u.envMap.mapping === ch),
      lightMap: !!u.lightMap,
      aoMap: !!u.aoMap,
      emissiveMap: !!u.emissiveMap,
      emissiveMapEncoding: o(u.emissiveMap, e.gammaInput),
      bumpMap: !!u.bumpMap,
      normalMap: !!u.normalMap,
      displacementMap: !!u.displacementMap,
      roughnessMap: !!u.roughnessMap,
      metalnessMap: !!u.metalnessMap,
      specularMap: !!u.specularMap,
      alphaMap: !!u.alphaMap,
      gradientMap: !!u.gradientMap,
      combine: u.combine,
      vertexColors: u.vertexColors,
      fog: !!h,
      useFog: u.fog,
      fogExp: h && h.isFogExp2,
      flatShading: u.flatShading,
      sizeAttenuation: u.sizeAttenuation,
      logarithmicDepthBuffer: i.logarithmicDepthBuffer,
      skinning: u.skinning && m > 0,
      maxBones: m,
      useVertexTexture: i.floatVertexTextures,
      morphTargets: u.morphTargets,
      morphNormals: u.morphNormals,
      maxMorphTargets: e.maxMorphTargets,
      maxMorphNormals: e.maxMorphNormals,
      numDirLights: l.directional.length,
      numPointLights: l.point.length,
      numSpotLights: l.spot.length,
      numRectAreaLights: l.rectArea.length,
      numHemiLights: l.hemi.length,
      numClippingPlanes: d,
      numClipIntersection: f,
      dithering: u.dithering,
      shadowMapEnabled: e.shadowMap.enabled && p.receiveShadow && c.length > 0,
      shadowMapType: e.shadowMap.type,
      toneMapping: e.toneMapping,
      physicallyCorrectLights: e.physicallyCorrectLights,
      premultipliedAlpha: u.premultipliedAlpha,
      alphaTest: u.alphaTest,
      doubleSided: u.side === Io,
      flipSided: u.side === Ti,
      depthPacking: u.depthPacking !== void 0 ? u.depthPacking : !1
    };
    return M;
  }, this.getProgramCode = function(u, l) {
    var c = [];
    if (l.shaderID ? c.push(l.shaderID) : (c.push(u.fragmentShader), c.push(u.vertexShader)), u.defines !== void 0)
      for (var h in u.defines)
        c.push(h), c.push(u.defines[h]);
    for (var d = 0; d < a.length; d++)
      c.push(l[a[d]]);
    return c.push(u.onBeforeCompile.toString()), c.push(e.gammaOutput), c.join();
  }, this.acquireProgram = function(u, l, c, h) {
    for (var d, f = 0, p = n.length; f < p; f++) {
      var _ = n[f];
      if (_.code === h) {
        d = _, ++d.usedTimes;
        break;
      }
    }
    return d === void 0 && (d = new B2(e, t, h, u, l, c), n.push(d)), d;
  }, this.releaseProgram = function(u) {
    if (--u.usedTimes === 0) {
      var l = n.indexOf(u);
      n[l] = n[n.length - 1], n.pop(), u.destroy();
    }
  }, this.programs = n;
}
function N2() {
  var e = /* @__PURE__ */ new WeakMap();
  function t(a) {
    var s = e.get(a);
    return s === void 0 && (s = {}, e.set(a, s)), s;
  }
  function i(a) {
    e.delete(a);
  }
  function n(a, s, o) {
    e.get(a)[s] = o;
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    remove: i,
    update: n,
    dispose: r
  };
}
function U2(e, t) {
  return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id;
}
function j2(e, t) {
  return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;
}
function G2() {
  var e = [], t = 0, i = [], n = [];
  function r() {
    t = 0, i.length = 0, n.length = 0;
  }
  function a(o, u, l, c, h) {
    var d = e[t];
    d === void 0 ? (d = {
      id: o.id,
      object: o,
      geometry: u,
      material: l,
      program: l.program,
      renderOrder: o.renderOrder,
      z: c,
      group: h
    }, e[t] = d) : (d.id = o.id, d.object = o, d.geometry = u, d.material = l, d.program = l.program, d.renderOrder = o.renderOrder, d.z = c, d.group = h), (l.transparent === !0 ? n : i).push(d), t++;
  }
  function s() {
    i.length > 1 && i.sort(U2), n.length > 1 && n.sort(j2);
  }
  return {
    opaque: i,
    transparent: n,
    init: r,
    push: a,
    sort: s
  };
}
function V2() {
  var e = {};
  function t(n, r) {
    var a = n.id + "," + r.id, s = e[a];
    return s === void 0 && (s = new G2(), e[a] = s), s;
  }
  function i() {
    e = {};
  }
  return {
    get: t,
    dispose: i
  };
}
function H2() {
  var e = {};
  return {
    get: function(t) {
      if (e[t.id] !== void 0)
        return e[t.id];
      var i;
      switch (t.type) {
        case "DirectionalLight":
          i = {
            direction: new H(),
            color: new We(),
            shadow: !1,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ue()
          };
          break;
        case "SpotLight":
          i = {
            position: new H(),
            direction: new H(),
            color: new We(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
            shadow: !1,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ue()
          };
          break;
        case "PointLight":
          i = {
            position: new H(),
            color: new We(),
            distance: 0,
            decay: 0,
            shadow: !1,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ue(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
        case "HemisphereLight":
          i = {
            direction: new H(),
            skyColor: new We(),
            groundColor: new We()
          };
          break;
        case "RectAreaLight":
          i = {
            color: new We(),
            position: new H(),
            halfWidth: new H(),
            halfHeight: new H()
            // TODO (abelnation): set RectAreaLight shadow uniforms
          };
          break;
      }
      return e[t.id] = i, i;
    }
  };
}
var z2 = 0;
function W2() {
  var e = new H2(), t = {
    id: z2++,
    hash: "",
    ambient: [0, 0, 0],
    directional: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  }, i = new H(), n = new at(), r = new at();
  function a(s, o, u) {
    for (var l = 0, c = 0, h = 0, d = 0, f = 0, p = 0, _ = 0, m = 0, x = u.matrixWorldInverse, E = 0, M = s.length; E < M; E++) {
      var C = s[E], R = C.color, k = C.intensity, F = C.distance, B = C.shadow && C.shadow.map ? C.shadow.map.texture : null;
      if (C.isAmbientLight)
        l += R.r * k, c += R.g * k, h += R.b * k;
      else if (C.isDirectionalLight) {
        var I = e.get(C);
        if (I.color.copy(C.color).multiplyScalar(C.intensity), I.direction.setFromMatrixPosition(C.matrixWorld), i.setFromMatrixPosition(C.target.matrixWorld), I.direction.sub(i), I.direction.transformDirection(x), I.shadow = C.castShadow, C.castShadow) {
          var V = C.shadow;
          I.shadowBias = V.bias, I.shadowRadius = V.radius, I.shadowMapSize = V.mapSize;
        }
        t.directionalShadowMap[d] = B, t.directionalShadowMatrix[d] = C.shadow.matrix, t.directional[d] = I, d++;
      } else if (C.isSpotLight) {
        var I = e.get(C);
        if (I.position.setFromMatrixPosition(C.matrixWorld), I.position.applyMatrix4(x), I.color.copy(R).multiplyScalar(k), I.distance = F, I.direction.setFromMatrixPosition(C.matrixWorld), i.setFromMatrixPosition(C.target.matrixWorld), I.direction.sub(i), I.direction.transformDirection(x), I.coneCos = Math.cos(C.angle), I.penumbraCos = Math.cos(C.angle * (1 - C.penumbra)), I.decay = C.distance === 0 ? 0 : C.decay, I.shadow = C.castShadow, C.castShadow) {
          var V = C.shadow;
          I.shadowBias = V.bias, I.shadowRadius = V.radius, I.shadowMapSize = V.mapSize;
        }
        t.spotShadowMap[p] = B, t.spotShadowMatrix[p] = C.shadow.matrix, t.spot[p] = I, p++;
      } else if (C.isRectAreaLight) {
        var I = e.get(C);
        I.color.copy(R).multiplyScalar(k), I.position.setFromMatrixPosition(C.matrixWorld), I.position.applyMatrix4(x), r.identity(), n.copy(C.matrixWorld), n.premultiply(x), r.extractRotation(n), I.halfWidth.set(C.width * 0.5, 0, 0), I.halfHeight.set(0, C.height * 0.5, 0), I.halfWidth.applyMatrix4(r), I.halfHeight.applyMatrix4(r), t.rectArea[_] = I, _++;
      } else if (C.isPointLight) {
        var I = e.get(C);
        if (I.position.setFromMatrixPosition(C.matrixWorld), I.position.applyMatrix4(x), I.color.copy(C.color).multiplyScalar(C.intensity), I.distance = C.distance, I.decay = C.distance === 0 ? 0 : C.decay, I.shadow = C.castShadow, C.castShadow) {
          var V = C.shadow;
          I.shadowBias = V.bias, I.shadowRadius = V.radius, I.shadowMapSize = V.mapSize, I.shadowCameraNear = V.camera.near, I.shadowCameraFar = V.camera.far;
        }
        t.pointShadowMap[f] = B, t.pointShadowMatrix[f] = C.shadow.matrix, t.point[f] = I, f++;
      } else if (C.isHemisphereLight) {
        var I = e.get(C);
        I.direction.setFromMatrixPosition(C.matrixWorld), I.direction.transformDirection(x), I.direction.normalize(), I.skyColor.copy(C.color).multiplyScalar(k), I.groundColor.copy(C.groundColor).multiplyScalar(k), t.hemi[m] = I, m++;
      }
    }
    t.ambient[0] = l, t.ambient[1] = c, t.ambient[2] = h, t.directional.length = d, t.spot.length = p, t.rectArea.length = _, t.point.length = f, t.hemi.length = m, t.hash = t.id + "," + d + "," + f + "," + p + "," + _ + "," + m + "," + o.length;
  }
  return {
    setup: a,
    state: t
  };
}
function q2() {
  var e = new W2(), t = [], i = [], n = [];
  function r() {
    t.length = 0, i.length = 0, n.length = 0;
  }
  function a(c) {
    t.push(c);
  }
  function s(c) {
    i.push(c);
  }
  function o(c) {
    n.push(c);
  }
  function u(c) {
    e.setup(t, i, c);
  }
  var l = {
    lightsArray: t,
    shadowsArray: i,
    spritesArray: n,
    lights: e
  };
  return {
    init: r,
    state: l,
    setupLights: u,
    pushLight: a,
    pushShadow: s,
    pushSprite: o
  };
}
function X2() {
  var e = {};
  function t(n, r) {
    var a = n.id + "," + r.id, s = e[a];
    return s === void 0 && (s = new q2(), e[a] = s), s;
  }
  function i() {
    e = {};
  }
  return {
    get: t,
    dispose: i
  };
}
function ha(e) {
  dt.call(this), this.type = "MeshDepthMaterial", this.depthPacking = F0, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e);
}
ha.prototype = Object.create(dt.prototype);
ha.prototype.constructor = ha;
ha.prototype.isMeshDepthMaterial = !0;
ha.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
};
function da(e) {
  dt.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new H(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e);
}
da.prototype = Object.create(dt.prototype);
da.prototype.constructor = da;
da.prototype.isMeshDistanceMaterial = !0;
da.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
};
function Z0(e, t, i) {
  for (var n = new vh(), r = new at(), a = new ue(), s = new ue(i, i), o = new H(), u = new H(), l = 1, c = 2, h = (l | c) + 1, d = new Array(h), f = new Array(h), p = {}, _ = { 0: Ti, 1: _l, 2: Io }, m = [
    new H(1, 0, 0),
    new H(-1, 0, 0),
    new H(0, 0, 1),
    new H(0, 0, -1),
    new H(0, 1, 0),
    new H(0, -1, 0)
  ], x = [
    new H(0, 1, 0),
    new H(0, 1, 0),
    new H(0, 1, 0),
    new H(0, 1, 0),
    new H(0, 0, 1),
    new H(0, 0, -1)
  ], E = [
    new Ft(),
    new Ft(),
    new Ft(),
    new Ft(),
    new Ft(),
    new Ft()
  ], M = 0; M !== h; ++M) {
    var C = (M & l) !== 0, R = (M & c) !== 0, k = new ha({
      depthPacking: N0,
      morphTargets: C,
      skinning: R
    });
    d[M] = k;
    var F = new da({
      morphTargets: C,
      skinning: R
    });
    f[M] = F;
  }
  var B = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Tf, this.render = function(Q, ee, oe) {
    if (B.enabled !== !1 && !(B.autoUpdate === !1 && B.needsUpdate === !1) && Q.length !== 0) {
      var fe = e.context, he = e.state;
      he.disable(fe.BLEND), he.buffers.color.setClear(1, 1, 1, 1), he.buffers.depth.setTest(!0), he.setScissorTest(!1);
      for (var de, G = 0, j = Q.length; G < j; G++) {
        var se = Q[G], ie = se.shadow, Ce = se && se.isPointLight;
        if (ie === void 0) {
          console.warn("THREE.WebGLShadowMap:", se, "has no shadow.");
          continue;
        }
        var K = ie.camera;
        if (a.copy(ie.mapSize), a.min(s), Ce) {
          var xe = a.x, pe = a.y;
          E[0].set(xe * 2, pe, xe, pe), E[1].set(0, pe, xe, pe), E[2].set(xe * 3, pe, xe, pe), E[3].set(xe, pe, xe, pe), E[4].set(xe * 3, 0, xe, pe), E[5].set(xe, 0, xe, pe), a.x *= 4, a.y *= 2;
        }
        if (ie.map === null) {
          var Re = { minFilter: wr, magFilter: wr, format: gn };
          ie.map = new Wa(a.x, a.y, Re), ie.map.texture.name = se.name + ".shadowMap", K.updateProjectionMatrix();
        }
        ie.isSpotLightShadow && ie.update(se);
        var _e = ie.map, Le = ie.matrix;
        u.setFromMatrixPosition(se.matrixWorld), K.position.copy(u), Ce ? (de = 6, Le.makeTranslation(-u.x, -u.y, -u.z)) : (de = 1, o.setFromMatrixPosition(se.target.matrixWorld), K.lookAt(o), K.updateMatrixWorld(), Le.set(
          0.5,
          0,
          0,
          0.5,
          0,
          0.5,
          0,
          0.5,
          0,
          0,
          0.5,
          0.5,
          0,
          0,
          0,
          1
        ), Le.multiply(K.projectionMatrix), Le.multiply(K.matrixWorldInverse)), e.setRenderTarget(_e), e.clear();
        for (var Ve = 0; Ve < de; Ve++) {
          if (Ce) {
            o.copy(K.position), o.add(m[Ve]), K.up.copy(x[Ve]), K.lookAt(o), K.updateMatrixWorld();
            var ft = E[Ve];
            he.viewport(ft);
          }
          r.multiplyMatrices(K.projectionMatrix, K.matrixWorldInverse), n.setFromMatrix(r), V(ee, oe, K, Ce);
        }
      }
      B.needsUpdate = !1;
    }
  };
  function I(Q, ee, oe, fe, he, de) {
    var G = Q.geometry, j = null, se = d, ie = Q.customDepthMaterial;
    if (oe && (se = f, ie = Q.customDistanceMaterial), ie)
      j = ie;
    else {
      var Ce = !1;
      ee.morphTargets && (G && G.isBufferGeometry ? Ce = G.morphAttributes && G.morphAttributes.position && G.morphAttributes.position.length > 0 : G && G.isGeometry && (Ce = G.morphTargets && G.morphTargets.length > 0)), Q.isSkinnedMesh && ee.skinning === !1 && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", Q);
      var K = Q.isSkinnedMesh && ee.skinning, xe = 0;
      Ce && (xe |= l), K && (xe |= c), j = se[xe];
    }
    if (e.localClippingEnabled && ee.clipShadows === !0 && ee.clippingPlanes.length !== 0) {
      var pe = j.uuid, Re = ee.uuid, _e = p[pe];
      _e === void 0 && (_e = {}, p[pe] = _e);
      var Le = _e[Re];
      Le === void 0 && (Le = j.clone(), _e[Re] = Le), j = Le;
    }
    return j.visible = ee.visible, j.wireframe = ee.wireframe, j.side = ee.shadowSide != null ? ee.shadowSide : _[ee.side], j.clipShadows = ee.clipShadows, j.clippingPlanes = ee.clippingPlanes, j.clipIntersection = ee.clipIntersection, j.wireframeLinewidth = ee.wireframeLinewidth, j.linewidth = ee.linewidth, oe && j.isMeshDistanceMaterial && (j.referencePosition.copy(fe), j.nearDistance = he, j.farDistance = de), j;
  }
  function V(Q, ee, oe, fe) {
    if (Q.visible !== !1) {
      var he = Q.layers.test(ee.layers);
      if (he && (Q.isMesh || Q.isLine || Q.isPoints) && Q.castShadow && (!Q.frustumCulled || n.intersectsObject(Q))) {
        Q.modelViewMatrix.multiplyMatrices(oe.matrixWorldInverse, Q.matrixWorld);
        var de = t.update(Q), G = Q.material;
        if (Array.isArray(G))
          for (var j = de.groups, se = 0, ie = j.length; se < ie; se++) {
            var Ce = j[se], K = G[Ce.materialIndex];
            if (K && K.visible) {
              var xe = I(Q, K, fe, u, oe.near, oe.far);
              e.renderBufferDirect(oe, null, de, xe, Q, Ce);
            }
          }
        else if (G.visible) {
          var xe = I(Q, G, fe, u, oe.near, oe.far);
          e.renderBufferDirect(oe, null, de, xe, Q, null);
        }
      }
      for (var pe = Q.children, Re = 0, _e = pe.length; Re < _e; Re++)
        V(pe[Re], ee, oe, fe);
    }
  }
}
function zs(e, t, i, n, r, a, s, o, u) {
  ri.call(this, e, t, i, n, r, a, s, o, u), this.needsUpdate = !0;
}
zs.prototype = Object.create(ri.prototype);
zs.prototype.constructor = zs;
zs.prototype.isCanvasTexture = !0;
function Y2(e, t, i, n, r) {
  var a, s, o, u, l, c, h = new H(), d = new _i(), f = new H();
  function p() {
    var x = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0.5,
      -0.5,
      1,
      0,
      0.5,
      0.5,
      1,
      1,
      -0.5,
      0.5,
      0,
      1
    ]), E = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    a = t.createBuffer(), s = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, a), t.bufferData(t.ARRAY_BUFFER, x, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, s), t.bufferData(t.ELEMENT_ARRAY_BUFFER, E, t.STATIC_DRAW), o = _(), u = {
      position: t.getAttribLocation(o, "position"),
      uv: t.getAttribLocation(o, "uv")
    }, l = {
      uvOffset: t.getUniformLocation(o, "uvOffset"),
      uvScale: t.getUniformLocation(o, "uvScale"),
      rotation: t.getUniformLocation(o, "rotation"),
      center: t.getUniformLocation(o, "center"),
      scale: t.getUniformLocation(o, "scale"),
      color: t.getUniformLocation(o, "color"),
      map: t.getUniformLocation(o, "map"),
      opacity: t.getUniformLocation(o, "opacity"),
      modelViewMatrix: t.getUniformLocation(o, "modelViewMatrix"),
      projectionMatrix: t.getUniformLocation(o, "projectionMatrix"),
      fogType: t.getUniformLocation(o, "fogType"),
      fogDensity: t.getUniformLocation(o, "fogDensity"),
      fogNear: t.getUniformLocation(o, "fogNear"),
      fogFar: t.getUniformLocation(o, "fogFar"),
      fogColor: t.getUniformLocation(o, "fogColor"),
      fogDepth: t.getUniformLocation(o, "fogDepth"),
      alphaTest: t.getUniformLocation(o, "alphaTest")
    };
    var M = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    M.width = 8, M.height = 8;
    var C = M.getContext("2d");
    C.fillStyle = "white", C.fillRect(0, 0, 8, 8), c = new zs(M);
  }
  this.render = function(x, E, M) {
    if (x.length !== 0) {
      o === void 0 && p(), i.useProgram(o), i.initAttributes(), i.enableAttribute(u.position), i.enableAttribute(u.uv), i.disableUnusedAttributes(), i.disable(t.CULL_FACE), i.enable(t.BLEND), t.bindBuffer(t.ARRAY_BUFFER, a), t.vertexAttribPointer(u.position, 2, t.FLOAT, !1, 2 * 8, 0), t.vertexAttribPointer(u.uv, 2, t.FLOAT, !1, 2 * 8, 8), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, s), t.uniformMatrix4fv(l.projectionMatrix, !1, M.projectionMatrix.elements), i.activeTexture(t.TEXTURE0), t.uniform1i(l.map, 0);
      var C = 0, R = 0, k = E.fog;
      k ? (t.uniform3f(l.fogColor, k.color.r, k.color.g, k.color.b), k.isFog ? (t.uniform1f(l.fogNear, k.near), t.uniform1f(l.fogFar, k.far), t.uniform1i(l.fogType, 1), C = 1, R = 1) : k.isFogExp2 && (t.uniform1f(l.fogDensity, k.density), t.uniform1i(l.fogType, 2), C = 2, R = 2)) : (t.uniform1i(l.fogType, 0), C = 0, R = 0);
      for (var F = 0, B = x.length; F < B; F++) {
        var I = x[F];
        I.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse, I.matrixWorld), I.z = -I.modelViewMatrix.elements[14];
      }
      x.sort(m);
      for (var V = [], Q = [], F = 0, B = x.length; F < B; F++) {
        var I = x[F], ee = I.material;
        if (ee.visible !== !1) {
          I.onBeforeRender(e, E, M, void 0, ee, void 0), t.uniform1f(l.alphaTest, ee.alphaTest), t.uniformMatrix4fv(l.modelViewMatrix, !1, I.modelViewMatrix.elements), I.matrixWorld.decompose(h, d, f), V[0] = f.x, V[1] = f.y, Q[0] = I.center.x - 0.5, Q[1] = I.center.y - 0.5;
          var oe = 0;
          E.fog && ee.fog && (oe = R), C !== oe && (t.uniform1i(l.fogType, oe), C = oe), ee.map !== null ? (t.uniform2f(l.uvOffset, ee.map.offset.x, ee.map.offset.y), t.uniform2f(l.uvScale, ee.map.repeat.x, ee.map.repeat.y)) : (t.uniform2f(l.uvOffset, 0, 0), t.uniform2f(l.uvScale, 1, 1)), t.uniform1f(l.opacity, ee.opacity), t.uniform3f(l.color, ee.color.r, ee.color.g, ee.color.b), t.uniform1f(l.rotation, ee.rotation), t.uniform2fv(l.center, Q), t.uniform2fv(l.scale, V), i.setBlending(ee.blending, ee.blendEquation, ee.blendSrc, ee.blendDst, ee.blendEquationAlpha, ee.blendSrcAlpha, ee.blendDstAlpha, ee.premultipliedAlpha), i.buffers.depth.setTest(ee.depthTest), i.buffers.depth.setMask(ee.depthWrite), i.buffers.color.setMask(ee.colorWrite), n.setTexture2D(ee.map || c, 0), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0), I.onAfterRender(e, E, M, void 0, ee, void 0);
        }
      }
      i.enable(t.CULL_FACE), i.reset();
    }
  };
  function _() {
    var x = t.createProgram(), E = t.createShader(t.VERTEX_SHADER), M = t.createShader(t.FRAGMENT_SHADER);
    return t.shaderSource(E, [
      "precision " + r.precision + " float;",
      "#define SHADER_NAME SpriteMaterial",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform float rotation;",
      "uniform vec2 center;",
      "uniform vec2 scale;",
      "uniform vec2 uvOffset;",
      "uniform vec2 uvScale;",
      "attribute vec2 position;",
      "attribute vec2 uv;",
      "varying vec2 vUV;",
      "varying float fogDepth;",
      "void main() {",
      "	vUV = uvOffset + uv * uvScale;",
      "	vec2 alignedPosition = ( position - center ) * scale;",
      "	vec2 rotatedPosition;",
      "	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;",
      "	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;",
      "	vec4 mvPosition;",
      "	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
      "	mvPosition.xy += rotatedPosition;",
      "	gl_Position = projectionMatrix * mvPosition;",
      "	fogDepth = - mvPosition.z;",
      "}"
    ].join(`
`)), t.shaderSource(M, [
      "precision " + r.precision + " float;",
      "#define SHADER_NAME SpriteMaterial",
      "uniform vec3 color;",
      "uniform sampler2D map;",
      "uniform float opacity;",
      "uniform int fogType;",
      "uniform vec3 fogColor;",
      "uniform float fogDensity;",
      "uniform float fogNear;",
      "uniform float fogFar;",
      "uniform float alphaTest;",
      "varying vec2 vUV;",
      "varying float fogDepth;",
      "void main() {",
      "	vec4 texture = texture2D( map, vUV );",
      "	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",
      "	if ( gl_FragColor.a < alphaTest ) discard;",
      "	if ( fogType > 0 ) {",
      "		float fogFactor = 0.0;",
      "		if ( fogType == 1 ) {",
      "			fogFactor = smoothstep( fogNear, fogFar, fogDepth );",
      "		} else {",
      "			const float LOG2 = 1.442695;",
      "			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );",
      "			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
      "		}",
      "		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );",
      "	}",
      "}"
    ].join(`
`)), t.compileShader(E), t.compileShader(M), t.attachShader(x, E), t.attachShader(x, M), t.linkProgram(x), x;
  }
  function m(x, E) {
    return x.renderOrder !== E.renderOrder ? x.renderOrder - E.renderOrder : x.z !== E.z ? E.z - x.z : E.id - x.id;
  }
}
function Q2(e, t, i) {
  function n() {
    var ae = !1, Pe = new Ft(), Ie = null, Je = new Ft(0, 0, 0, 0);
    return {
      setMask: function(Be) {
        Ie !== Be && !ae && (e.colorMask(Be, Be, Be, Be), Ie = Be);
      },
      setLocked: function(Be) {
        ae = Be;
      },
      setClear: function(Be, st, Ne, vt, Rt) {
        Rt === !0 && (Be *= vt, st *= vt, Ne *= vt), Pe.set(Be, st, Ne, vt), Je.equals(Pe) === !1 && (e.clearColor(Be, st, Ne, vt), Je.copy(Pe));
      },
      reset: function() {
        ae = !1, Ie = null, Je.set(-1, 0, 0, 0);
      }
    };
  }
  function r() {
    var ae = !1, Pe = null, Ie = null, Je = null;
    return {
      setTest: function(Be) {
        Be ? Le(e.DEPTH_TEST) : Ve(e.DEPTH_TEST);
      },
      setMask: function(Be) {
        Pe !== Be && !ae && (e.depthMask(Be), Pe = Be);
      },
      setFunc: function(Be) {
        if (Ie !== Be) {
          if (Be)
            switch (Be) {
              case Wg:
                e.depthFunc(e.NEVER);
                break;
              case qg:
                e.depthFunc(e.ALWAYS);
                break;
              case Xg:
                e.depthFunc(e.LESS);
                break;
              case uc:
                e.depthFunc(e.LEQUAL);
                break;
              case Yg:
                e.depthFunc(e.EQUAL);
                break;
              case Qg:
                e.depthFunc(e.GEQUAL);
                break;
              case Kg:
                e.depthFunc(e.GREATER);
                break;
              case Zg:
                e.depthFunc(e.NOTEQUAL);
                break;
              default:
                e.depthFunc(e.LEQUAL);
            }
          else
            e.depthFunc(e.LEQUAL);
          Ie = Be;
        }
      },
      setLocked: function(Be) {
        ae = Be;
      },
      setClear: function(Be) {
        Je !== Be && (e.clearDepth(Be), Je = Be);
      },
      reset: function() {
        ae = !1, Pe = null, Ie = null, Je = null;
      }
    };
  }
  function a() {
    var ae = !1, Pe = null, Ie = null, Je = null, Be = null, st = null, Ne = null, vt = null, Rt = null;
    return {
      setTest: function(ht) {
        ht ? Le(e.STENCIL_TEST) : Ve(e.STENCIL_TEST);
      },
      setMask: function(ht) {
        Pe !== ht && !ae && (e.stencilMask(ht), Pe = ht);
      },
      setFunc: function(ht, Ct, Lt) {
        (Ie !== ht || Je !== Ct || Be !== Lt) && (e.stencilFunc(ht, Ct, Lt), Ie = ht, Je = Ct, Be = Lt);
      },
      setOp: function(ht, Ct, Lt) {
        (st !== ht || Ne !== Ct || vt !== Lt) && (e.stencilOp(ht, Ct, Lt), st = ht, Ne = Ct, vt = Lt);
      },
      setLocked: function(ht) {
        ae = ht;
      },
      setClear: function(ht) {
        Rt !== ht && (e.clearStencil(ht), Rt = ht);
      },
      reset: function() {
        ae = !1, Pe = null, Ie = null, Je = null, Be = null, st = null, Ne = null, vt = null, Rt = null;
      }
    };
  }
  var s = new n(), o = new r(), u = new a(), l = e.getParameter(e.MAX_VERTEX_ATTRIBS), c = new Uint8Array(l), h = new Uint8Array(l), d = new Uint8Array(l), f = {}, p = null, _ = null, m = null, x = null, E = null, M = null, C = null, R = null, k = null, F = !1, B = null, I = null, V = null, Q = null, ee = null, oe = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS), fe = !1, he = 0, de = e.getParameter(e.VERSION);
  de.indexOf("WebGL") !== -1 ? (he = parseFloat(/^WebGL\ ([0-9])/.exec(de)[1]), fe = he >= 1) : de.indexOf("OpenGL ES") !== -1 && (he = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(de)[1]), fe = he >= 2);
  var G = null, j = {}, se = new Ft(), ie = new Ft();
  function Ce(ae, Pe, Ie) {
    var Je = new Uint8Array(4), Be = e.createTexture();
    e.bindTexture(ae, Be), e.texParameteri(ae, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(ae, e.TEXTURE_MAG_FILTER, e.NEAREST);
    for (var st = 0; st < Ie; st++)
      e.texImage2D(Pe + st, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, Je);
    return Be;
  }
  var K = {};
  K[e.TEXTURE_2D] = Ce(e.TEXTURE_2D, e.TEXTURE_2D, 1), K[e.TEXTURE_CUBE_MAP] = Ce(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), s.setClear(0, 0, 0, 1), o.setClear(1), u.setClear(0), Le(e.DEPTH_TEST), o.setFunc(uc), Mt(!1), Vt(Ed), Le(e.CULL_FACE), Le(e.BLEND), ct(bl);
  function xe() {
    for (var ae = 0, Pe = c.length; ae < Pe; ae++)
      c[ae] = 0;
  }
  function pe(ae) {
    Re(ae, 0);
  }
  function Re(ae, Pe) {
    if (c[ae] = 1, h[ae] === 0 && (e.enableVertexAttribArray(ae), h[ae] = 1), d[ae] !== Pe) {
      var Ie = t.get("ANGLE_instanced_arrays");
      Ie.vertexAttribDivisorANGLE(ae, Pe), d[ae] = Pe;
    }
  }
  function _e() {
    for (var ae = 0, Pe = h.length; ae !== Pe; ++ae)
      h[ae] !== c[ae] && (e.disableVertexAttribArray(ae), h[ae] = 0);
  }
  function Le(ae) {
    f[ae] !== !0 && (e.enable(ae), f[ae] = !0);
  }
  function Ve(ae) {
    f[ae] !== !1 && (e.disable(ae), f[ae] = !1);
  }
  function ft() {
    if (p === null && (p = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
      for (var ae = e.getParameter(e.COMPRESSED_TEXTURE_FORMATS), Pe = 0; Pe < ae.length; Pe++)
        p.push(ae[Pe]);
    return p;
  }
  function Ee(ae) {
    return _ !== ae ? (e.useProgram(ae), _ = ae, !0) : !1;
  }
  function ct(ae, Pe, Ie, Je, Be, st, Ne, vt) {
    if (ae !== oc ? Le(e.BLEND) : Ve(e.BLEND), ae !== Df) {
      if (ae !== m || vt !== F)
        switch (ae) {
          case Sf:
            vt ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE, e.ONE, e.ONE)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE));
            break;
          case Cf:
            vt ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR));
            break;
          case Mf:
            vt ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.SRC_COLOR));
            break;
          default:
            vt ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA));
        }
      x = null, E = null, M = null, C = null, R = null, k = null;
    } else
      Be = Be || Pe, st = st || Ie, Ne = Ne || Je, (Pe !== x || Be !== C) && (e.blendEquationSeparate(i.convert(Pe), i.convert(Be)), x = Pe, C = Be), (Ie !== E || Je !== M || st !== R || Ne !== k) && (e.blendFuncSeparate(i.convert(Ie), i.convert(Je), i.convert(st), i.convert(Ne)), E = Ie, M = Je, R = st, k = Ne);
    m = ae, F = vt;
  }
  function kt(ae, Pe) {
    ae.side === Io ? Ve(e.CULL_FACE) : Le(e.CULL_FACE);
    var Ie = ae.side === Ti;
    Pe && (Ie = !Ie), Mt(Ie), ae.transparent === !0 ? ct(ae.blending, ae.blendEquation, ae.blendSrc, ae.blendDst, ae.blendEquationAlpha, ae.blendSrcAlpha, ae.blendDstAlpha, ae.premultipliedAlpha) : ct(oc), o.setFunc(ae.depthFunc), o.setTest(ae.depthTest), o.setMask(ae.depthWrite), s.setMask(ae.colorWrite), jt(ae.polygonOffset, ae.polygonOffsetFactor, ae.polygonOffsetUnits);
  }
  function Mt(ae) {
    B !== ae && (ae ? e.frontFace(e.CW) : e.frontFace(e.CCW), B = ae);
  }
  function Vt(ae) {
    ae !== Lg ? (Le(e.CULL_FACE), ae !== I && (ae === Ed ? e.cullFace(e.BACK) : ae === Rg ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : Ve(e.CULL_FACE), I = ae;
  }
  function yt(ae) {
    ae !== V && (fe && e.lineWidth(ae), V = ae);
  }
  function jt(ae, Pe, Ie) {
    ae ? (Le(e.POLYGON_OFFSET_FILL), (Q !== Pe || ee !== Ie) && (e.polygonOffset(Pe, Ie), Q = Pe, ee = Ie)) : Ve(e.POLYGON_OFFSET_FILL);
  }
  function Et(ae) {
    ae ? Le(e.SCISSOR_TEST) : Ve(e.SCISSOR_TEST);
  }
  function gr(ae) {
    ae === void 0 && (ae = e.TEXTURE0 + oe - 1), G !== ae && (e.activeTexture(ae), G = ae);
  }
  function xt(ae, Pe) {
    G === null && gr();
    var Ie = j[G];
    Ie === void 0 && (Ie = { type: void 0, texture: void 0 }, j[G] = Ie), (Ie.type !== ae || Ie.texture !== Pe) && (e.bindTexture(ae, Pe || K[ae]), Ie.type = ae, Ie.texture = Pe);
  }
  function ci() {
    try {
      e.compressedTexImage2D.apply(e, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function Gt() {
    try {
      e.texImage2D.apply(e, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function yr(ae) {
    se.equals(ae) === !1 && (e.scissor(ae.x, ae.y, ae.z, ae.w), se.copy(ae));
  }
  function gi(ae) {
    ie.equals(ae) === !1 && (e.viewport(ae.x, ae.y, ae.z, ae.w), ie.copy(ae));
  }
  function ai() {
    for (var ae = 0; ae < h.length; ae++)
      h[ae] === 1 && (e.disableVertexAttribArray(ae), h[ae] = 0);
    f = {}, p = null, G = null, j = {}, _ = null, m = null, B = null, I = null, s.reset(), o.reset(), u.reset();
  }
  return {
    buffers: {
      color: s,
      depth: o,
      stencil: u
    },
    initAttributes: xe,
    enableAttribute: pe,
    enableAttributeAndDivisor: Re,
    disableUnusedAttributes: _e,
    enable: Le,
    disable: Ve,
    getCompressedTextureFormats: ft,
    useProgram: Ee,
    setBlending: ct,
    setMaterial: kt,
    setFlipSided: Mt,
    setCullFace: Vt,
    setLineWidth: yt,
    setPolygonOffset: jt,
    setScissorTest: Et,
    activeTexture: gr,
    bindTexture: xt,
    compressedTexImage2D: ci,
    texImage2D: Gt,
    scissor: yr,
    viewport: gi,
    reset: ai
  };
}
function K2(e, t, i, n, r, a, s) {
  var o = typeof WebGL2RenderingContext < "u" && e instanceof WebGL2RenderingContext, u = {}, l;
  function c(G, j) {
    if (G.width > j || G.height > j) {
      if ("data" in G) {
        console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + G.width + "x" + G.height + ").");
        return;
      }
      var se = j / Math.max(G.width, G.height), ie = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      ie.width = Math.floor(G.width * se), ie.height = Math.floor(G.height * se);
      var Ce = ie.getContext("2d");
      return Ce.drawImage(G, 0, 0, G.width, G.height, 0, 0, ie.width, ie.height), console.warn("THREE.WebGLRenderer: image is too big (" + G.width + "x" + G.height + "). Resized to " + ie.width + "x" + ie.height, G), ie;
    }
    return G;
  }
  function h(G) {
    return gt.isPowerOfTwo(G.width) && gt.isPowerOfTwo(G.height);
  }
  function d(G) {
    if (G instanceof HTMLImageElement || G instanceof HTMLCanvasElement || G instanceof ImageBitmap) {
      l === void 0 && (l = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), l.width = gt.floorPowerOfTwo(G.width), l.height = gt.floorPowerOfTwo(G.height);
      var j = l.getContext("2d");
      return j.drawImage(G, 0, 0, l.width, l.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + G.width + "x" + G.height + "). Resized to " + l.width + "x" + l.height, G), l;
    }
    return G;
  }
  function f(G) {
    return G.wrapS !== Er || G.wrapT !== Er || G.minFilter !== wr && G.minFilter !== Gi;
  }
  function p(G, j) {
    return G.generateMipmaps && j && G.minFilter !== wr && G.minFilter !== Gi;
  }
  function _(G, j, se, ie) {
    e.generateMipmap(G);
    var Ce = n.get(j);
    Ce.__maxMipLevel = Math.log(Math.max(se, ie)) * Math.LOG2E;
  }
  function m(G) {
    return G === wr || G === hh || G === dh ? e.NEAREST : e.LINEAR;
  }
  function x(G) {
    var j = G.target;
    j.removeEventListener("dispose", x), M(j), j.isVideoTexture && delete u[j.id], s.memory.textures--;
  }
  function E(G) {
    var j = G.target;
    j.removeEventListener("dispose", E), C(j), s.memory.textures--;
  }
  function M(G) {
    var j = n.get(G);
    if (G.image && j.__image__webglTextureCube)
      e.deleteTexture(j.__image__webglTextureCube);
    else {
      if (j.__webglInit === void 0) return;
      e.deleteTexture(j.__webglTexture);
    }
    n.remove(G);
  }
  function C(G) {
    var j = n.get(G), se = n.get(G.texture);
    if (G) {
      if (se.__webglTexture !== void 0 && e.deleteTexture(se.__webglTexture), G.depthTexture && G.depthTexture.dispose(), G.isWebGLRenderTargetCube)
        for (var ie = 0; ie < 6; ie++)
          e.deleteFramebuffer(j.__webglFramebuffer[ie]), j.__webglDepthbuffer && e.deleteRenderbuffer(j.__webglDepthbuffer[ie]);
      else
        e.deleteFramebuffer(j.__webglFramebuffer), j.__webglDepthbuffer && e.deleteRenderbuffer(j.__webglDepthbuffer);
      n.remove(G.texture), n.remove(G);
    }
  }
  function R(G, j) {
    var se = n.get(G);
    if (G.isVideoTexture && de(G), G.version > 0 && se.__version !== G.version) {
      var ie = G.image;
      if (ie === void 0)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", G);
      else if (ie.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", G);
      else {
        I(se, G, j);
        return;
      }
    }
    i.activeTexture(e.TEXTURE0 + j), i.bindTexture(e.TEXTURE_2D, se.__webglTexture);
  }
  function k(G, j) {
    var se = n.get(G);
    if (G.image.length === 6)
      if (G.version > 0 && se.__version !== G.version) {
        se.__image__webglTextureCube || (G.addEventListener("dispose", x), se.__image__webglTextureCube = e.createTexture(), s.memory.textures++), i.activeTexture(e.TEXTURE0 + j), i.bindTexture(e.TEXTURE_CUBE_MAP, se.__image__webglTextureCube), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, G.flipY);
        for (var ie = G && G.isCompressedTexture, Ce = G.image[0] && G.image[0].isDataTexture, K = [], xe = 0; xe < 6; xe++)
          !ie && !Ce ? K[xe] = c(G.image[xe], r.maxCubemapSize) : K[xe] = Ce ? G.image[xe].image : G.image[xe];
        var pe = K[0], Re = h(pe), _e = a.convert(G.format), Le = a.convert(G.type);
        B(e.TEXTURE_CUBE_MAP, G, Re);
        for (var xe = 0; xe < 6; xe++)
          if (!ie)
            Ce ? i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, _e, K[xe].width, K[xe].height, 0, _e, Le, K[xe].data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, _e, _e, Le, K[xe]);
          else
            for (var Ve, ft = K[xe].mipmaps, Ee = 0, ct = ft.length; Ee < ct; Ee++)
              Ve = ft[Ee], G.format !== gn && G.format !== Ha ? i.getCompressedTextureFormats().indexOf(_e) > -1 ? i.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ee, _e, Ve.width, Ve.height, 0, Ve.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ee, _e, Ve.width, Ve.height, 0, _e, Le, Ve.data);
        ie ? se.__maxMipLevel = ft.length - 1 : se.__maxMipLevel = 0, p(G, Re) && _(e.TEXTURE_CUBE_MAP, G, pe.width, pe.height), se.__version = G.version, G.onUpdate && G.onUpdate(G);
      } else
        i.activeTexture(e.TEXTURE0 + j), i.bindTexture(e.TEXTURE_CUBE_MAP, se.__image__webglTextureCube);
  }
  function F(G, j) {
    i.activeTexture(e.TEXTURE0 + j), i.bindTexture(e.TEXTURE_CUBE_MAP, n.get(G).__webglTexture);
  }
  function B(G, j, se) {
    var ie;
    if (se ? (e.texParameteri(G, e.TEXTURE_WRAP_S, a.convert(j.wrapS)), e.texParameteri(G, e.TEXTURE_WRAP_T, a.convert(j.wrapT)), e.texParameteri(G, e.TEXTURE_MAG_FILTER, a.convert(j.magFilter)), e.texParameteri(G, e.TEXTURE_MIN_FILTER, a.convert(j.minFilter))) : (e.texParameteri(G, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(G, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), (j.wrapS !== Er || j.wrapT !== Er) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", j), e.texParameteri(G, e.TEXTURE_MAG_FILTER, m(j.magFilter)), e.texParameteri(G, e.TEXTURE_MIN_FILTER, m(j.minFilter)), j.minFilter !== wr && j.minFilter !== Gi && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", j)), ie = t.get("EXT_texture_filter_anisotropic"), ie) {
      if (j.type === js && t.get("OES_texture_float_linear") === null || j.type === ph && t.get("OES_texture_half_float_linear") === null) return;
      (j.anisotropy > 1 || n.get(j).__currentAnisotropy) && (e.texParameterf(G, ie.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(j.anisotropy, r.getMaxAnisotropy())), n.get(j).__currentAnisotropy = j.anisotropy);
    }
  }
  function I(G, j, se) {
    G.__webglInit === void 0 && (G.__webglInit = !0, j.addEventListener("dispose", x), G.__webglTexture = e.createTexture(), s.memory.textures++), i.activeTexture(e.TEXTURE0 + se), i.bindTexture(e.TEXTURE_2D, G.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, j.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, j.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, j.unpackAlignment);
    var ie = c(j.image, r.maxTextureSize);
    f(j) && h(ie) === !1 && (ie = d(ie));
    var Ce = h(ie), K = a.convert(j.format), xe = a.convert(j.type);
    B(e.TEXTURE_2D, j, Ce);
    var pe, Re = j.mipmaps;
    if (j.isDepthTexture) {
      var _e = e.DEPTH_COMPONENT;
      if (j.type === js) {
        if (!o) throw new Error("Float Depth Texture only supported in WebGL2.0");
        _e = e.DEPTH_COMPONENT32F;
      } else o && (_e = e.DEPTH_COMPONENT16);
      j.format === Ba && _e === e.DEPTH_COMPONENT && j.type !== vu && j.type !== Ff && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), j.type = vu, xe = a.convert(j.type)), j.format === Gs && (_e = e.DEPTH_STENCIL, j.type !== mu && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), j.type = mu, xe = a.convert(j.type))), i.texImage2D(e.TEXTURE_2D, 0, _e, ie.width, ie.height, 0, K, xe, null);
    } else if (j.isDataTexture)
      if (Re.length > 0 && Ce) {
        for (var Le = 0, Ve = Re.length; Le < Ve; Le++)
          pe = Re[Le], i.texImage2D(e.TEXTURE_2D, Le, K, pe.width, pe.height, 0, K, xe, pe.data);
        j.generateMipmaps = !1, G.__maxMipLevel = Re.length - 1;
      } else
        i.texImage2D(e.TEXTURE_2D, 0, K, ie.width, ie.height, 0, K, xe, ie.data), G.__maxMipLevel = 0;
    else if (j.isCompressedTexture) {
      for (var Le = 0, Ve = Re.length; Le < Ve; Le++)
        pe = Re[Le], j.format !== gn && j.format !== Ha ? i.getCompressedTextureFormats().indexOf(K) > -1 ? i.compressedTexImage2D(e.TEXTURE_2D, Le, K, pe.width, pe.height, 0, pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(e.TEXTURE_2D, Le, K, pe.width, pe.height, 0, K, xe, pe.data);
      G.__maxMipLevel = Re.length - 1;
    } else if (Re.length > 0 && Ce) {
      for (var Le = 0, Ve = Re.length; Le < Ve; Le++)
        pe = Re[Le], i.texImage2D(e.TEXTURE_2D, Le, K, K, xe, pe);
      j.generateMipmaps = !1, G.__maxMipLevel = Re.length - 1;
    } else
      i.texImage2D(e.TEXTURE_2D, 0, K, K, xe, ie), G.__maxMipLevel = 0;
    p(j, Ce) && _(e.TEXTURE_2D, j, ie.width, ie.height), G.__version = j.version, j.onUpdate && j.onUpdate(j);
  }
  function V(G, j, se, ie) {
    var Ce = a.convert(j.texture.format), K = a.convert(j.texture.type);
    i.texImage2D(ie, 0, Ce, j.width, j.height, 0, Ce, K, null), e.bindFramebuffer(e.FRAMEBUFFER, G), e.framebufferTexture2D(e.FRAMEBUFFER, se, ie, n.get(j.texture).__webglTexture, 0), e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  function Q(G, j) {
    e.bindRenderbuffer(e.RENDERBUFFER, G), j.depthBuffer && !j.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, j.width, j.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, G)) : j.depthBuffer && j.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, j.width, j.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, G)) : e.renderbufferStorage(e.RENDERBUFFER, e.RGBA4, j.width, j.height), e.bindRenderbuffer(e.RENDERBUFFER, null);
  }
  function ee(G, j) {
    var se = j && j.isWebGLRenderTargetCube;
    if (se) throw new Error("Depth Texture with cube render targets is not supported");
    if (e.bindFramebuffer(e.FRAMEBUFFER, G), !(j.depthTexture && j.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(j.depthTexture).__webglTexture || j.depthTexture.image.width !== j.width || j.depthTexture.image.height !== j.height) && (j.depthTexture.image.width = j.width, j.depthTexture.image.height = j.height, j.depthTexture.needsUpdate = !0), R(j.depthTexture, 0);
    var ie = n.get(j.depthTexture).__webglTexture;
    if (j.depthTexture.format === Ba)
      e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, ie, 0);
    else if (j.depthTexture.format === Gs)
      e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, ie, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function oe(G) {
    var j = n.get(G), se = G.isWebGLRenderTargetCube === !0;
    if (G.depthTexture) {
      if (se) throw new Error("target.depthTexture not supported in Cube render targets");
      ee(j.__webglFramebuffer, G);
    } else if (se) {
      j.__webglDepthbuffer = [];
      for (var ie = 0; ie < 6; ie++)
        e.bindFramebuffer(e.FRAMEBUFFER, j.__webglFramebuffer[ie]), j.__webglDepthbuffer[ie] = e.createRenderbuffer(), Q(j.__webglDepthbuffer[ie], G);
    } else
      e.bindFramebuffer(e.FRAMEBUFFER, j.__webglFramebuffer), j.__webglDepthbuffer = e.createRenderbuffer(), Q(j.__webglDepthbuffer, G);
    e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  function fe(G) {
    var j = n.get(G), se = n.get(G.texture);
    G.addEventListener("dispose", E), se.__webglTexture = e.createTexture(), s.memory.textures++;
    var ie = G.isWebGLRenderTargetCube === !0, Ce = h(G);
    if (ie) {
      j.__webglFramebuffer = [];
      for (var K = 0; K < 6; K++)
        j.__webglFramebuffer[K] = e.createFramebuffer();
    } else
      j.__webglFramebuffer = e.createFramebuffer();
    if (ie) {
      i.bindTexture(e.TEXTURE_CUBE_MAP, se.__webglTexture), B(e.TEXTURE_CUBE_MAP, G.texture, Ce);
      for (var K = 0; K < 6; K++)
        V(j.__webglFramebuffer[K], G, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + K);
      p(G.texture, Ce) && _(e.TEXTURE_CUBE_MAP, G.texture, G.width, G.height), i.bindTexture(e.TEXTURE_CUBE_MAP, null);
    } else
      i.bindTexture(e.TEXTURE_2D, se.__webglTexture), B(e.TEXTURE_2D, G.texture, Ce), V(j.__webglFramebuffer, G, e.COLOR_ATTACHMENT0, e.TEXTURE_2D), p(G.texture, Ce) && _(e.TEXTURE_2D, G.texture, G.width, G.height), i.bindTexture(e.TEXTURE_2D, null);
    G.depthBuffer && oe(G);
  }
  function he(G) {
    var j = G.texture, se = h(G);
    if (p(j, se)) {
      var ie = G.isWebGLRenderTargetCube ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D, Ce = n.get(j).__webglTexture;
      i.bindTexture(ie, Ce), _(ie, j, G.width, G.height), i.bindTexture(ie, null);
    }
  }
  function de(G) {
    var j = G.id, se = s.render.frame;
    u[j] !== se && (u[j] = se, G.update());
  }
  this.setTexture2D = R, this.setTextureCube = k, this.setTextureCubeDynamic = F, this.setupRenderTarget = fe, this.updateRenderTargetMipmap = he;
}
function J0(e, t) {
  function i(n) {
    var r;
    if (n === In) return e.REPEAT;
    if (n === Er) return e.CLAMP_TO_EDGE;
    if (n === Va) return e.MIRRORED_REPEAT;
    if (n === wr) return e.NEAREST;
    if (n === hh) return e.NEAREST_MIPMAP_NEAREST;
    if (n === dh) return e.NEAREST_MIPMAP_LINEAR;
    if (n === Gi) return e.LINEAR;
    if (n === Bf) return e.LINEAR_MIPMAP_NEAREST;
    if (n === Al) return e.LINEAR_MIPMAP_LINEAR;
    if (n === fh) return e.UNSIGNED_BYTE;
    if (n === s0) return e.UNSIGNED_SHORT_4_4_4_4;
    if (n === o0) return e.UNSIGNED_SHORT_5_5_5_1;
    if (n === u0) return e.UNSIGNED_SHORT_5_6_5;
    if (n === r0) return e.BYTE;
    if (n === n0) return e.SHORT;
    if (n === vu) return e.UNSIGNED_SHORT;
    if (n === a0) return e.INT;
    if (n === Ff) return e.UNSIGNED_INT;
    if (n === js) return e.FLOAT;
    if (n === ph && (r = t.get("OES_texture_half_float"), r !== null))
      return r.HALF_FLOAT_OES;
    if (n === l0) return e.ALPHA;
    if (n === Ha) return e.RGB;
    if (n === gn) return e.RGBA;
    if (n === c0) return e.LUMINANCE;
    if (n === h0) return e.LUMINANCE_ALPHA;
    if (n === Ba) return e.DEPTH_COMPONENT;
    if (n === Gs) return e.DEPTH_STENCIL;
    if (n === Pf) return e.FUNC_ADD;
    if (n === Og) return e.FUNC_SUBTRACT;
    if (n === kg) return e.FUNC_REVERSE_SUBTRACT;
    if (n === Bg) return e.ZERO;
    if (n === Fg) return e.ONE;
    if (n === Ng) return e.SRC_COLOR;
    if (n === Ug) return e.ONE_MINUS_SRC_COLOR;
    if (n === Lf) return e.SRC_ALPHA;
    if (n === Rf) return e.ONE_MINUS_SRC_ALPHA;
    if (n === jg) return e.DST_ALPHA;
    if (n === Gg) return e.ONE_MINUS_DST_ALPHA;
    if (n === Vg) return e.DST_COLOR;
    if (n === Hg) return e.ONE_MINUS_DST_COLOR;
    if (n === zg) return e.SRC_ALPHA_SATURATE;
    if ((n === Cd || n === Md || n === Dd || n === Pd) && (r = t.get("WEBGL_compressed_texture_s3tc"), r !== null)) {
      if (n === Cd) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (n === Md) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (n === Dd) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (n === Pd) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    if ((n === Ld || n === Rd || n === Id || n === Od) && (r = t.get("WEBGL_compressed_texture_pvrtc"), r !== null)) {
      if (n === Ld) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (n === Rd) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (n === Id) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (n === Od) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (n === d0 && (r = t.get("WEBGL_compressed_texture_etc1"), r !== null))
      return r.COMPRESSED_RGB_ETC1_WEBGL;
    if ((n === f0 || n === p0 || n === v0 || n === m0 || n === g0 || n === y0 || n === _0 || n === b0 || n === x0 || n === A0 || n === T0 || n === E0 || n === w0 || n === S0) && (r = t.get("WEBGL_compressed_texture_astc"), r !== null))
      return n;
    if ((n === wd || n === Sd) && (r = t.get("EXT_blend_minmax"), r !== null)) {
      if (n === wd) return r.MIN_EXT;
      if (n === Sd) return r.MAX_EXT;
    }
    return n === mu && (r = t.get("WEBGL_depth_texture"), r !== null) ? r.UNSIGNED_INT_24_8_WEBGL : 0;
  }
  return { convert: i };
}
function oi(e, t, i, n) {
  yn.call(this), this.type = "PerspectiveCamera", this.fov = e !== void 0 ? e : 50, this.zoom = 1, this.near = i !== void 0 ? i : 0.1, this.far = n !== void 0 ? n : 2e3, this.focus = 10, this.aspect = t !== void 0 ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
}
oi.prototype = Object.assign(Object.create(yn.prototype), {
  constructor: oi,
  isPerspectiveCamera: !0,
  copy: function(e, t) {
    return yn.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  },
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function(e) {
    var t = 0.5 * this.getFilmHeight() / e;
    this.fov = gt.RAD2DEG * 2 * Math.atan(t), this.updateProjectionMatrix();
  },
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function() {
    var e = Math.tan(gt.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  },
  getEffectiveFOV: function() {
    return gt.RAD2DEG * 2 * Math.atan(
      Math.tan(gt.DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   var w = 1920;
   *   var h = 1080;
   *   var fullWidth = w * 3;
   *   var fullHeight = h * 2;
   *
   *   --A--
   *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function(e, t, i, n, r, a) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var e = this.near, t = e * Math.tan(
      gt.DEG2RAD * 0.5 * this.fov
    ) / this.zoom, i = 2 * t, n = this.aspect * i, r = -0.5 * n, a = this.view;
    if (this.view !== null && this.view.enabled) {
      var s = a.fullWidth, o = a.fullHeight;
      r += a.offsetX * n / s, t -= a.offsetY * i / o, n *= a.width / s, i *= a.height / o;
    }
    var u = this.filmOffset;
    u !== 0 && (r += e * u / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far);
  },
  toJSON: function(e) {
    var t = Fe.prototype.toJSON.call(this, e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
});
function Cu(e) {
  oi.call(this), this.cameras = e || [];
}
Cu.prototype = Object.assign(Object.create(oi.prototype), {
  constructor: Cu,
  isArrayCamera: !0
});
function $0(e) {
  var t = this, i = null, n = null, r = null, a = new at(), s = new at();
  typeof window < "u" && "VRFrameData" in window && (n = new window.VRFrameData(), window.addEventListener("vrdisplaypresentchange", m, !1));
  var o = new at(), u = new _i(), l = new H(), c = new oi();
  c.bounds = new Ft(0, 0, 0.5, 1), c.layers.enable(1);
  var h = new oi();
  h.bounds = new Ft(0.5, 0, 0.5, 1), h.layers.enable(2);
  var d = new Cu([c, h]);
  d.layers.enable(1), d.layers.enable(2);
  function f() {
    return i !== null && i.isPresenting === !0;
  }
  var p, _;
  function m() {
    if (f()) {
      var E = i.getEyeParameters("left"), M = E.renderWidth, C = E.renderHeight;
      _ = e.getPixelRatio(), p = e.getSize(), e.setDrawingBufferSize(M * 2, C, 1), x.start();
    } else t.enabled && (e.setDrawingBufferSize(p.width, p.height, _), x.stop());
  }
  this.enabled = !1, this.userHeight = 1.6, this.getDevice = function() {
    return i;
  }, this.setDevice = function(E) {
    E !== void 0 && (i = E), x.setContext(E);
  }, this.setPoseTarget = function(E) {
    E !== void 0 && (r = E);
  }, this.getCamera = function(E) {
    if (i === null) return E;
    i.depthNear = E.near, i.depthFar = E.far, i.getFrameData(n);
    var M = i.stageParameters;
    M ? a.fromArray(M.sittingToStandingTransform) : a.makeTranslation(0, t.userHeight, 0);
    var C = n.pose, R = r !== null ? r : E;
    if (R.matrix.copy(a), R.matrix.decompose(R.position, R.quaternion, R.scale), C.orientation !== null && (u.fromArray(C.orientation), R.quaternion.multiply(u)), C.position !== null && (u.setFromRotationMatrix(a), l.fromArray(C.position), l.applyQuaternion(u), R.position.add(l)), R.updateMatrixWorld(), i.isPresenting === !1) return E;
    c.near = E.near, h.near = E.near, c.far = E.far, h.far = E.far, d.matrixWorld.copy(E.matrixWorld), d.matrixWorldInverse.copy(E.matrixWorldInverse), c.matrixWorldInverse.fromArray(n.leftViewMatrix), h.matrixWorldInverse.fromArray(n.rightViewMatrix), s.getInverse(a), c.matrixWorldInverse.multiply(s), h.matrixWorldInverse.multiply(s);
    var k = R.parent;
    k !== null && (o.getInverse(k.matrixWorld), c.matrixWorldInverse.multiply(o), h.matrixWorldInverse.multiply(o)), c.matrixWorld.getInverse(c.matrixWorldInverse), h.matrixWorld.getInverse(h.matrixWorldInverse), c.projectionMatrix.fromArray(n.leftProjectionMatrix), h.projectionMatrix.fromArray(n.rightProjectionMatrix), d.projectionMatrix.copy(c.projectionMatrix);
    var F = i.getLayers();
    if (F.length) {
      var B = F[0];
      B.leftBounds !== null && B.leftBounds.length === 4 && c.bounds.fromArray(B.leftBounds), B.rightBounds !== null && B.rightBounds.length === 4 && h.bounds.fromArray(B.rightBounds);
    }
    return d;
  }, this.getStandingMatrix = function() {
    return a;
  }, this.isPresenting = f;
  var x = new jf();
  this.setAnimationLoop = function(E) {
    x.setAnimationLoop(E);
  }, this.submitFrame = function() {
    f() && i.submitFrame();
  }, this.dispose = function() {
    typeof window < "u" && window.removeEventListener("vrdisplaypresentchange", m);
  };
}
function Z2(e) {
  var t = e.context, i = null, n = null, r = null, a = null;
  function s() {
    return n !== null && r !== null;
  }
  var o = new oi();
  o.layers.enable(1), o.viewport = new Ft();
  var u = new oi();
  u.layers.enable(2), u.viewport = new Ft();
  var l = new Cu([o, u]);
  l.layers.enable(1), l.layers.enable(2), this.enabled = !1, this.getDevice = function() {
    return i;
  }, this.setDevice = function(p) {
    p !== void 0 && (i = p), t.setCompatibleXRDevice(p);
  }, this.setSession = function(p, _) {
    n = p, n !== null && (n.addEventListener("end", function() {
      e.setFramebuffer(null), f.stop();
    }), n.baseLayer = new XRWebGLLayer(n, t), n.requestFrameOfReference(_.frameOfReferenceType).then(function(m) {
      r = m, e.setFramebuffer(n.baseLayer.framebuffer), f.setContext(n), f.start();
    }));
  };
  function c(p, _) {
    _ === null ? p.matrixWorld.copy(p.matrix) : p.matrixWorld.multiplyMatrices(_.matrixWorld, p.matrix), p.matrixWorldInverse.getInverse(p.matrixWorld);
  }
  this.getCamera = function(p) {
    if (s()) {
      var _ = p.parent, m = l.cameras;
      c(l, _);
      for (var x = 0; x < m.length; x++)
        c(m[x], _);
      p.matrixWorld.copy(l.matrixWorld);
      for (var E = p.children, x = 0, M = E.length; x < M; x++)
        E[x].updateMatrixWorld(!0);
      return l;
    }
    return p;
  }, this.isPresenting = s;
  var h = null;
  function d(p, _) {
    a = _.getDevicePose(r);
    for (var m = n.baseLayer, x = _.views, E = 0; E < x.length; E++) {
      var M = x[E], C = m.getViewport(M), R = a.getViewMatrix(M), k = l.cameras[E];
      k.matrix.fromArray(R).getInverse(k.matrix), k.projectionMatrix.fromArray(M.projectionMatrix), k.viewport.set(C.x, C.y, C.width, C.height), E === 0 && (l.matrix.copy(k.matrix), l.projectionMatrix.copy(k.projectionMatrix));
    }
    h && h();
  }
  var f = new jf();
  f.setAnimationLoop(d), this.setAnimationLoop = function(p) {
    h = p;
  }, this.getStandingMatrix = function() {
    return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4();
  }, this.submitFrame = function() {
  };
}
function mh(e) {
  console.log("THREE.WebGLRenderer", Pg), e = e || {};
  var t = e.canvas !== void 0 ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), i = e.context !== void 0 ? e.context : null, n = e.alpha !== void 0 ? e.alpha : !1, r = e.depth !== void 0 ? e.depth : !0, a = e.stencil !== void 0 ? e.stencil : !0, s = e.antialias !== void 0 ? e.antialias : !1, o = e.premultipliedAlpha !== void 0 ? e.premultipliedAlpha : !0, u = e.preserveDrawingBuffer !== void 0 ? e.preserveDrawingBuffer : !1, l = e.powerPreference !== void 0 ? e.powerPreference : "default", c = null, h = null;
  this.domElement = t, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = If, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
  var d = this, f = !1, p = null, _ = null, m = null, x = -1, E = "", M = null, C = null, R = new Ft(), k = new Ft(), F = null, B = 0, I = t.width, V = t.height, Q = 1, ee = new Ft(0, 0, I, V), oe = new Ft(0, 0, I, V), fe = !1, he = new vh(), de = new ZT(), G = !1, j = !1, se = new at(), ie = new H();
  function Ce() {
    return _ === null ? Q : 1;
  }
  var K;
  try {
    var xe = {
      alpha: n,
      depth: r,
      stencil: a,
      antialias: s,
      premultipliedAlpha: o,
      preserveDrawingBuffer: u,
      powerPreference: l
    };
    if (t.addEventListener("webglcontextlost", ae, !1), t.addEventListener("webglcontextrestored", Pe, !1), K = i || t.getContext("webgl", xe) || t.getContext("experimental-webgl", xe), K === null)
      throw t.getContext("webgl") !== null ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    K.getShaderPrecisionFormat === void 0 && (K.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (O) {
    console.error("THREE.WebGLRenderer: " + O.message);
  }
  var pe, Re, _e, Le, Ve, ft, Ee, ct, kt, Mt, Vt, yt, jt, Et, gr, xt, ci, Gt;
  function yr() {
    pe = new JT(K), pe.get("WEBGL_depth_texture"), pe.get("OES_texture_float"), pe.get("OES_texture_float_linear"), pe.get("OES_texture_half_float"), pe.get("OES_texture_half_float_linear"), pe.get("OES_standard_derivatives"), pe.get("OES_element_index_uint"), pe.get("ANGLE_instanced_arrays"), Gt = new J0(K, pe), Re = new KT(K, pe, e), _e = new Q2(K, pe, Gt), _e.scissor(k.copy(oe).multiplyScalar(Q)), _e.viewport(R.copy(ee).multiplyScalar(Q)), Le = new t2(K), Ve = new N2(), ft = new K2(K, pe, _e, Ve, Re, Gt, Le), Ee = new HT(K), ct = new $T(K, Ee, Le), kt = new n2(ct, Le), Et = new r2(K), Mt = new F2(d, pe, Re), Vt = new V2(), yt = new X2(), jt = new YT(d, _e, kt, o), gr = new QT(K, pe, Le), xt = new e2(K, pe, Le), ci = new Y2(d, K, _e, ft, Re), Le.programs = Mt.programs, d.context = K, d.capabilities = Re, d.extensions = pe, d.properties = Ve, d.renderLists = Vt, d.state = _e, d.info = Le;
  }
  yr();
  var gi = "xr" in navigator ? new Z2(d) : new $0(d);
  this.vr = gi;
  var ai = new Z0(d, kt, Re.maxTextureSize);
  this.shadowMap = ai, this.getContext = function() {
    return K;
  }, this.getContextAttributes = function() {
    return K.getContextAttributes();
  }, this.forceContextLoss = function() {
    var O = pe.get("WEBGL_lose_context");
    O && O.loseContext();
  }, this.forceContextRestore = function() {
    var O = pe.get("WEBGL_lose_context");
    O && O.restoreContext();
  }, this.getPixelRatio = function() {
    return Q;
  }, this.setPixelRatio = function(O) {
    O !== void 0 && (Q = O, this.setSize(I, V, !1));
  }, this.getSize = function() {
    return {
      width: I,
      height: V
    };
  }, this.setSize = function(O, z, $) {
    if (gi.isPresenting()) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    I = O, V = z, t.width = O * Q, t.height = z * Q, $ !== !1 && (t.style.width = O + "px", t.style.height = z + "px"), this.setViewport(0, 0, O, z);
  }, this.getDrawingBufferSize = function() {
    return {
      width: I * Q,
      height: V * Q
    };
  }, this.setDrawingBufferSize = function(O, z, $) {
    I = O, V = z, Q = $, t.width = O * $, t.height = z * $, this.setViewport(0, 0, O, z);
  }, this.getCurrentViewport = function() {
    return R;
  }, this.setViewport = function(O, z, $, ge) {
    ee.set(O, V - z - ge, $, ge), _e.viewport(R.copy(ee).multiplyScalar(Q));
  }, this.setScissor = function(O, z, $, ge) {
    oe.set(O, V - z - ge, $, ge), _e.scissor(k.copy(oe).multiplyScalar(Q));
  }, this.setScissorTest = function(O) {
    _e.setScissorTest(fe = O);
  }, this.getClearColor = function() {
    return jt.getClearColor();
  }, this.setClearColor = function() {
    jt.setClearColor.apply(jt, arguments);
  }, this.getClearAlpha = function() {
    return jt.getClearAlpha();
  }, this.setClearAlpha = function() {
    jt.setClearAlpha.apply(jt, arguments);
  }, this.clear = function(O, z, $) {
    var ge = 0;
    (O === void 0 || O) && (ge |= K.COLOR_BUFFER_BIT), (z === void 0 || z) && (ge |= K.DEPTH_BUFFER_BIT), ($ === void 0 || $) && (ge |= K.STENCIL_BUFFER_BIT), K.clear(ge);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.clearTarget = function(O, z, $, ge) {
    this.setRenderTarget(O), this.clear(z, $, ge);
  }, this.dispose = function() {
    t.removeEventListener("webglcontextlost", ae, !1), t.removeEventListener("webglcontextrestored", Pe, !1), Vt.dispose(), yt.dispose(), Ve.dispose(), kt.dispose(), gi.dispose(), ht.stop();
  };
  function ae(O) {
    O.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), f = !0;
  }
  function Pe() {
    console.log("THREE.WebGLRenderer: Context Restored."), f = !1, yr();
  }
  function Ie(O) {
    var z = O.target;
    z.removeEventListener("dispose", Ie), Je(z);
  }
  function Je(O) {
    Be(O), Ve.remove(O);
  }
  function Be(O) {
    var z = Ve.get(O).program;
    O.program = void 0, z !== void 0 && Mt.releaseProgram(z);
  }
  function st(O, z, $) {
    O.render(function(ge) {
      d.renderBufferImmediate(ge, z, $);
    });
  }
  this.renderBufferImmediate = function(O, z, $) {
    _e.initAttributes();
    var ge = Ve.get(O);
    O.hasPositions && !ge.position && (ge.position = K.createBuffer()), O.hasNormals && !ge.normal && (ge.normal = K.createBuffer()), O.hasUvs && !ge.uv && (ge.uv = K.createBuffer()), O.hasColors && !ge.color && (ge.color = K.createBuffer());
    var Me = z.getAttributes();
    if (O.hasPositions && (K.bindBuffer(K.ARRAY_BUFFER, ge.position), K.bufferData(K.ARRAY_BUFFER, O.positionArray, K.DYNAMIC_DRAW), _e.enableAttribute(Me.position), K.vertexAttribPointer(Me.position, 3, K.FLOAT, !1, 0, 0)), O.hasNormals) {
      if (K.bindBuffer(K.ARRAY_BUFFER, ge.normal), !$.isMeshPhongMaterial && !$.isMeshStandardMaterial && !$.isMeshNormalMaterial && $.flatShading === !0)
        for (var ze = 0, Ke = O.count * 3; ze < Ke; ze += 9) {
          var we = O.normalArray, et = (we[ze + 0] + we[ze + 3] + we[ze + 6]) / 3, nt = (we[ze + 1] + we[ze + 4] + we[ze + 7]) / 3, it = (we[ze + 2] + we[ze + 5] + we[ze + 8]) / 3;
          we[ze + 0] = et, we[ze + 1] = nt, we[ze + 2] = it, we[ze + 3] = et, we[ze + 4] = nt, we[ze + 5] = it, we[ze + 6] = et, we[ze + 7] = nt, we[ze + 8] = it;
        }
      K.bufferData(K.ARRAY_BUFFER, O.normalArray, K.DYNAMIC_DRAW), _e.enableAttribute(Me.normal), K.vertexAttribPointer(Me.normal, 3, K.FLOAT, !1, 0, 0);
    }
    O.hasUvs && $.map && (K.bindBuffer(K.ARRAY_BUFFER, ge.uv), K.bufferData(K.ARRAY_BUFFER, O.uvArray, K.DYNAMIC_DRAW), _e.enableAttribute(Me.uv), K.vertexAttribPointer(Me.uv, 2, K.FLOAT, !1, 0, 0)), O.hasColors && $.vertexColors !== sh && (K.bindBuffer(K.ARRAY_BUFFER, ge.color), K.bufferData(K.ARRAY_BUFFER, O.colorArray, K.DYNAMIC_DRAW), _e.enableAttribute(Me.color), K.vertexAttribPointer(Me.color, 3, K.FLOAT, !1, 0, 0)), _e.disableUnusedAttributes(), K.drawArrays(K.TRIANGLES, 0, O.count), O.count = 0;
  }, this.renderBufferDirect = function(O, z, $, ge, Me, ze) {
    var Ke = Me.isMesh && Me.matrixWorld.determinant() < 0;
    _e.setMaterial(ge, Ke);
    var we = Br(O, z, ge, Me), et = $.id + "_" + we.id + "_" + (ge.wireframe === !0), nt = !1;
    et !== E && (E = et, nt = !0), Me.morphTargetInfluences && (Et.update(Me, $, ge, we), nt = !0);
    var it = $.index, Tt = $.attributes.position, Qe = 1;
    ge.wireframe === !0 && (it = ct.getWireframeAttribute($), Qe = 2);
    var Dt, bt = gr;
    it !== null && (Dt = Ee.get(it), bt = xt, bt.setIndex(Dt)), nt && (Ne(ge, we, $), it !== null && K.bindBuffer(K.ELEMENT_ARRAY_BUFFER, Dt.buffer));
    var $t = 1 / 0;
    it !== null ? $t = it.count : Tt !== void 0 && ($t = Tt.count);
    var hi = $.drawRange.start * Qe, Ni = $.drawRange.count * Qe, Ci = ze !== null ? ze.start * Qe : 0, an = ze !== null ? ze.count * Qe : 1 / 0, ra = Math.max(hi, Ci), na = Math.min($t, hi + Ni, Ci + an) - 1, aa = Math.max(0, na - ra + 1);
    if (aa !== 0) {
      if (Me.isMesh)
        if (ge.wireframe === !0)
          _e.setLineWidth(ge.wireframeLinewidth * Ce()), bt.setMode(K.LINES);
        else
          switch (Me.drawMode) {
            case Nf:
              bt.setMode(K.TRIANGLES);
              break;
            case P0:
              bt.setMode(K.TRIANGLE_STRIP);
              break;
            case L0:
              bt.setMode(K.TRIANGLE_FAN);
              break;
          }
      else if (Me.isLine) {
        var It = ge.linewidth;
        It === void 0 && (It = 1), _e.setLineWidth(It * Ce()), Me.isLineSegments ? bt.setMode(K.LINES) : Me.isLineLoop ? bt.setMode(K.LINE_LOOP) : bt.setMode(K.LINE_STRIP);
      } else Me.isPoints && bt.setMode(K.POINTS);
      $ && $.isInstancedBufferGeometry ? $.maxInstancedCount > 0 && bt.renderInstances($, ra, aa) : bt.render(ra, aa);
    }
  };
  function Ne(O, z, $) {
    if ($ && $.isInstancedBufferGeometry && pe.get("ANGLE_instanced_arrays") === null) {
      console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    _e.initAttributes();
    var ge = $.attributes, Me = z.getAttributes(), ze = O.defaultAttributeValues;
    for (var Ke in Me) {
      var we = Me[Ke];
      if (we >= 0) {
        var et = ge[Ke];
        if (et !== void 0) {
          var nt = et.normalized, it = et.itemSize, Tt = Ee.get(et);
          if (Tt === void 0) continue;
          var Qe = Tt.buffer, Dt = Tt.type, bt = Tt.bytesPerElement;
          if (et.isInterleavedBufferAttribute) {
            var $t = et.data, hi = $t.stride, Ni = et.offset;
            $t && $t.isInstancedInterleavedBuffer ? (_e.enableAttributeAndDivisor(we, $t.meshPerAttribute), $.maxInstancedCount === void 0 && ($.maxInstancedCount = $t.meshPerAttribute * $t.count)) : _e.enableAttribute(we), K.bindBuffer(K.ARRAY_BUFFER, Qe), K.vertexAttribPointer(we, it, Dt, nt, hi * bt, Ni * bt);
          } else
            et.isInstancedBufferAttribute ? (_e.enableAttributeAndDivisor(we, et.meshPerAttribute), $.maxInstancedCount === void 0 && ($.maxInstancedCount = et.meshPerAttribute * et.count)) : _e.enableAttribute(we), K.bindBuffer(K.ARRAY_BUFFER, Qe), K.vertexAttribPointer(we, it, Dt, nt, 0, 0);
        } else if (ze !== void 0) {
          var Ci = ze[Ke];
          if (Ci !== void 0)
            switch (Ci.length) {
              case 2:
                K.vertexAttrib2fv(we, Ci);
                break;
              case 3:
                K.vertexAttrib3fv(we, Ci);
                break;
              case 4:
                K.vertexAttrib4fv(we, Ci);
                break;
              default:
                K.vertexAttrib1fv(we, Ci);
            }
        }
      }
    }
    _e.disableUnusedAttributes();
  }
  this.compile = function(O, z) {
    h = yt.get(O, z), h.init(), O.traverse(function($) {
      $.isLight && (h.pushLight($), $.castShadow && h.pushShadow($));
    }), h.setupLights(z), O.traverse(function($) {
      if ($.material)
        if (Array.isArray($.material))
          for (var ge = 0; ge < $.material.length; ge++)
            _t($.material[ge], O.fog, $);
        else
          _t($.material, O.fog, $);
    });
  };
  var vt = null;
  function Rt() {
    gi.isPresenting() || vt && vt();
  }
  var ht = new jf();
  ht.setAnimationLoop(Rt), ht.setContext(window), this.setAnimationLoop = function(O) {
    vt = O, gi.setAnimationLoop(O), ht.start();
  }, this.render = function(O, z, $, ge) {
    if (!(z && z.isCamera)) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (!f) {
      E = "", x = -1, M = null, O.autoUpdate === !0 && O.updateMatrixWorld(), z.parent === null && z.updateMatrixWorld(), gi.enabled && (z = gi.getCamera(z)), h = yt.get(O, z), h.init(), O.onBeforeRender(d, O, z, $), se.multiplyMatrices(z.projectionMatrix, z.matrixWorldInverse), he.setFromMatrix(se), j = this.localClippingEnabled, G = de.init(this.clippingPlanes, j, z), c = Vt.get(O, z), c.init(), Ct(O, z, d.sortObjects), d.sortObjects === !0 && c.sort(), G && de.beginShadows();
      var Me = h.state.shadowsArray;
      ai.render(Me, O, z), h.setupLights(z), G && de.endShadows(), this.info.autoReset && this.info.reset(), $ === void 0 && ($ = null), this.setRenderTarget($), jt.render(c, O, z, ge);
      var ze = c.opaque, Ke = c.transparent;
      if (O.overrideMaterial) {
        var we = O.overrideMaterial;
        ze.length && Lt(ze, O, z, we), Ke.length && Lt(Ke, O, z, we);
      } else
        ze.length && Lt(ze, O, z), Ke.length && Lt(Ke, O, z);
      var et = h.state.spritesArray;
      ci.render(et, O, z), $ && ft.updateRenderTargetMipmap($), _e.buffers.depth.setTest(!0), _e.buffers.depth.setMask(!0), _e.buffers.color.setMask(!0), _e.setPolygonOffset(!1), O.onAfterRender(d, O, z), gi.enabled && gi.submitFrame(), c = null, h = null;
    }
  };
  function Ct(O, z, $) {
    if (O.visible !== !1) {
      var ge = O.layers.test(z.layers);
      if (ge) {
        if (O.isLight)
          h.pushLight(O), O.castShadow && h.pushShadow(O);
        else if (O.isSprite)
          (!O.frustumCulled || he.intersectsSprite(O)) && h.pushSprite(O);
        else if (O.isImmediateRenderObject)
          $ && ie.setFromMatrixPosition(O.matrixWorld).applyMatrix4(se), c.push(O, null, O.material, ie.z, null);
        else if ((O.isMesh || O.isLine || O.isPoints) && (O.isSkinnedMesh && O.skeleton.update(), !O.frustumCulled || he.intersectsObject(O))) {
          $ && ie.setFromMatrixPosition(O.matrixWorld).applyMatrix4(se);
          var Me = kt.update(O), ze = O.material;
          if (Array.isArray(ze))
            for (var Ke = Me.groups, we = 0, et = Ke.length; we < et; we++) {
              var nt = Ke[we], it = ze[nt.materialIndex];
              it && it.visible && c.push(O, Me, it, ie.z, nt);
            }
          else ze.visible && c.push(O, Me, ze, ie.z, null);
        }
      }
      for (var Tt = O.children, we = 0, et = Tt.length; we < et; we++)
        Ct(Tt[we], z, $);
    }
  }
  function Lt(O, z, $, ge) {
    for (var Me = 0, ze = O.length; Me < ze; Me++) {
      var Ke = O[Me], we = Ke.object, et = Ke.geometry, nt = ge === void 0 ? Ke.material : ge, it = Ke.group;
      if ($.isArrayCamera) {
        C = $;
        for (var Tt = $.cameras, Qe = 0, Dt = Tt.length; Qe < Dt; Qe++) {
          var bt = Tt[Qe];
          if (we.layers.test(bt.layers)) {
            if ("viewport" in bt)
              _e.viewport(R.copy(bt.viewport));
            else {
              var $t = bt.bounds, hi = $t.x * I, Ni = $t.y * V, Ci = $t.z * I, an = $t.w * V;
              _e.viewport(R.set(hi, Ni, Ci, an).multiplyScalar(Q));
            }
            wt(we, z, bt, et, nt, it);
          }
        }
      } else
        C = null, wt(we, z, $, et, nt, it);
    }
  }
  function wt(O, z, $, ge, Me, ze) {
    if (O.onBeforeRender(d, z, $, ge, Me, ze), h = yt.get(z, C || $), O.modelViewMatrix.multiplyMatrices($.matrixWorldInverse, O.matrixWorld), O.normalMatrix.getNormalMatrix(O.modelViewMatrix), O.isImmediateRenderObject) {
      var Ke = O.isMesh && O.matrixWorld.determinant() < 0;
      _e.setMaterial(Me, Ke);
      var we = Br($, z.fog, Me, O);
      E = "", st(O, we, Me);
    } else
      d.renderBufferDirect($, z.fog, ge, Me, O, ze);
    O.onAfterRender(d, z, $, ge, Me, ze), h = yt.get(z, C || $);
  }
  function _t(O, z, $) {
    var ge = Ve.get(O), Me = h.state.lights, ze = h.state.shadowsArray, Ke = Mt.getParameters(
      O,
      Me.state,
      ze,
      z,
      de.numPlanes,
      de.numIntersection,
      $
    ), we = Mt.getProgramCode(O, Ke), et = ge.program, nt = !0;
    if (et === void 0)
      O.addEventListener("dispose", Ie);
    else if (et.code !== we)
      Be(O);
    else if (ge.lightsHash !== Me.state.hash)
      Ve.update(O, "lightsHash", Me.state.hash), nt = !1;
    else {
      if (Ke.shaderID !== void 0)
        return;
      nt = !1;
    }
    if (nt) {
      if (Ke.shaderID) {
        var it = Fa[Ke.shaderID];
        ge.shader = {
          name: O.type,
          uniforms: sr.clone(it.uniforms),
          vertexShader: it.vertexShader,
          fragmentShader: it.fragmentShader
        };
      } else
        ge.shader = {
          name: O.type,
          uniforms: O.uniforms,
          vertexShader: O.vertexShader,
          fragmentShader: O.fragmentShader
        };
      O.onBeforeCompile(ge.shader, d), et = Mt.acquireProgram(O, ge.shader, Ke, we), ge.program = et, O.program = et;
    }
    var Tt = et.getAttributes();
    if (O.morphTargets) {
      O.numSupportedMorphTargets = 0;
      for (var Qe = 0; Qe < d.maxMorphTargets; Qe++)
        Tt["morphTarget" + Qe] >= 0 && O.numSupportedMorphTargets++;
    }
    if (O.morphNormals) {
      O.numSupportedMorphNormals = 0;
      for (var Qe = 0; Qe < d.maxMorphNormals; Qe++)
        Tt["morphNormal" + Qe] >= 0 && O.numSupportedMorphNormals++;
    }
    var Dt = ge.shader.uniforms;
    (!O.isShaderMaterial && !O.isRawShaderMaterial || O.clipping === !0) && (ge.numClippingPlanes = de.numPlanes, ge.numIntersection = de.numIntersection, Dt.clippingPlanes = de.uniform), ge.fog = z, ge.lightsHash = Me.state.hash, O.lights && (Dt.ambientLightColor.value = Me.state.ambient, Dt.directionalLights.value = Me.state.directional, Dt.spotLights.value = Me.state.spot, Dt.rectAreaLights.value = Me.state.rectArea, Dt.pointLights.value = Me.state.point, Dt.hemisphereLights.value = Me.state.hemi, Dt.directionalShadowMap.value = Me.state.directionalShadowMap, Dt.directionalShadowMatrix.value = Me.state.directionalShadowMatrix, Dt.spotShadowMap.value = Me.state.spotShadowMap, Dt.spotShadowMatrix.value = Me.state.spotShadowMatrix, Dt.pointShadowMap.value = Me.state.pointShadowMap, Dt.pointShadowMatrix.value = Me.state.pointShadowMatrix);
    var bt = ge.program.getUniforms(), $t = oa.seqWithValue(bt.seq, Dt);
    ge.uniformsList = $t;
  }
  function Br(O, z, $, ge) {
    B = 0;
    var Me = Ve.get($), ze = h.state.lights;
    if (G && (j || O !== M)) {
      var Ke = O === M && $.id === x;
      de.setState(
        $.clippingPlanes,
        $.clipIntersection,
        $.clipShadows,
        O,
        Me,
        Ke
      );
    }
    $.needsUpdate === !1 && (Me.program === void 0 || $.fog && Me.fog !== z || $.lights && Me.lightsHash !== ze.state.hash || Me.numClippingPlanes !== void 0 && (Me.numClippingPlanes !== de.numPlanes || Me.numIntersection !== de.numIntersection)) && ($.needsUpdate = !0), $.needsUpdate && (_t($, z, ge), $.needsUpdate = !1);
    var we = !1, et = !1, nt = !1, it = Me.program, Tt = it.getUniforms(), Qe = Me.shader.uniforms;
    if (_e.useProgram(it.program) && (we = !0, et = !0, nt = !0), $.id !== x && (x = $.id, et = !0), we || O !== M) {
      if (Tt.setValue(K, "projectionMatrix", O.projectionMatrix), Re.logarithmicDepthBuffer && Tt.setValue(
        K,
        "logDepthBufFC",
        2 / (Math.log(O.far + 1) / Math.LN2)
      ), M !== (C || O) && (M = C || O, et = !0, nt = !0), $.isShaderMaterial || $.isMeshPhongMaterial || $.isMeshStandardMaterial || $.envMap) {
        var Dt = Tt.map.cameraPosition;
        Dt !== void 0 && Dt.setValue(
          K,
          ie.setFromMatrixPosition(O.matrixWorld)
        );
      }
      ($.isMeshPhongMaterial || $.isMeshLambertMaterial || $.isMeshBasicMaterial || $.isMeshStandardMaterial || $.isShaderMaterial || $.skinning) && Tt.setValue(K, "viewMatrix", O.matrixWorldInverse);
    }
    if ($.skinning) {
      Tt.setOptional(K, ge, "bindMatrix"), Tt.setOptional(K, ge, "bindMatrixInverse");
      var bt = ge.skeleton;
      if (bt) {
        var $t = bt.bones;
        if (Re.floatVertexTextures) {
          if (bt.boneTexture === void 0) {
            var hi = Math.sqrt($t.length * 4);
            hi = gt.ceilPowerOfTwo(hi), hi = Math.max(hi, 4);
            var Ni = new Float32Array(hi * hi * 4);
            Ni.set(bt.boneMatrices);
            var Ci = new qa(Ni, hi, hi, gn, js);
            Ci.needsUpdate = !0, bt.boneMatrices = Ni, bt.boneTexture = Ci, bt.boneTextureSize = hi;
          }
          Tt.setValue(K, "boneTexture", bt.boneTexture), Tt.setValue(K, "boneTextureSize", bt.boneTextureSize);
        } else
          Tt.setOptional(K, bt, "boneMatrices");
      }
    }
    return et && (Tt.setValue(K, "toneMappingExposure", d.toneMappingExposure), Tt.setValue(K, "toneMappingWhitePoint", d.toneMappingWhitePoint), $.lights && wn(Qe, nt), z && $.fog && nn(Qe, z), $.isMeshBasicMaterial ? nr(Qe, $) : $.isMeshLambertMaterial ? (nr(Qe, $), ia(Qe, $)) : $.isMeshPhongMaterial ? (nr(Qe, $), $.isMeshToonMaterial ? zo(Qe, $) : Fr(Qe, $)) : $.isMeshStandardMaterial ? (nr(Qe, $), $.isMeshPhysicalMaterial ? _r(Qe, $) : bs(Qe, $)) : $.isMeshDepthMaterial ? (nr(Qe, $), Oi(Qe, $)) : $.isMeshDistanceMaterial ? (nr(Qe, $), En(Qe, $)) : $.isMeshNormalMaterial ? (nr(Qe, $), Nr(Qe, $)) : $.isLineBasicMaterial ? (ta(Qe, $), $.isLineDashedMaterial && xi(Qe, $)) : $.isPointsMaterial ? Xt(Qe, $) : $.isShadowMaterial && (Qe.color.value = $.color, Qe.opacity.value = $.opacity), Qe.ltc_1 !== void 0 && (Qe.ltc_1.value = Xe.LTC_1), Qe.ltc_2 !== void 0 && (Qe.ltc_2.value = Xe.LTC_2), oa.upload(K, Me.uniformsList, Qe, d)), $.isShaderMaterial && $.uniformsNeedUpdate === !0 && (oa.upload(K, Me.uniformsList, Qe, d), $.uniformsNeedUpdate = !1), Tt.setValue(K, "modelViewMatrix", ge.modelViewMatrix), Tt.setValue(K, "normalMatrix", ge.normalMatrix), Tt.setValue(K, "modelMatrix", ge.matrixWorld), it;
  }
  function nr(O, z) {
    O.opacity.value = z.opacity, z.color && (O.diffuse.value = z.color), z.emissive && O.emissive.value.copy(z.emissive).multiplyScalar(z.emissiveIntensity), z.map && (O.map.value = z.map), z.alphaMap && (O.alphaMap.value = z.alphaMap), z.specularMap && (O.specularMap.value = z.specularMap), z.envMap && (O.envMap.value = z.envMap, O.flipEnvMap.value = z.envMap && z.envMap.isCubeTexture ? -1 : 1, O.reflectivity.value = z.reflectivity, O.refractionRatio.value = z.refractionRatio, O.maxMipLevel.value = Ve.get(z.envMap).__maxMipLevel), z.lightMap && (O.lightMap.value = z.lightMap, O.lightMapIntensity.value = z.lightMapIntensity), z.aoMap && (O.aoMap.value = z.aoMap, O.aoMapIntensity.value = z.aoMapIntensity);
    var $;
    z.map ? $ = z.map : z.specularMap ? $ = z.specularMap : z.displacementMap ? $ = z.displacementMap : z.normalMap ? $ = z.normalMap : z.bumpMap ? $ = z.bumpMap : z.roughnessMap ? $ = z.roughnessMap : z.metalnessMap ? $ = z.metalnessMap : z.alphaMap ? $ = z.alphaMap : z.emissiveMap && ($ = z.emissiveMap), $ !== void 0 && ($.isWebGLRenderTarget && ($ = $.texture), $.matrixAutoUpdate === !0 && $.updateMatrix(), O.uvTransform.value.copy($.matrix));
  }
  function ta(O, z) {
    O.diffuse.value = z.color, O.opacity.value = z.opacity;
  }
  function xi(O, z) {
    O.dashSize.value = z.dashSize, O.totalSize.value = z.dashSize + z.gapSize, O.scale.value = z.scale;
  }
  function Xt(O, z) {
    O.diffuse.value = z.color, O.opacity.value = z.opacity, O.size.value = z.size * Q, O.scale.value = V * 0.5, O.map.value = z.map, z.map !== null && (z.map.matrixAutoUpdate === !0 && z.map.updateMatrix(), O.uvTransform.value.copy(z.map.matrix));
  }
  function nn(O, z) {
    O.fogColor.value = z.color, z.isFog ? (O.fogNear.value = z.near, O.fogFar.value = z.far) : z.isFogExp2 && (O.fogDensity.value = z.density);
  }
  function ia(O, z) {
    z.emissiveMap && (O.emissiveMap.value = z.emissiveMap);
  }
  function Fr(O, z) {
    O.specular.value = z.specular, O.shininess.value = Math.max(z.shininess, 1e-4), z.emissiveMap && (O.emissiveMap.value = z.emissiveMap), z.bumpMap && (O.bumpMap.value = z.bumpMap, O.bumpScale.value = z.bumpScale, z.side === Ti && (O.bumpScale.value *= -1)), z.normalMap && (O.normalMap.value = z.normalMap, O.normalScale.value.copy(z.normalScale), z.side === Ti && O.normalScale.value.negate()), z.displacementMap && (O.displacementMap.value = z.displacementMap, O.displacementScale.value = z.displacementScale, O.displacementBias.value = z.displacementBias);
  }
  function zo(O, z) {
    Fr(O, z), z.gradientMap && (O.gradientMap.value = z.gradientMap);
  }
  function bs(O, z) {
    O.roughness.value = z.roughness, O.metalness.value = z.metalness, z.roughnessMap && (O.roughnessMap.value = z.roughnessMap), z.metalnessMap && (O.metalnessMap.value = z.metalnessMap), z.emissiveMap && (O.emissiveMap.value = z.emissiveMap), z.bumpMap && (O.bumpMap.value = z.bumpMap, O.bumpScale.value = z.bumpScale, z.side === Ti && (O.bumpScale.value *= -1)), z.normalMap && (O.normalMap.value = z.normalMap, O.normalScale.value.copy(z.normalScale), z.side === Ti && O.normalScale.value.negate()), z.displacementMap && (O.displacementMap.value = z.displacementMap, O.displacementScale.value = z.displacementScale, O.displacementBias.value = z.displacementBias), z.envMap && (O.envMapIntensity.value = z.envMapIntensity);
  }
  function _r(O, z) {
    O.clearCoat.value = z.clearCoat, O.clearCoatRoughness.value = z.clearCoatRoughness, bs(O, z);
  }
  function Oi(O, z) {
    z.displacementMap && (O.displacementMap.value = z.displacementMap, O.displacementScale.value = z.displacementScale, O.displacementBias.value = z.displacementBias);
  }
  function En(O, z) {
    z.displacementMap && (O.displacementMap.value = z.displacementMap, O.displacementScale.value = z.displacementScale, O.displacementBias.value = z.displacementBias), O.referencePosition.value.copy(z.referencePosition), O.nearDistance.value = z.nearDistance, O.farDistance.value = z.farDistance;
  }
  function Nr(O, z) {
    z.bumpMap && (O.bumpMap.value = z.bumpMap, O.bumpScale.value = z.bumpScale, z.side === Ti && (O.bumpScale.value *= -1)), z.normalMap && (O.normalMap.value = z.normalMap, O.normalScale.value.copy(z.normalScale), z.side === Ti && O.normalScale.value.negate()), z.displacementMap && (O.displacementMap.value = z.displacementMap, O.displacementScale.value = z.displacementScale, O.displacementBias.value = z.displacementBias);
  }
  function wn(O, z) {
    O.ambientLightColor.needsUpdate = z, O.directionalLights.needsUpdate = z, O.pointLights.needsUpdate = z, O.spotLights.needsUpdate = z, O.rectAreaLights.needsUpdate = z, O.hemisphereLights.needsUpdate = z;
  }
  function Jt() {
    var O = B;
    return O >= Re.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + O + " texture units while this GPU supports only " + Re.maxTextures), B += 1, O;
  }
  this.allocTextureUnit = Jt, this.setTexture2D = /* @__PURE__ */ function() {
    var O = !1;
    return function($, ge) {
      $ && $.isWebGLRenderTarget && (O || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), O = !0), $ = $.texture), ft.setTexture2D($, ge);
    };
  }(), this.setTexture = /* @__PURE__ */ function() {
    var O = !1;
    return function($, ge) {
      O || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), O = !0), ft.setTexture2D($, ge);
    };
  }(), this.setTextureCube = /* @__PURE__ */ function() {
    var O = !1;
    return function($, ge) {
      $ && $.isWebGLRenderTargetCube && (O || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), O = !0), $ = $.texture), $ && $.isCubeTexture || Array.isArray($.image) && $.image.length === 6 ? ft.setTextureCube($, ge) : ft.setTextureCubeDynamic($, ge);
    };
  }(), this.setFramebuffer = function(O) {
    p = O;
  }, this.getRenderTarget = function() {
    return _;
  }, this.setRenderTarget = function(O) {
    _ = O, O && Ve.get(O).__webglFramebuffer === void 0 && ft.setupRenderTarget(O);
    var z = p, $ = !1;
    if (O) {
      var ge = Ve.get(O).__webglFramebuffer;
      O.isWebGLRenderTargetCube ? (z = ge[O.activeCubeFace], $ = !0) : z = ge, R.copy(O.viewport), k.copy(O.scissor), F = O.scissorTest;
    } else
      R.copy(ee).multiplyScalar(Q), k.copy(oe).multiplyScalar(Q), F = fe;
    if (m !== z && (K.bindFramebuffer(K.FRAMEBUFFER, z), m = z), _e.viewport(R), _e.scissor(k), _e.setScissorTest(F), $) {
      var Me = Ve.get(O.texture);
      K.framebufferTexture2D(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, K.TEXTURE_CUBE_MAP_POSITIVE_X + O.activeCubeFace, Me.__webglTexture, O.activeMipMapLevel);
    }
  }, this.readRenderTargetPixels = function(O, z, $, ge, Me, ze) {
    if (!(O && O.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    var Ke = Ve.get(O).__webglFramebuffer;
    if (Ke) {
      var we = !1;
      Ke !== m && (K.bindFramebuffer(K.FRAMEBUFFER, Ke), we = !0);
      try {
        var et = O.texture, nt = et.format, it = et.type;
        if (nt !== gn && Gt.convert(nt) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_FORMAT)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (it !== fh && Gt.convert(it) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(it === js && (pe.get("OES_texture_float") || pe.get("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !(it === ph && pe.get("EXT_color_buffer_half_float"))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        K.checkFramebufferStatus(K.FRAMEBUFFER) === K.FRAMEBUFFER_COMPLETE ? z >= 0 && z <= O.width - ge && $ >= 0 && $ <= O.height - Me && K.readPixels(z, $, ge, Me, Gt.convert(nt), Gt.convert(it), ze) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        we && K.bindFramebuffer(K.FRAMEBUFFER, m);
      }
    }
  }, this.copyFramebufferToTexture = function(O, z, $) {
    var ge = z.image.width, Me = z.image.height, ze = Gt.convert(z.format);
    this.setTexture2D(z, 0), K.copyTexImage2D(K.TEXTURE_2D, $ || 0, ze, O.x, O.y, ge, Me, 0);
  }, this.copyTextureToTexture = function(O, z, $, ge) {
    var Me = z.image.width, ze = z.image.height, Ke = Gt.convert($.format), we = Gt.convert($.type);
    this.setTexture2D($, 0), z.isDataTexture ? K.texSubImage2D(K.TEXTURE_2D, ge || 0, O.x, O.y, Me, ze, Ke, we, z.image.data) : K.texSubImage2D(K.TEXTURE_2D, ge || 0, O.x, O.y, Ke, we, z.image);
  };
}
function Ws(e, t) {
  this.name = "", this.color = new We(e), this.density = t !== void 0 ? t : 25e-5;
}
Ws.prototype.isFogExp2 = !0;
Ws.prototype.clone = function() {
  return new Ws(this.color, this.density);
};
Ws.prototype.toJSON = function() {
  return {
    type: "FogExp2",
    color: this.color.getHex(),
    density: this.density
  };
};
function qs(e, t, i) {
  this.name = "", this.color = new We(e), this.near = t !== void 0 ? t : 1, this.far = i !== void 0 ? i : 1e3;
}
qs.prototype.isFog = !0;
qs.prototype.clone = function() {
  return new qs(this.color, this.near, this.far);
};
qs.prototype.toJSON = function() {
  return {
    type: "Fog",
    color: this.color.getHex(),
    near: this.near,
    far: this.far
  };
};
function Mu() {
  Fe.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0;
}
Mu.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: Mu,
  copy: function(e, t) {
    return Fe.prototype.copy.call(this, e, t), e.background !== null && (this.background = e.background.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  },
  toJSON: function(e) {
    var t = Fe.prototype.toJSON.call(this, e);
    return this.background !== null && (t.object.background = this.background.toJSON(e)), this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  }
});
function fa(e) {
  dt.call(this), this.type = "SpriteMaterial", this.color = new We(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(e);
}
fa.prototype = Object.create(dt.prototype);
fa.prototype.constructor = fa;
fa.prototype.isSpriteMaterial = !0;
fa.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this;
};
function Du(e) {
  Fe.call(this), this.type = "Sprite", this.material = e !== void 0 ? e : new fa(), this.center = new ue(0.5, 0.5);
}
Du.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: Du,
  isSprite: !0,
  raycast: function() {
    var e = new H(), t = new H(), i = new H();
    return function(r, a) {
      t.setFromMatrixPosition(this.matrixWorld), r.ray.closestPointToPoint(t, e), i.setFromMatrixScale(this.matrixWorld);
      var s = i.x * i.y / 4;
      if (!(t.distanceToSquared(e) > s)) {
        var o = r.ray.origin.distanceTo(e);
        o < r.near || o > r.far || a.push({
          distance: o,
          point: e.clone(),
          face: null,
          object: this
        });
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.material).copy(this);
  },
  copy: function(e) {
    return Fe.prototype.copy.call(this, e), e.center !== void 0 && this.center.copy(e.center), this;
  }
});
function Pu() {
  Fe.call(this), this.type = "LOD", Object.defineProperties(this, {
    levels: {
      enumerable: !0,
      value: []
    }
  });
}
Pu.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: Pu,
  copy: function(e) {
    Fe.prototype.copy.call(this, e, !1);
    for (var t = e.levels, i = 0, n = t.length; i < n; i++) {
      var r = t[i];
      this.addLevel(r.object.clone(), r.distance);
    }
    return this;
  },
  addLevel: function(e, t) {
    t === void 0 && (t = 0), t = Math.abs(t);
    for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++)
      ;
    i.splice(n, 0, { distance: t, object: e }), this.add(e);
  },
  getObjectForDistance: function(e) {
    for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++)
      ;
    return t[i - 1].object;
  },
  raycast: function() {
    var e = new H();
    return function(i, n) {
      e.setFromMatrixPosition(this.matrixWorld);
      var r = i.ray.origin.distanceTo(e);
      this.getObjectForDistance(r).raycast(i, n);
    };
  }(),
  update: function() {
    var e = new H(), t = new H();
    return function(n) {
      var r = this.levels;
      if (r.length > 1) {
        e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
        var a = e.distanceTo(t);
        r[0].object.visible = !0;
        for (var s = 1, o = r.length; s < o && a >= r[s].distance; s++)
          r[s - 1].object.visible = !1, r[s].object.visible = !0;
        for (; s < o; s++)
          r[s].object.visible = !1;
      }
    };
  }(),
  toJSON: function(e) {
    var t = Fe.prototype.toJSON.call(this, e);
    t.object.levels = [];
    for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
      var a = i[n];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance
      });
    }
    return t;
  }
});
function Lu(e, t) {
  if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(this.bones.length * 16), t === void 0)
    this.calculateInverses();
  else if (this.bones.length === t.length)
    this.boneInverses = t.slice(0);
  else {
    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
    for (var i = 0, n = this.bones.length; i < n; i++)
      this.boneInverses.push(new at());
  }
}
Object.assign(Lu.prototype, {
  calculateInverses: function() {
    this.boneInverses = [];
    for (var e = 0, t = this.bones.length; e < t; e++) {
      var i = new at();
      this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i);
    }
  },
  pose: function() {
    var e, t, i;
    for (t = 0, i = this.bones.length; t < i; t++)
      e = this.bones[t], e && e.matrixWorld.getInverse(this.boneInverses[t]);
    for (t = 0, i = this.bones.length; t < i; t++)
      e = this.bones[t], e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale));
  },
  update: function() {
    var e = new at(), t = new at();
    return function() {
      for (var n = this.bones, r = this.boneInverses, a = this.boneMatrices, s = this.boneTexture, o = 0, u = n.length; o < u; o++) {
        var l = n[o] ? n[o].matrixWorld : t;
        e.multiplyMatrices(l, r[o]), e.toArray(a, o * 16);
      }
      s !== void 0 && (s.needsUpdate = !0);
    };
  }(),
  clone: function() {
    return new Lu(this.bones, this.boneInverses);
  },
  getBoneByName: function(e) {
    for (var t = 0, i = this.bones.length; t < i; t++) {
      var n = this.bones[t];
      if (n.name === e)
        return n;
    }
  }
});
function hc() {
  Fe.call(this), this.type = "Bone";
}
hc.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: hc,
  isBone: !0
});
function dc(e, t) {
  fi.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new at(), this.bindMatrixInverse = new at();
  var i = this.initBones(), n = new Lu(i);
  this.bind(n, this.matrixWorld), this.normalizeSkinWeights();
}
dc.prototype = Object.assign(Object.create(fi.prototype), {
  constructor: dc,
  isSkinnedMesh: !0,
  initBones: function() {
    var e = [], t, i, n, r;
    if (this.geometry && this.geometry.bones !== void 0) {
      for (n = 0, r = this.geometry.bones.length; n < r; n++)
        i = this.geometry.bones[n], t = new hc(), e.push(t), t.name = i.name, t.position.fromArray(i.pos), t.quaternion.fromArray(i.rotq), i.scl !== void 0 && t.scale.fromArray(i.scl);
      for (n = 0, r = this.geometry.bones.length; n < r; n++)
        i = this.geometry.bones[n], i.parent !== -1 && i.parent !== null && e[i.parent] !== void 0 ? e[i.parent].add(e[n]) : this.add(e[n]);
    }
    return this.updateMatrixWorld(!0), e;
  },
  bind: function(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t);
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    var e, t;
    if (this.geometry && this.geometry.isGeometry)
      for (t = 0; t < this.geometry.skinWeights.length; t++) {
        var i = this.geometry.skinWeights[t];
        e = 1 / i.manhattanLength(), e !== 1 / 0 ? i.multiplyScalar(e) : i.set(1, 0, 0, 0);
      }
    else if (this.geometry && this.geometry.isBufferGeometry) {
      var n = new Ft(), r = this.geometry.attributes.skinWeight;
      for (t = 0; t < r.count; t++)
        n.x = r.getX(t), n.y = r.getY(t), n.z = r.getZ(t), n.w = r.getW(t), e = 1 / n.manhattanLength(), e !== 1 / 0 ? n.multiplyScalar(e) : n.set(1, 0, 0, 0), r.setXYZW(t, n.x, n.y, n.z, n.w);
    }
  },
  updateMatrixWorld: function(e) {
    fi.prototype.updateMatrixWorld.call(this, e), this.bindMode === "attached" ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === "detached" ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  },
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function qt(e) {
  dt.call(this), this.type = "LineBasicMaterial", this.color = new We(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e);
}
qt.prototype = Object.create(dt.prototype);
qt.prototype.constructor = qt;
qt.prototype.isLineBasicMaterial = !0;
qt.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this;
};
function hr(e, t, i) {
  if (i === 1)
    return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new Yt(e, t);
  Fe.call(this), this.type = "Line", this.geometry = e !== void 0 ? e : new je(), this.material = t !== void 0 ? t : new qt({ color: Math.random() * 16777215 });
}
hr.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: hr,
  isLine: !0,
  computeLineDistances: function() {
    var e = new H(), t = new H();
    return function() {
      var n = this.geometry;
      if (n.isBufferGeometry)
        if (n.index === null) {
          for (var r = n.attributes.position, a = [0], s = 1, o = r.count; s < o; s++)
            e.fromBufferAttribute(r, s - 1), t.fromBufferAttribute(r, s), a[s] = a[s - 1], a[s] += e.distanceTo(t);
          n.addAttribute("lineDistance", new ke(a, 1));
        } else
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else if (n.isGeometry) {
        var u = n.vertices, a = n.lineDistances;
        a[0] = 0;
        for (var s = 1, o = u.length; s < o; s++)
          a[s] = a[s - 1], a[s] += u[s - 1].distanceTo(u[s]);
      }
      return this;
    };
  }(),
  raycast: function() {
    var e = new at(), t = new ms(), i = new qr();
    return function(r, a) {
      var s = r.linePrecision, o = s * s, u = this.geometry, l = this.matrixWorld;
      if (u.boundingSphere === null && u.computeBoundingSphere(), i.copy(u.boundingSphere), i.applyMatrix4(l), r.ray.intersectsSphere(i) !== !1) {
        e.getInverse(l), t.copy(r.ray).applyMatrix4(e);
        var c = new H(), h = new H(), d = new H(), f = new H(), p = this && this.isLineSegments ? 2 : 1;
        if (u.isBufferGeometry) {
          var _ = u.index, m = u.attributes, x = m.position.array;
          if (_ !== null)
            for (var E = _.array, M = 0, C = E.length - 1; M < C; M += p) {
              var R = E[M], k = E[M + 1];
              c.fromArray(x, R * 3), h.fromArray(x, k * 3);
              var F = t.distanceSqToSegment(c, h, f, d);
              if (!(F > o)) {
                f.applyMatrix4(this.matrixWorld);
                var B = r.ray.origin.distanceTo(f);
                B < r.near || B > r.far || a.push({
                  distance: B,
                  // What do we want? intersection point on the ray or on the segment??
                  // point: raycaster.ray.at( distance ),
                  point: d.clone().applyMatrix4(this.matrixWorld),
                  index: M,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
          else
            for (var M = 0, C = x.length / 3 - 1; M < C; M += p) {
              c.fromArray(x, 3 * M), h.fromArray(x, 3 * M + 3);
              var F = t.distanceSqToSegment(c, h, f, d);
              if (!(F > o)) {
                f.applyMatrix4(this.matrixWorld);
                var B = r.ray.origin.distanceTo(f);
                B < r.near || B > r.far || a.push({
                  distance: B,
                  // What do we want? intersection point on the ray or on the segment??
                  // point: raycaster.ray.at( distance ),
                  point: d.clone().applyMatrix4(this.matrixWorld),
                  index: M,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
        } else if (u.isGeometry)
          for (var I = u.vertices, V = I.length, M = 0; M < V - 1; M += p) {
            var F = t.distanceSqToSegment(I[M], I[M + 1], f, d);
            if (!(F > o)) {
              f.applyMatrix4(this.matrixWorld);
              var B = r.ray.origin.distanceTo(f);
              B < r.near || B > r.far || a.push({
                distance: B,
                // What do we want? intersection point on the ray or on the segment??
                // point: raycaster.ray.at( distance ),
                point: d.clone().applyMatrix4(this.matrixWorld),
                index: M,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function Yt(e, t) {
  hr.call(this, e, t), this.type = "LineSegments";
}
Yt.prototype = Object.assign(Object.create(hr.prototype), {
  constructor: Yt,
  isLineSegments: !0,
  computeLineDistances: function() {
    var e = new H(), t = new H();
    return function() {
      var n = this.geometry;
      if (n.isBufferGeometry)
        if (n.index === null) {
          for (var r = n.attributes.position, a = [], s = 0, o = r.count; s < o; s += 2)
            e.fromBufferAttribute(r, s), t.fromBufferAttribute(r, s + 1), a[s] = s === 0 ? 0 : a[s - 1], a[s + 1] = a[s] + e.distanceTo(t);
          n.addAttribute("lineDistance", new ke(a, 1));
        } else
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else if (n.isGeometry)
        for (var u = n.vertices, a = n.lineDistances, s = 0, o = u.length; s < o; s += 2)
          e.copy(u[s]), t.copy(u[s + 1]), a[s] = s === 0 ? 0 : a[s - 1], a[s + 1] = a[s] + e.distanceTo(t);
      return this;
    };
  }()
});
function fc(e, t) {
  hr.call(this, e, t), this.type = "LineLoop";
}
fc.prototype = Object.assign(Object.create(hr.prototype), {
  constructor: fc,
  isLineLoop: !0
});
function Xr(e) {
  dt.call(this), this.type = "PointsMaterial", this.color = new We(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(e);
}
Xr.prototype = Object.create(dt.prototype);
Xr.prototype.constructor = Xr;
Xr.prototype.isPointsMaterial = !0;
Xr.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this;
};
function Xs(e, t) {
  Fe.call(this), this.type = "Points", this.geometry = e !== void 0 ? e : new je(), this.material = t !== void 0 ? t : new Xr({ color: Math.random() * 16777215 });
}
Xs.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: Xs,
  isPoints: !0,
  raycast: function() {
    var e = new at(), t = new ms(), i = new qr();
    return function(r, a) {
      var s = this, o = this.geometry, u = this.matrixWorld, l = r.params.Points.threshold;
      if (o.boundingSphere === null && o.computeBoundingSphere(), i.copy(o.boundingSphere), i.applyMatrix4(u), i.radius += l, r.ray.intersectsSphere(i) === !1) return;
      e.getInverse(u), t.copy(r.ray).applyMatrix4(e);
      var c = l / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = c * c, d = new H(), f = new H();
      function p(B, I) {
        var V = t.distanceSqToPoint(B);
        if (V < h) {
          t.closestPointToPoint(B, f), f.applyMatrix4(u);
          var Q = r.ray.origin.distanceTo(f);
          if (Q < r.near || Q > r.far) return;
          a.push({
            distance: Q,
            distanceToRay: Math.sqrt(V),
            point: f.clone(),
            index: I,
            face: null,
            object: s
          });
        }
      }
      if (o.isBufferGeometry) {
        var _ = o.index, m = o.attributes, x = m.position.array;
        if (_ !== null)
          for (var E = _.array, M = 0, C = E.length; M < C; M++) {
            var R = E[M];
            d.fromArray(x, R * 3), p(d, R);
          }
        else
          for (var M = 0, k = x.length / 3; M < k; M++)
            d.fromArray(x, M * 3), p(d, M);
      } else
        for (var F = o.vertices, M = 0, k = F.length; M < k; M++)
          p(F[M], M);
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function pc() {
  Fe.call(this), this.type = "Group";
}
pc.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: pc,
  isGroup: !0
});
function vc(e, t, i, n, r, a, s, o, u) {
  ri.call(this, e, t, i, n, r, a, s, o, u), this.generateMipmaps = !1;
}
vc.prototype = Object.assign(Object.create(ri.prototype), {
  constructor: vc,
  isVideoTexture: !0,
  update: function() {
    var e = this.image;
    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
});
function Ys(e, t, i, n, r, a, s, o, u, l, c, h) {
  ri.call(this, null, a, s, o, u, l, n, r, c, h), this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
}
Ys.prototype = Object.create(ri.prototype);
Ys.prototype.constructor = Ys;
Ys.prototype.isCompressedTexture = !0;
function Ru(e, t, i, n, r, a, s, o, u, l) {
  if (l = l !== void 0 ? l : Ba, l !== Ba && l !== Gs)
    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  i === void 0 && l === Ba && (i = vu), i === void 0 && l === Gs && (i = mu), ri.call(this, null, n, r, a, s, o, l, i, u), this.image = { width: e, height: t }, this.magFilter = s !== void 0 ? s : wr, this.minFilter = o !== void 0 ? o : wr, this.flipY = !1, this.generateMipmaps = !1;
}
Ru.prototype = Object.create(ri.prototype);
Ru.prototype.constructor = Ru;
Ru.prototype.isDepthTexture = !0;
function Qs(e) {
  je.call(this), this.type = "WireframeGeometry";
  var t = [], i, n, r, a, s, o = [0, 0], u = {}, l, c, h, d, f = ["a", "b", "c"], p;
  if (e && e.isGeometry) {
    var _ = e.faces;
    for (i = 0, r = _.length; i < r; i++) {
      var m = _[i];
      for (n = 0; n < 3; n++)
        c = m[f[n]], h = m[f[(n + 1) % 3]], o[0] = Math.min(c, h), o[1] = Math.max(c, h), d = o[0] + "," + o[1], u[d] === void 0 && (u[d] = { index1: o[0], index2: o[1] });
    }
    for (d in u)
      l = u[d], p = e.vertices[l.index1], t.push(p.x, p.y, p.z), p = e.vertices[l.index2], t.push(p.x, p.y, p.z);
  } else if (e && e.isBufferGeometry) {
    var x, E, M, C, R, k, F, B;
    if (p = new H(), e.index !== null) {
      for (x = e.attributes.position, E = e.index, M = e.groups, M.length === 0 && (M = [{ start: 0, count: E.count, materialIndex: 0 }]), a = 0, s = M.length; a < s; ++a)
        for (C = M[a], R = C.start, k = C.count, i = R, r = R + k; i < r; i += 3)
          for (n = 0; n < 3; n++)
            c = E.getX(i + n), h = E.getX(i + (n + 1) % 3), o[0] = Math.min(c, h), o[1] = Math.max(c, h), d = o[0] + "," + o[1], u[d] === void 0 && (u[d] = { index1: o[0], index2: o[1] });
      for (d in u)
        l = u[d], p.fromBufferAttribute(x, l.index1), t.push(p.x, p.y, p.z), p.fromBufferAttribute(x, l.index2), t.push(p.x, p.y, p.z);
    } else
      for (x = e.attributes.position, i = 0, r = x.count / 3; i < r; i++)
        for (n = 0; n < 3; n++)
          F = 3 * i + n, p.fromBufferAttribute(x, F), t.push(p.x, p.y, p.z), B = 3 * i + (n + 1) % 3, p.fromBufferAttribute(x, B), t.push(p.x, p.y, p.z);
  }
  this.addAttribute("position", new ke(t, 3));
}
Qs.prototype = Object.create(je.prototype);
Qs.prototype.constructor = Qs;
function Iu(e, t, i) {
  tt.call(this), this.type = "ParametricGeometry", this.parameters = {
    func: e,
    slices: t,
    stacks: i
  }, this.fromBufferGeometry(new Ks(e, t, i)), this.mergeVertices();
}
Iu.prototype = Object.create(tt.prototype);
Iu.prototype.constructor = Iu;
function Ks(e, t, i) {
  je.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
    func: e,
    slices: t,
    stacks: i
  };
  var n = [], r = [], a = [], s = [], o = 1e-5, u = new H(), l = new H(), c = new H(), h = new H(), d = new H(), f, p;
  e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  var _ = t + 1;
  for (f = 0; f <= i; f++) {
    var m = f / i;
    for (p = 0; p <= t; p++) {
      var x = p / t;
      e(x, m, l), r.push(l.x, l.y, l.z), x - o >= 0 ? (e(x - o, m, c), h.subVectors(l, c)) : (e(x + o, m, c), h.subVectors(c, l)), m - o >= 0 ? (e(x, m - o, c), d.subVectors(l, c)) : (e(x, m + o, c), d.subVectors(c, l)), u.crossVectors(h, d).normalize(), a.push(u.x, u.y, u.z), s.push(x, m);
    }
  }
  for (f = 0; f < i; f++)
    for (p = 0; p < t; p++) {
      var E = f * _ + p, M = f * _ + p + 1, C = (f + 1) * _ + p + 1, R = (f + 1) * _ + p;
      n.push(E, M, R), n.push(M, C, R);
    }
  this.setIndex(n), this.addAttribute("position", new ke(r, 3)), this.addAttribute("normal", new ke(a, 3)), this.addAttribute("uv", new ke(s, 2));
}
Ks.prototype = Object.create(je.prototype);
Ks.prototype.constructor = Ks;
function Ou(e, t, i, n) {
  tt.call(this), this.type = "PolyhedronGeometry", this.parameters = {
    vertices: e,
    indices: t,
    radius: i,
    detail: n
  }, this.fromBufferGeometry(new dr(e, t, i, n)), this.mergeVertices();
}
Ou.prototype = Object.create(tt.prototype);
Ou.prototype.constructor = Ou;
function dr(e, t, i, n) {
  je.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
    vertices: e,
    indices: t,
    radius: i,
    detail: n
  }, i = i || 1, n = n || 0;
  var r = [], a = [];
  s(n), u(i), l(), this.addAttribute("position", new ke(r, 3)), this.addAttribute("normal", new ke(r.slice(), 3)), this.addAttribute("uv", new ke(a, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  function s(x) {
    for (var E = new H(), M = new H(), C = new H(), R = 0; R < t.length; R += 3)
      d(t[R + 0], E), d(t[R + 1], M), d(t[R + 2], C), o(E, M, C, x);
  }
  function o(x, E, M, C) {
    var R = Math.pow(2, C), k = [], F, B;
    for (F = 0; F <= R; F++) {
      k[F] = [];
      var I = x.clone().lerp(M, F / R), V = E.clone().lerp(M, F / R), Q = R - F;
      for (B = 0; B <= Q; B++)
        B === 0 && F === R ? k[F][B] = I : k[F][B] = I.clone().lerp(V, B / Q);
    }
    for (F = 0; F < R; F++)
      for (B = 0; B < 2 * (R - F) - 1; B++) {
        var ee = Math.floor(B / 2);
        B % 2 === 0 ? (h(k[F][ee + 1]), h(k[F + 1][ee]), h(k[F][ee])) : (h(k[F][ee + 1]), h(k[F + 1][ee + 1]), h(k[F + 1][ee]));
      }
  }
  function u(x) {
    for (var E = new H(), M = 0; M < r.length; M += 3)
      E.x = r[M + 0], E.y = r[M + 1], E.z = r[M + 2], E.normalize().multiplyScalar(x), r[M + 0] = E.x, r[M + 1] = E.y, r[M + 2] = E.z;
  }
  function l() {
    for (var x = new H(), E = 0; E < r.length; E += 3) {
      x.x = r[E + 0], x.y = r[E + 1], x.z = r[E + 2];
      var M = _(x) / 2 / Math.PI + 0.5, C = m(x) / Math.PI + 0.5;
      a.push(M, 1 - C);
    }
    f(), c();
  }
  function c() {
    for (var x = 0; x < a.length; x += 6) {
      var E = a[x + 0], M = a[x + 2], C = a[x + 4], R = Math.max(E, M, C), k = Math.min(E, M, C);
      R > 0.9 && k < 0.1 && (E < 0.2 && (a[x + 0] += 1), M < 0.2 && (a[x + 2] += 1), C < 0.2 && (a[x + 4] += 1));
    }
  }
  function h(x) {
    r.push(x.x, x.y, x.z);
  }
  function d(x, E) {
    var M = x * 3;
    E.x = e[M + 0], E.y = e[M + 1], E.z = e[M + 2];
  }
  function f() {
    for (var x = new H(), E = new H(), M = new H(), C = new H(), R = new ue(), k = new ue(), F = new ue(), B = 0, I = 0; B < r.length; B += 9, I += 6) {
      x.set(r[B + 0], r[B + 1], r[B + 2]), E.set(r[B + 3], r[B + 4], r[B + 5]), M.set(r[B + 6], r[B + 7], r[B + 8]), R.set(a[I + 0], a[I + 1]), k.set(a[I + 2], a[I + 3]), F.set(a[I + 4], a[I + 5]), C.copy(x).add(E).add(M).divideScalar(3);
      var V = _(C);
      p(R, I + 0, x, V), p(k, I + 2, E, V), p(F, I + 4, M, V);
    }
  }
  function p(x, E, M, C) {
    C < 0 && x.x === 1 && (a[E] = x.x - 1), M.x === 0 && M.z === 0 && (a[E] = C / 2 / Math.PI + 0.5);
  }
  function _(x) {
    return Math.atan2(x.z, -x.x);
  }
  function m(x) {
    return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
  }
}
dr.prototype = Object.create(je.prototype);
dr.prototype.constructor = dr;
function ku(e, t) {
  tt.call(this), this.type = "TetrahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new Zs(e, t)), this.mergeVertices();
}
ku.prototype = Object.create(tt.prototype);
ku.prototype.constructor = ku;
function Zs(e, t) {
  var i = [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
  ], n = [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
  ];
  dr.call(this, i, n, e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
Zs.prototype = Object.create(dr.prototype);
Zs.prototype.constructor = Zs;
function Bu(e, t) {
  tt.call(this), this.type = "OctahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new Za(e, t)), this.mergeVertices();
}
Bu.prototype = Object.create(tt.prototype);
Bu.prototype.constructor = Bu;
function Za(e, t) {
  var i = [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
  ], n = [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
  ];
  dr.call(this, i, n, e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
Za.prototype = Object.create(dr.prototype);
Za.prototype.constructor = Za;
function Fu(e, t) {
  tt.call(this), this.type = "IcosahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new Js(e, t)), this.mergeVertices();
}
Fu.prototype = Object.create(tt.prototype);
Fu.prototype.constructor = Fu;
function Js(e, t) {
  var i = (1 + Math.sqrt(5)) / 2, n = [
    -1,
    i,
    0,
    1,
    i,
    0,
    -1,
    -i,
    0,
    1,
    -i,
    0,
    0,
    -1,
    i,
    0,
    1,
    i,
    0,
    -1,
    -i,
    0,
    1,
    -i,
    i,
    0,
    -1,
    i,
    0,
    1,
    -i,
    0,
    -1,
    -i,
    0,
    1
  ], r = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ];
  dr.call(this, n, r, e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
Js.prototype = Object.create(dr.prototype);
Js.prototype.constructor = Js;
function Nu(e, t) {
  tt.call(this), this.type = "DodecahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new $s(e, t)), this.mergeVertices();
}
Nu.prototype = Object.create(tt.prototype);
Nu.prototype.constructor = Nu;
function $s(e, t) {
  var i = (1 + Math.sqrt(5)) / 2, n = 1 / i, r = [
    // (1, 1, 1)
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    // (0, 1/, )
    0,
    -n,
    -i,
    0,
    -n,
    i,
    0,
    n,
    -i,
    0,
    n,
    i,
    // (1/, , 0)
    -n,
    -i,
    0,
    -n,
    i,
    0,
    n,
    -i,
    0,
    n,
    i,
    0,
    // (, 0, 1/)
    -i,
    0,
    -n,
    i,
    0,
    -n,
    -i,
    0,
    n,
    i,
    0,
    n
  ], a = [
    3,
    11,
    7,
    3,
    7,
    15,
    3,
    15,
    13,
    7,
    19,
    17,
    7,
    17,
    6,
    7,
    6,
    15,
    17,
    4,
    8,
    17,
    8,
    10,
    17,
    10,
    6,
    8,
    0,
    16,
    8,
    16,
    2,
    8,
    2,
    10,
    0,
    12,
    1,
    0,
    1,
    18,
    0,
    18,
    16,
    6,
    10,
    2,
    6,
    2,
    13,
    6,
    13,
    15,
    2,
    16,
    18,
    2,
    18,
    3,
    2,
    3,
    13,
    18,
    1,
    9,
    18,
    9,
    11,
    18,
    11,
    3,
    4,
    14,
    12,
    4,
    12,
    0,
    4,
    0,
    8,
    11,
    9,
    5,
    11,
    5,
    19,
    11,
    19,
    7,
    19,
    5,
    14,
    19,
    14,
    4,
    19,
    4,
    17,
    1,
    12,
    14,
    1,
    14,
    5,
    1,
    5,
    9
  ];
  dr.call(this, r, a, e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
$s.prototype = Object.create(dr.prototype);
$s.prototype.constructor = $s;
function Uu(e, t, i, n, r, a) {
  tt.call(this), this.type = "TubeGeometry", this.parameters = {
    path: e,
    tubularSegments: t,
    radius: i,
    radialSegments: n,
    closed: r
  }, a !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed.");
  var s = new eo(e, t, i, n, r);
  this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, this.fromBufferGeometry(s), this.mergeVertices();
}
Uu.prototype = Object.create(tt.prototype);
Uu.prototype.constructor = Uu;
function eo(e, t, i, n, r) {
  je.call(this), this.type = "TubeBufferGeometry", this.parameters = {
    path: e,
    tubularSegments: t,
    radius: i,
    radialSegments: n,
    closed: r
  }, t = t || 64, i = i || 1, n = n || 8, r = r || !1;
  var a = e.computeFrenetFrames(t, r);
  this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
  var s = new H(), o = new H(), u = new ue(), l = new H(), c, h, d = [], f = [], p = [], _ = [];
  m(), this.setIndex(_), this.addAttribute("position", new ke(d, 3)), this.addAttribute("normal", new ke(f, 3)), this.addAttribute("uv", new ke(p, 2));
  function m() {
    for (c = 0; c < t; c++)
      x(c);
    x(r === !1 ? t : 0), M(), E();
  }
  function x(C) {
    l = e.getPointAt(C / t, l);
    var R = a.normals[C], k = a.binormals[C];
    for (h = 0; h <= n; h++) {
      var F = h / n * Math.PI * 2, B = Math.sin(F), I = -Math.cos(F);
      o.x = I * R.x + B * k.x, o.y = I * R.y + B * k.y, o.z = I * R.z + B * k.z, o.normalize(), f.push(o.x, o.y, o.z), s.x = l.x + i * o.x, s.y = l.y + i * o.y, s.z = l.z + i * o.z, d.push(s.x, s.y, s.z);
    }
  }
  function E() {
    for (h = 1; h <= t; h++)
      for (c = 1; c <= n; c++) {
        var C = (n + 1) * (h - 1) + (c - 1), R = (n + 1) * h + (c - 1), k = (n + 1) * h + c, F = (n + 1) * (h - 1) + c;
        _.push(C, R, F), _.push(R, k, F);
      }
  }
  function M() {
    for (c = 0; c <= t; c++)
      for (h = 0; h <= n; h++)
        u.x = c / t, u.y = h / n, p.push(u.x, u.y);
  }
}
eo.prototype = Object.create(je.prototype);
eo.prototype.constructor = eo;
function ju(e, t, i, n, r, a, s) {
  tt.call(this), this.type = "TorusKnotGeometry", this.parameters = {
    radius: e,
    tube: t,
    tubularSegments: i,
    radialSegments: n,
    p: r,
    q: a
  }, s !== void 0 && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new to(e, t, i, n, r, a)), this.mergeVertices();
}
ju.prototype = Object.create(tt.prototype);
ju.prototype.constructor = ju;
function to(e, t, i, n, r, a) {
  je.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
    radius: e,
    tube: t,
    tubularSegments: i,
    radialSegments: n,
    p: r,
    q: a
  }, e = e || 1, t = t || 0.4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, a = a || 3;
  var s = [], o = [], u = [], l = [], c, h, d = new H(), f = new H(), p = new H(), _ = new H(), m = new H(), x = new H(), E = new H();
  for (c = 0; c <= i; ++c) {
    var M = c / i * r * Math.PI * 2;
    for (Q(M, r, a, e, p), Q(M + 0.01, r, a, e, _), x.subVectors(_, p), E.addVectors(_, p), m.crossVectors(x, E), E.crossVectors(m, x), m.normalize(), E.normalize(), h = 0; h <= n; ++h) {
      var C = h / n * Math.PI * 2, R = -t * Math.cos(C), k = t * Math.sin(C);
      d.x = p.x + (R * E.x + k * m.x), d.y = p.y + (R * E.y + k * m.y), d.z = p.z + (R * E.z + k * m.z), o.push(d.x, d.y, d.z), f.subVectors(d, p).normalize(), u.push(f.x, f.y, f.z), l.push(c / i), l.push(h / n);
    }
  }
  for (h = 1; h <= i; h++)
    for (c = 1; c <= n; c++) {
      var F = (n + 1) * (h - 1) + (c - 1), B = (n + 1) * h + (c - 1), I = (n + 1) * h + c, V = (n + 1) * (h - 1) + c;
      s.push(F, B, V), s.push(B, I, V);
    }
  this.setIndex(s), this.addAttribute("position", new ke(o, 3)), this.addAttribute("normal", new ke(u, 3)), this.addAttribute("uv", new ke(l, 2));
  function Q(ee, oe, fe, he, de) {
    var G = Math.cos(ee), j = Math.sin(ee), se = fe / oe * ee, ie = Math.cos(se);
    de.x = he * (2 + ie) * 0.5 * G, de.y = he * (2 + ie) * j * 0.5, de.z = he * Math.sin(se) * 0.5;
  }
}
to.prototype = Object.create(je.prototype);
to.prototype.constructor = to;
function Gu(e, t, i, n, r) {
  tt.call(this), this.type = "TorusGeometry", this.parameters = {
    radius: e,
    tube: t,
    radialSegments: i,
    tubularSegments: n,
    arc: r
  }, this.fromBufferGeometry(new io(e, t, i, n, r)), this.mergeVertices();
}
Gu.prototype = Object.create(tt.prototype);
Gu.prototype.constructor = Gu;
function io(e, t, i, n, r) {
  je.call(this), this.type = "TorusBufferGeometry", this.parameters = {
    radius: e,
    tube: t,
    radialSegments: i,
    tubularSegments: n,
    arc: r
  }, e = e || 1, t = t || 0.4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || Math.PI * 2;
  var a = [], s = [], o = [], u = [], l = new H(), c = new H(), h = new H(), d, f;
  for (d = 0; d <= i; d++)
    for (f = 0; f <= n; f++) {
      var p = f / n * r, _ = d / i * Math.PI * 2;
      c.x = (e + t * Math.cos(_)) * Math.cos(p), c.y = (e + t * Math.cos(_)) * Math.sin(p), c.z = t * Math.sin(_), s.push(c.x, c.y, c.z), l.x = e * Math.cos(p), l.y = e * Math.sin(p), h.subVectors(c, l).normalize(), o.push(h.x, h.y, h.z), u.push(f / n), u.push(d / i);
    }
  for (d = 1; d <= i; d++)
    for (f = 1; f <= n; f++) {
      var m = (n + 1) * d + f - 1, x = (n + 1) * (d - 1) + f - 1, E = (n + 1) * (d - 1) + f, M = (n + 1) * d + f;
      a.push(m, x, M), a.push(x, E, M);
    }
  this.setIndex(a), this.addAttribute("position", new ke(s, 3)), this.addAttribute("normal", new ke(o, 3)), this.addAttribute("uv", new ke(u, 2));
}
io.prototype = Object.create(je.prototype);
io.prototype.constructor = io;
var J2 = {
  triangulate: function(e, t, i) {
    i = i || 2;
    var n = t && t.length, r = n ? t[0] * i : e.length, a = ey(e, 0, r, i, !0), s = [];
    if (!a) return s;
    var o, u, l, c, h, d, f;
    if (n && (a = rE(e, t, a, i)), e.length > 80 * i) {
      o = l = e[0], u = c = e[1];
      for (var p = i; p < r; p += i)
        h = e[p], d = e[p + 1], h < o && (o = h), d < u && (u = d), h > l && (l = h), d > c && (c = d);
      f = Math.max(l - o, c - u), f = f !== 0 ? 1 / f : 0;
    }
    return Hu(a, s, i, o, u, f), s;
  }
};
function ey(e, t, i, n, r) {
  var a, s;
  if (r === fE(e, t, i, n) > 0)
    for (a = t; a < i; a += n) s = Wv(a, e[a], e[a + 1], s);
  else
    for (a = i - n; a >= t; a -= n) s = Wv(a, e[a], e[a + 1], s);
  return s && Ia(s, s.next) && (Wu(s), s = s.next), s;
}
function Vu(e, t) {
  if (!e) return e;
  t || (t = e);
  var i = e, n;
  do
    if (n = !1, !i.steiner && (Ia(i, i.next) || $i(i.prev, i, i.next) === 0)) {
      if (Wu(i), i = t = i.prev, i === i.next) break;
      n = !0;
    } else
      i = i.next;
  while (n || i !== t);
  return t;
}
function Hu(e, t, i, n, r, a, s) {
  if (e) {
    !s && a && oE(e, n, r, a);
    for (var o = e, u, l; e.prev !== e.next; ) {
      if (u = e.prev, l = e.next, a ? eE(e, n, r, a) : $2(e)) {
        t.push(u.i / i), t.push(e.i / i), t.push(l.i / i), Wu(e), e = l.next, o = l.next;
        continue;
      }
      if (e = l, e === o) {
        s ? s === 1 ? (e = tE(e, t, i), Hu(e, t, i, n, r, a, 2)) : s === 2 && iE(e, t, i, n, r, a) : Hu(Vu(e), t, i, n, r, a, 1);
        break;
      }
    }
  }
}
function $2(e) {
  var t = e.prev, i = e, n = e.next;
  if ($i(t, i, n) >= 0) return !1;
  for (var r = e.next.next; r !== e.prev; ) {
    if (mc(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) && $i(r.prev, r, r.next) >= 0)
      return !1;
    r = r.next;
  }
  return !0;
}
function eE(e, t, i, n) {
  var r = e.prev, a = e, s = e.next;
  if ($i(r, a, s) >= 0) return !1;
  for (var o = r.x < a.x ? r.x < s.x ? r.x : s.x : a.x < s.x ? a.x : s.x, u = r.y < a.y ? r.y < s.y ? r.y : s.y : a.y < s.y ? a.y : s.y, l = r.x > a.x ? r.x > s.x ? r.x : s.x : a.x > s.x ? a.x : s.x, c = r.y > a.y ? r.y > s.y ? r.y : s.y : a.y > s.y ? a.y : s.y, h = Bd(o, u, t, i, n), d = Bd(l, c, t, i, n), f = e.nextZ; f && f.z <= d; ) {
    if (f !== e.prev && f !== e.next && mc(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && $i(f.prev, f, f.next) >= 0) return !1;
    f = f.nextZ;
  }
  for (f = e.prevZ; f && f.z >= h; ) {
    if (f !== e.prev && f !== e.next && mc(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && $i(f.prev, f, f.next) >= 0) return !1;
    f = f.prevZ;
  }
  return !0;
}
function tE(e, t, i) {
  var n = e;
  do {
    var r = n.prev, a = n.next.next;
    !Ia(r, a) && ty(r, n, n.next, a) && zu(r, a) && zu(a, r) && (t.push(r.i / i), t.push(n.i / i), t.push(a.i / i), Wu(n), Wu(n.next), n = e = a), n = n.next;
  } while (n !== e);
  return n;
}
function iE(e, t, i, n, r, a) {
  var s = e;
  do {
    for (var o = s.next.next; o !== s.prev; ) {
      if (s.i !== o.i && cE(s, o)) {
        var u = iy(s, o);
        s = Vu(s, s.next), u = Vu(u, u.next), Hu(s, t, i, n, r, a), Hu(u, t, i, n, r, a);
        return;
      }
      o = o.next;
    }
    s = s.next;
  } while (s !== e);
}
function rE(e, t, i, n) {
  var r = [], a, s, o, u, l;
  for (a = 0, s = t.length; a < s; a++)
    o = t[a] * n, u = a < s - 1 ? t[a + 1] * n : e.length, l = ey(e, o, u, n, !1), l === l.next && (l.steiner = !0), r.push(lE(l));
  for (r.sort(nE), a = 0; a < r.length; a++)
    aE(r[a], i), i = Vu(i, i.next);
  return i;
}
function nE(e, t) {
  return e.x - t.x;
}
function aE(e, t) {
  if (t = sE(e, t), t) {
    var i = iy(t, e);
    Vu(i, i.next);
  }
}
function sE(e, t) {
  var i = t, n = e.x, r = e.y, a = -1 / 0, s;
  do {
    if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
      var o = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
      if (o <= n && o > a) {
        if (a = o, o === n) {
          if (r === i.y) return i;
          if (r === i.next.y) return i.next;
        }
        s = i.x < i.next.x ? i : i.next;
      }
    }
    i = i.next;
  } while (i !== t);
  if (!s) return null;
  if (n === a) return s.prev;
  var u = s, l = s.x, c = s.y, h = 1 / 0, d;
  for (i = s.next; i !== u; )
    n >= i.x && i.x >= l && n !== i.x && mc(r < c ? n : a, r, l, c, r < c ? a : n, r, i.x, i.y) && (d = Math.abs(r - i.y) / (n - i.x), (d < h || d === h && i.x > s.x) && zu(i, e) && (s = i, h = d)), i = i.next;
  return s;
}
function oE(e, t, i, n) {
  var r = e;
  do
    r.z === null && (r.z = Bd(r.x, r.y, t, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== e);
  r.prevZ.nextZ = null, r.prevZ = null, uE(r);
}
function uE(e) {
  var t, i, n, r, a, s, o, u, l = 1;
  do {
    for (i = e, e = null, a = null, s = 0; i; ) {
      for (s++, n = i, o = 0, t = 0; t < l && (o++, n = n.nextZ, !!n); t++)
        ;
      for (u = l; o > 0 || u > 0 && n; )
        o !== 0 && (u === 0 || !n || i.z <= n.z) ? (r = i, i = i.nextZ, o--) : (r = n, n = n.nextZ, u--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r;
      i = n;
    }
    a.nextZ = null, l *= 2;
  } while (s > 1);
  return e;
}
function Bd(e, t, i, n, r) {
  return e = 32767 * (e - i) * r, t = 32767 * (t - n) * r, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1;
}
function lE(e) {
  var t = e, i = e;
  do
    t.x < i.x && (i = t), t = t.next;
  while (t !== e);
  return i;
}
function mc(e, t, i, n, r, a, s, o) {
  return (r - s) * (t - o) - (e - s) * (a - o) >= 0 && (e - s) * (n - o) - (i - s) * (t - o) >= 0 && (i - s) * (a - o) - (r - s) * (n - o) >= 0;
}
function cE(e, t) {
  return e.next.i !== t.i && e.prev.i !== t.i && !hE(e, t) && zu(e, t) && zu(t, e) && dE(e, t);
}
function $i(e, t, i) {
  return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
}
function Ia(e, t) {
  return e.x === t.x && e.y === t.y;
}
function ty(e, t, i, n) {
  return Ia(e, t) && Ia(i, n) || Ia(e, n) && Ia(i, t) ? !0 : $i(e, t, i) > 0 != $i(e, t, n) > 0 && $i(i, n, e) > 0 != $i(i, n, t) > 0;
}
function hE(e, t) {
  var i = e;
  do {
    if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && ty(i, i.next, e, t))
      return !0;
    i = i.next;
  } while (i !== e);
  return !1;
}
function zu(e, t) {
  return $i(e.prev, e, e.next) < 0 ? $i(e, t, e.next) >= 0 && $i(e, e.prev, t) >= 0 : $i(e, t, e.prev) < 0 || $i(e, e.next, t) < 0;
}
function dE(e, t) {
  var i = e, n = !1, r = (e.x + t.x) / 2, a = (e.y + t.y) / 2;
  do
    i.y > a != i.next.y > a && i.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next;
  while (i !== e);
  return n;
}
function iy(e, t) {
  var i = new Fd(e.i, e.x, e.y), n = new Fd(t.i, t.x, t.y), r = e.next, a = t.prev;
  return e.next = t, t.prev = e, i.next = r, r.prev = i, n.next = i, i.prev = n, a.next = n, n.prev = a, n;
}
function Wv(e, t, i, n) {
  var r = new Fd(e, t, i);
  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
}
function Wu(e) {
  e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
}
function Fd(e, t, i) {
  this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function fE(e, t, i, n) {
  for (var r = 0, a = t, s = i - n; a < i; a += n)
    r += (e[s] - e[a]) * (e[a + 1] + e[s + 1]), s = a;
  return r;
}
var Fn = {
  // calculate area of the contour polygon
  area: function(e) {
    for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++)
      i += e[n].x * e[r].y - e[r].x * e[n].y;
    return i * 0.5;
  },
  isClockWise: function(e) {
    return Fn.area(e) < 0;
  },
  triangulateShape: function(e, t) {
    var i = [], n = [], r = [];
    qv(e), Xv(i, e);
    var a = e.length;
    t.forEach(qv);
    for (var s = 0; s < t.length; s++)
      n.push(a), a += t[s].length, Xv(i, t[s]);
    for (var o = J2.triangulate(i, n), s = 0; s < o.length; s += 3)
      r.push(o.slice(s, s + 3));
    return r;
  }
};
function qv(e) {
  var t = e.length;
  t > 2 && e[t - 1].equals(e[0]) && e.pop();
}
function Xv(e, t) {
  for (var i = 0; i < t.length; i++)
    e.push(t[i].x), e.push(t[i].y);
}
function Ja(e, t) {
  tt.call(this), this.type = "ExtrudeGeometry", this.parameters = {
    shapes: e,
    options: t
  }, this.fromBufferGeometry(new _n(e, t)), this.mergeVertices();
}
Ja.prototype = Object.create(tt.prototype);
Ja.prototype.constructor = Ja;
Ja.prototype.toJSON = function() {
  var e = tt.prototype.toJSON.call(this), t = this.parameters.shapes, i = this.parameters.options;
  return ry(t, i, e);
};
function _n(e, t) {
  je.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
    shapes: e,
    options: t
  }, e = Array.isArray(e) ? e : [e];
  for (var i = this, n = [], r = [], a = 0, s = e.length; a < s; a++) {
    var o = e[a];
    u(o);
  }
  this.addAttribute("position", new ke(n, 3)), this.addAttribute("uv", new ke(r, 2)), this.computeVertexNormals();
  function u(l) {
    var c = [], h = t.curveSegments !== void 0 ? t.curveSegments : 12, d = t.steps !== void 0 ? t.steps : 1, f = t.depth !== void 0 ? t.depth : 100, p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, _ = t.bevelThickness !== void 0 ? t.bevelThickness : 6, m = t.bevelSize !== void 0 ? t.bevelSize : _ - 2, x = t.bevelSegments !== void 0 ? t.bevelSegments : 3, E = t.extrudePath, M = t.UVGenerator !== void 0 ? t.UVGenerator : pE;
    t.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), f = t.amount);
    var C, R = !1, k, F, B, I;
    E && (C = E.getSpacedPoints(d), R = !0, p = !1, k = E.computeFrenetFrames(d, !1), F = new H(), B = new H(), I = new H()), p || (x = 0, _ = 0, m = 0);
    var V, Q, ee, oe = l.extractPoints(h), fe = oe.shape, he = oe.holes, de = !Fn.isClockWise(fe);
    if (de)
      for (fe = fe.reverse(), Q = 0, ee = he.length; Q < ee; Q++)
        V = he[Q], Fn.isClockWise(V) && (he[Q] = V.reverse());
    var G = Fn.triangulateShape(fe, he), j = fe;
    for (Q = 0, ee = he.length; Q < ee; Q++)
      V = he[Q], fe = fe.concat(V);
    function se(Pe, Ie, Je) {
      return Ie || console.error("THREE.ExtrudeGeometry: vec does not exist"), Ie.clone().multiplyScalar(Je).add(Pe);
    }
    var ie, Ce, K, xe, pe, Re = fe.length, _e, Le = G.length;
    function Ve(Pe, Ie, Je) {
      var Be, st, Ne, vt = Pe.x - Ie.x, Rt = Pe.y - Ie.y, ht = Je.x - Pe.x, Ct = Je.y - Pe.y, Lt = vt * vt + Rt * Rt, wt = vt * Ct - Rt * ht;
      if (Math.abs(wt) > Number.EPSILON) {
        var _t = Math.sqrt(Lt), Br = Math.sqrt(ht * ht + Ct * Ct), nr = Ie.x - Rt / _t, ta = Ie.y + vt / _t, xi = Je.x - Ct / Br, Xt = Je.y + ht / Br, nn = ((xi - nr) * Ct - (Xt - ta) * ht) / (vt * Ct - Rt * ht);
        Be = nr + vt * nn - Pe.x, st = ta + Rt * nn - Pe.y;
        var ia = Be * Be + st * st;
        if (ia <= 2)
          return new ue(Be, st);
        Ne = Math.sqrt(ia / 2);
      } else {
        var Fr = !1;
        vt > Number.EPSILON ? ht > Number.EPSILON && (Fr = !0) : vt < -Number.EPSILON ? ht < -Number.EPSILON && (Fr = !0) : Math.sign(Rt) === Math.sign(Ct) && (Fr = !0), Fr ? (Be = -Rt, st = vt, Ne = Math.sqrt(Lt)) : (Be = vt, st = Rt, Ne = Math.sqrt(Lt / 2));
      }
      return new ue(Be / Ne, st / Ne);
    }
    for (var ft = [], Ee = 0, ct = j.length, kt = ct - 1, Mt = Ee + 1; Ee < ct; Ee++, kt++, Mt++)
      kt === ct && (kt = 0), Mt === ct && (Mt = 0), ft[Ee] = Ve(j[Ee], j[kt], j[Mt]);
    var Vt = [], yt, jt = ft.concat();
    for (Q = 0, ee = he.length; Q < ee; Q++) {
      for (V = he[Q], yt = [], Ee = 0, ct = V.length, kt = ct - 1, Mt = Ee + 1; Ee < ct; Ee++, kt++, Mt++)
        kt === ct && (kt = 0), Mt === ct && (Mt = 0), yt[Ee] = Ve(V[Ee], V[kt], V[Mt]);
      Vt.push(yt), jt = jt.concat(yt);
    }
    for (ie = 0; ie < x; ie++) {
      for (K = ie / x, xe = _ * Math.cos(K * Math.PI / 2), Ce = m * Math.sin(K * Math.PI / 2), Ee = 0, ct = j.length; Ee < ct; Ee++)
        pe = se(j[Ee], ft[Ee], Ce), Gt(pe.x, pe.y, -xe);
      for (Q = 0, ee = he.length; Q < ee; Q++)
        for (V = he[Q], yt = Vt[Q], Ee = 0, ct = V.length; Ee < ct; Ee++)
          pe = se(V[Ee], yt[Ee], Ce), Gt(pe.x, pe.y, -xe);
    }
    for (Ce = m, Ee = 0; Ee < Re; Ee++)
      pe = p ? se(fe[Ee], jt[Ee], Ce) : fe[Ee], R ? (B.copy(k.normals[0]).multiplyScalar(pe.x), F.copy(k.binormals[0]).multiplyScalar(pe.y), I.copy(C[0]).add(B).add(F), Gt(I.x, I.y, I.z)) : Gt(pe.x, pe.y, 0);
    var Et;
    for (Et = 1; Et <= d; Et++)
      for (Ee = 0; Ee < Re; Ee++)
        pe = p ? se(fe[Ee], jt[Ee], Ce) : fe[Ee], R ? (B.copy(k.normals[Et]).multiplyScalar(pe.x), F.copy(k.binormals[Et]).multiplyScalar(pe.y), I.copy(C[Et]).add(B).add(F), Gt(I.x, I.y, I.z)) : Gt(pe.x, pe.y, f / d * Et);
    for (ie = x - 1; ie >= 0; ie--) {
      for (K = ie / x, xe = _ * Math.cos(K * Math.PI / 2), Ce = m * Math.sin(K * Math.PI / 2), Ee = 0, ct = j.length; Ee < ct; Ee++)
        pe = se(j[Ee], ft[Ee], Ce), Gt(pe.x, pe.y, f + xe);
      for (Q = 0, ee = he.length; Q < ee; Q++)
        for (V = he[Q], yt = Vt[Q], Ee = 0, ct = V.length; Ee < ct; Ee++)
          pe = se(V[Ee], yt[Ee], Ce), R ? Gt(pe.x, pe.y + C[d - 1].y, C[d - 1].x + xe) : Gt(pe.x, pe.y, f + xe);
    }
    gr(), xt();
    function gr() {
      var Pe = n.length / 3;
      if (p) {
        var Ie = 0, Je = Re * Ie;
        for (Ee = 0; Ee < Le; Ee++)
          _e = G[Ee], yr(_e[2] + Je, _e[1] + Je, _e[0] + Je);
        for (Ie = d + x * 2, Je = Re * Ie, Ee = 0; Ee < Le; Ee++)
          _e = G[Ee], yr(_e[0] + Je, _e[1] + Je, _e[2] + Je);
      } else {
        for (Ee = 0; Ee < Le; Ee++)
          _e = G[Ee], yr(_e[2], _e[1], _e[0]);
        for (Ee = 0; Ee < Le; Ee++)
          _e = G[Ee], yr(_e[0] + Re * d, _e[1] + Re * d, _e[2] + Re * d);
      }
      i.addGroup(Pe, n.length / 3 - Pe, 0);
    }
    function xt() {
      var Pe = n.length / 3, Ie = 0;
      for (ci(j, Ie), Ie += j.length, Q = 0, ee = he.length; Q < ee; Q++)
        V = he[Q], ci(V, Ie), Ie += V.length;
      i.addGroup(Pe, n.length / 3 - Pe, 1);
    }
    function ci(Pe, Ie) {
      var Je, Be;
      for (Ee = Pe.length; --Ee >= 0; ) {
        Je = Ee, Be = Ee - 1, Be < 0 && (Be = Pe.length - 1);
        var st = 0, Ne = d + x * 2;
        for (st = 0; st < Ne; st++) {
          var vt = Re * st, Rt = Re * (st + 1), ht = Ie + Je + vt, Ct = Ie + Be + vt, Lt = Ie + Be + Rt, wt = Ie + Je + Rt;
          gi(ht, Ct, Lt, wt);
        }
      }
    }
    function Gt(Pe, Ie, Je) {
      c.push(Pe), c.push(Ie), c.push(Je);
    }
    function yr(Pe, Ie, Je) {
      ai(Pe), ai(Ie), ai(Je);
      var Be = n.length / 3, st = M.generateTopUV(i, n, Be - 3, Be - 2, Be - 1);
      ae(st[0]), ae(st[1]), ae(st[2]);
    }
    function gi(Pe, Ie, Je, Be) {
      ai(Pe), ai(Ie), ai(Be), ai(Ie), ai(Je), ai(Be);
      var st = n.length / 3, Ne = M.generateSideWallUV(i, n, st - 6, st - 3, st - 2, st - 1);
      ae(Ne[0]), ae(Ne[1]), ae(Ne[3]), ae(Ne[1]), ae(Ne[2]), ae(Ne[3]);
    }
    function ai(Pe) {
      n.push(c[Pe * 3 + 0]), n.push(c[Pe * 3 + 1]), n.push(c[Pe * 3 + 2]);
    }
    function ae(Pe) {
      r.push(Pe.x), r.push(Pe.y);
    }
  }
}
_n.prototype = Object.create(je.prototype);
_n.prototype.constructor = _n;
_n.prototype.toJSON = function() {
  var e = je.prototype.toJSON.call(this), t = this.parameters.shapes, i = this.parameters.options;
  return ry(t, i, e);
};
var pE = {
  generateTopUV: function(e, t, i, n, r) {
    var a = t[i * 3], s = t[i * 3 + 1], o = t[n * 3], u = t[n * 3 + 1], l = t[r * 3], c = t[r * 3 + 1];
    return [
      new ue(a, s),
      new ue(o, u),
      new ue(l, c)
    ];
  },
  generateSideWallUV: function(e, t, i, n, r, a) {
    var s = t[i * 3], o = t[i * 3 + 1], u = t[i * 3 + 2], l = t[n * 3], c = t[n * 3 + 1], h = t[n * 3 + 2], d = t[r * 3], f = t[r * 3 + 1], p = t[r * 3 + 2], _ = t[a * 3], m = t[a * 3 + 1], x = t[a * 3 + 2];
    return Math.abs(o - c) < 0.01 ? [
      new ue(s, 1 - u),
      new ue(l, 1 - h),
      new ue(d, 1 - p),
      new ue(_, 1 - x)
    ] : [
      new ue(o, 1 - u),
      new ue(c, 1 - h),
      new ue(f, 1 - p),
      new ue(m, 1 - x)
    ];
  }
};
function ry(e, t, i) {
  if (i.shapes = [], Array.isArray(e))
    for (var n = 0, r = e.length; n < r; n++) {
      var a = e[n];
      i.shapes.push(a.uuid);
    }
  else
    i.shapes.push(e.uuid);
  return t.extrudePath !== void 0 && (i.options.extrudePath = t.extrudePath.toJSON()), i;
}
function qu(e, t) {
  tt.call(this), this.type = "TextGeometry", this.parameters = {
    text: e,
    parameters: t
  }, this.fromBufferGeometry(new ro(e, t)), this.mergeVertices();
}
qu.prototype = Object.create(tt.prototype);
qu.prototype.constructor = qu;
function ro(e, t) {
  t = t || {};
  var i = t.font;
  if (!(i && i.isFont))
    return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new tt();
  var n = i.generateShapes(e, t.size, t.curveSegments);
  t.depth = t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), _n.call(this, n, t), this.type = "TextBufferGeometry";
}
ro.prototype = Object.create(_n.prototype);
ro.prototype.constructor = ro;
function On(e, t, i, n, r, a, s) {
  tt.call(this), this.type = "SphereGeometry", this.parameters = {
    radius: e,
    widthSegments: t,
    heightSegments: i,
    phiStart: n,
    phiLength: r,
    thetaStart: a,
    thetaLength: s
  }, this.fromBufferGeometry(new pa(e, t, i, n, r, a, s)), this.mergeVertices();
}
On.prototype = Object.create(tt.prototype);
On.prototype.constructor = On;
function pa(e, t, i, n, r, a, s) {
  je.call(this), this.type = "SphereBufferGeometry", this.parameters = {
    radius: e,
    widthSegments: t,
    heightSegments: i,
    phiStart: n,
    phiLength: r,
    thetaStart: a,
    thetaLength: s
  }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = n !== void 0 ? n : 0, r = r !== void 0 ? r : Math.PI * 2, a = a !== void 0 ? a : 0, s = s !== void 0 ? s : Math.PI;
  var o = a + s, u, l, c = 0, h = [], d = new H(), f = new H(), p = [], _ = [], m = [], x = [];
  for (l = 0; l <= i; l++) {
    var E = [], M = l / i;
    for (u = 0; u <= t; u++) {
      var C = u / t;
      d.x = -e * Math.cos(n + C * r) * Math.sin(a + M * s), d.y = e * Math.cos(a + M * s), d.z = e * Math.sin(n + C * r) * Math.sin(a + M * s), _.push(d.x, d.y, d.z), f.set(d.x, d.y, d.z).normalize(), m.push(f.x, f.y, f.z), x.push(C, 1 - M), E.push(c++);
    }
    h.push(E);
  }
  for (l = 0; l < i; l++)
    for (u = 0; u < t; u++) {
      var R = h[l][u + 1], k = h[l][u], F = h[l + 1][u], B = h[l + 1][u + 1];
      (l !== 0 || a > 0) && p.push(R, k, B), (l !== i - 1 || o < Math.PI) && p.push(k, F, B);
    }
  this.setIndex(p), this.addAttribute("position", new ke(_, 3)), this.addAttribute("normal", new ke(m, 3)), this.addAttribute("uv", new ke(x, 2));
}
pa.prototype = Object.create(je.prototype);
pa.prototype.constructor = pa;
function Xu(e, t, i, n, r, a) {
  tt.call(this), this.type = "RingGeometry", this.parameters = {
    innerRadius: e,
    outerRadius: t,
    thetaSegments: i,
    phiSegments: n,
    thetaStart: r,
    thetaLength: a
  }, this.fromBufferGeometry(new no(e, t, i, n, r, a)), this.mergeVertices();
}
Xu.prototype = Object.create(tt.prototype);
Xu.prototype.constructor = Xu;
function no(e, t, i, n, r, a) {
  je.call(this), this.type = "RingBufferGeometry", this.parameters = {
    innerRadius: e,
    outerRadius: t,
    thetaSegments: i,
    phiSegments: n,
    thetaStart: r,
    thetaLength: a
  }, e = e || 0.5, t = t || 1, r = r !== void 0 ? r : 0, a = a !== void 0 ? a : Math.PI * 2, i = i !== void 0 ? Math.max(3, i) : 8, n = n !== void 0 ? Math.max(1, n) : 1;
  var s = [], o = [], u = [], l = [], c, h = e, d = (t - e) / n, f = new H(), p = new ue(), _, m;
  for (_ = 0; _ <= n; _++) {
    for (m = 0; m <= i; m++)
      c = r + m / i * a, f.x = h * Math.cos(c), f.y = h * Math.sin(c), o.push(f.x, f.y, f.z), u.push(0, 0, 1), p.x = (f.x / t + 1) / 2, p.y = (f.y / t + 1) / 2, l.push(p.x, p.y);
    h += d;
  }
  for (_ = 0; _ < n; _++) {
    var x = _ * (i + 1);
    for (m = 0; m < i; m++) {
      c = m + x;
      var E = c, M = c + i + 1, C = c + i + 2, R = c + 1;
      s.push(E, M, R), s.push(M, C, R);
    }
  }
  this.setIndex(s), this.addAttribute("position", new ke(o, 3)), this.addAttribute("normal", new ke(u, 3)), this.addAttribute("uv", new ke(l, 2));
}
no.prototype = Object.create(je.prototype);
no.prototype.constructor = no;
function Yu(e, t, i, n) {
  tt.call(this), this.type = "LatheGeometry", this.parameters = {
    points: e,
    segments: t,
    phiStart: i,
    phiLength: n
  }, this.fromBufferGeometry(new ao(e, t, i, n)), this.mergeVertices();
}
Yu.prototype = Object.create(tt.prototype);
Yu.prototype.constructor = Yu;
function ao(e, t, i, n) {
  je.call(this), this.type = "LatheBufferGeometry", this.parameters = {
    points: e,
    segments: t,
    phiStart: i,
    phiLength: n
  }, t = Math.floor(t) || 12, i = i || 0, n = n || Math.PI * 2, n = gt.clamp(n, 0, Math.PI * 2);
  var r = [], a = [], s = [], o, u = 1 / t, l = new H(), c = new ue(), h, d;
  for (h = 0; h <= t; h++) {
    var f = i + h * u * n, p = Math.sin(f), _ = Math.cos(f);
    for (d = 0; d <= e.length - 1; d++)
      l.x = e[d].x * p, l.y = e[d].y, l.z = e[d].x * _, a.push(l.x, l.y, l.z), c.x = h / t, c.y = d / (e.length - 1), s.push(c.x, c.y);
  }
  for (h = 0; h < t; h++)
    for (d = 0; d < e.length - 1; d++) {
      o = d + h * e.length;
      var m = o, x = o + e.length, E = o + e.length + 1, M = o + 1;
      r.push(m, x, M), r.push(x, E, M);
    }
  if (this.setIndex(r), this.addAttribute("position", new ke(a, 3)), this.addAttribute("uv", new ke(s, 2)), this.computeVertexNormals(), n === Math.PI * 2) {
    var C = this.attributes.normal.array, R = new H(), k = new H(), F = new H();
    for (o = t * e.length * 3, h = 0, d = 0; h < e.length; h++, d += 3)
      R.x = C[d + 0], R.y = C[d + 1], R.z = C[d + 2], k.x = C[o + d + 0], k.y = C[o + d + 1], k.z = C[o + d + 2], F.addVectors(R, k).normalize(), C[d + 0] = C[o + d + 0] = F.x, C[d + 1] = C[o + d + 1] = F.y, C[d + 2] = C[o + d + 2] = F.z;
  }
}
ao.prototype = Object.create(je.prototype);
ao.prototype.constructor = ao;
function $a(e, t) {
  tt.call(this), this.type = "ShapeGeometry", typeof t == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
    shapes: e,
    curveSegments: t
  }, this.fromBufferGeometry(new es(e, t)), this.mergeVertices();
}
$a.prototype = Object.create(tt.prototype);
$a.prototype.constructor = $a;
$a.prototype.toJSON = function() {
  var e = tt.prototype.toJSON.call(this), t = this.parameters.shapes;
  return ny(t, e);
};
function es(e, t) {
  je.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
    shapes: e,
    curveSegments: t
  }, t = t || 12;
  var i = [], n = [], r = [], a = [], s = 0, o = 0;
  if (Array.isArray(e) === !1)
    l(e);
  else
    for (var u = 0; u < e.length; u++)
      l(e[u]), this.addGroup(s, o, u), s += o, o = 0;
  this.setIndex(i), this.addAttribute("position", new ke(n, 3)), this.addAttribute("normal", new ke(r, 3)), this.addAttribute("uv", new ke(a, 2));
  function l(c) {
    var h, d, f, p = n.length / 3, _ = c.extractPoints(t), m = _.shape, x = _.holes;
    if (Fn.isClockWise(m) === !1)
      for (m = m.reverse(), h = 0, d = x.length; h < d; h++)
        f = x[h], Fn.isClockWise(f) === !0 && (x[h] = f.reverse());
    var E = Fn.triangulateShape(m, x);
    for (h = 0, d = x.length; h < d; h++)
      f = x[h], m = m.concat(f);
    for (h = 0, d = m.length; h < d; h++) {
      var M = m[h];
      n.push(M.x, M.y, 0), r.push(0, 0, 1), a.push(M.x, M.y);
    }
    for (h = 0, d = E.length; h < d; h++) {
      var C = E[h], R = C[0] + p, k = C[1] + p, F = C[2] + p;
      i.push(R, k, F), o += 3;
    }
  }
}
es.prototype = Object.create(je.prototype);
es.prototype.constructor = es;
es.prototype.toJSON = function() {
  var e = je.prototype.toJSON.call(this), t = this.parameters.shapes;
  return ny(t, e);
};
function ny(e, t) {
  if (t.shapes = [], Array.isArray(e))
    for (var i = 0, n = e.length; i < n; i++) {
      var r = e[i];
      t.shapes.push(r.uuid);
    }
  else
    t.shapes.push(e.uuid);
  return t;
}
function so(e, t) {
  je.call(this), this.type = "EdgesGeometry", this.parameters = {
    thresholdAngle: t
  }, t = t !== void 0 ? t : 1;
  var i = [], n = Math.cos(gt.DEG2RAD * t), r = [0, 0], a = {}, s, o, u, l = ["a", "b", "c"], c;
  e.isBufferGeometry ? (c = new tt(), c.fromBufferGeometry(e)) : c = e.clone(), c.mergeVertices(), c.computeFaceNormals();
  for (var h = c.vertices, d = c.faces, f = 0, p = d.length; f < p; f++)
    for (var _ = d[f], m = 0; m < 3; m++)
      s = _[l[m]], o = _[l[(m + 1) % 3]], r[0] = Math.min(s, o), r[1] = Math.max(s, o), u = r[0] + "," + r[1], a[u] === void 0 ? a[u] = { index1: r[0], index2: r[1], face1: f, face2: void 0 } : a[u].face2 = f;
  for (u in a) {
    var x = a[u];
    if (x.face2 === void 0 || d[x.face1].normal.dot(d[x.face2].normal) <= n) {
      var E = h[x.index1];
      i.push(E.x, E.y, E.z), E = h[x.index2], i.push(E.x, E.y, E.z);
    }
  }
  this.addAttribute("position", new ke(i, 3));
}
so.prototype = Object.create(je.prototype);
so.prototype.constructor = so;
function ts(e, t, i, n, r, a, s, o) {
  tt.call(this), this.type = "CylinderGeometry", this.parameters = {
    radiusTop: e,
    radiusBottom: t,
    height: i,
    radialSegments: n,
    heightSegments: r,
    openEnded: a,
    thetaStart: s,
    thetaLength: o
  }, this.fromBufferGeometry(new Vn(e, t, i, n, r, a, s, o)), this.mergeVertices();
}
ts.prototype = Object.create(tt.prototype);
ts.prototype.constructor = ts;
function Vn(e, t, i, n, r, a, s, o) {
  je.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
    radiusTop: e,
    radiusBottom: t,
    height: i,
    radialSegments: n,
    heightSegments: r,
    openEnded: a,
    thetaStart: s,
    thetaLength: o
  };
  var u = this;
  e = e !== void 0 ? e : 1, t = t !== void 0 ? t : 1, i = i || 1, n = Math.floor(n) || 8, r = Math.floor(r) || 1, a = a !== void 0 ? a : !1, s = s !== void 0 ? s : 0, o = o !== void 0 ? o : Math.PI * 2;
  var l = [], c = [], h = [], d = [], f = 0, p = [], _ = i / 2, m = 0;
  x(), a === !1 && (e > 0 && E(!0), t > 0 && E(!1)), this.setIndex(l), this.addAttribute("position", new ke(c, 3)), this.addAttribute("normal", new ke(h, 3)), this.addAttribute("uv", new ke(d, 2));
  function x() {
    var M, C, R = new H(), k = new H(), F = 0, B = (t - e) / i;
    for (C = 0; C <= r; C++) {
      var I = [], V = C / r, Q = V * (t - e) + e;
      for (M = 0; M <= n; M++) {
        var ee = M / n, oe = ee * o + s, fe = Math.sin(oe), he = Math.cos(oe);
        k.x = Q * fe, k.y = -V * i + _, k.z = Q * he, c.push(k.x, k.y, k.z), R.set(fe, B, he).normalize(), h.push(R.x, R.y, R.z), d.push(ee, 1 - V), I.push(f++);
      }
      p.push(I);
    }
    for (M = 0; M < n; M++)
      for (C = 0; C < r; C++) {
        var de = p[C][M], G = p[C + 1][M], j = p[C + 1][M + 1], se = p[C][M + 1];
        l.push(de, G, se), l.push(G, j, se), F += 6;
      }
    u.addGroup(m, F, 0), m += F;
  }
  function E(M) {
    var C, R, k, F = new ue(), B = new H(), I = 0, V = M === !0 ? e : t, Q = M === !0 ? 1 : -1;
    for (R = f, C = 1; C <= n; C++)
      c.push(0, _ * Q, 0), h.push(0, Q, 0), d.push(0.5, 0.5), f++;
    for (k = f, C = 0; C <= n; C++) {
      var ee = C / n, oe = ee * o + s, fe = Math.cos(oe), he = Math.sin(oe);
      B.x = V * he, B.y = _ * Q, B.z = V * fe, c.push(B.x, B.y, B.z), h.push(0, Q, 0), F.x = fe * 0.5 + 0.5, F.y = he * 0.5 * Q + 0.5, d.push(F.x, F.y), f++;
    }
    for (C = 0; C < n; C++) {
      var de = R + C, G = k + C;
      M === !0 ? l.push(G, G + 1, de) : l.push(G + 1, G, de), I += 3;
    }
    u.addGroup(m, I, M === !0 ? 1 : 2), m += I;
  }
}
Vn.prototype = Object.create(je.prototype);
Vn.prototype.constructor = Vn;
function Qu(e, t, i, n, r, a, s) {
  ts.call(this, 0, e, t, i, n, r, a, s), this.type = "ConeGeometry", this.parameters = {
    radius: e,
    height: t,
    radialSegments: i,
    heightSegments: n,
    openEnded: r,
    thetaStart: a,
    thetaLength: s
  };
}
Qu.prototype = Object.create(ts.prototype);
Qu.prototype.constructor = Qu;
function Ku(e, t, i, n, r, a, s) {
  Vn.call(this, 0, e, t, i, n, r, a, s), this.type = "ConeBufferGeometry", this.parameters = {
    radius: e,
    height: t,
    radialSegments: i,
    heightSegments: n,
    openEnded: r,
    thetaStart: a,
    thetaLength: s
  };
}
Ku.prototype = Object.create(Vn.prototype);
Ku.prototype.constructor = Ku;
function Zu(e, t, i, n) {
  tt.call(this), this.type = "CircleGeometry", this.parameters = {
    radius: e,
    segments: t,
    thetaStart: i,
    thetaLength: n
  }, this.fromBufferGeometry(new oo(e, t, i, n)), this.mergeVertices();
}
Zu.prototype = Object.create(tt.prototype);
Zu.prototype.constructor = Zu;
function oo(e, t, i, n) {
  je.call(this), this.type = "CircleBufferGeometry", this.parameters = {
    radius: e,
    segments: t,
    thetaStart: i,
    thetaLength: n
  }, e = e || 1, t = t !== void 0 ? Math.max(3, t) : 8, i = i !== void 0 ? i : 0, n = n !== void 0 ? n : Math.PI * 2;
  var r = [], a = [], s = [], o = [], u, l, c = new H(), h = new ue();
  for (a.push(0, 0, 0), s.push(0, 0, 1), o.push(0.5, 0.5), l = 0, u = 3; l <= t; l++, u += 3) {
    var d = i + l / t * n;
    c.x = e * Math.cos(d), c.y = e * Math.sin(d), a.push(c.x, c.y, c.z), s.push(0, 0, 1), h.x = (a[u] / e + 1) / 2, h.y = (a[u + 1] / e + 1) / 2, o.push(h.x, h.y);
  }
  for (u = 1; u <= t; u++)
    r.push(u, u + 1, 0);
  this.setIndex(r), this.addAttribute("position", new ke(a, 3)), this.addAttribute("normal", new ke(s, 3)), this.addAttribute("uv", new ke(o, 2));
}
oo.prototype = Object.create(je.prototype);
oo.prototype.constructor = oo;
var ar = /* @__PURE__ */ Object.freeze({
  WireframeGeometry: Qs,
  ParametricGeometry: Iu,
  ParametricBufferGeometry: Ks,
  TetrahedronGeometry: ku,
  TetrahedronBufferGeometry: Zs,
  OctahedronGeometry: Bu,
  OctahedronBufferGeometry: Za,
  IcosahedronGeometry: Fu,
  IcosahedronBufferGeometry: Js,
  DodecahedronGeometry: Nu,
  DodecahedronBufferGeometry: $s,
  PolyhedronGeometry: Ou,
  PolyhedronBufferGeometry: dr,
  TubeGeometry: Uu,
  TubeBufferGeometry: eo,
  TorusKnotGeometry: ju,
  TorusKnotBufferGeometry: to,
  TorusGeometry: Gu,
  TorusBufferGeometry: io,
  TextGeometry: qu,
  TextBufferGeometry: ro,
  SphereGeometry: On,
  SphereBufferGeometry: pa,
  RingGeometry: Xu,
  RingBufferGeometry: no,
  PlaneGeometry: Su,
  PlaneBufferGeometry: Ka,
  LatheGeometry: Yu,
  LatheBufferGeometry: ao,
  ShapeGeometry: $a,
  ShapeBufferGeometry: es,
  ExtrudeGeometry: Ja,
  ExtrudeBufferGeometry: _n,
  EdgesGeometry: so,
  ConeGeometry: Qu,
  ConeBufferGeometry: Ku,
  CylinderGeometry: ts,
  CylinderBufferGeometry: Vn,
  CircleGeometry: Zu,
  CircleBufferGeometry: oo,
  BoxGeometry: la,
  BoxBufferGeometry: Qa
});
function is(e) {
  dt.call(this), this.type = "ShadowMaterial", this.color = new We(0), this.transparent = !0, this.setValues(e);
}
is.prototype = Object.create(dt.prototype);
is.prototype.constructor = is;
is.prototype.isShadowMaterial = !0;
is.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.color.copy(e.color), this;
};
function uo(e) {
  Mr.call(this, e), this.type = "RawShaderMaterial";
}
uo.prototype = Object.create(Mr.prototype);
uo.prototype.constructor = uo;
uo.prototype.isRawShaderMaterial = !0;
function bn(e) {
  dt.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new We(16777215), this.roughness = 0.5, this.metalness = 0.5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
bn.prototype = Object.create(dt.prototype);
bn.prototype.constructor = bn;
bn.prototype.isMeshStandardMaterial = !0;
bn.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function rs(e) {
  bn.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = 0.5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e);
}
rs.prototype = Object.create(bn.prototype);
rs.prototype.constructor = rs;
rs.prototype.isMeshPhysicalMaterial = !0;
rs.prototype.copy = function(e) {
  return bn.prototype.copy.call(this, e), this.defines = { PHYSICAL: "" }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this;
};
function Yr(e) {
  dt.call(this), this.type = "MeshPhongMaterial", this.color = new We(16777215), this.specular = new We(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = xl, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
Yr.prototype = Object.create(dt.prototype);
Yr.prototype.constructor = Yr;
Yr.prototype.isMeshPhongMaterial = !0;
Yr.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function ns(e) {
  Yr.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e);
}
ns.prototype = Object.create(Yr.prototype);
ns.prototype.constructor = ns;
ns.prototype.isMeshToonMaterial = !0;
ns.prototype.copy = function(e) {
  return Yr.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this;
};
function as(e) {
  dt.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
as.prototype = Object.create(dt.prototype);
as.prototype.constructor = as;
as.prototype.isMeshNormalMaterial = !0;
as.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function ss(e) {
  dt.call(this), this.type = "MeshLambertMaterial", this.color = new We(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new We(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = xl, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
ss.prototype = Object.create(dt.prototype);
ss.prototype.constructor = ss;
ss.prototype.isMeshLambertMaterial = !0;
ss.prototype.copy = function(e) {
  return dt.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function os(e) {
  qt.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
}
os.prototype = Object.create(qt.prototype);
os.prototype.constructor = os;
os.prototype.isLineDashedMaterial = !0;
os.prototype.copy = function(e) {
  return qt.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
};
var vE = /* @__PURE__ */ Object.freeze({
  ShadowMaterial: is,
  SpriteMaterial: fa,
  RawShaderMaterial: uo,
  ShaderMaterial: Mr,
  PointsMaterial: Xr,
  MeshPhysicalMaterial: rs,
  MeshStandardMaterial: bn,
  MeshPhongMaterial: Yr,
  MeshToonMaterial: ns,
  MeshNormalMaterial: as,
  MeshLambertMaterial: ss,
  MeshDepthMaterial: ha,
  MeshDistanceMaterial: da,
  MeshBasicMaterial: Ei,
  LineDashedMaterial: os,
  LineBasicMaterial: qt,
  Material: dt
}), us = {
  enabled: !1,
  files: {},
  add: function(e, t) {
    this.enabled !== !1 && (this.files[e] = t);
  },
  get: function(e) {
    if (this.enabled !== !1)
      return this.files[e];
  },
  remove: function(e) {
    delete this.files[e];
  },
  clear: function() {
    this.files = {};
  }
};
function Vf(e, t, i) {
  var n = this, r = !1, a = 0, s = 0, o = void 0;
  this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(u) {
    s++, r === !1 && n.onStart !== void 0 && n.onStart(u, a, s), r = !0;
  }, this.itemEnd = function(u) {
    a++, n.onProgress !== void 0 && n.onProgress(u, a, s), a === s && (r = !1, n.onLoad !== void 0 && n.onLoad());
  }, this.itemError = function(u) {
    n.onError !== void 0 && n.onError(u);
  }, this.resolveURL = function(u) {
    return o ? o(u) : u;
  }, this.setURLModifier = function(u) {
    return o = u, this;
  };
}
var pr = new Vf(), Mn = {};
function en(e) {
  this.manager = e !== void 0 ? e : pr;
}
Object.assign(en.prototype, {
  load: function(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    var r = this, a = us.get(e);
    if (a !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    if (Mn[e] !== void 0) {
      Mn[e].push({
        onLoad: t,
        onProgress: i,
        onError: n
      });
      return;
    }
    var s = /^data:(.*?)(;base64)?,(.*)$/, o = e.match(s);
    if (o) {
      var u = o[1], l = !!o[2], c = o[3];
      c = window.decodeURIComponent(c), l && (c = window.atob(c));
      try {
        var h, d = (this.responseType || "").toLowerCase();
        switch (d) {
          case "arraybuffer":
          case "blob":
            for (var f = new Uint8Array(c.length), p = 0; p < c.length; p++)
              f[p] = c.charCodeAt(p);
            d === "blob" ? h = new Blob([f.buffer], { type: u }) : h = f.buffer;
            break;
          case "document":
            var _ = new DOMParser();
            h = _.parseFromString(c, u);
            break;
          case "json":
            h = JSON.parse(c);
            break;
          default:
            h = c;
            break;
        }
        window.setTimeout(function() {
          t && t(h), r.manager.itemEnd(e);
        }, 0);
      } catch (E) {
        window.setTimeout(function() {
          n && n(E), r.manager.itemEnd(e), r.manager.itemError(e);
        }, 0);
      }
    } else {
      Mn[e] = [], Mn[e].push({
        onLoad: t,
        onProgress: i,
        onError: n
      });
      var m = new XMLHttpRequest();
      m.open("GET", e, !0), m.addEventListener("load", function(E) {
        var M = this.response;
        us.add(e, M);
        var C = Mn[e];
        if (delete Mn[e], this.status === 200 || this.status === 0) {
          this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received.");
          for (var R = 0, k = C.length; R < k; R++) {
            var F = C[R];
            F.onLoad && F.onLoad(M);
          }
          r.manager.itemEnd(e);
        } else {
          for (var R = 0, k = C.length; R < k; R++) {
            var F = C[R];
            F.onError && F.onError(E);
          }
          r.manager.itemEnd(e), r.manager.itemError(e);
        }
      }, !1), m.addEventListener("progress", function(E) {
        for (var M = Mn[e], C = 0, R = M.length; C < R; C++) {
          var k = M[C];
          k.onProgress && k.onProgress(E);
        }
      }, !1), m.addEventListener("error", function(E) {
        var M = Mn[e];
        delete Mn[e];
        for (var C = 0, R = M.length; C < R; C++) {
          var k = M[C];
          k.onError && k.onError(E);
        }
        r.manager.itemEnd(e), r.manager.itemError(e);
      }, !1), this.responseType !== void 0 && (m.responseType = this.responseType), this.withCredentials !== void 0 && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (var x in this.requestHeader)
        m.setRequestHeader(x, this.requestHeader[x]);
      m.send(null);
    }
    return r.manager.itemStart(e), m;
  },
  setPath: function(e) {
    return this.path = e, this;
  },
  setResponseType: function(e) {
    return this.responseType = e, this;
  },
  setWithCredentials: function(e) {
    return this.withCredentials = e, this;
  },
  setMimeType: function(e) {
    return this.mimeType = e, this;
  },
  setRequestHeader: function(e) {
    return this.requestHeader = e, this;
  }
});
function ay(e) {
  this.manager = e !== void 0 ? e : pr, this._parser = null;
}
Object.assign(ay.prototype, {
  load: function(e, t, i, n) {
    var r = this, a = [], s = new Ys();
    s.image = a;
    var o = new en(this.manager);
    o.setPath(this.path), o.setResponseType("arraybuffer");
    function u(d) {
      o.load(e[d], function(f) {
        var p = r._parser(f, !0);
        a[d] = {
          width: p.width,
          height: p.height,
          format: p.format,
          mipmaps: p.mipmaps
        }, l += 1, l === 6 && (p.mipmapCount === 1 && (s.minFilter = Gi), s.format = p.format, s.needsUpdate = !0, t && t(s));
      }, i, n);
    }
    if (Array.isArray(e))
      for (var l = 0, c = 0, h = e.length; c < h; ++c)
        u(c);
    else
      o.load(e, function(d) {
        var f = r._parser(d, !0);
        if (f.isCubemap)
          for (var p = f.mipmaps.length / f.mipmapCount, _ = 0; _ < p; _++) {
            a[_] = { mipmaps: [] };
            for (var m = 0; m < f.mipmapCount; m++)
              a[_].mipmaps.push(f.mipmaps[_ * f.mipmapCount + m]), a[_].format = f.format, a[_].width = f.width, a[_].height = f.height;
          }
        else
          s.image.width = f.width, s.image.height = f.height, s.mipmaps = f.mipmaps;
        f.mipmapCount === 1 && (s.minFilter = Gi), s.format = f.format, s.needsUpdate = !0, t && t(s);
      }, i, n);
    return s;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
function Hf(e) {
  this.manager = e !== void 0 ? e : pr, this._parser = null;
}
Object.assign(Hf.prototype, {
  load: function(e, t, i, n) {
    var r = this, a = new qa(), s = new en(this.manager);
    return s.setResponseType("arraybuffer"), s.load(e, function(o) {
      var u = r._parser(o);
      u && (u.image !== void 0 ? a.image = u.image : u.data !== void 0 && (a.image.width = u.width, a.image.height = u.height, a.image.data = u.data), a.wrapS = u.wrapS !== void 0 ? u.wrapS : Er, a.wrapT = u.wrapT !== void 0 ? u.wrapT : Er, a.magFilter = u.magFilter !== void 0 ? u.magFilter : Gi, a.minFilter = u.minFilter !== void 0 ? u.minFilter : Al, a.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1, u.format !== void 0 && (a.format = u.format), u.type !== void 0 && (a.type = u.type), u.mipmaps !== void 0 && (a.mipmaps = u.mipmaps), u.mipmapCount === 1 && (a.minFilter = Gi), a.needsUpdate = !0, t && t(a, u));
    }, i, n), a;
  }
});
function Tl(e) {
  this.manager = e !== void 0 ? e : pr;
}
Object.assign(Tl.prototype, {
  crossOrigin: "Anonymous",
  load: function(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    var r = this, a = us.get(e);
    if (a !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    var s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function o() {
      s.removeEventListener("load", o, !1), s.removeEventListener("error", u, !1), us.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function u(l) {
      s.removeEventListener("load", o, !1), s.removeEventListener("error", u, !1), n && n(l), r.manager.itemEnd(e), r.manager.itemError(e);
    }
    return s.addEventListener("load", o, !1), s.addEventListener("error", u, !1), e.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s;
  },
  setCrossOrigin: function(e) {
    return this.crossOrigin = e, this;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
function zf(e) {
  this.manager = e !== void 0 ? e : pr;
}
Object.assign(zf.prototype, {
  crossOrigin: "Anonymous",
  load: function(e, t, i, n) {
    var r = new ca(), a = new Tl(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    var s = 0;
    function o(l) {
      a.load(e[l], function(c) {
        r.images[l] = c, s++, s === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, n);
    }
    for (var u = 0; u < e.length; ++u)
      o(u);
    return r;
  },
  setCrossOrigin: function(e) {
    return this.crossOrigin = e, this;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
function gh(e) {
  this.manager = e !== void 0 ? e : pr;
}
Object.assign(gh.prototype, {
  crossOrigin: "Anonymous",
  load: function(e, t, i, n) {
    var r = new ri(), a = new Tl(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(s) {
      r.image = s;
      var o = e.search(/\.(jpg|jpeg)$/) > 0 || e.search(/^data\:image\/jpeg/) === 0;
      r.format = o ? Ha : gn, r.needsUpdate = !0, t !== void 0 && t(r);
    }, i, n), r;
  },
  setCrossOrigin: function(e) {
    return this.crossOrigin = e, this;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
function Ye() {
  this.type = "Curve", this.arcLengthDivisions = 200;
}
Object.assign(Ye.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function(e, t) {
    var i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function(e) {
    e === void 0 && (e = 5);
    for (var t = [], i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return t;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function(e) {
    e === void 0 && (e = 5);
    for (var t = [], i = 0; i <= e; i++)
      t.push(this.getPointAt(i / e));
    return t;
  },
  // Get total curve arc length
  getLength: function() {
    var e = this.getLengths();
    return e[e.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function(e) {
    if (e === void 0 && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    var t = [], i, n = this.getPoint(0), r, a = 0;
    for (t.push(0), r = 1; r <= e; r++)
      i = this.getPoint(r / e), a += i.distanceTo(n), t.push(a), n = i;
    return this.cacheArcLengths = t, t;
  },
  updateArcLengths: function() {
    this.needsUpdate = !0, this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function(e, t) {
    var i = this.getLengths(), n = 0, r = i.length, a;
    t ? a = t : a = e * i[r - 1];
    for (var s = 0, o = r - 1, u; s <= o; )
      if (n = Math.floor(s + (o - s) / 2), u = i[n] - a, u < 0)
        s = n + 1;
      else if (u > 0)
        o = n - 1;
      else {
        o = n;
        break;
      }
    if (n = o, i[n] === a)
      return n / (r - 1);
    var l = i[n], c = i[n + 1], h = c - l, d = (a - l) / h, f = (n + d) / (r - 1);
    return f;
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function(e) {
    var t = 1e-4, i = e - t, n = e + t;
    i < 0 && (i = 0), n > 1 && (n = 1);
    var r = this.getPoint(i), a = this.getPoint(n), s = a.clone().sub(r);
    return s.normalize();
  },
  getTangentAt: function(e) {
    var t = this.getUtoTmapping(e);
    return this.getTangent(t);
  },
  computeFrenetFrames: function(e, t) {
    var i = new H(), n = [], r = [], a = [], s = new H(), o = new at(), u, l, c;
    for (u = 0; u <= e; u++)
      l = u / e, n[u] = this.getTangentAt(l), n[u].normalize();
    r[0] = new H(), a[0] = new H();
    var h = Number.MAX_VALUE, d = Math.abs(n[0].x), f = Math.abs(n[0].y), p = Math.abs(n[0].z);
    for (d <= h && (h = d, i.set(1, 0, 0)), f <= h && (h = f, i.set(0, 1, 0)), p <= h && i.set(0, 0, 1), s.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], s), a[0].crossVectors(n[0], r[0]), u = 1; u <= e; u++)
      r[u] = r[u - 1].clone(), a[u] = a[u - 1].clone(), s.crossVectors(n[u - 1], n[u]), s.length() > Number.EPSILON && (s.normalize(), c = Math.acos(gt.clamp(n[u - 1].dot(n[u]), -1, 1)), r[u].applyMatrix4(o.makeRotationAxis(s, c))), a[u].crossVectors(n[u], r[u]);
    if (t === !0)
      for (c = Math.acos(gt.clamp(r[0].dot(r[e]), -1, 1)), c /= e, n[0].dot(s.crossVectors(r[0], r[e])) > 0 && (c = -c), u = 1; u <= e; u++)
        r[u].applyMatrix4(o.makeRotationAxis(n[u], c * u)), a[u].crossVectors(n[u], r[u]);
    return {
      tangents: n,
      normals: r,
      binormals: a
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  },
  toJSON: function() {
    var e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  },
  fromJSON: function(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
});
function Dr(e, t, i, n, r, a, s, o) {
  Ye.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = o || 0;
}
Dr.prototype = Object.create(Ye.prototype);
Dr.prototype.constructor = Dr;
Dr.prototype.isEllipseCurve = !0;
Dr.prototype.getPoint = function(e, t) {
  for (var i = t || new ue(), n = Math.PI * 2, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0; ) r += n;
  for (; r > n; ) r -= n;
  r < Number.EPSILON && (a ? r = 0 : r = n), this.aClockwise === !0 && !a && (r === n ? r = -n : r = r - n);
  var s = this.aStartAngle + e * r, o = this.aX + this.xRadius * Math.cos(s), u = this.aY + this.yRadius * Math.sin(s);
  if (this.aRotation !== 0) {
    var l = Math.cos(this.aRotation), c = Math.sin(this.aRotation), h = o - this.aX, d = u - this.aY;
    o = h * l - d * c + this.aX, u = h * c + d * l + this.aY;
  }
  return i.set(o, u);
};
Dr.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
};
Dr.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
};
Dr.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
};
function lo(e, t, i, n, r, a) {
  Dr.call(this, e, t, i, i, n, r, a), this.type = "ArcCurve";
}
lo.prototype = Object.create(Dr.prototype);
lo.prototype.constructor = lo;
lo.prototype.isArcCurve = !0;
function Wf() {
  var e = 0, t = 0, i = 0, n = 0;
  function r(a, s, o, u) {
    e = a, t = o, i = -3 * a + 3 * s - 2 * o - u, n = 2 * a - 2 * s + o + u;
  }
  return {
    initCatmullRom: function(a, s, o, u, l) {
      r(s, o, l * (o - a), l * (u - s));
    },
    initNonuniformCatmullRom: function(a, s, o, u, l, c, h) {
      var d = (s - a) / l - (o - a) / (l + c) + (o - s) / c, f = (o - s) / c - (u - s) / (c + h) + (u - o) / h;
      d *= c, f *= c, r(s, o, d, f);
    },
    calc: function(a) {
      var s = a * a, o = s * a;
      return e + t * a + i * s + n * o;
    }
  };
}
var Ul = new H(), Yh = new Wf(), Qh = new Wf(), Kh = new Wf();
function zi(e, t, i, n) {
  Ye.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = i || "centripetal", this.tension = n || 0.5;
}
zi.prototype = Object.create(Ye.prototype);
zi.prototype.constructor = zi;
zi.prototype.isCatmullRomCurve3 = !0;
zi.prototype.getPoint = function(e, t) {
  var i = t || new H(), n = this.points, r = n.length, a = (r - (this.closed ? 0 : 1)) * e, s = Math.floor(a), o = a - s;
  this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / r) + 1) * r : o === 0 && s === r - 1 && (s = r - 2, o = 1);
  var u, l, c, h;
  if (this.closed || s > 0 ? u = n[(s - 1) % r] : (Ul.subVectors(n[0], n[1]).add(n[0]), u = Ul), l = n[s % r], c = n[(s + 1) % r], this.closed || s + 2 < r ? h = n[(s + 2) % r] : (Ul.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), h = Ul), this.curveType === "centripetal" || this.curveType === "chordal") {
    var d = this.curveType === "chordal" ? 0.5 : 0.25, f = Math.pow(u.distanceToSquared(l), d), p = Math.pow(l.distanceToSquared(c), d), _ = Math.pow(c.distanceToSquared(h), d);
    p < 1e-4 && (p = 1), f < 1e-4 && (f = p), _ < 1e-4 && (_ = p), Yh.initNonuniformCatmullRom(u.x, l.x, c.x, h.x, f, p, _), Qh.initNonuniformCatmullRom(u.y, l.y, c.y, h.y, f, p, _), Kh.initNonuniformCatmullRom(u.z, l.z, c.z, h.z, f, p, _);
  } else this.curveType === "catmullrom" && (Yh.initCatmullRom(u.x, l.x, c.x, h.x, this.tension), Qh.initCatmullRom(u.y, l.y, c.y, h.y, this.tension), Kh.initCatmullRom(u.z, l.z, c.z, h.z, this.tension));
  return i.set(
    Yh.calc(o),
    Qh.calc(o),
    Kh.calc(o)
  ), i;
};
zi.prototype.copy = function(e) {
  Ye.prototype.copy.call(this, e), this.points = [];
  for (var t = 0, i = e.points.length; t < i; t++) {
    var n = e.points[t];
    this.points.push(n.clone());
  }
  return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
};
zi.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  e.points = [];
  for (var t = 0, i = this.points.length; t < i; t++) {
    var n = this.points[t];
    e.points.push(n.toArray());
  }
  return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
};
zi.prototype.fromJSON = function(e) {
  Ye.prototype.fromJSON.call(this, e), this.points = [];
  for (var t = 0, i = e.points.length; t < i; t++) {
    var n = e.points[t];
    this.points.push(new H().fromArray(n));
  }
  return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
};
function Yv(e, t, i, n, r) {
  var a = (n - t) * 0.5, s = (r - i) * 0.5, o = e * e, u = e * o;
  return (2 * i - 2 * n + a + s) * u + (-3 * i + 3 * n - 2 * a - s) * o + a * e + i;
}
function mE(e, t) {
  var i = 1 - e;
  return i * i * t;
}
function gE(e, t) {
  return 2 * (1 - e) * e * t;
}
function yE(e, t) {
  return e * e * t;
}
function lu(e, t, i, n) {
  return mE(e, t) + gE(e, i) + yE(e, n);
}
function _E(e, t) {
  var i = 1 - e;
  return i * i * i * t;
}
function bE(e, t) {
  var i = 1 - e;
  return 3 * i * i * e * t;
}
function xE(e, t) {
  return 3 * (1 - e) * e * e * t;
}
function AE(e, t) {
  return e * e * e * t;
}
function cu(e, t, i, n, r) {
  return _E(e, t) + bE(e, i) + xE(e, n) + AE(e, r);
}
function Qr(e, t, i, n) {
  Ye.call(this), this.type = "CubicBezierCurve", this.v0 = e || new ue(), this.v1 = t || new ue(), this.v2 = i || new ue(), this.v3 = n || new ue();
}
Qr.prototype = Object.create(Ye.prototype);
Qr.prototype.constructor = Qr;
Qr.prototype.isCubicBezierCurve = !0;
Qr.prototype.getPoint = function(e, t) {
  var i = t || new ue(), n = this.v0, r = this.v1, a = this.v2, s = this.v3;
  return i.set(
    cu(e, n.x, r.x, a.x, s.x),
    cu(e, n.y, r.y, a.y, s.y)
  ), i;
};
Qr.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
};
Qr.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
};
Qr.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
};
function xn(e, t, i, n) {
  Ye.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new H(), this.v1 = t || new H(), this.v2 = i || new H(), this.v3 = n || new H();
}
xn.prototype = Object.create(Ye.prototype);
xn.prototype.constructor = xn;
xn.prototype.isCubicBezierCurve3 = !0;
xn.prototype.getPoint = function(e, t) {
  var i = t || new H(), n = this.v0, r = this.v1, a = this.v2, s = this.v3;
  return i.set(
    cu(e, n.x, r.x, a.x, s.x),
    cu(e, n.y, r.y, a.y, s.y),
    cu(e, n.z, r.z, a.z, s.z)
  ), i;
};
xn.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
};
xn.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
};
xn.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
};
function fr(e, t) {
  Ye.call(this), this.type = "LineCurve", this.v1 = e || new ue(), this.v2 = t || new ue();
}
fr.prototype = Object.create(Ye.prototype);
fr.prototype.constructor = fr;
fr.prototype.isLineCurve = !0;
fr.prototype.getPoint = function(e, t) {
  var i = t || new ue();
  return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
};
fr.prototype.getPointAt = function(e, t) {
  return this.getPoint(e, t);
};
fr.prototype.getTangent = function() {
  var e = this.v2.clone().sub(this.v1);
  return e.normalize();
};
fr.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
fr.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
fr.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function Kr(e, t) {
  Ye.call(this), this.type = "LineCurve3", this.v1 = e || new H(), this.v2 = t || new H();
}
Kr.prototype = Object.create(Ye.prototype);
Kr.prototype.constructor = Kr;
Kr.prototype.isLineCurve3 = !0;
Kr.prototype.getPoint = function(e, t) {
  var i = t || new H();
  return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
};
Kr.prototype.getPointAt = function(e, t) {
  return this.getPoint(e, t);
};
Kr.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
Kr.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
Kr.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function Zr(e, t, i) {
  Ye.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new ue(), this.v1 = t || new ue(), this.v2 = i || new ue();
}
Zr.prototype = Object.create(Ye.prototype);
Zr.prototype.constructor = Zr;
Zr.prototype.isQuadraticBezierCurve = !0;
Zr.prototype.getPoint = function(e, t) {
  var i = t || new ue(), n = this.v0, r = this.v1, a = this.v2;
  return i.set(
    lu(e, n.x, r.x, a.x),
    lu(e, n.y, r.y, a.y)
  ), i;
};
Zr.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
Zr.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
Zr.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function An(e, t, i) {
  Ye.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new H(), this.v1 = t || new H(), this.v2 = i || new H();
}
An.prototype = Object.create(Ye.prototype);
An.prototype.constructor = An;
An.prototype.isQuadraticBezierCurve3 = !0;
An.prototype.getPoint = function(e, t) {
  var i = t || new H(), n = this.v0, r = this.v1, a = this.v2;
  return i.set(
    lu(e, n.x, r.x, a.x),
    lu(e, n.y, r.y, a.y),
    lu(e, n.z, r.z, a.z)
  ), i;
};
An.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
An.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
An.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function Jr(e) {
  Ye.call(this), this.type = "SplineCurve", this.points = e || [];
}
Jr.prototype = Object.create(Ye.prototype);
Jr.prototype.constructor = Jr;
Jr.prototype.isSplineCurve = !0;
Jr.prototype.getPoint = function(e, t) {
  var i = t || new ue(), n = this.points, r = (n.length - 1) * e, a = Math.floor(r), s = r - a, o = n[a === 0 ? a : a - 1], u = n[a], l = n[a > n.length - 2 ? n.length - 1 : a + 1], c = n[a > n.length - 3 ? n.length - 1 : a + 2];
  return i.set(
    Yv(s, o.x, u.x, l.x, c.x),
    Yv(s, o.y, u.y, l.y, c.y)
  ), i;
};
Jr.prototype.copy = function(e) {
  Ye.prototype.copy.call(this, e), this.points = [];
  for (var t = 0, i = e.points.length; t < i; t++) {
    var n = e.points[t];
    this.points.push(n.clone());
  }
  return this;
};
Jr.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  e.points = [];
  for (var t = 0, i = this.points.length; t < i; t++) {
    var n = this.points[t];
    e.points.push(n.toArray());
  }
  return e;
};
Jr.prototype.fromJSON = function(e) {
  Ye.prototype.fromJSON.call(this, e), this.points = [];
  for (var t = 0, i = e.points.length; t < i; t++) {
    var n = e.points[t];
    this.points.push(new ue().fromArray(n));
  }
  return this;
};
var sy = /* @__PURE__ */ Object.freeze({
  ArcCurve: lo,
  CatmullRomCurve3: zi,
  CubicBezierCurve: Qr,
  CubicBezierCurve3: xn,
  EllipseCurve: Dr,
  LineCurve: fr,
  LineCurve3: Kr,
  QuadraticBezierCurve: Zr,
  QuadraticBezierCurve3: An,
  SplineCurve: Jr
});
function kn() {
  Ye.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
}
kn.prototype = Object.assign(Object.create(Ye.prototype), {
  constructor: kn,
  add: function(e) {
    this.curves.push(e);
  },
  closePath: function() {
    var e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new fr(t, e));
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function(e) {
    for (var t = e * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length; ) {
      if (i[n] >= t) {
        var r = i[n] - t, a = this.curves[n], s = a.getLength(), o = s === 0 ? 0 : 1 - r / s;
        return a.getPointAt(o);
      }
      n++;
    }
    return null;
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function() {
    var e = this.getCurveLengths();
    return e[e.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++)
      t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  },
  getSpacedPoints: function(e) {
    e === void 0 && (e = 40);
    for (var t = [], i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  },
  getPoints: function(e) {
    e = e || 12;
    for (var t = [], i, n = 0, r = this.curves; n < r.length; n++)
      for (var a = r[n], s = a && a.isEllipseCurve ? e * 2 : a && a.isLineCurve ? 1 : a && a.isSplineCurve ? e * a.points.length : e, o = a.getPoints(s), u = 0; u < o.length; u++) {
        var l = o[u];
        i && i.equals(l) || (t.push(l), i = l);
      }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  },
  copy: function(e) {
    Ye.prototype.copy.call(this, e), this.curves = [];
    for (var t = 0, i = e.curves.length; t < i; t++) {
      var n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  },
  toJSON: function() {
    var e = Ye.prototype.toJSON.call(this);
    e.autoClose = this.autoClose, e.curves = [];
    for (var t = 0, i = this.curves.length; t < i; t++) {
      var n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  },
  fromJSON: function(e) {
    Ye.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
    for (var t = 0, i = e.curves.length; t < i; t++) {
      var n = e.curves[t];
      this.curves.push(new sy[n.type]().fromJSON(n));
    }
    return this;
  }
});
function Hr(e) {
  kn.call(this), this.type = "Path", this.currentPoint = new ue(), e && this.setFromPoints(e);
}
Hr.prototype = Object.assign(Object.create(kn.prototype), {
  constructor: Hr,
  setFromPoints: function(e) {
    this.moveTo(e[0].x, e[0].y);
    for (var t = 1, i = e.length; t < i; t++)
      this.lineTo(e[t].x, e[t].y);
  },
  moveTo: function(e, t) {
    this.currentPoint.set(e, t);
  },
  lineTo: function(e, t) {
    var i = new fr(this.currentPoint.clone(), new ue(e, t));
    this.curves.push(i), this.currentPoint.set(e, t);
  },
  quadraticCurveTo: function(e, t, i, n) {
    var r = new Zr(
      this.currentPoint.clone(),
      new ue(e, t),
      new ue(i, n)
    );
    this.curves.push(r), this.currentPoint.set(i, n);
  },
  bezierCurveTo: function(e, t, i, n, r, a) {
    var s = new Qr(
      this.currentPoint.clone(),
      new ue(e, t),
      new ue(i, n),
      new ue(r, a)
    );
    this.curves.push(s), this.currentPoint.set(r, a);
  },
  splineThru: function(e) {
    var t = [this.currentPoint.clone()].concat(e), i = new Jr(t);
    this.curves.push(i), this.currentPoint.copy(e[e.length - 1]);
  },
  arc: function(e, t, i, n, r, a) {
    var s = this.currentPoint.x, o = this.currentPoint.y;
    this.absarc(
      e + s,
      t + o,
      i,
      n,
      r,
      a
    );
  },
  absarc: function(e, t, i, n, r, a) {
    this.absellipse(e, t, i, i, n, r, a);
  },
  ellipse: function(e, t, i, n, r, a, s, o) {
    var u = this.currentPoint.x, l = this.currentPoint.y;
    this.absellipse(e + u, t + l, i, n, r, a, s, o);
  },
  absellipse: function(e, t, i, n, r, a, s, o) {
    var u = new Dr(e, t, i, n, r, a, s, o);
    if (this.curves.length > 0) {
      var l = u.getPoint(0);
      l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
    }
    this.curves.push(u);
    var c = u.getPoint(1);
    this.currentPoint.copy(c);
  },
  copy: function(e) {
    return kn.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this;
  },
  toJSON: function() {
    var e = kn.prototype.toJSON.call(this);
    return e.currentPoint = this.currentPoint.toArray(), e;
  },
  fromJSON: function(e) {
    return kn.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this;
  }
});
function ua(e) {
  Hr.call(this, e), this.uuid = gt.generateUUID(), this.type = "Shape", this.holes = [];
}
ua.prototype = Object.assign(Object.create(Hr.prototype), {
  constructor: ua,
  getPointsHoles: function(e) {
    for (var t = [], i = 0, n = this.holes.length; i < n; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  },
  copy: function(e) {
    Hr.prototype.copy.call(this, e), this.holes = [];
    for (var t = 0, i = e.holes.length; t < i; t++) {
      var n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  },
  toJSON: function() {
    var e = Hr.prototype.toJSON.call(this);
    e.uuid = this.uuid, e.holes = [];
    for (var t = 0, i = this.holes.length; t < i; t++) {
      var n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  },
  fromJSON: function(e) {
    Hr.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
    for (var t = 0, i = e.holes.length; t < i; t++) {
      var n = e.holes[t];
      this.holes.push(new Hr().fromJSON(n));
    }
    return this;
  }
});
function ui(e, t) {
  Fe.call(this), this.type = "Light", this.color = new We(e), this.intensity = t !== void 0 ? t : 1, this.receiveShadow = void 0;
}
ui.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: ui,
  isLight: !0,
  copy: function(e) {
    return Fe.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this;
  },
  toJSON: function(e) {
    var t = Fe.prototype.toJSON.call(this, e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
});
function gc(e, t, i) {
  ui.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Fe.DefaultUp), this.updateMatrix(), this.groundColor = new We(t);
}
gc.prototype = Object.assign(Object.create(ui.prototype), {
  constructor: gc,
  isHemisphereLight: !0,
  copy: function(e) {
    return ui.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this;
  }
});
function gs(e) {
  this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new ue(512, 512), this.map = null, this.matrix = new at();
}
Object.assign(gs.prototype, {
  copy: function(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    var e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
});
function yc() {
  gs.call(this, new oi(50, 1, 0.5, 500));
}
yc.prototype = Object.assign(Object.create(gs.prototype), {
  constructor: yc,
  isSpotLightShadow: !0,
  update: function(e) {
    var t = this.camera, i = gt.RAD2DEG * 2 * e.angle, n = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (i !== t.fov || n !== t.aspect || r !== t.far) && (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix());
  }
});
function _c(e, t, i, n, r, a) {
  ui.call(this, e, t), this.type = "SpotLight", this.position.copy(Fe.DefaultUp), this.updateMatrix(), this.target = new Fe(), Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(s) {
      this.intensity = s / Math.PI;
    }
  }), this.distance = i !== void 0 ? i : 0, this.angle = n !== void 0 ? n : Math.PI / 3, this.penumbra = r !== void 0 ? r : 0, this.decay = a !== void 0 ? a : 1, this.shadow = new yc();
}
_c.prototype = Object.assign(Object.create(ui.prototype), {
  constructor: _c,
  isSpotLight: !0,
  copy: function(e) {
    return ui.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
});
function bc(e, t, i, n) {
  ui.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(r) {
      this.intensity = r / (4 * Math.PI);
    }
  }), this.distance = i !== void 0 ? i : 0, this.decay = n !== void 0 ? n : 1, this.shadow = new gs(new oi(90, 1, 0.5, 500));
}
bc.prototype = Object.assign(Object.create(ui.prototype), {
  constructor: bc,
  isPointLight: !0,
  copy: function(e) {
    return ui.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
});
function xc() {
  gs.call(this, new Hs(-5, 5, 5, -5, 0.5, 500));
}
xc.prototype = Object.assign(Object.create(gs.prototype), {
  constructor: xc
});
function Ac(e, t) {
  ui.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Fe.DefaultUp), this.updateMatrix(), this.target = new Fe(), this.shadow = new xc();
}
Ac.prototype = Object.assign(Object.create(ui.prototype), {
  constructor: Ac,
  isDirectionalLight: !0,
  copy: function(e) {
    return ui.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
});
function Tc(e, t) {
  ui.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0;
}
Tc.prototype = Object.assign(Object.create(ui.prototype), {
  constructor: Tc,
  isAmbientLight: !0
});
function Ec(e, t, i, n) {
  ui.call(this, e, t), this.type = "RectAreaLight", this.width = i !== void 0 ? i : 10, this.height = n !== void 0 ? n : 10;
}
Ec.prototype = Object.assign(Object.create(ui.prototype), {
  constructor: Ec,
  isRectAreaLight: !0,
  copy: function(e) {
    return ui.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this;
  },
  toJSON: function(e) {
    var t = ui.prototype.toJSON.call(this, e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
});
function wc(e, t, i, n) {
  Si.call(this, e, t, i, n);
}
wc.prototype = Object.assign(Object.create(Si.prototype), {
  constructor: wc,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: gu,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function Sc(e, t, i) {
  Si.call(this, e, t, i);
}
Sc.prototype = Object.assign(Object.create(Si.prototype), {
  constructor: Sc,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: gu,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
  // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".
});
function Cr(e, t, i, n) {
  this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i;
}
Object.assign(Cr.prototype, {
  evaluate: function(e) {
    var t = this.parameterPositions, i = this._cachedIndex, n = t[i], r = t[i - 1];
    e: {
      t: {
        var a;
        i: {
          r: if (!(e < n)) {
            for (var s = i + 2; ; ) {
              if (n === void 0) {
                if (e < r) break r;
                return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, e, r);
              }
              if (i === s) break;
              if (r = n, n = t[++i], e < n)
                break t;
            }
            a = t.length;
            break i;
          }
          if (!(e >= r)) {
            var o = t[1];
            e < o && (i = 2, r = o);
            for (var s = i - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, e, n);
              if (i === s) break;
              if (n = r, r = t[--i - 1], e >= r)
                break t;
            }
            a = i, i = 0;
            break i;
          }
          break e;
        }
        for (; i < a; ) {
          var u = i + a >>> 1;
          e < t[u] ? a = u : i = u + 1;
        }
        if (n = t[i], r = t[i - 1], r === void 0)
          return this._cachedIndex = 0, this.beforeStart_(0, e, n);
        if (n === void 0)
          return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, e);
      }
      this._cachedIndex = i, this.intervalChanged_(i, r, n);
    }
    return this.interpolate_(i, r, e, n);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(e) {
    for (var t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n, a = 0; a !== n; ++a)
      t[a] = i[r + a];
    return t;
  },
  // Template methods for derived classes:
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Cr.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Cr.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Cr.prototype.copySampleValue_
});
function Cc(e, t, i, n) {
  Cr.call(this, e, t, i, n);
}
Cc.prototype = Object.assign(Object.create(Cr.prototype), {
  constructor: Cc,
  interpolate_: function(e, t, i, n) {
    for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, u = (i - t) / (n - t), l = o + s; o !== l; o += 4)
      _i.slerpFlat(r, 0, a, o - s, a, o, u);
    return r;
  }
});
function Ju(e, t, i, n) {
  Si.call(this, e, t, i, n);
}
Ju.prototype = Object.assign(Object.create(Si.prototype), {
  constructor: Ju,
  ValueTypeName: "quaternion",
  // ValueBufferType is inherited
  DefaultInterpolation: uu,
  InterpolantFactoryMethodLinear: function(e) {
    return new Cc(this.times, this.values, this.getValueSize(), e);
  },
  InterpolantFactoryMethodSmooth: void 0
  // not yet implemented
});
function Mc(e, t, i, n) {
  Si.call(this, e, t, i, n);
}
Mc.prototype = Object.assign(Object.create(Si.prototype), {
  constructor: Mc,
  ValueTypeName: "color"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.
});
function co(e, t, i, n) {
  Si.call(this, e, t, i, n);
}
co.prototype = Object.assign(Object.create(Si.prototype), {
  constructor: co,
  ValueTypeName: "number"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function Dc(e, t, i, n) {
  Cr.call(this, e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
}
Dc.prototype = Object.assign(Object.create(Cr.prototype), {
  constructor: Dc,
  DefaultSettings_: {
    endingStart: za,
    endingEnd: za
  },
  intervalChanged_: function(e, t, i) {
    var n = this.parameterPositions, r = e - 2, a = e + 1, s = n[r], o = n[a];
    if (s === void 0)
      switch (this.getSettings_().endingStart) {
        case Ra:
          r = e, s = 2 * t - i;
          break;
        case yu:
          r = n.length - 2, s = t + n[r] - n[r + 1];
          break;
        default:
          r = e, s = i;
      }
    if (o === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ra:
          a = e, o = 2 * i - t;
          break;
        case yu:
          a = 1, o = i + n[1] - n[0];
          break;
        default:
          a = e - 1, o = t;
      }
    var u = (i - t) * 0.5, l = this.valueSize;
    this._weightPrev = u / (t - s), this._weightNext = u / (o - i), this._offsetPrev = r * l, this._offsetNext = a * l;
  },
  interpolate_: function(e, t, i, n) {
    for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, u = o - s, l = this._offsetPrev, c = this._offsetNext, h = this._weightPrev, d = this._weightNext, f = (i - t) / (n - t), p = f * f, _ = p * f, m = -h * _ + 2 * h * p - h * f, x = (1 + h) * _ + (-1.5 - 2 * h) * p + (-0.5 + h) * f + 1, E = (-1 - d) * _ + (1.5 + d) * p + 0.5 * f, M = d * _ - d * p, C = 0; C !== s; ++C)
      r[C] = m * a[l + C] + x * a[u + C] + E * a[o + C] + M * a[c + C];
    return r;
  }
});
function $u(e, t, i, n) {
  Cr.call(this, e, t, i, n);
}
$u.prototype = Object.assign(Object.create(Cr.prototype), {
  constructor: $u,
  interpolate_: function(e, t, i, n) {
    for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, u = o - s, l = (i - t) / (n - t), c = 1 - l, h = 0; h !== s; ++h)
      r[h] = a[u + h] * c + a[o + h] * l;
    return r;
  }
});
function Pc(e, t, i, n) {
  Cr.call(this, e, t, i, n);
}
Pc.prototype = Object.assign(Object.create(Cr.prototype), {
  constructor: Pc,
  interpolate_: function(e) {
    return this.copySampleValue_(e - 1);
  }
});
var ji = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(e, t, i) {
    return ji.isTypedArray(e) ? new e.constructor(e.subarray(t, i !== void 0 ? i : e.length)) : e.slice(t, i);
  },
  // converts an array to a specific type
  convertArray: function(e, t, i) {
    return !e || // let 'undefined' and 'null' pass
    !i && e.constructor === t ? e : typeof t.BYTES_PER_ELEMENT == "number" ? new t(e) : Array.prototype.slice.call(e);
  },
  isTypedArray: function(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(e) {
    function t(a, s) {
      return e[a] - e[s];
    }
    for (var i = e.length, n = new Array(i), r = 0; r !== i; ++r) n[r] = r;
    return n.sort(t), n;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(e, t, i) {
    for (var n = e.length, r = new e.constructor(n), a = 0, s = 0; s !== n; ++a)
      for (var o = i[a] * t, u = 0; u !== t; ++u)
        r[s++] = e[o + u];
    return r;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(e, t, i, n) {
    for (var r = 1, a = e[0]; a !== void 0 && a[n] === void 0; )
      a = e[r++];
    if (a !== void 0) {
      var s = a[n];
      if (s !== void 0)
        if (Array.isArray(s))
          do
            s = a[n], s !== void 0 && (t.push(a.time), i.push.apply(i, s)), a = e[r++];
          while (a !== void 0);
        else if (s.toArray !== void 0)
          do
            s = a[n], s !== void 0 && (t.push(a.time), s.toArray(i, i.length)), a = e[r++];
          while (a !== void 0);
        else
          do
            s = a[n], s !== void 0 && (t.push(a.time), i.push(s)), a = e[r++];
          while (a !== void 0);
    }
  }
};
function Si(e, t, i, n) {
  if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
  this.name = e, this.times = ji.convertArray(t, this.TimeBufferType), this.values = ji.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation), this.validate(), this.optimize();
}
Object.assign(Si, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  parse: function(e) {
    if (e.type === void 0)
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var t = Si._getTrackTypeForValueTypeName(e.type);
    if (e.times === void 0) {
      var i = [], n = [];
      ji.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n;
    }
    return t.parse !== void 0 ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
  },
  toJSON: function(e) {
    var t = e.constructor, i;
    if (t.toJSON !== void 0)
      i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: ji.convertArray(e.times, Array),
        values: ji.convertArray(e.values, Array)
      };
      var n = e.getInterpolation();
      n !== e.DefaultInterpolation && (i.interpolation = n);
    }
    return i.type = e.ValueTypeName, i;
  },
  _getTrackTypeForValueTypeName: function(e) {
    switch (e.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return co;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ho;
      case "color":
        return Mc;
      case "quaternion":
        return Ju;
      case "bool":
      case "boolean":
        return Sc;
      case "string":
        return wc;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
  }
});
Object.assign(Si.prototype, {
  constructor: Si,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: uu,
  InterpolantFactoryMethodDiscrete: function(e) {
    return new Pc(this.times, this.values, this.getValueSize(), e);
  },
  InterpolantFactoryMethodLinear: function(e) {
    return new $u(this.times, this.values, this.getValueSize(), e);
  },
  InterpolantFactoryMethodSmooth: function(e) {
    return new Dc(this.times, this.values, this.getValueSize(), e);
  },
  setInterpolation: function(e) {
    var t;
    switch (e) {
      case gu:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case uu:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case ec:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(i);
      console.warn("THREE.KeyframeTrack:", i);
      return;
    }
    this.createInterpolant = t;
  },
  getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return gu;
      case this.InterpolantFactoryMethodLinear:
        return uu;
      case this.InterpolantFactoryMethodSmooth:
        return ec;
    }
  },
  getValueSize: function() {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function(e) {
    if (e !== 0)
      for (var t = this.times, i = 0, n = t.length; i !== n; ++i)
        t[i] += e;
    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function(e) {
    if (e !== 1)
      for (var t = this.times, i = 0, n = t.length; i !== n; ++i)
        t[i] *= e;
    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function(e, t) {
    for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < e; )
      ++r;
    for (; a !== -1 && i[a] > t; )
      --a;
    if (++a, r !== 0 || a !== n) {
      r >= a && (a = Math.max(a, 1), r = a - 1);
      var s = this.getValueSize();
      this.times = ji.arraySlice(i, r, a), this.values = ji.arraySlice(this.values, r * s, a * s);
    }
    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function() {
    var e = !0, t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    var i = this.times, n = this.values, r = i.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    for (var a = null, s = 0; s !== r; s++) {
      var o = i[s];
      if (typeof o == "number" && isNaN(o)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, o), e = !1;
        break;
      }
      if (a !== null && a > o) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, s, o, a), e = !1;
        break;
      }
      a = o;
    }
    if (n !== void 0 && ji.isTypedArray(n))
      for (var s = 0, u = n.length; s !== u; ++s) {
        var l = n[s];
        if (isNaN(l)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, l), e = !1;
          break;
        }
      }
    return e;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function() {
    for (var e = this.times, t = this.values, i = this.getValueSize(), n = this.getInterpolation() === ec, r = 1, a = e.length - 1, s = 1; s < a; ++s) {
      var o = !1, u = e[s], l = e[s + 1];
      if (u !== l && (s !== 1 || u !== u[0]))
        if (n)
          o = !0;
        else
          for (var c = s * i, h = c - i, d = c + i, f = 0; f !== i; ++f) {
            var p = t[c + f];
            if (p !== t[h + f] || p !== t[d + f]) {
              o = !0;
              break;
            }
          }
      if (o) {
        if (s !== r) {
          e[r] = e[s];
          for (var _ = s * i, m = r * i, f = 0; f !== i; ++f)
            t[m + f] = t[_ + f];
        }
        ++r;
      }
    }
    if (a > 0) {
      e[r] = e[a];
      for (var _ = a * i, m = r * i, f = 0; f !== i; ++f)
        t[m + f] = t[_ + f];
      ++r;
    }
    return r !== e.length && (this.times = ji.arraySlice(e, 0, r), this.values = ji.arraySlice(t, 0, r * i)), this;
  }
});
function ho(e, t, i, n) {
  Si.call(this, e, t, i, n);
}
ho.prototype = Object.assign(Object.create(Si.prototype), {
  constructor: ho,
  ValueTypeName: "vector"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function Ir(e, t, i) {
  this.name = e, this.tracks = i, this.duration = t !== void 0 ? t : -1, this.uuid = gt.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize();
}
Object.assign(Ir, {
  parse: function(e) {
    for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, a = i.length; r !== a; ++r)
      t.push(Si.parse(i[r]).scale(n));
    return new Ir(e.name, e.duration, t);
  },
  toJSON: function(e) {
    for (var t = [], i = e.tracks, n = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid
    }, r = 0, a = i.length; r !== a; ++r)
      t.push(Si.toJSON(i[r]));
    return n;
  },
  CreateFromMorphTargetSequence: function(e, t, i, n) {
    for (var r = t.length, a = [], s = 0; s < r; s++) {
      var o = [], u = [];
      o.push(
        (s + r - 1) % r,
        s,
        (s + 1) % r
      ), u.push(0, 1, 0);
      var l = ji.getKeyframeOrder(o);
      o = ji.sortedArray(o, 1, l), u = ji.sortedArray(u, 1, l), !n && o[0] === 0 && (o.push(r), u.push(u[0])), a.push(
        new co(
          ".morphTargetInfluences[" + t[s].name + "]",
          o,
          u
        ).scale(1 / i)
      );
    }
    return new Ir(e, -1, a);
  },
  findByName: function(e, t) {
    var i = e;
    if (!Array.isArray(e)) {
      var n = e;
      i = n.geometry && n.geometry.animations || n.animations;
    }
    for (var r = 0; r < i.length; r++)
      if (i[r].name === t)
        return i[r];
    return null;
  },
  CreateClipsFromMorphTargetSequences: function(e, t, i) {
    for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, s = e.length; a < s; a++) {
      var o = e[a], u = o.name.match(r);
      if (u && u.length > 1) {
        var l = u[1], c = n[l];
        c || (n[l] = c = []), c.push(o);
      }
    }
    var h = [];
    for (var l in n)
      h.push(Ir.CreateFromMorphTargetSequence(l, n[l], t, i));
    return h;
  },
  // parse the animation.hierarchy format
  parseAnimation: function(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    for (var i = function(M, C, R, k, F) {
      if (R.length !== 0) {
        var B = [], I = [];
        ji.flattenJSON(R, B, I, k), B.length !== 0 && F.push(new M(C, B, I));
      }
    }, n = [], r = e.name || "default", a = e.length || -1, s = e.fps || 30, o = e.hierarchy || [], u = 0; u < o.length; u++) {
      var l = o[u].keys;
      if (!(!l || l.length === 0))
        if (l[0].morphTargets) {
          for (var c = {}, h = 0; h < l.length; h++)
            if (l[h].morphTargets)
              for (var d = 0; d < l[h].morphTargets.length; d++)
                c[l[h].morphTargets[d]] = -1;
          for (var f in c) {
            for (var p = [], _ = [], d = 0; d !== l[h].morphTargets.length; ++d) {
              var m = l[h];
              p.push(m.time), _.push(m.morphTarget === f ? 1 : 0);
            }
            n.push(new co(".morphTargetInfluence[" + f + "]", p, _));
          }
          a = c.length * s;
        } else {
          var x = ".bones[" + t[u].name + "]";
          i(
            ho,
            x + ".position",
            l,
            "pos",
            n
          ), i(
            Ju,
            x + ".quaternion",
            l,
            "rot",
            n
          ), i(
            ho,
            x + ".scale",
            l,
            "scl",
            n
          );
        }
    }
    if (n.length === 0)
      return null;
    var E = new Ir(r, a, n);
    return E;
  }
});
Object.assign(Ir.prototype, {
  resetDuration: function() {
    for (var e = this.tracks, t = 0, i = 0, n = e.length; i !== n; ++i) {
      var r = this.tracks[i];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    this.duration = t;
  },
  trim: function() {
    for (var e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  },
  optimize: function() {
    for (var e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
});
function yh(e) {
  this.manager = e !== void 0 ? e : pr, this.textures = {};
}
Object.assign(yh.prototype, {
  load: function(e, t, i, n) {
    var r = this, a = new en(r.manager);
    a.load(e, function(s) {
      t(r.parse(JSON.parse(s)));
    }, i, n);
  },
  setTextures: function(e) {
    this.textures = e;
  },
  parse: function(e) {
    var t = this.textures;
    function i(a) {
      return t[a] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", a), t[a];
    }
    var n = new vE[e.type]();
    if (e.uuid !== void 0 && (n.uuid = e.uuid), e.name !== void 0 && (n.name = e.name), e.color !== void 0 && n.color.setHex(e.color), e.roughness !== void 0 && (n.roughness = e.roughness), e.metalness !== void 0 && (n.metalness = e.metalness), e.emissive !== void 0 && n.emissive.setHex(e.emissive), e.specular !== void 0 && n.specular.setHex(e.specular), e.shininess !== void 0 && (n.shininess = e.shininess), e.clearCoat !== void 0 && (n.clearCoat = e.clearCoat), e.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = e.clearCoatRoughness), e.uniforms !== void 0 && (n.uniforms = e.uniforms), e.vertexShader !== void 0 && (n.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (n.fragmentShader = e.fragmentShader), e.vertexColors !== void 0 && (n.vertexColors = e.vertexColors), e.fog !== void 0 && (n.fog = e.fog), e.flatShading !== void 0 && (n.flatShading = e.flatShading), e.blending !== void 0 && (n.blending = e.blending), e.side !== void 0 && (n.side = e.side), e.opacity !== void 0 && (n.opacity = e.opacity), e.transparent !== void 0 && (n.transparent = e.transparent), e.alphaTest !== void 0 && (n.alphaTest = e.alphaTest), e.depthTest !== void 0 && (n.depthTest = e.depthTest), e.depthWrite !== void 0 && (n.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (n.colorWrite = e.colorWrite), e.wireframe !== void 0 && (n.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (n.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (n.rotation = e.rotation), e.linewidth !== 1 && (n.linewidth = e.linewidth), e.dashSize !== void 0 && (n.dashSize = e.dashSize), e.gapSize !== void 0 && (n.gapSize = e.gapSize), e.scale !== void 0 && (n.scale = e.scale), e.polygonOffset !== void 0 && (n.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = e.polygonOffsetUnits), e.skinning !== void 0 && (n.skinning = e.skinning), e.morphTargets !== void 0 && (n.morphTargets = e.morphTargets), e.dithering !== void 0 && (n.dithering = e.dithering), e.visible !== void 0 && (n.visible = e.visible), e.userData !== void 0 && (n.userData = e.userData), e.shading !== void 0 && (n.flatShading = e.shading === 1), e.size !== void 0 && (n.size = e.size), e.sizeAttenuation !== void 0 && (n.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (n.map = i(e.map)), e.alphaMap !== void 0 && (n.alphaMap = i(e.alphaMap), n.transparent = !0), e.bumpMap !== void 0 && (n.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (n.bumpScale = e.bumpScale), e.normalMap !== void 0 && (n.normalMap = i(e.normalMap)), e.normalScale !== void 0) {
      var r = e.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]), n.normalScale = new ue().fromArray(r);
    }
    return e.displacementMap !== void 0 && (n.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (n.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (n.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (n.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (n.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (n.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (n.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (n.specularMap = i(e.specularMap)), e.envMap !== void 0 && (n.envMap = i(e.envMap)), e.reflectivity !== void 0 && (n.reflectivity = e.reflectivity), e.lightMap !== void 0 && (n.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (n.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (n.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (n.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (n.gradientMap = i(e.gradientMap)), n;
  }
});
function qf(e) {
  this.manager = e !== void 0 ? e : pr;
}
Object.assign(qf.prototype, {
  load: function(e, t, i, n) {
    var r = this, a = new en(r.manager);
    a.load(e, function(s) {
      t(r.parse(JSON.parse(s)));
    }, i, n);
  },
  parse: function(e) {
    var t = new je(), i = e.data.index;
    if (i !== void 0) {
      var n = new Qv[i.type](i.array);
      t.setIndex(new pt(n, 1));
    }
    var r = e.data.attributes;
    for (var a in r) {
      var s = r[a], n = new Qv[s.type](s.array);
      t.addAttribute(a, new pt(n, s.itemSize, s.normalized));
    }
    var o = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (o !== void 0)
      for (var u = 0, l = o.length; u !== l; ++u) {
        var c = o[u];
        t.addGroup(c.start, c.count, c.materialIndex);
      }
    var h = e.data.boundingSphere;
    if (h !== void 0) {
      var d = new H();
      h.center !== void 0 && d.fromArray(h.center), t.boundingSphere = new qr(d, h.radius);
    }
    return t;
  }
});
var Qv = {
  Int8Array,
  Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function fo() {
}
fo.Handlers = {
  handlers: [],
  add: function(e, t) {
    this.handlers.push(e, t);
  },
  get: function(e) {
    for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) {
      var r = t[i], a = t[i + 1];
      if (r.test(e))
        return a;
    }
    return null;
  }
};
Object.assign(fo.prototype, {
  crossOrigin: void 0,
  onLoadStart: function() {
  },
  onLoadProgress: function() {
  },
  onLoadComplete: function() {
  },
  initMaterials: function(e, t, i) {
    for (var n = [], r = 0; r < e.length; ++r)
      n[r] = this.createMaterial(e[r], t, i);
    return n;
  },
  createMaterial: function() {
    var e = {
      NoBlending: oc,
      NormalBlending: bl,
      AdditiveBlending: Sf,
      SubtractiveBlending: Cf,
      MultiplyBlending: Mf,
      CustomBlending: Df
    }, t = new We(), i = new gh(), n = new yh();
    return function(a, s, o) {
      var u = {};
      function l(f, p, _, m, x) {
        var E = s + f, M = fo.Handlers.get(E), C;
        M !== null ? C = M.load(E) : (i.setCrossOrigin(o), C = i.load(E)), p !== void 0 && (C.repeat.fromArray(p), p[0] !== 1 && (C.wrapS = In), p[1] !== 1 && (C.wrapT = In)), _ !== void 0 && C.offset.fromArray(_), m !== void 0 && (m[0] === "repeat" && (C.wrapS = In), m[0] === "mirror" && (C.wrapS = Va), m[1] === "repeat" && (C.wrapT = In), m[1] === "mirror" && (C.wrapT = Va)), x !== void 0 && (C.anisotropy = x);
        var R = gt.generateUUID();
        return u[R] = C, R;
      }
      var c = {
        uuid: gt.generateUUID(),
        type: "MeshLambertMaterial"
      };
      for (var h in a) {
        var d = a[h];
        switch (h) {
          case "DbgColor":
          case "DbgIndex":
          case "opticalDensity":
          case "illumination":
            break;
          case "DbgName":
            c.name = d;
            break;
          case "blending":
            c.blending = e[d];
            break;
          case "colorAmbient":
          case "mapAmbient":
            console.warn("THREE.Loader.createMaterial:", h, "is no longer supported.");
            break;
          case "colorDiffuse":
            c.color = t.fromArray(d).getHex();
            break;
          case "colorSpecular":
            c.specular = t.fromArray(d).getHex();
            break;
          case "colorEmissive":
            c.emissive = t.fromArray(d).getHex();
            break;
          case "specularCoef":
            c.shininess = d;
            break;
          case "shading":
            d.toLowerCase() === "basic" && (c.type = "MeshBasicMaterial"), d.toLowerCase() === "phong" && (c.type = "MeshPhongMaterial"), d.toLowerCase() === "standard" && (c.type = "MeshStandardMaterial");
            break;
          case "mapDiffuse":
            c.map = l(d, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
            break;
          case "mapDiffuseRepeat":
          case "mapDiffuseOffset":
          case "mapDiffuseWrap":
          case "mapDiffuseAnisotropy":
            break;
          case "mapEmissive":
            c.emissiveMap = l(d, a.mapEmissiveRepeat, a.mapEmissiveOffset, a.mapEmissiveWrap, a.mapEmissiveAnisotropy);
            break;
          case "mapEmissiveRepeat":
          case "mapEmissiveOffset":
          case "mapEmissiveWrap":
          case "mapEmissiveAnisotropy":
            break;
          case "mapLight":
            c.lightMap = l(d, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
            break;
          case "mapLightRepeat":
          case "mapLightOffset":
          case "mapLightWrap":
          case "mapLightAnisotropy":
            break;
          case "mapAO":
            c.aoMap = l(d, a.mapAORepeat, a.mapAOOffset, a.mapAOWrap, a.mapAOAnisotropy);
            break;
          case "mapAORepeat":
          case "mapAOOffset":
          case "mapAOWrap":
          case "mapAOAnisotropy":
            break;
          case "mapBump":
            c.bumpMap = l(d, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
            break;
          case "mapBumpScale":
            c.bumpScale = d;
            break;
          case "mapBumpRepeat":
          case "mapBumpOffset":
          case "mapBumpWrap":
          case "mapBumpAnisotropy":
            break;
          case "mapNormal":
            c.normalMap = l(d, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
            break;
          case "mapNormalFactor":
            c.normalScale = d;
            break;
          case "mapNormalRepeat":
          case "mapNormalOffset":
          case "mapNormalWrap":
          case "mapNormalAnisotropy":
            break;
          case "mapSpecular":
            c.specularMap = l(d, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
            break;
          case "mapSpecularRepeat":
          case "mapSpecularOffset":
          case "mapSpecularWrap":
          case "mapSpecularAnisotropy":
            break;
          case "mapMetalness":
            c.metalnessMap = l(d, a.mapMetalnessRepeat, a.mapMetalnessOffset, a.mapMetalnessWrap, a.mapMetalnessAnisotropy);
            break;
          case "mapMetalnessRepeat":
          case "mapMetalnessOffset":
          case "mapMetalnessWrap":
          case "mapMetalnessAnisotropy":
            break;
          case "mapRoughness":
            c.roughnessMap = l(d, a.mapRoughnessRepeat, a.mapRoughnessOffset, a.mapRoughnessWrap, a.mapRoughnessAnisotropy);
            break;
          case "mapRoughnessRepeat":
          case "mapRoughnessOffset":
          case "mapRoughnessWrap":
          case "mapRoughnessAnisotropy":
            break;
          case "mapAlpha":
            c.alphaMap = l(d, a.mapAlphaRepeat, a.mapAlphaOffset, a.mapAlphaWrap, a.mapAlphaAnisotropy);
            break;
          case "mapAlphaRepeat":
          case "mapAlphaOffset":
          case "mapAlphaWrap":
          case "mapAlphaAnisotropy":
            break;
          case "flipSided":
            c.side = Ti;
            break;
          case "doubleSided":
            c.side = Io;
            break;
          case "transparency":
            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), c.opacity = d;
            break;
          case "depthTest":
          case "depthWrite":
          case "colorWrite":
          case "opacity":
          case "reflectivity":
          case "transparent":
          case "visible":
          case "wireframe":
            c[h] = d;
            break;
          case "vertexColors":
            d === !0 && (c.vertexColors = ps), d === "face" && (c.vertexColors = wf);
            break;
          default:
            console.error("THREE.Loader.createMaterial: Unsupported", h, d);
            break;
        }
      }
      return c.type === "MeshBasicMaterial" && delete c.emissive, c.type !== "MeshPhongMaterial" && delete c.specular, c.opacity < 1 && (c.transparent = !0), n.setTextures(u), n.parse(c);
    };
  }()
});
var Xf = {
  decodeText: function(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    for (var t = "", i = 0, n = e.length; i < n; i++)
      t += String.fromCharCode(e[i]);
    return decodeURIComponent(escape(t));
  },
  extractUrlBase: function(e) {
    var t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.substr(0, t + 1);
  }
};
function Yf(e) {
  typeof e == "boolean" && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = e !== void 0 ? e : pr, this.withCredentials = !1;
}
Object.assign(Yf.prototype, {
  load: function(e, t, i, n) {
    var r = this, a = this.texturePath && typeof this.texturePath == "string" ? this.texturePath : Xf.extractUrlBase(e), s = new en(this.manager);
    s.setWithCredentials(this.withCredentials), s.load(e, function(o) {
      var u = JSON.parse(o), l = u.metadata;
      if (l !== void 0) {
        var c = l.type;
        if (c !== void 0 && c.toLowerCase() === "object") {
          console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead.");
          return;
        }
      }
      var h = r.parse(u, a);
      t(h.geometry, h.materials);
    }, i, n);
  },
  setTexturePath: function(e) {
    this.texturePath = e;
  },
  parse: /* @__PURE__ */ function() {
    function e(r, a) {
      function s(pe, Re) {
        return pe & 1 << Re;
      }
      var o, u, l, c, h, d, f, p, _, m, x, E, M, C, R, k, F, B, I, V, Q, ee, oe, fe, he, de, G, j = r.faces, se = r.vertices, ie = r.normals, Ce = r.colors, K = r.scale, xe = 0;
      if (r.uvs !== void 0) {
        for (o = 0; o < r.uvs.length; o++)
          r.uvs[o].length && xe++;
        for (o = 0; o < xe; o++)
          a.faceVertexUvs[o] = [];
      }
      for (c = 0, h = se.length; c < h; )
        B = new H(), B.x = se[c++] * K, B.y = se[c++] * K, B.z = se[c++] * K, a.vertices.push(B);
      for (c = 0, h = j.length; c < h; )
        if (m = j[c++], x = s(m, 0), E = s(m, 1), M = s(m, 3), C = s(m, 4), R = s(m, 5), k = s(m, 6), F = s(m, 7), x) {
          if (V = new Bn(), V.a = j[c], V.b = j[c + 1], V.c = j[c + 3], Q = new Bn(), Q.a = j[c + 1], Q.b = j[c + 2], Q.c = j[c + 3], c += 4, E && (_ = j[c++], V.materialIndex = _, Q.materialIndex = _), l = a.faces.length, M)
            for (o = 0; o < xe; o++)
              for (fe = r.uvs[o], a.faceVertexUvs[o][l] = [], a.faceVertexUvs[o][l + 1] = [], u = 0; u < 4; u++)
                p = j[c++], de = fe[p * 2], G = fe[p * 2 + 1], he = new ue(de, G), u !== 2 && a.faceVertexUvs[o][l].push(he), u !== 0 && a.faceVertexUvs[o][l + 1].push(he);
          if (C && (f = j[c++] * 3, V.normal.set(
            ie[f++],
            ie[f++],
            ie[f]
          ), Q.normal.copy(V.normal)), R)
            for (o = 0; o < 4; o++)
              f = j[c++] * 3, oe = new H(
                ie[f++],
                ie[f++],
                ie[f]
              ), o !== 2 && V.vertexNormals.push(oe), o !== 0 && Q.vertexNormals.push(oe);
          if (k && (d = j[c++], ee = Ce[d], V.color.setHex(ee), Q.color.setHex(ee)), F)
            for (o = 0; o < 4; o++)
              d = j[c++], ee = Ce[d], o !== 2 && V.vertexColors.push(new We(ee)), o !== 0 && Q.vertexColors.push(new We(ee));
          a.faces.push(V), a.faces.push(Q);
        } else {
          if (I = new Bn(), I.a = j[c++], I.b = j[c++], I.c = j[c++], E && (_ = j[c++], I.materialIndex = _), l = a.faces.length, M)
            for (o = 0; o < xe; o++)
              for (fe = r.uvs[o], a.faceVertexUvs[o][l] = [], u = 0; u < 3; u++)
                p = j[c++], de = fe[p * 2], G = fe[p * 2 + 1], he = new ue(de, G), a.faceVertexUvs[o][l].push(he);
          if (C && (f = j[c++] * 3, I.normal.set(
            ie[f++],
            ie[f++],
            ie[f]
          )), R)
            for (o = 0; o < 3; o++)
              f = j[c++] * 3, oe = new H(
                ie[f++],
                ie[f++],
                ie[f]
              ), I.vertexNormals.push(oe);
          if (k && (d = j[c++], I.color.setHex(Ce[d])), F)
            for (o = 0; o < 3; o++)
              d = j[c++], I.vertexColors.push(new We(Ce[d]));
          a.faces.push(I);
        }
    }
    function t(r, a) {
      var s = r.influencesPerVertex !== void 0 ? r.influencesPerVertex : 2;
      if (r.skinWeights)
        for (var o = 0, u = r.skinWeights.length; o < u; o += s) {
          var l = r.skinWeights[o], c = s > 1 ? r.skinWeights[o + 1] : 0, h = s > 2 ? r.skinWeights[o + 2] : 0, d = s > 3 ? r.skinWeights[o + 3] : 0;
          a.skinWeights.push(new Ft(l, c, h, d));
        }
      if (r.skinIndices)
        for (var o = 0, u = r.skinIndices.length; o < u; o += s) {
          var f = r.skinIndices[o], p = s > 1 ? r.skinIndices[o + 1] : 0, _ = s > 2 ? r.skinIndices[o + 2] : 0, m = s > 3 ? r.skinIndices[o + 3] : 0;
          a.skinIndices.push(new Ft(f, p, _, m));
        }
      a.bones = r.bones, a.bones && a.bones.length > 0 && (a.skinWeights.length !== a.skinIndices.length || a.skinIndices.length !== a.vertices.length) && console.warn("When skinning, number of vertices (" + a.vertices.length + "), skinIndices (" + a.skinIndices.length + "), and skinWeights (" + a.skinWeights.length + ") should match.");
    }
    function i(r, a) {
      var s = r.scale;
      if (r.morphTargets !== void 0)
        for (var o = 0, u = r.morphTargets.length; o < u; o++) {
          a.morphTargets[o] = {}, a.morphTargets[o].name = r.morphTargets[o].name, a.morphTargets[o].vertices = [];
          for (var l = a.morphTargets[o].vertices, c = r.morphTargets[o].vertices, h = 0, d = c.length; h < d; h += 3) {
            var f = new H();
            f.x = c[h] * s, f.y = c[h + 1] * s, f.z = c[h + 2] * s, l.push(f);
          }
        }
      if (r.morphColors !== void 0 && r.morphColors.length > 0) {
        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
        for (var p = a.faces, _ = r.morphColors[0].colors, o = 0, u = p.length; o < u; o++)
          p[o].color.fromArray(_, o * 3);
      }
    }
    function n(r, a) {
      var s = [], o = [];
      r.animation !== void 0 && o.push(r.animation), r.animations !== void 0 && (r.animations.length ? o = o.concat(r.animations) : o.push(r.animations));
      for (var u = 0; u < o.length; u++) {
        var l = Ir.parseAnimation(o[u], a.bones);
        l && s.push(l);
      }
      if (a.morphTargets) {
        var c = Ir.CreateClipsFromMorphTargetSequences(a.morphTargets, 10);
        s = s.concat(c);
      }
      s.length > 0 && (a.animations = s);
    }
    return function(a, s) {
      a.data !== void 0 && (a = a.data), a.scale !== void 0 ? a.scale = 1 / a.scale : a.scale = 1;
      var o = new tt();
      if (e(a, o), t(a, o), i(a, o), n(a, o), o.computeFaceNormals(), o.computeBoundingSphere(), a.materials === void 0 || a.materials.length === 0)
        return { geometry: o };
      var u = fo.prototype.initMaterials(a.materials, s, this.crossOrigin);
      return { geometry: o, materials: u };
    };
  }()
});
function oy(e) {
  this.manager = e !== void 0 ? e : pr, this.texturePath = "";
}
Object.assign(oy.prototype, {
  load: function(e, t, i, n) {
    this.texturePath === "" && (this.texturePath = e.substring(0, e.lastIndexOf("/") + 1));
    var r = this, a = new en(r.manager);
    a.load(e, function(s) {
      var o = null;
      try {
        o = JSON.parse(s);
      } catch (l) {
        n !== void 0 && n(l), console.error("THREE:ObjectLoader: Can't parse " + e + ".", l.message);
        return;
      }
      var u = o.metadata;
      if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + e + ". Use THREE.JSONLoader instead.");
        return;
      }
      r.parse(o, t);
    }, i, n);
  },
  setTexturePath: function(e) {
    return this.texturePath = e, this;
  },
  setCrossOrigin: function(e) {
    return this.crossOrigin = e, this;
  },
  parse: function(e, t) {
    var i = this.parseShape(e.shapes), n = this.parseGeometries(e.geometries, i), r = this.parseImages(e.images, function() {
      t !== void 0 && t(o);
    }), a = this.parseTextures(e.textures, r), s = this.parseMaterials(e.materials, a), o = this.parseObject(e.object, n, s);
    return e.animations && (o.animations = this.parseAnimations(e.animations)), (e.images === void 0 || e.images.length === 0) && t !== void 0 && t(o), o;
  },
  parseShape: function(e) {
    var t = {};
    if (e !== void 0)
      for (var i = 0, n = e.length; i < n; i++) {
        var r = new ua().fromJSON(e[i]);
        t[r.uuid] = r;
      }
    return t;
  },
  parseGeometries: function(e, t) {
    var i = {};
    if (e !== void 0)
      for (var n = new Yf(), r = new qf(), a = 0, s = e.length; a < s; a++) {
        var o, u = e[a];
        switch (u.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            o = new ar[u.type](
              u.width,
              u.height,
              u.widthSegments,
              u.heightSegments
            );
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            o = new ar[u.type](
              u.width,
              u.height,
              u.depth,
              u.widthSegments,
              u.heightSegments,
              u.depthSegments
            );
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            o = new ar[u.type](
              u.radius,
              u.segments,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            o = new ar[u.type](
              u.radiusTop,
              u.radiusBottom,
              u.height,
              u.radialSegments,
              u.heightSegments,
              u.openEnded,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            o = new ar[u.type](
              u.radius,
              u.height,
              u.radialSegments,
              u.heightSegments,
              u.openEnded,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            o = new ar[u.type](
              u.radius,
              u.widthSegments,
              u.heightSegments,
              u.phiStart,
              u.phiLength,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            o = new ar[u.type](
              u.radius,
              u.detail
            );
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            o = new ar[u.type](
              u.innerRadius,
              u.outerRadius,
              u.thetaSegments,
              u.phiSegments,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            o = new ar[u.type](
              u.radius,
              u.tube,
              u.radialSegments,
              u.tubularSegments,
              u.arc
            );
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            o = new ar[u.type](
              u.radius,
              u.tube,
              u.tubularSegments,
              u.radialSegments,
              u.p,
              u.q
            );
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            o = new ar[u.type](
              u.points,
              u.segments,
              u.phiStart,
              u.phiLength
            );
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            o = new ar[u.type](
              u.vertices,
              u.indices,
              u.radius,
              u.details
            );
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            for (var d = [], l = 0, c = u.shapes.length; l < c; l++) {
              var h = t[u.shapes[l]];
              d.push(h);
            }
            o = new ar[u.type](
              d,
              u.curveSegments
            );
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            for (var d = [], l = 0, c = u.shapes.length; l < c; l++) {
              var h = t[u.shapes[l]];
              d.push(h);
            }
            var f = u.options.extrudePath;
            f !== void 0 && (u.options.extrudePath = new sy[f.type]().fromJSON(f)), o = new ar[u.type](
              d,
              u.options
            );
            break;
          case "BufferGeometry":
            o = r.parse(u);
            break;
          case "Geometry":
            o = n.parse(u, this.texturePath).geometry;
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + u.type + '"');
            continue;
        }
        o.uuid = u.uuid, u.name !== void 0 && (o.name = u.name), o.isBufferGeometry === !0 && u.userData !== void 0 && (o.userData = u.userData), i[u.uuid] = o;
      }
    return i;
  },
  parseMaterials: function(e, t) {
    var i = {};
    if (e !== void 0) {
      var n = new yh();
      n.setTextures(t);
      for (var r = 0, a = e.length; r < a; r++) {
        var s = e[r];
        if (s.type === "MultiMaterial") {
          for (var o = [], u = 0; u < s.materials.length; u++)
            o.push(n.parse(s.materials[u]));
          i[s.uuid] = o;
        } else
          i[s.uuid] = n.parse(s);
      }
    }
    return i;
  },
  parseAnimations: function(e) {
    for (var t = [], i = 0; i < e.length; i++) {
      var n = e[i], r = Ir.parse(n);
      n.uuid !== void 0 && (r.uuid = n.uuid), t.push(r);
    }
    return t;
  },
  parseImages: function(e, t) {
    var i = this, n = {};
    function r(h) {
      return i.manager.itemStart(h), s.load(h, function() {
        i.manager.itemEnd(h);
      }, void 0, function() {
        i.manager.itemEnd(h), i.manager.itemError(h);
      });
    }
    if (e !== void 0 && e.length > 0) {
      var a = new Vf(t), s = new Tl(a);
      s.setCrossOrigin(this.crossOrigin);
      for (var o = 0, u = e.length; o < u; o++) {
        var l = e[o], c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : i.texturePath + l.url;
        n[l.uuid] = r(c);
      }
    }
    return n;
  },
  parseTextures: function(e, t) {
    function i(u, l) {
      return typeof u == "number" ? u : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", u), l[u]);
    }
    var n = {};
    if (e !== void 0)
      for (var r = 0, a = e.length; r < a; r++) {
        var s = e[r];
        s.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), t[s.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", s.image);
        var o = new ri(t[s.image]);
        o.needsUpdate = !0, o.uuid = s.uuid, s.name !== void 0 && (o.name = s.name), s.mapping !== void 0 && (o.mapping = i(s.mapping, TE)), s.offset !== void 0 && o.offset.fromArray(s.offset), s.repeat !== void 0 && o.repeat.fromArray(s.repeat), s.center !== void 0 && o.center.fromArray(s.center), s.rotation !== void 0 && (o.rotation = s.rotation), s.wrap !== void 0 && (o.wrapS = i(s.wrap[0], Kv), o.wrapT = i(s.wrap[1], Kv)), s.format !== void 0 && (o.format = s.format), s.minFilter !== void 0 && (o.minFilter = i(s.minFilter, Zv)), s.magFilter !== void 0 && (o.magFilter = i(s.magFilter, Zv)), s.anisotropy !== void 0 && (o.anisotropy = s.anisotropy), s.flipY !== void 0 && (o.flipY = s.flipY), n[s.uuid] = o;
      }
    return n;
  },
  parseObject: function(e, t, i) {
    var n;
    function r(p) {
      return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p];
    }
    function a(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          for (var _ = [], m = 0, x = p.length; m < x; m++) {
            var E = p[m];
            i[E] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", E), _.push(i[E]);
          }
          return _;
        }
        return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), i[p];
      }
    }
    switch (e.type) {
      case "Scene":
        n = new Mu(), e.background !== void 0 && Number.isInteger(e.background) && (n.background = new We(e.background)), e.fog !== void 0 && (e.fog.type === "Fog" ? n.fog = new qs(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (n.fog = new Ws(e.fog.color, e.fog.density)));
        break;
      case "PerspectiveCamera":
        n = new oi(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (n.focus = e.focus), e.zoom !== void 0 && (n.zoom = e.zoom), e.filmGauge !== void 0 && (n.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (n.filmOffset = e.filmOffset), e.view !== void 0 && (n.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        n = new Hs(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (n.zoom = e.zoom), e.view !== void 0 && (n.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        n = new Tc(e.color, e.intensity);
        break;
      case "DirectionalLight":
        n = new Ac(e.color, e.intensity);
        break;
      case "PointLight":
        n = new bc(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        n = new Ec(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        n = new _c(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        n = new gc(e.color, e.groundColor, e.intensity);
        break;
      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
      case "Mesh":
        var s = r(e.geometry), o = a(e.material);
        s.bones && s.bones.length > 0 ? n = new dc(s, o) : n = new fi(s, o);
        break;
      case "LOD":
        n = new Pu();
        break;
      case "Line":
        n = new hr(r(e.geometry), a(e.material), e.mode);
        break;
      case "LineLoop":
        n = new fc(r(e.geometry), a(e.material));
        break;
      case "LineSegments":
        n = new Yt(r(e.geometry), a(e.material));
        break;
      case "PointCloud":
      case "Points":
        n = new Xs(r(e.geometry), a(e.material));
        break;
      case "Sprite":
        n = new Du(a(e.material));
        break;
      case "Group":
        n = new pc();
        break;
      default:
        n = new Fe();
    }
    if (n.uuid = e.uuid, e.name !== void 0 && (n.name = e.name), e.matrix !== void 0 ? (n.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (e.position !== void 0 && n.position.fromArray(e.position), e.rotation !== void 0 && n.rotation.fromArray(e.rotation), e.quaternion !== void 0 && n.quaternion.fromArray(e.quaternion), e.scale !== void 0 && n.scale.fromArray(e.scale)), e.castShadow !== void 0 && (n.castShadow = e.castShadow), e.receiveShadow !== void 0 && (n.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (n.shadow.bias = e.shadow.bias), e.shadow.radius !== void 0 && (n.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && n.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (n.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (n.visible = e.visible), e.frustumCulled !== void 0 && (n.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (n.renderOrder = e.renderOrder), e.userData !== void 0 && (n.userData = e.userData), e.children !== void 0)
      for (var u = e.children, l = 0; l < u.length; l++)
        n.add(this.parseObject(u[l], t, i));
    if (e.type === "LOD")
      for (var c = e.levels, h = 0; h < c.length; h++) {
        var d = c[h], f = n.getObjectByProperty("uuid", d.object);
        f !== void 0 && n.addLevel(f, d.distance);
      }
    return n;
  }
});
var TE = {
  UVMapping: oh,
  CubeReflectionMapping: uh,
  CubeRefractionMapping: lc,
  EquirectangularReflectionMapping: Of,
  EquirectangularRefractionMapping: cc,
  SphericalReflectionMapping: kf,
  CubeUVReflectionMapping: lh,
  CubeUVRefractionMapping: ch
}, Kv = {
  RepeatWrapping: In,
  ClampToEdgeWrapping: Er,
  MirroredRepeatWrapping: Va
}, Zv = {
  NearestFilter: wr,
  NearestMipMapNearestFilter: hh,
  NearestMipMapLinearFilter: dh,
  LinearFilter: Gi,
  LinearMipMapNearestFilter: Bf,
  LinearMipMapLinearFilter: Al
};
function Nd(e) {
  typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = e !== void 0 ? e : pr, this.options = void 0;
}
Nd.prototype = {
  constructor: Nd,
  setOptions: function(t) {
    return this.options = t, this;
  },
  load: function(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    var r = this, a = us.get(e);
    if (a !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    fetch(e).then(function(s) {
      return s.blob();
    }).then(function(s) {
      return createImageBitmap(s, r.options);
    }).then(function(s) {
      us.add(e, s), t && t(s), r.manager.itemEnd(e);
    }).catch(function(s) {
      n && n(s), r.manager.itemEnd(e), r.manager.itemError(e);
    });
  },
  setCrossOrigin: function() {
    return this;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
};
function Qf() {
  this.type = "ShapePath", this.color = new We(), this.subPaths = [], this.currentPath = null;
}
Object.assign(Qf.prototype, {
  moveTo: function(e, t) {
    this.currentPath = new Hr(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t);
  },
  lineTo: function(e, t) {
    this.currentPath.lineTo(e, t);
  },
  quadraticCurveTo: function(e, t, i, n) {
    this.currentPath.quadraticCurveTo(e, t, i, n);
  },
  bezierCurveTo: function(e, t, i, n, r, a) {
    this.currentPath.bezierCurveTo(e, t, i, n, r, a);
  },
  splineThru: function(e) {
    this.currentPath.splineThru(e);
  },
  toShapes: function(e, t) {
    function i(he) {
      for (var de = [], G = 0, j = he.length; G < j; G++) {
        var se = he[G], ie = new ua();
        ie.curves = se.curves, de.push(ie);
      }
      return de;
    }
    function n(he, de) {
      for (var G = de.length, j = !1, se = G - 1, ie = 0; ie < G; se = ie++) {
        var Ce = de[se], K = de[ie], xe = K.x - Ce.x, pe = K.y - Ce.y;
        if (Math.abs(pe) > Number.EPSILON) {
          if (pe < 0 && (Ce = de[ie], xe = -xe, K = de[se], pe = -pe), he.y < Ce.y || he.y > K.y) continue;
          if (he.y === Ce.y) {
            if (he.x === Ce.x) return !0;
          } else {
            var Re = pe * (he.x - Ce.x) - xe * (he.y - Ce.y);
            if (Re === 0) return !0;
            if (Re < 0) continue;
            j = !j;
          }
        } else {
          if (he.y !== Ce.y) continue;
          if (K.x <= he.x && he.x <= Ce.x || Ce.x <= he.x && he.x <= K.x) return !0;
        }
      }
      return j;
    }
    var r = Fn.isClockWise, a = this.subPaths;
    if (a.length === 0) return [];
    if (t === !0) return i(a);
    var s, o, u, l = [];
    if (a.length === 1)
      return o = a[0], u = new ua(), u.curves = o.curves, l.push(u), l;
    var c = !r(a[0].getPoints());
    c = e ? !c : c;
    var h = [], d = [], f = [], p = 0, _;
    d[p] = void 0, f[p] = [];
    for (var m = 0, x = a.length; m < x; m++)
      o = a[m], _ = o.getPoints(), s = r(_), s = e ? !s : s, s ? (!c && d[p] && p++, d[p] = { s: new ua(), p: _ }, d[p].s.curves = o.curves, c && p++, f[p] = []) : f[p].push({ h: o, p: _[0] });
    if (!d[0]) return i(a);
    if (d.length > 1) {
      for (var E = !1, M = [], C = 0, R = d.length; C < R; C++)
        h[C] = [];
      for (var C = 0, R = d.length; C < R; C++)
        for (var k = f[C], F = 0; F < k.length; F++) {
          for (var B = k[F], I = !0, V = 0; V < d.length; V++)
            n(B.p, d[V].p) && (C !== V && M.push({ froms: C, tos: V, hole: F }), I ? (I = !1, h[V].push(B)) : E = !0);
          I && h[C].push(B);
        }
      M.length > 0 && (E || (f = h));
    }
    for (var Q, m = 0, ee = d.length; m < ee; m++) {
      u = d[m].s, l.push(u), Q = f[m];
      for (var oe = 0, fe = Q.length; oe < fe; oe++)
        u.holes.push(Q[oe].h);
    }
    return l;
  }
});
function Kf(e) {
  this.type = "Font", this.data = e;
}
Object.assign(Kf.prototype, {
  isFont: !0,
  generateShapes: function(e, t, i) {
    t === void 0 && (t = 100), i === void 0 && (i = 4);
    for (var n = [], r = EE(e, t, i, this.data), a = 0, s = r.length; a < s; a++)
      Array.prototype.push.apply(n, r[a].toShapes());
    return n;
  }
});
function EE(e, t, i, n) {
  for (var r = Array.from ? Array.from(e) : String(e).split(""), a = t / n.resolution, s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * a, o = [], u = 0, l = 0, c = 0; c < r.length; c++) {
    var h = r[c];
    if (h === `
`)
      u = 0, l -= s;
    else {
      var d = wE(h, i, a, u, l, n);
      u += d.offsetX, o.push(d.path);
    }
  }
  return o;
}
function wE(e, t, i, n, r, a) {
  var s = a.glyphs[e] || a.glyphs["?"];
  if (s) {
    var o = new Qf(), u, l, c, h, d, f, p, _;
    if (s.o)
      for (var m = s._cachedOutline || (s._cachedOutline = s.o.split(" ")), x = 0, E = m.length; x < E; ) {
        var M = m[x++];
        switch (M) {
          case "m":
            u = m[x++] * i + n, l = m[x++] * i + r, o.moveTo(u, l);
            break;
          case "l":
            u = m[x++] * i + n, l = m[x++] * i + r, o.lineTo(u, l);
            break;
          case "q":
            c = m[x++] * i + n, h = m[x++] * i + r, d = m[x++] * i + n, f = m[x++] * i + r, o.quadraticCurveTo(d, f, c, h);
            break;
          case "b":
            c = m[x++] * i + n, h = m[x++] * i + r, d = m[x++] * i + n, f = m[x++] * i + r, p = m[x++] * i + n, _ = m[x++] * i + r, o.bezierCurveTo(d, f, p, _, c, h);
            break;
        }
      }
    return { offsetX: s.ha * i, path: o };
  }
}
function uy(e) {
  this.manager = e !== void 0 ? e : pr;
}
Object.assign(uy.prototype, {
  load: function(e, t, i, n) {
    var r = this, a = new en(this.manager);
    a.setPath(this.path), a.load(e, function(s) {
      var o;
      try {
        o = JSON.parse(s);
      } catch {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), o = JSON.parse(s.substring(65, s.length - 2));
      }
      var u = r.parse(o);
      t && t(u);
    }, i, n);
  },
  parse: function(e) {
    return new Kf(e);
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
var jl, _h = {
  getContext: function() {
    return jl === void 0 && (jl = new (window.AudioContext || window.webkitAudioContext)()), jl;
  },
  setContext: function(e) {
    jl = e;
  }
};
function Zf(e) {
  this.manager = e !== void 0 ? e : pr;
}
Object.assign(Zf.prototype, {
  load: function(e, t, i, n) {
    var r = new en(this.manager);
    r.setResponseType("arraybuffer"), r.load(e, function(a) {
      var s = _h.getContext();
      s.decodeAudioData(a, function(o) {
        t(o);
      });
    }, i, n);
  }
});
function ly() {
  this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new oi(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new oi(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
}
Object.assign(ly.prototype, {
  update: function() {
    var e, t, i, n, r, a, s, o, u = new at(), l = new at();
    return function(h) {
      var d = e !== this || t !== h.focus || i !== h.fov || n !== h.aspect * this.aspect || r !== h.near || a !== h.far || s !== h.zoom || o !== this.eyeSep;
      if (d) {
        e = this, t = h.focus, i = h.fov, n = h.aspect * this.aspect, r = h.near, a = h.far, s = h.zoom;
        var f = h.projectionMatrix.clone();
        o = this.eyeSep / 2;
        var p = o * r / t, _ = r * Math.tan(gt.DEG2RAD * i * 0.5) / s, m, x;
        l.elements[12] = -o, u.elements[12] = o, m = -_ * n + p, x = _ * n + p, f.elements[0] = 2 * r / (x - m), f.elements[8] = (x + m) / (x - m), this.cameraL.projectionMatrix.copy(f), m = -_ * n - p, x = _ * n - p, f.elements[0] = 2 * r / (x - m), f.elements[8] = (x + m) / (x - m), this.cameraR.projectionMatrix.copy(f);
      }
      this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(u);
    };
  }()
});
function el(e, t, i) {
  Fe.call(this), this.type = "CubeCamera";
  var n = 90, r = 1, a = new oi(n, r, e, t);
  a.up.set(0, -1, 0), a.lookAt(new H(1, 0, 0)), this.add(a);
  var s = new oi(n, r, e, t);
  s.up.set(0, -1, 0), s.lookAt(new H(-1, 0, 0)), this.add(s);
  var o = new oi(n, r, e, t);
  o.up.set(0, 0, 1), o.lookAt(new H(0, 1, 0)), this.add(o);
  var u = new oi(n, r, e, t);
  u.up.set(0, 0, -1), u.lookAt(new H(0, -1, 0)), this.add(u);
  var l = new oi(n, r, e, t);
  l.up.set(0, -1, 0), l.lookAt(new H(0, 0, 1)), this.add(l);
  var c = new oi(n, r, e, t);
  c.up.set(0, -1, 0), c.lookAt(new H(0, 0, -1)), this.add(c);
  var h = { format: Ha, magFilter: Gi, minFilter: Gi };
  this.renderTarget = new Vs(i, i, h), this.renderTarget.texture.name = "CubeCamera", this.update = function(d, f) {
    this.parent === null && this.updateMatrixWorld();
    var p = this.renderTarget, _ = p.texture.generateMipmaps;
    p.texture.generateMipmaps = !1, p.activeCubeFace = 0, d.render(f, a, p), p.activeCubeFace = 1, d.render(f, s, p), p.activeCubeFace = 2, d.render(f, o, p), p.activeCubeFace = 3, d.render(f, u, p), p.activeCubeFace = 4, d.render(f, l, p), p.texture.generateMipmaps = _, p.activeCubeFace = 5, d.render(f, c, p), d.setRenderTarget(null);
  }, this.clear = function(d, f, p, _) {
    for (var m = this.renderTarget, x = 0; x < 6; x++)
      m.activeCubeFace = x, d.setRenderTarget(m), d.clear(f, p, _);
    d.setRenderTarget(null);
  };
}
el.prototype = Object.create(Fe.prototype);
el.prototype.constructor = el;
function Ud() {
  Fe.call(this), this.type = "AudioListener", this.context = _h.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null;
}
Ud.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: Ud,
  getInput: function() {
    return this.gain;
  },
  removeFilter: function() {
    this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null);
  },
  getFilter: function() {
    return this.filter;
  },
  setFilter: function(e) {
    this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination);
  },
  getMasterVolume: function() {
    return this.gain.gain.value;
  },
  setMasterVolume: function(e) {
    this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01);
  },
  updateMatrixWorld: function() {
    var e = new H(), t = new _i(), i = new H(), n = new H();
    return function(a) {
      Fe.prototype.updateMatrixWorld.call(this, a);
      var s = this.context.listener, o = this.up;
      this.matrixWorld.decompose(e, t, i), n.set(0, 0, -1).applyQuaternion(t), s.positionX ? (s.positionX.setValueAtTime(e.x, this.context.currentTime), s.positionY.setValueAtTime(e.y, this.context.currentTime), s.positionZ.setValueAtTime(e.z, this.context.currentTime), s.forwardX.setValueAtTime(n.x, this.context.currentTime), s.forwardY.setValueAtTime(n.y, this.context.currentTime), s.forwardZ.setValueAtTime(n.z, this.context.currentTime), s.upX.setValueAtTime(o.x, this.context.currentTime), s.upY.setValueAtTime(o.y, this.context.currentTime), s.upZ.setValueAtTime(o.z, this.context.currentTime)) : (s.setPosition(e.x, e.y, e.z), s.setOrientation(n.x, n.y, n.z, o.x, o.y, o.z));
    };
  }()
});
function po(e) {
  Fe.call(this), this.type = "Audio", this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [];
}
po.prototype = Object.assign(Object.create(Fe.prototype), {
  constructor: po,
  getOutput: function() {
    return this.gain;
  },
  setNodeSource: function(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  },
  setMediaElementSource: function(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  },
  setBuffer: function(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  },
  play: function() {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    var e = this.context.createBufferSource();
    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), e.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.connect();
  },
  pause: function() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
  },
  stop: function() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.source.stop(), this.offset = 0, this.isPlaying = !1, this;
  },
  connect: function() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (var e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this;
  },
  disconnect: function() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (var e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this;
  },
  getFilters: function() {
    return this.filters;
  },
  setFilters: function(e) {
    return e || (e = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this;
  },
  getFilter: function() {
    return this.getFilters()[0];
  },
  setFilter: function(e) {
    return this.setFilters(e ? [e] : []);
  },
  setPlaybackRate: function(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
  },
  getPlaybackRate: function() {
    return this.playbackRate;
  },
  onEnded: function() {
    this.isPlaying = !1;
  },
  getLoop: function() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  },
  setLoop: function(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  },
  getVolume: function() {
    return this.gain.gain.value;
  },
  setVolume: function(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
});
function jd(e) {
  po.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
}
jd.prototype = Object.assign(Object.create(po.prototype), {
  constructor: jd,
  getOutput: function() {
    return this.panner;
  },
  getRefDistance: function() {
    return this.panner.refDistance;
  },
  setRefDistance: function(e) {
    this.panner.refDistance = e;
  },
  getRolloffFactor: function() {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function(e) {
    this.panner.rolloffFactor = e;
  },
  getDistanceModel: function() {
    return this.panner.distanceModel;
  },
  setDistanceModel: function(e) {
    this.panner.distanceModel = e;
  },
  getMaxDistance: function() {
    return this.panner.maxDistance;
  },
  setMaxDistance: function(e) {
    this.panner.maxDistance = e;
  },
  updateMatrixWorld: function() {
    var e = new H();
    return function(i) {
      Fe.prototype.updateMatrixWorld.call(this, i), e.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(e.x, e.y, e.z);
    };
  }()
});
function Jf(e, t) {
  this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t !== void 0 ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
}
Object.assign(Jf.prototype, {
  getFrequencyData: function() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  },
  getAverageFrequency: function() {
    for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++)
      e += t[i];
    return e / t.length;
  }
});
function $f(e, t, i) {
  this.binding = e, this.valueSize = i;
  var n = Float64Array, r;
  switch (t) {
    case "quaternion":
      r = this._slerp;
      break;
    case "string":
    case "bool":
      n = Array, r = this._select;
      break;
    default:
      r = this._lerp;
  }
  this.buffer = new n(i * 4), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0;
}
Object.assign($f.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function(e, t) {
    var i = this.buffer, n = this.valueSize, r = e * n + n, a = this.cumulativeWeight;
    if (a === 0) {
      for (var s = 0; s !== n; ++s)
        i[r + s] = i[s];
      a = t;
    } else {
      a += t;
      var o = t / a;
      this._mixBufferRegion(i, r, 0, o, n);
    }
    this.cumulativeWeight = a;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function(e) {
    var t = this.valueSize, i = this.buffer, n = e * t + t, r = this.cumulativeWeight, a = this.binding;
    if (this.cumulativeWeight = 0, r < 1) {
      var s = t * 3;
      this._mixBufferRegion(
        i,
        n,
        s,
        1 - r,
        t
      );
    }
    for (var o = t, u = t + t; o !== u; ++o)
      if (i[o] !== i[o + t]) {
        a.setValue(i, n);
        break;
      }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function() {
    var e = this.binding, t = this.buffer, i = this.valueSize, n = i * 3;
    e.getValue(t, n);
    for (var r = i, a = n; r !== a; ++r)
      t[r] = t[n + r % i];
    this.cumulativeWeight = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function() {
    var e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  },
  // mix functions
  _select: function(e, t, i, n, r) {
    if (n >= 0.5)
      for (var a = 0; a !== r; ++a)
        e[t + a] = e[i + a];
  },
  _slerp: function(e, t, i, n) {
    _i.slerpFlat(e, t, e, t, e, i, n);
  },
  _lerp: function(e, t, i, n, r) {
    for (var a = 1 - n, s = 0; s !== r; ++s) {
      var o = t + s;
      e[o] = e[o] * a + e[i + s] * n;
    }
  }
});
var Zh = "\\[\\]\\.:\\/";
function cy(e, t, i) {
  var n = i || Vi.parseTrackName(t);
  this._targetGroup = e, this._bindings = e.subscribe_(t, n);
}
Object.assign(cy.prototype, {
  getValue: function(e, t) {
    this.bind();
    var i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
    n !== void 0 && n.getValue(e, t);
  },
  setValue: function(e, t) {
    for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
      i[n].setValue(e, t);
  },
  bind: function() {
    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  },
  unbind: function() {
    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
});
function Vi(e, t, i) {
  this.path = t, this.parsedPath = i || Vi.parseTrackName(t), this.node = Vi.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e;
}
Object.assign(Vi, {
  Composite: cy,
  create: function(e, t, i) {
    return e && e.isAnimationObjectGroup ? new Vi.Composite(e, t, i) : new Vi(e, t, i);
  },
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param  {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function() {
    var e = new RegExp("[" + Zh + "]", "g");
    return function(i) {
      return i.replace(/\s/g, "_").replace(e, "");
    };
  }(),
  parseTrackName: function() {
    var e = "[^" + Zh + "]", t = "[^" + Zh.replace("\\.", "") + "]", i = /((?:WC+[\/:])*)/.source.replace("WC", e), n = /(WCOD+)?/.source.replace("WCOD", t), r = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", e), a = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", e), s = new RegExp(
      "^" + i + n + r + a + "$"
    ), o = ["material", "materials", "bones"];
    return function(l) {
      var c = s.exec(l);
      if (!c)
        throw new Error("PropertyBinding: Cannot parse trackName: " + l);
      var h = {
        // directoryName: matches[ 1 ], // (tschw) currently unused
        nodeName: c[2],
        objectName: c[3],
        objectIndex: c[4],
        propertyName: c[5],
        // required
        propertyIndex: c[6]
      }, d = h.nodeName && h.nodeName.lastIndexOf(".");
      if (d !== void 0 && d !== -1) {
        var f = h.nodeName.substring(d + 1);
        o.indexOf(f) !== -1 && (h.nodeName = h.nodeName.substring(0, d), h.objectName = f);
      }
      if (h.propertyName === null || h.propertyName.length === 0)
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + l);
      return h;
    };
  }(),
  findNode: function(e, t) {
    if (!t || t === "" || t === "root" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      var i = e.skeleton.getBoneByName(t);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      var n = function(a) {
        for (var s = 0; s < a.length; s++) {
          var o = a[s];
          if (o.name === t || o.uuid === t)
            return o;
          var u = n(o.children);
          if (u) return u;
        }
        return null;
      }, r = n(e.children);
      if (r)
        return r;
    }
    return null;
  }
});
Object.assign(Vi.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function(t, i) {
      t[i] = this.node[this.propertyName];
    },
    function(t, i) {
      for (var n = this.resolvedProperty, r = 0, a = n.length; r !== a; ++r)
        t[i++] = n[r];
    },
    function(t, i) {
      t[i] = this.resolvedProperty[this.propertyIndex];
    },
    function(t, i) {
      this.resolvedProperty.toArray(t, i);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      // Direct
      function(t, i) {
        this.targetObject[this.propertyName] = t[i];
      },
      function(t, i) {
        this.targetObject[this.propertyName] = t[i], this.targetObject.needsUpdate = !0;
      },
      function(t, i) {
        this.targetObject[this.propertyName] = t[i], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // EntireArray
      function(t, i) {
        for (var n = this.resolvedProperty, r = 0, a = n.length; r !== a; ++r)
          n[r] = t[i++];
      },
      function(t, i) {
        for (var n = this.resolvedProperty, r = 0, a = n.length; r !== a; ++r)
          n[r] = t[i++];
        this.targetObject.needsUpdate = !0;
      },
      function(t, i) {
        for (var n = this.resolvedProperty, r = 0, a = n.length; r !== a; ++r)
          n[r] = t[i++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // ArrayElement
      function(t, i) {
        this.resolvedProperty[this.propertyIndex] = t[i];
      },
      function(t, i) {
        this.resolvedProperty[this.propertyIndex] = t[i], this.targetObject.needsUpdate = !0;
      },
      function(t, i) {
        this.resolvedProperty[this.propertyIndex] = t[i], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // HasToFromArray
      function(t, i) {
        this.resolvedProperty.fromArray(t, i);
      },
      function(t, i) {
        this.resolvedProperty.fromArray(t, i), this.targetObject.needsUpdate = !0;
      },
      function(t, i) {
        this.resolvedProperty.fromArray(t, i), this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ]
  ],
  getValue: function(t, i) {
    this.bind(), this.getValue(t, i);
  },
  setValue: function(t, i) {
    this.bind(), this.setValue(t, i);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function() {
    var e = this.node, t = this.parsedPath, i = t.objectName, n = t.propertyName, r = t.propertyIndex;
    if (e || (e = Vi.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (i) {
      var a = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (var s = 0; s < e.length; s++)
            if (e[s].name === a) {
              a = s;
              break;
            }
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (a !== void 0) {
        if (e[a] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[a];
      }
    }
    var o = e[n];
    if (o === void 0) {
      var u = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + n + " but it wasn't found.", e);
      return;
    }
    var l = this.Versioning.None;
    e.needsUpdate !== void 0 ? (l = this.Versioning.NeedsUpdate, this.targetObject = e) : e.matrixWorldNeedsUpdate !== void 0 && (l = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = e);
    var c = this.BindingType.Direct;
    if (r !== void 0) {
      if (n === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (e.geometry.isBufferGeometry) {
          if (!e.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          for (var s = 0; s < this.node.geometry.morphAttributes.position.length; s++)
            if (e.geometry.morphAttributes.position[s].name === r) {
              r = s;
              break;
            }
        } else {
          if (!e.geometry.morphTargets) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
            return;
          }
          for (var s = 0; s < this.node.geometry.morphTargets.length; s++)
            if (e.geometry.morphTargets[s].name === r) {
              r = s;
              break;
            }
        }
      }
      c = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l];
  },
  unbind: function() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Vi.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: Vi.prototype.getValue,
  _setValue_unbound: Vi.prototype.setValue
});
function hy() {
  this.uuid = gt.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
  var e = {};
  this._indicesByUUID = e;
  for (var t = 0, i = arguments.length; t !== i; ++t)
    e[arguments[t].uuid] = t;
  this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
  var n = this;
  this.stats = {
    objects: {
      get total() {
        return n._objects.length;
      },
      get inUse() {
        return this.total - n.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return n._bindings.length;
    }
  };
}
Object.assign(hy.prototype, {
  isAnimationObjectGroup: !0,
  add: function() {
    for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, a = this._parsedPaths, s = this._bindings, o = s.length, u = void 0, l = 0, c = arguments.length; l !== c; ++l) {
      var h = arguments[l], d = h.uuid, f = n[d];
      if (f === void 0) {
        f = t++, n[d] = f, e.push(h);
        for (var p = 0, _ = o; p !== _; ++p)
          s[p].push(new Vi(h, r[p], a[p]));
      } else if (f < i) {
        u = e[f];
        var m = --i, x = e[m];
        n[x.uuid] = f, e[f] = x, n[d] = m, e[m] = h;
        for (var p = 0, _ = o; p !== _; ++p) {
          var E = s[p], M = E[m], C = E[f];
          E[f] = M, C === void 0 && (C = new Vi(h, r[p], a[p])), E[m] = C;
        }
      } else e[f] !== u && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = i;
  },
  remove: function() {
    for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, a = 0, s = arguments.length; a !== s; ++a) {
      var o = arguments[a], u = o.uuid, l = i[u];
      if (l !== void 0 && l >= t) {
        var c = t++, h = e[c];
        i[h.uuid] = l, e[l] = h, i[u] = c, e[c] = o;
        for (var d = 0, f = r; d !== f; ++d) {
          var p = n[d], _ = p[c], m = p[l];
          p[l] = _, p[c] = m;
        }
      }
    }
    this.nCachedObjects_ = t;
  },
  // remove & forget
  uncache: function() {
    for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, s = 0, o = arguments.length; s !== o; ++s) {
      var u = arguments[s], l = u.uuid, c = n[l];
      if (c !== void 0)
        if (delete n[l], c < i) {
          var h = --i, d = e[h], f = --t, p = e[f];
          n[d.uuid] = c, e[c] = d, n[p.uuid] = h, e[h] = p, e.pop();
          for (var _ = 0, m = a; _ !== m; ++_) {
            var x = r[_], E = x[h], M = x[f];
            x[c] = E, x[h] = M, x.pop();
          }
        } else {
          var f = --t, p = e[f];
          n[p.uuid] = c, e[c] = p, e.pop();
          for (var _ = 0, m = a; _ !== m; ++_) {
            var x = r[_];
            x[c] = x[f], x.pop();
          }
        }
    }
    this.nCachedObjects_ = i;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function(e, t) {
    var i = this._bindingsIndicesByPath, n = i[e], r = this._bindings;
    if (n !== void 0) return r[n];
    var a = this._paths, s = this._parsedPaths, o = this._objects, u = o.length, l = this.nCachedObjects_, c = new Array(u);
    n = r.length, i[e] = n, a.push(e), s.push(t), r.push(c);
    for (var h = l, d = o.length; h !== d; ++h) {
      var f = o[h];
      c[h] = new Vi(f, e, t);
    }
    return c;
  },
  unsubscribe_: function(e) {
    var t = this._bindingsIndicesByPath, i = t[e];
    if (i !== void 0) {
      var n = this._paths, r = this._parsedPaths, a = this._bindings, s = a.length - 1, o = a[s], u = e[s];
      t[u] = i, a[i] = o, a.pop(), r[i] = r[s], r.pop(), n[i] = n[s], n.pop();
    }
  }
});
function dy(e, t, i) {
  this._mixer = e, this._clip = t, this._localRoot = i || null;
  for (var n = t.tracks, r = n.length, a = new Array(r), s = {
    endingStart: za,
    endingEnd: za
  }, o = 0; o !== r; ++o) {
    var u = n[o].createInterpolant(null);
    a[o] = u, u.settings = s;
  }
  this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = M0, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
}
Object.assign(dy.prototype, {
  // State & Scheduling
  play: function() {
    return this._mixer._activateAction(this), this;
  },
  stop: function() {
    return this._mixer._deactivateAction(this), this.reset();
  },
  reset: function() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  },
  isRunning: function() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  // return true when play has been called
  isScheduled: function() {
    return this._mixer._isActiveAction(this);
  },
  startAt: function(e) {
    return this._startTime = e, this;
  },
  setLoop: function(e, t) {
    return this.loop = e, this.repetitions = t, this;
  },
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight: function(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  },
  // return the weight considering fading and .enabled
  getEffectiveWeight: function() {
    return this._effectiveWeight;
  },
  fadeIn: function(e) {
    return this._scheduleFading(e, 0, 1);
  },
  fadeOut: function(e) {
    return this._scheduleFading(e, 1, 0);
  },
  crossFadeFrom: function(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      var n = this._clip.duration, r = e._clip.duration, a = r / n, s = n / r;
      e.warp(1, a, t), this.warp(s, 1, t);
    }
    return this;
  },
  crossFadeTo: function(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  },
  stopFading: function() {
    var e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  },
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale: function(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  },
  // return the time scale considering warping and .paused
  getEffectiveTimeScale: function() {
    return this._effectiveTimeScale;
  },
  setDuration: function(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  },
  syncWith: function(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  },
  halt: function(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  },
  warp: function(e, t, i) {
    var n = this._mixer, r = n.time, a = this._timeScaleInterpolant, s = this.timeScale;
    a === null && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
    var o = a.parameterPositions, u = a.sampleValues;
    return o[0] = r, o[1] = r + i, u[0] = e / s, u[1] = t / s, this;
  },
  stopWarping: function() {
    var e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  },
  // Object Accessors
  getMixer: function() {
    return this._mixer;
  },
  getClip: function() {
    return this._clip;
  },
  getRoot: function() {
    return this._localRoot || this._mixer._root;
  },
  // Interna
  _update: function(e, t, i, n) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    var r = this._startTime;
    if (r !== null) {
      var a = (e - r) * i;
      if (a < 0 || i === 0)
        return;
      this._startTime = null, t = i * a;
    }
    t *= this._updateTimeScale(e);
    var s = this._updateTime(t), o = this._updateWeight(e);
    if (o > 0)
      for (var u = this._interpolants, l = this._propertyBindings, c = 0, h = u.length; c !== h; ++c)
        u[c].evaluate(s), l[c].accumulate(n, o);
  },
  _updateWeight: function(e) {
    var t = 0;
    if (this.enabled) {
      t = this.weight;
      var i = this._weightInterpolant;
      if (i !== null) {
        var n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  },
  _updateTimeScale: function(e) {
    var t = 0;
    if (!this.paused) {
      t = this.timeScale;
      var i = this._timeScaleInterpolant;
      if (i !== null) {
        var n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  },
  _updateTime: function(e) {
    var t = this.time + e;
    if (e === 0) return t;
    var i = this._clip.duration, n = this.loop, r = this._loopCount;
    if (n === C0) {
      r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (t >= i)
          t = i;
        else if (t < 0)
          t = 0;
        else break e;
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      var a = n === D0;
      if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), t >= i || t < 0) {
        var s = Math.floor(t / i);
        t -= i * s, r += Math.abs(s);
        var o = this.repetitions - r;
        if (o <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? i : 0, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (o === 1) {
            var u = e < 0;
            this._setEndings(u, !u, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = r, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: s
          });
        }
      }
      if (a && (r & 1) === 1)
        return this.time = t, i - t;
    }
    return this.time = t, t;
  },
  _setEndings: function(e, t, i) {
    var n = this._interpolantSettings;
    i ? (n.endingStart = Ra, n.endingEnd = Ra) : (e ? n.endingStart = this.zeroSlopeAtStart ? Ra : za : n.endingStart = yu, t ? n.endingEnd = this.zeroSlopeAtEnd ? Ra : za : n.endingEnd = yu);
  },
  _scheduleFading: function(e, t, i) {
    var n = this._mixer, r = n.time, a = this._weightInterpolant;
    a === null && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
    var s = a.parameterPositions, o = a.sampleValues;
    return s[0] = r, o[0] = t, s[1] = r + e, o[1] = i, this;
  }
});
function Gd(e) {
  this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
}
Gd.prototype = Object.assign(Object.create(Kn.prototype), {
  constructor: Gd,
  _bindAction: function(e, t) {
    var i = e._localRoot || this._root, n = e._clip.tracks, r = n.length, a = e._propertyBindings, s = e._interpolants, o = i.uuid, u = this._bindingsByRootAndName, l = u[o];
    l === void 0 && (l = {}, u[o] = l);
    for (var c = 0; c !== r; ++c) {
      var h = n[c], d = h.name, f = l[d];
      if (f !== void 0)
        a[c] = f;
      else {
        if (f = a[c], f !== void 0) {
          f._cacheIndex === null && (++f.referenceCount, this._addInactiveBinding(f, o, d));
          continue;
        }
        var p = t && t._propertyBindings[c].binding.parsedPath;
        f = new $f(
          Vi.create(i, d, p),
          h.ValueTypeName,
          h.getValueSize()
        ), ++f.referenceCount, this._addInactiveBinding(f, o, d), a[c] = f;
      }
      s[c].resultBuffer = f.buffer;
    }
  },
  _activateAction: function(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        var t = (e._localRoot || this._root).uuid, i = e._clip.uuid, n = this._actionsByClip[i];
        this._bindAction(
          e,
          n && n.knownActions[0]
        ), this._addInactiveAction(e, i, t);
      }
      for (var r = e._propertyBindings, a = 0, s = r.length; a !== s; ++a) {
        var o = r[a];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  },
  _deactivateAction: function(e) {
    if (this._isActiveAction(e)) {
      for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
        var r = t[i];
        --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  },
  // Memory manager
  _initMemoryManager: function() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    var e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function(e) {
    var t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  },
  _addInactiveAction: function(e, t, i) {
    var n = this._actions, r = this._actionsByClip, a = r[t];
    if (a === void 0)
      a = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = a;
    else {
      var s = a.knownActions;
      e._byClipCacheIndex = s.length, s.push(e);
    }
    e._cacheIndex = n.length, n.push(e), a.actionByRoot[i] = e;
  },
  _removeInactiveAction: function(e) {
    var t = this._actions, i = t[t.length - 1], n = e._cacheIndex;
    i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null;
    var r = e._clip.uuid, a = this._actionsByClip, s = a[r], o = s.knownActions, u = o[o.length - 1], l = e._byClipCacheIndex;
    u._byClipCacheIndex = l, o[l] = u, o.pop(), e._byClipCacheIndex = null;
    var c = s.actionByRoot, h = (e._localRoot || this._root).uuid;
    delete c[h], o.length === 0 && delete a[r], this._removeInactiveBindingsForAction(e);
  },
  _removeInactiveBindingsForAction: function(e) {
    for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
      var r = t[i];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  },
  _lendAction: function(e) {
    var t = this._actions, i = e._cacheIndex, n = this._nActiveActions++, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  },
  _takeBackAction: function(e) {
    var t = this._actions, i = e._cacheIndex, n = --this._nActiveActions, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function(e, t, i) {
    var n = this._bindingsByRootAndName, r = n[t], a = this._bindings;
    r === void 0 && (r = {}, n[t] = r), r[i] = e, e._cacheIndex = a.length, a.push(e);
  },
  _removeInactiveBinding: function(e) {
    var t = this._bindings, i = e.binding, n = i.rootNode.uuid, r = i.path, a = this._bindingsByRootAndName, s = a[n], o = t[t.length - 1], u = e._cacheIndex;
    o._cacheIndex = u, t[u] = o, t.pop(), delete s[r];
    e: {
      for (var l in s) break e;
      delete a[n];
    }
  },
  _lendBinding: function(e) {
    var t = this._bindings, i = e._cacheIndex, n = this._nActiveBindings++, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  },
  _takeBackBinding: function(e) {
    var t = this._bindings, i = e._cacheIndex, n = --this._nActiveBindings, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function() {
    var e = this._controlInterpolants, t = this._nActiveControlInterpolants++, i = e[t];
    return i === void 0 && (i = new $u(
      new Float32Array(2),
      new Float32Array(2),
      1,
      this._controlInterpolantsResultBuffer
    ), i.__cacheIndex = t, e[t] = i), i;
  },
  _takeBackControlInterpolant: function(e) {
    var t = this._controlInterpolants, i = e.__cacheIndex, n = --this._nActiveControlInterpolants, r = t[n];
    e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function(e, t) {
    var i = t || this._root, n = i.uuid, r = typeof e == "string" ? Ir.findByName(i, e) : e, a = r !== null ? r.uuid : e, s = this._actionsByClip[a], o = null;
    if (s !== void 0) {
      var u = s.actionByRoot[n];
      if (u !== void 0)
        return u;
      o = s.knownActions[0], r === null && (r = o._clip);
    }
    if (r === null) return null;
    var l = new dy(this, r, t);
    return this._bindAction(l, o), this._addInactiveAction(l, a, n), l;
  },
  // get an existing action
  existingAction: function(e, t) {
    var i = t || this._root, n = i.uuid, r = typeof e == "string" ? Ir.findByName(i, e) : e, a = r ? r.uuid : e, s = this._actionsByClip[a];
    return s !== void 0 && s.actionByRoot[n] || null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function() {
    var e = this._actions, t = this._nActiveActions, i = this._bindings, n = this._nActiveBindings;
    this._nActiveActions = 0, this._nActiveBindings = 0;
    for (var r = 0; r !== t; ++r)
      e[r].reset();
    for (var r = 0; r !== n; ++r)
      i[r].useCount = 0;
    return this;
  },
  // advance the time and update apply the animation
  update: function(e) {
    e *= this.timeScale;
    for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, s = 0; s !== i; ++s) {
      var o = t[s];
      o._update(n, e, r, a);
    }
    for (var u = this._bindings, l = this._nActiveBindings, s = 0; s !== l; ++s)
      u[s].apply(a);
    return this;
  },
  // return this mixer's root target object
  getRoot: function() {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function(e) {
    var t = this._actions, i = e.uuid, n = this._actionsByClip, r = n[i];
    if (r !== void 0) {
      for (var a = r.knownActions, s = 0, o = a.length; s !== o; ++s) {
        var u = a[s];
        this._deactivateAction(u);
        var l = u._cacheIndex, c = t[t.length - 1];
        u._cacheIndex = null, u._byClipCacheIndex = null, c._cacheIndex = l, t[l] = c, t.pop(), this._removeInactiveBindingsForAction(u);
      }
      delete n[i];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function(e) {
    var t = e.uuid, i = this._actionsByClip;
    for (var n in i) {
      var r = i[n].actionByRoot, a = r[t];
      a !== void 0 && (this._deactivateAction(a), this._removeInactiveAction(a));
    }
    var s = this._bindingsByRootAndName, o = s[t];
    if (o !== void 0)
      for (var u in o) {
        var l = o[u];
        l.restoreOriginalState(), this._removeInactiveBinding(l);
      }
  },
  // remove a targeted clip from the cache
  uncacheAction: function(e, t) {
    var i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
});
function Lc(e) {
  typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e;
}
Lc.prototype.clone = function() {
  return new Lc(this.value.clone === void 0 ? this.value : this.value.clone());
};
function Vd() {
  je.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
}
Vd.prototype = Object.assign(Object.create(je.prototype), {
  constructor: Vd,
  isInstancedBufferGeometry: !0,
  copy: function(e) {
    return je.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function ep(e, t, i, n) {
  this.data = e, this.itemSize = t, this.offset = i, this.normalized = n === !0;
}
Object.defineProperties(ep.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  }
});
Object.assign(ep.prototype, {
  isInterleavedBufferAttribute: !0,
  setX: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset] = t, this;
  },
  setY: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  },
  setZ: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  },
  setW: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  },
  getX: function(e) {
    return this.data.array[e * this.data.stride + this.offset];
  },
  getY: function(e) {
    return this.data.array[e * this.data.stride + this.offset + 1];
  },
  getZ: function(e) {
    return this.data.array[e * this.data.stride + this.offset + 2];
  },
  getW: function(e) {
    return this.data.array[e * this.data.stride + this.offset + 3];
  },
  setXY: function(e, t, i) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  },
  setXYZ: function(e, t, i, n) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this;
  },
  setXYZW: function(e, t, i, n, r) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this;
  }
});
function vo(e, t) {
  this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
Object.defineProperty(vo.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
Object.assign(vo.prototype, {
  isInterleavedBuffer: !0,
  onUploadCallback: function() {
  },
  setArray: function(e) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    return this.count = e !== void 0 ? e.length / this.stride : 0, this.array = e, this;
  },
  setDynamic: function(e) {
    return this.dynamic = e, this;
  },
  copy: function(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this;
  },
  copyAt: function(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (var n = 0, r = this.stride; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  },
  set: function(e, t) {
    return t === void 0 && (t = 0), this.array.set(e, t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  onUpload: function(e) {
    return this.onUploadCallback = e, this;
  }
});
function Hd(e, t, i) {
  vo.call(this, e, t), this.meshPerAttribute = i || 1;
}
Hd.prototype = Object.assign(Object.create(vo.prototype), {
  constructor: Hd,
  isInstancedInterleavedBuffer: !0,
  copy: function(e) {
    return vo.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
});
function zd(e, t, i) {
  pt.call(this, e, t), this.meshPerAttribute = i || 1;
}
zd.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: zd,
  isInstancedBufferAttribute: !0,
  copy: function(e) {
    return pt.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
});
function fy(e, t, i, n) {
  this.ray = new ms(e, t), this.near = i || 0, this.far = n || 1 / 0, this.params = {
    Mesh: {},
    Line: {},
    LOD: {},
    Points: { threshold: 1 },
    Sprite: {}
  }, Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
      }
    }
  });
}
function Jv(e, t) {
  return e.distance - t.distance;
}
function Wd(e, t, i, n) {
  if (e.visible !== !1 && (e.raycast(t, i), n === !0))
    for (var r = e.children, a = 0, s = r.length; a < s; a++)
      Wd(r[a], t, i, !0);
}
Object.assign(fy.prototype, {
  linePrecision: 1,
  set: function(e, t) {
    this.ray.set(e, t);
  },
  setFromCamera: function(e, t) {
    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
  },
  intersectObject: function(e, t, i) {
    var n = i || [];
    return Wd(e, this, n, t), n.sort(Jv), n;
  },
  intersectObjects: function(e, t, i) {
    var n = i || [];
    if (Array.isArray(e) === !1)
      return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
    for (var r = 0, a = e.length; r < a; r++)
      Wd(e[r], this, n, t);
    return n.sort(Jv), n;
  }
});
function py(e) {
  this.autoStart = e !== void 0 ? e : !0, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
}
Object.assign(py.prototype, {
  start: function() {
    this.startTime = (typeof performance > "u" ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  },
  stop: function() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  },
  getElapsedTime: function() {
    return this.getDelta(), this.elapsedTime;
  },
  getDelta: function() {
    var e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      var t = (typeof performance > "u" ? Date : performance).now();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
});
function vy(e, t, i) {
  return this.radius = e !== void 0 ? e : 1, this.phi = t !== void 0 ? t : 0, this.theta = i !== void 0 ? i : 0, this;
}
Object.assign(vy.prototype, {
  set: function(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  },
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe: function() {
    var e = 1e-6;
    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this;
  },
  setFromVector3: function(e) {
    return this.radius = e.length(), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e.x, e.z), this.phi = Math.acos(gt.clamp(e.y / this.radius, -1, 1))), this;
  }
});
function my(e, t, i) {
  return this.radius = e !== void 0 ? e : 1, this.theta = t !== void 0 ? t : 0, this.y = i !== void 0 ? i : 0, this;
}
Object.assign(my.prototype, {
  set: function(e, t, i) {
    return this.radius = e, this.theta = t, this.y = i, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  },
  setFromVector3: function(e) {
    return this.radius = Math.sqrt(e.x * e.x + e.z * e.z), this.theta = Math.atan2(e.x, e.z), this.y = e.y, this;
  }
});
function tp(e, t) {
  this.min = e !== void 0 ? e : new ue(1 / 0, 1 / 0), this.max = t !== void 0 ? t : new ue(-1 / 0, -1 / 0);
}
Object.assign(tp.prototype, {
  set: function(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  },
  setFromPoints: function(e) {
    this.makeEmpty();
    for (var t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  },
  setFromCenterAndSize: function() {
    var e = new ue();
    return function(i, n) {
      var r = e.copy(n).multiplyScalar(0.5);
      return this.min.copy(i).sub(r), this.max.copy(i).add(r), this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  },
  makeEmpty: function() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new ue()), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), e = new ue()), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  },
  expandByPoint: function(e) {
    return this.min.min(e), this.max.max(e), this;
  },
  expandByVector: function(e) {
    return this.min.sub(e), this.max.add(e), this;
  },
  expandByScalar: function(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  },
  containsPoint: function(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  },
  containsBox: function(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  },
  getParameter: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new ue()), t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  },
  intersectsBox: function(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  },
  clampPoint: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new ue()), t.copy(e).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var e = new ue();
    return function(i) {
      var n = e.copy(i).clamp(this.min, this.max);
      return n.sub(i).length();
    };
  }(),
  intersect: function(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  },
  union: function(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  },
  translate: function(e) {
    return this.min.add(e), this.max.add(e), this;
  },
  equals: function(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
});
function tl(e) {
  Fe.call(this), this.material = e, this.render = function() {
  };
}
tl.prototype = Object.create(Fe.prototype);
tl.prototype.constructor = tl;
tl.prototype.isImmediateRenderObject = !0;
function il(e, t, i, n) {
  this.object = e, this.size = t !== void 0 ? t : 1;
  var r = i !== void 0 ? i : 16711680, a = n !== void 0 ? n : 1, s = 0, o = this.object.geometry;
  o && o.isGeometry ? s = o.faces.length * 3 : o && o.isBufferGeometry && (s = o.attributes.normal.count);
  var u = new je(), l = new ke(s * 2 * 3, 3);
  u.addAttribute("position", l), Yt.call(this, u, new qt({ color: r, linewidth: a })), this.matrixAutoUpdate = !1, this.update();
}
il.prototype = Object.create(Yt.prototype);
il.prototype.constructor = il;
il.prototype.update = function() {
  var e = new H(), t = new H(), i = new wi();
  return function() {
    var r = ["a", "b", "c"];
    this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
    var a = this.object.matrixWorld, s = this.geometry.attributes.position, o = this.object.geometry;
    if (o && o.isGeometry)
      for (var u = o.vertices, l = o.faces, c = 0, h = 0, d = l.length; h < d; h++)
        for (var f = l[h], p = 0, _ = f.vertexNormals.length; p < _; p++) {
          var m = u[f[r[p]]], x = f.vertexNormals[p];
          e.copy(m).applyMatrix4(a), t.copy(x).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), s.setXYZ(c, e.x, e.y, e.z), c = c + 1, s.setXYZ(c, t.x, t.y, t.z), c = c + 1;
        }
    else if (o && o.isBufferGeometry)
      for (var E = o.attributes.position, M = o.attributes.normal, c = 0, p = 0, _ = E.count; p < _; p++)
        e.set(E.getX(p), E.getY(p), E.getZ(p)).applyMatrix4(a), t.set(M.getX(p), M.getY(p), M.getZ(p)), t.applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), s.setXYZ(c, e.x, e.y, e.z), c = c + 1, s.setXYZ(c, t.x, t.y, t.z), c = c + 1;
    s.needsUpdate = !0;
  };
}();
function mo(e, t) {
  Fe.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
  for (var i = new je(), n = [
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    -1,
    1
  ], r = 0, a = 1, s = 32; r < s; r++, a++) {
    var o = r / s * Math.PI * 2, u = a / s * Math.PI * 2;
    n.push(
      Math.cos(o),
      Math.sin(o),
      1,
      Math.cos(u),
      Math.sin(u),
      1
    );
  }
  i.addAttribute("position", new ke(n, 3));
  var l = new qt({ fog: !1 });
  this.cone = new Yt(i, l), this.add(this.cone), this.update();
}
mo.prototype = Object.create(Fe.prototype);
mo.prototype.constructor = mo;
mo.prototype.dispose = function() {
  this.cone.geometry.dispose(), this.cone.material.dispose();
};
mo.prototype.update = function() {
  var e = new H(), t = new H();
  return function() {
    this.light.updateMatrixWorld();
    var n = this.light.distance ? this.light.distance : 1e3, r = n * Math.tan(this.light.angle);
    this.cone.scale.set(r, r, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  };
}();
function gy(e) {
  var t = [];
  e && e.isBone && t.push(e);
  for (var i = 0; i < e.children.length; i++)
    t.push.apply(t, gy(e.children[i]));
  return t;
}
function go(e) {
  for (var t = gy(e), i = new je(), n = [], r = [], a = new We(0, 0, 1), s = new We(0, 1, 0), o = 0; o < t.length; o++) {
    var u = t[o];
    u.parent && u.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(s.r, s.g, s.b));
  }
  i.addAttribute("position", new ke(n, 3)), i.addAttribute("color", new ke(r, 3));
  var l = new qt({ vertexColors: ps, depthTest: !1, depthWrite: !1, transparent: !0 });
  Yt.call(this, i, l), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
}
go.prototype = Object.create(Yt.prototype);
go.prototype.constructor = go;
go.prototype.updateMatrixWorld = function() {
  var e = new H(), t = new at(), i = new at();
  return function(r) {
    var a = this.bones, s = this.geometry, o = s.getAttribute("position");
    i.getInverse(this.root.matrixWorld);
    for (var u = 0, l = 0; u < a.length; u++) {
      var c = a[u];
      c.parent && c.parent.isBone && (t.multiplyMatrices(i, c.matrixWorld), e.setFromMatrixPosition(t), o.setXYZ(l, e.x, e.y, e.z), t.multiplyMatrices(i, c.parent.matrixWorld), e.setFromMatrixPosition(t), o.setXYZ(l + 1, e.x, e.y, e.z), l += 2);
    }
    s.getAttribute("position").needsUpdate = !0, Fe.prototype.updateMatrixWorld.call(this, r);
  };
}();
function yo(e, t, i) {
  this.light = e, this.light.updateMatrixWorld(), this.color = i;
  var n = new pa(t, 4, 2), r = new Ei({ wireframe: !0, fog: !1 });
  fi.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
}
yo.prototype = Object.create(fi.prototype);
yo.prototype.constructor = yo;
yo.prototype.dispose = function() {
  this.geometry.dispose(), this.material.dispose();
};
yo.prototype.update = function() {
  this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
};
function _o(e, t) {
  Fe.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
  var i = new qt({ fog: !1 }), n = new je();
  n.addAttribute("position", new pt(new Float32Array(5 * 3), 3)), this.line = new hr(n, i), this.add(this.line), this.update();
}
_o.prototype = Object.create(Fe.prototype);
_o.prototype.constructor = _o;
_o.prototype.dispose = function() {
  this.children[0].geometry.dispose(), this.children[0].material.dispose();
};
_o.prototype.update = function() {
  var e = this.light.width * 0.5, t = this.light.height * 0.5, i = this.line.geometry.attributes.position, n = i.array;
  n[0] = e, n[1] = -t, n[2] = 0, n[3] = e, n[4] = t, n[5] = 0, n[6] = -e, n[7] = t, n[8] = 0, n[9] = -e, n[10] = -t, n[11] = 0, n[12] = e, n[13] = -t, n[14] = 0, i.needsUpdate = !0, this.color !== void 0 ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
};
function bo(e, t, i) {
  Fe.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
  var n = new Za(t);
  n.rotateY(Math.PI * 0.5), this.material = new Ei({ wireframe: !0, fog: !1 }), this.color === void 0 && (this.material.vertexColors = ps);
  var r = n.getAttribute("position"), a = new Float32Array(r.count * 3);
  n.addAttribute("color", new pt(a, 3)), this.add(new fi(n, this.material)), this.update();
}
bo.prototype = Object.create(Fe.prototype);
bo.prototype.constructor = bo;
bo.prototype.dispose = function() {
  this.children[0].geometry.dispose(), this.children[0].material.dispose();
};
bo.prototype.update = function() {
  var e = new H(), t = new We(), i = new We();
  return function() {
    var r = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      var a = r.geometry.getAttribute("color");
      t.copy(this.light.color), i.copy(this.light.groundColor);
      for (var s = 0, o = a.count; s < o; s++) {
        var u = s < o / 2 ? t : i;
        a.setXYZ(s, u.r, u.g, u.b);
      }
      a.needsUpdate = !0;
    }
    r.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate());
  };
}();
function rl(e, t, i, n) {
  e = e || 10, t = t || 10, i = new We(i !== void 0 ? i : 4473924), n = new We(n !== void 0 ? n : 8947848);
  for (var r = t / 2, a = e / t, s = e / 2, o = [], u = [], l = 0, c = 0, h = -s; l <= t; l++, h += a) {
    o.push(-s, 0, h, s, 0, h), o.push(h, 0, -s, h, 0, s);
    var d = l === r ? i : n;
    d.toArray(u, c), c += 3, d.toArray(u, c), c += 3, d.toArray(u, c), c += 3, d.toArray(u, c), c += 3;
  }
  var f = new je();
  f.addAttribute("position", new ke(o, 3)), f.addAttribute("color", new ke(u, 3));
  var p = new qt({ vertexColors: ps });
  Yt.call(this, f, p);
}
rl.prototype = Object.create(Yt.prototype);
rl.prototype.constructor = rl;
function Rc(e, t, i, n, r, a) {
  e = e || 10, t = t || 16, i = i || 8, n = n || 64, r = new We(r !== void 0 ? r : 4473924), a = new We(a !== void 0 ? a : 8947848);
  var s = [], o = [], u, l, c, h, d, f, p;
  for (h = 0; h <= t; h++)
    c = h / t * (Math.PI * 2), u = Math.sin(c) * e, l = Math.cos(c) * e, s.push(0, 0, 0), s.push(u, 0, l), p = h & 1 ? r : a, o.push(p.r, p.g, p.b), o.push(p.r, p.g, p.b);
  for (h = 0; h <= i; h++)
    for (p = h & 1 ? r : a, f = e - e / i * h, d = 0; d < n; d++)
      c = d / n * (Math.PI * 2), u = Math.sin(c) * f, l = Math.cos(c) * f, s.push(u, 0, l), o.push(p.r, p.g, p.b), c = (d + 1) / n * (Math.PI * 2), u = Math.sin(c) * f, l = Math.cos(c) * f, s.push(u, 0, l), o.push(p.r, p.g, p.b);
  var _ = new je();
  _.addAttribute("position", new ke(s, 3)), _.addAttribute("color", new ke(o, 3));
  var m = new qt({ vertexColors: ps });
  Yt.call(this, _, m);
}
Rc.prototype = Object.create(Yt.prototype);
Rc.prototype.constructor = Rc;
function nl(e, t, i, n) {
  this.object = e, this.size = t !== void 0 ? t : 1;
  var r = i !== void 0 ? i : 16776960, a = n !== void 0 ? n : 1, s = 0, o = this.object.geometry;
  o && o.isGeometry ? s = o.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
  var u = new je(), l = new ke(s * 2 * 3, 3);
  u.addAttribute("position", l), Yt.call(this, u, new qt({ color: r, linewidth: a })), this.matrixAutoUpdate = !1, this.update();
}
nl.prototype = Object.create(Yt.prototype);
nl.prototype.constructor = nl;
nl.prototype.update = function() {
  var e = new H(), t = new H(), i = new wi();
  return function() {
    this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
    for (var r = this.object.matrixWorld, a = this.geometry.attributes.position, s = this.object.geometry, o = s.vertices, u = s.faces, l = 0, c = 0, h = u.length; c < h; c++) {
      var d = u[c], f = d.normal;
      e.copy(o[d.a]).add(o[d.b]).add(o[d.c]).divideScalar(3).applyMatrix4(r), t.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), a.setXYZ(l, e.x, e.y, e.z), l = l + 1, a.setXYZ(l, t.x, t.y, t.z), l = l + 1;
    }
    a.needsUpdate = !0;
  };
}();
function xo(e, t, i) {
  Fe.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, t === void 0 && (t = 1);
  var n = new je();
  n.addAttribute("position", new ke([
    -t,
    t,
    0,
    t,
    t,
    0,
    t,
    -t,
    0,
    -t,
    -t,
    0,
    -t,
    t,
    0
  ], 3));
  var r = new qt({ fog: !1 });
  this.lightPlane = new hr(n, r), this.add(this.lightPlane), n = new je(), n.addAttribute("position", new ke([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new hr(n, r), this.add(this.targetLine), this.update();
}
xo.prototype = Object.create(Fe.prototype);
xo.prototype.constructor = xo;
xo.prototype.dispose = function() {
  this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
};
xo.prototype.update = function() {
  var e = new H(), t = new H(), i = new H();
  return function() {
    e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e), this.lightPlane.lookAt(i), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(i), this.targetLine.scale.z = i.length();
  };
}();
function al(e) {
  var t = new je(), i = new qt({ color: 16777215, vertexColors: wf }), n = [], r = [], a = {}, s = new We(16755200), o = new We(16711680), u = new We(43775), l = new We(16777215), c = new We(3355443);
  h("n1", "n2", s), h("n2", "n4", s), h("n4", "n3", s), h("n3", "n1", s), h("f1", "f2", s), h("f2", "f4", s), h("f4", "f3", s), h("f3", "f1", s), h("n1", "f1", s), h("n2", "f2", s), h("n3", "f3", s), h("n4", "f4", s), h("p", "n1", o), h("p", "n2", o), h("p", "n3", o), h("p", "n4", o), h("u1", "u2", u), h("u2", "u3", u), h("u3", "u1", u), h("c", "t", l), h("p", "c", c), h("cn1", "cn2", c), h("cn3", "cn4", c), h("cf1", "cf2", c), h("cf3", "cf4", c);
  function h(f, p, _) {
    d(f, _), d(p, _);
  }
  function d(f, p) {
    n.push(0, 0, 0), r.push(p.r, p.g, p.b), a[f] === void 0 && (a[f] = []), a[f].push(n.length / 3 - 1);
  }
  t.addAttribute("position", new ke(n, 3)), t.addAttribute("color", new ke(r, 3)), Yt.call(this, t, i), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
}
al.prototype = Object.create(Yt.prototype);
al.prototype.constructor = al;
al.prototype.update = function() {
  var e, t, i = new H(), n = new yn();
  function r(a, s, o, u) {
    i.set(s, o, u).unproject(n);
    var l = t[a];
    if (l !== void 0)
      for (var c = e.getAttribute("position"), h = 0, d = l.length; h < d; h++)
        c.setXYZ(l[h], i.x, i.y, i.z);
  }
  return function() {
    e = this.geometry, t = this.pointMap;
    var s = 1, o = 1;
    n.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -s, -o, -1), r("n2", s, -o, -1), r("n3", -s, o, -1), r("n4", s, o, -1), r("f1", -s, -o, 1), r("f2", s, -o, 1), r("f3", -s, o, 1), r("f4", s, o, 1), r("u1", s * 0.7, o * 1.1, -1), r("u2", -s * 0.7, o * 1.1, -1), r("u3", 0, o * 2, -1), r("cf1", -s, 0, 1), r("cf2", s, 0, 1), r("cf3", 0, -o, 1), r("cf4", 0, o, 1), r("cn1", -s, 0, -1), r("cn2", s, 0, -1), r("cn3", 0, -o, -1), r("cn4", 0, o, -1), e.getAttribute("position").needsUpdate = !0;
  };
}();
function ls(e, t) {
  this.object = e, t === void 0 && (t = 16776960);
  var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(8 * 3), r = new je();
  r.setIndex(new pt(i, 1)), r.addAttribute("position", new pt(n, 3)), Yt.call(this, r, new qt({ color: t })), this.matrixAutoUpdate = !1, this.update();
}
ls.prototype = Object.create(Yt.prototype);
ls.prototype.constructor = ls;
ls.prototype.update = function() {
  var e = new Gn();
  return function(i) {
    if (i !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && e.setFromObject(this.object), !e.isEmpty()) {
      var n = e.min, r = e.max, a = this.geometry.attributes.position, s = a.array;
      s[0] = r.x, s[1] = r.y, s[2] = r.z, s[3] = n.x, s[4] = r.y, s[5] = r.z, s[6] = n.x, s[7] = n.y, s[8] = r.z, s[9] = r.x, s[10] = n.y, s[11] = r.z, s[12] = r.x, s[13] = r.y, s[14] = n.z, s[15] = n.x, s[16] = r.y, s[17] = n.z, s[18] = n.x, s[19] = n.y, s[20] = n.z, s[21] = r.x, s[22] = n.y, s[23] = n.z, a.needsUpdate = !0, this.geometry.computeBoundingSphere();
    }
  };
}();
ls.prototype.setFromObject = function(e) {
  return this.object = e, this.update(), this;
};
function sl(e, t) {
  this.type = "Box3Helper", this.box = e;
  var i = t !== void 0 ? t : 16776960, n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], a = new je();
  a.setIndex(new pt(n, 1)), a.addAttribute("position", new ke(r, 3)), Yt.call(this, a, new qt({ color: i })), this.geometry.computeBoundingSphere();
}
sl.prototype = Object.create(Yt.prototype);
sl.prototype.constructor = sl;
sl.prototype.updateMatrixWorld = function(e) {
  var t = this.box;
  t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), Fe.prototype.updateMatrixWorld.call(this, e));
};
function ol(e, t, i) {
  this.type = "PlaneHelper", this.plane = e, this.size = t === void 0 ? 1 : t;
  var n = i !== void 0 ? i : 16776960, r = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], a = new je();
  a.addAttribute("position", new ke(r, 3)), a.computeBoundingSphere(), hr.call(this, a, new qt({ color: n }));
  var s = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], o = new je();
  o.addAttribute("position", new ke(s, 3)), o.computeBoundingSphere(), this.add(new fi(o, new Ei({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1 })));
}
ol.prototype = Object.create(hr.prototype);
ol.prototype.constructor = ol;
ol.prototype.updateMatrixWorld = function(e) {
  var t = -this.plane.constant;
  Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, t), this.children[0].material.side = t < 0 ? Ti : _l, this.lookAt(this.plane.normal), Fe.prototype.updateMatrixWorld.call(this, e);
};
var Gl, Jh;
function cs(e, t, i, n, r, a) {
  Fe.call(this), n === void 0 && (n = 16776960), i === void 0 && (i = 1), r === void 0 && (r = 0.2 * i), a === void 0 && (a = 0.2 * r), Gl === void 0 && (Gl = new je(), Gl.addAttribute("position", new ke([0, 0, 0, 0, 1, 0], 3)), Jh = new Vn(0, 0.5, 1, 5, 1), Jh.translate(0, -0.5, 0)), this.position.copy(t), this.line = new hr(Gl, new qt({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new fi(Jh, new Ei({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, a);
}
cs.prototype = Object.create(Fe.prototype);
cs.prototype.constructor = cs;
cs.prototype.setDirection = function() {
  var e = new H(), t;
  return function(n) {
    n.y > 0.99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -0.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t));
  };
}();
cs.prototype.setLength = function(e, t, i) {
  t === void 0 && (t = 0.2 * e), i === void 0 && (i = 0.2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix();
};
cs.prototype.setColor = function(e) {
  this.line.material.color.copy(e), this.cone.material.color.copy(e);
};
function ul(e) {
  e = e || 1;
  var t = [
    0,
    0,
    0,
    e,
    0,
    0,
    0,
    0,
    0,
    0,
    e,
    0,
    0,
    0,
    0,
    0,
    0,
    e
  ], i = [
    1,
    0,
    0,
    1,
    0.6,
    0,
    0,
    1,
    0,
    0.6,
    1,
    0,
    0,
    0,
    1,
    0,
    0.6,
    1
  ], n = new je();
  n.addAttribute("position", new ke(t, 3)), n.addAttribute("color", new ke(i, 3));
  var r = new qt({ vertexColors: ps });
  Yt.call(this, n, r);
}
ul.prototype = Object.create(Yt.prototype);
ul.prototype.constructor = ul;
function SE(e, t, i, n, r, a, s) {
  return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Bn(e, t, i, r, a, s);
}
var CE = 0, ME = 1;
function DE(e) {
  return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e;
}
function PE(e) {
  return e === void 0 && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
    return e.slice();
  }, e;
}
function LE(e, t) {
  return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Xs(e, t);
}
function RE(e) {
  return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Du(e);
}
function IE(e, t) {
  return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Xs(e, t);
}
function OE(e) {
  return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Xr(e);
}
function kE(e) {
  return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Xr(e);
}
function BE(e) {
  return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Xr(e);
}
function FE(e, t, i) {
  return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new H(e, t, i);
}
function NE(e, t) {
  return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new pt(e, t).setDynamic(!0);
}
function UE(e, t) {
  return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new bu(e, t);
}
function jE(e, t) {
  return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new xu(e, t);
}
function GE(e, t) {
  return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Au(e, t);
}
function VE(e, t) {
  return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Tu(e, t);
}
function HE(e, t) {
  return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Xa(e, t);
}
function zE(e, t) {
  return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Eu(e, t);
}
function WE(e, t) {
  return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Ya(e, t);
}
function qE(e, t) {
  return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new ke(e, t);
}
function XE(e, t) {
  return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new wu(e, t);
}
Ye.create = function(e, t) {
  return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Ye.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e;
};
Object.assign(kn.prototype, {
  createPointsGeometry: function(e) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var t = this.getPoints(e);
    return this.createGeometry(t);
  },
  createSpacedPointsGeometry: function(e) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var t = this.getSpacedPoints(e);
    return this.createGeometry(t);
  },
  createGeometry: function(e) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    for (var t = new tt(), i = 0, n = e.length; i < n; i++) {
      var r = e[i];
      t.vertices.push(new H(r.x, r.y, r.z || 0));
    }
    return t;
  }
});
Object.assign(Hr.prototype, {
  fromPoints: function(e) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e);
  }
});
function yy(e) {
  console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), zi.call(this, e), this.type = "catmullrom", this.closed = !0;
}
yy.prototype = Object.create(zi.prototype);
function _y(e) {
  console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), zi.call(this, e), this.type = "catmullrom";
}
_y.prototype = Object.create(zi.prototype);
function ip(e) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), zi.call(this, e), this.type = "catmullrom";
}
ip.prototype = Object.create(zi.prototype);
Object.assign(ip.prototype, {
  initFromArray: function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
});
function YE(e) {
  return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new ul(e);
}
function QE(e, t) {
  return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new ls(e, t);
}
function KE(e, t) {
  return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Yt(new so(e.geometry), new qt({ color: t !== void 0 ? t : 16777215 }));
}
rl.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
go.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
function ZE(e, t) {
  return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Yt(new Qs(e.geometry), new qt({ color: t !== void 0 ? t : 16777215 }));
}
Object.assign(fo.prototype, {
  extractUrlBase: function(e) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Xf.extractUrlBase(e);
  }
});
function JE(e) {
  return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new en(e);
}
function $E(e) {
  return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Hf(e);
}
Object.assign(tp.prototype, {
  center: function(e) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e);
  },
  empty: function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(e) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
  },
  size: function(e) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e);
  }
});
Object.assign(Gn.prototype, {
  center: function(e) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e);
  },
  empty: function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(e) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
  },
  isIntersectionSphere: function(e) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e);
  },
  size: function(e) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e);
  }
});
ks.prototype.center = function(e) {
  return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e);
};
Object.assign(gt, {
  random16: function() {
    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
  },
  nearestPowerOfTwo: function(e) {
    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), gt.floorPowerOfTwo(e);
  },
  nextPowerOfTwo: function(e) {
    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), gt.ceilPowerOfTwo(e);
  }
});
Object.assign(wi.prototype, {
  flattenToArrayOffset: function(e, t) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t);
  },
  multiplyVector3: function(e) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBuffer: function(e) {
    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }
});
Object.assign(at.prototype, {
  extractPosition: function(e) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e);
  },
  flattenToArrayOffset: function(e, t) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t);
  },
  getPosition: /* @__PURE__ */ function() {
    var e;
    return function() {
      return e === void 0 && (e = new H()), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3);
    };
  }(),
  setRotationFromQuaternion: function(e) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e);
  },
  multiplyToArray: function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function(e) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  multiplyVector4: function(e) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function(e) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this);
  },
  crossVector: function(e) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  translate: function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBuffer: function(e) {
    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function(e, t, i, n, r, a) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, a);
  }
});
Gr.prototype.isIntersectionLine = function(e) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e);
};
_i.prototype.multiplyVector3 = function(e) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this);
};
Object.assign(ms.prototype, {
  isIntersectionBox: function(e) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
  },
  isIntersectionPlane: function(e) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e);
  },
  isIntersectionSphere: function(e) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e);
  }
});
Object.assign(Sr.prototype, {
  area: function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  },
  barycoordFromPoint: function(e, t) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t);
  },
  midpoint: function(e) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e);
  },
  normal: function(e) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e);
  },
  plane: function(e) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e);
  }
});
Object.assign(Sr, {
  barycoordFromPoint: function(e, t, i, n, r) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Sr.getBarycoord(e, t, i, n, r);
  },
  normal: function(e, t, i, n) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Sr.getNormal(e, t, i, n);
  }
});
Object.assign(ua.prototype, {
  extractAllPoints: function(e) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e);
  },
  extrude: function(e) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ja(this, e);
  },
  makeGeometry: function(e) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new $a(this, e);
  }
});
Object.assign(ue.prototype, {
  fromAttribute: function(e, t, i) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i);
  },
  distanceToManhattan: function(e) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(H.prototype, {
  setEulerFromRotationMatrix: function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function(e) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e);
  },
  getScaleFromMatrix: function(e) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e);
  },
  getColumnFromMatrix: function(e, t) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e);
  },
  applyProjection: function(e) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e);
  },
  fromAttribute: function(e, t, i) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i);
  },
  distanceToManhattan: function(e) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(Ft.prototype, {
  fromAttribute: function(e, t, i) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(tt.prototype, {
  computeTangents: function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
});
Object.assign(Fe.prototype, {
  getChildByName: function(e) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e);
  },
  renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function(e, t) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e);
  },
  getWorldRotation: function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }
});
Object.defineProperties(Fe.prototype, {
  eulerOrder: {
    get: function() {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function(e) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Object.defineProperties(Pu.prototype, {
  objects: {
    get: function() {
      return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
    }
  }
});
Object.defineProperty(Lu.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
Object.defineProperty(Ye.prototype, "__arcLengthDivisions", {
  get: function() {
    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
  },
  set: function(e) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e;
  }
});
oi.prototype.setLens = function(e, t) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), t !== void 0 && (this.filmGauge = t), this.setFocalLength(e);
};
Object.defineProperties(ui.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e;
    }
  },
  shadowCameraLeft: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e;
    }
  },
  shadowCameraRight: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e;
    }
  },
  shadowCameraTop: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e;
    }
  },
  shadowCameraBottom: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e;
    }
  },
  shadowCameraNear: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e;
    }
  },
  shadowCameraFar: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(e) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(e) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e;
    }
  },
  shadowMapHeight: {
    set: function(e) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e;
    }
  }
});
Object.defineProperties(pt.prototype, {
  length: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  copyIndicesArray: function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }
});
Object.assign(je.prototype, {
  addIndex: function(e) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e);
  },
  addDrawCall: function(e, t, i) {
    i !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t);
  },
  clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  },
  computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }
});
Object.defineProperties(je.prototype, {
  drawcalls: {
    get: function() {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function() {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
});
Object.assign(_n.prototype, {
  getArrays: function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  },
  addShapeList: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  },
  addShape: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }
});
Object.defineProperties(Lc.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
    }
  }
});
Object.defineProperties(dt.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new We();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(e) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === Ef;
    }
  }
});
Object.defineProperties(Yr.prototype, {
  metal: {
    get: function() {
      return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(Mr.prototype, {
  derivatives: {
    get: function() {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function(e) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e;
    }
  }
});
Object.assign(mh.prototype, {
  animate: function(e) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e);
  },
  getCurrentRenderTarget: function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  },
  getMaxAnisotropy: function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  },
  resetGLState: function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  },
  supportsFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function(e) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e);
  },
  initMaterial: function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  }
});
Object.defineProperties(mh.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(Z0.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(Wa.prototype, {
  wrapS: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e;
    }
  },
  wrapT: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e;
    }
  },
  magFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e;
    }
  },
  minFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e;
    }
  },
  anisotropy: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e;
    }
  },
  offset: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e;
    }
  },
  repeat: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e;
    }
  },
  format: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e;
    }
  },
  type: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e;
    }
  },
  generateMipmaps: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e;
    }
  }
});
Object.defineProperties($0.prototype, {
  standing: {
    set: function() {
      console.warn("THREE.WebVRManager: .standing has been removed.");
    }
  }
});
po.prototype.load = function(e) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  var t = this, i = new Zf();
  return i.load(e, function(n) {
    t.setBuffer(n);
  }), this;
};
Jf.prototype.getData = function() {
  return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
};
el.prototype.updateCubeMap = function(e, t) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t);
};
var ew = {
  merge: function(e, t, i) {
    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
    var n;
    t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), n = t.matrix, t = t.geometry), e.merge(t, n, i);
  },
  center: function(e) {
    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center();
  }
}, tw = {
  crossOrigin: void 0,
  loadTexture: function(e, t, i, n) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var r = new gh();
    r.setCrossOrigin(this.crossOrigin);
    var a = r.load(e, i, void 0, n);
    return t && (a.mapping = t), a;
  },
  loadTextureCube: function(e, t, i, n) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var r = new zf();
    r.setCrossOrigin(this.crossOrigin);
    var a = r.load(e, i, void 0, n);
    return t && (a.mapping = t), a;
  },
  loadCompressedTexture: function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  },
  loadCompressedTextureCube: function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  }
};
function iw() {
  console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e, t) {
    console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t);
  }, this.unprojectVector = function(e, t) {
    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t);
  }, this.pickingRay = function() {
    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
  };
}
function rw() {
  console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {
  }, this.render = function() {
  }, this.setClearColor = function() {
  }, this.setSize = function() {
  };
}
var nw = {
  createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  },
  detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  },
  attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  }
};
function aw() {
  console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
}
const $v = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AddEquation: Pf,
  AddOperation: $g,
  AdditiveBlending: Sf,
  AlphaFormat: l0,
  AlwaysDepth: qg,
  AmbientLight: Tc,
  AnimationClip: Ir,
  AnimationMixer: Gd,
  AnimationObjectGroup: hy,
  AnimationUtils: ji,
  ArcCurve: lo,
  ArrayCamera: Cu,
  ArrowHelper: cs,
  Audio: po,
  AudioAnalyser: Jf,
  AudioContext: _h,
  AudioListener: Ud,
  AudioLoader: Zf,
  AxesHelper: ul,
  AxisHelper: YE,
  BackSide: Ti,
  BasicDepthPacking: F0,
  BasicShadowMap: Rx,
  BinaryTextureLoader: $E,
  Bone: hc,
  BooleanKeyframeTrack: Sc,
  BoundingBoxHelper: QE,
  Box2: tp,
  Box3: Gn,
  Box3Helper: sl,
  BoxBufferGeometry: Qa,
  BoxGeometry: la,
  BoxHelper: ls,
  BufferAttribute: pt,
  BufferGeometry: je,
  BufferGeometryLoader: qf,
  ByteType: r0,
  Cache: us,
  Camera: yn,
  CameraHelper: al,
  CanvasRenderer: rw,
  CanvasTexture: zs,
  CatmullRomCurve3: zi,
  CineonToneMapping: i0,
  CircleBufferGeometry: oo,
  CircleGeometry: Zu,
  ClampToEdgeWrapping: Er,
  Clock: py,
  ClosedSplineCurve3: yy,
  Color: We,
  ColorKeyframeTrack: Mc,
  CompressedTexture: Ys,
  CompressedTextureLoader: ay,
  ConeBufferGeometry: Ku,
  ConeGeometry: Qu,
  CubeCamera: el,
  CubeGeometry: la,
  CubeReflectionMapping: uh,
  CubeRefractionMapping: lc,
  CubeTexture: ca,
  CubeTextureLoader: zf,
  CubeUVReflectionMapping: lh,
  CubeUVRefractionMapping: ch,
  CubicBezierCurve: Qr,
  CubicBezierCurve3: xn,
  CubicInterpolant: Dc,
  CullFaceBack: Ed,
  CullFaceFront: Rg,
  CullFaceFrontBack: Dx,
  CullFaceNone: Lg,
  Curve: Ye,
  CurvePath: kn,
  CustomBlending: Df,
  CylinderBufferGeometry: Vn,
  CylinderGeometry: ts,
  Cylindrical: my,
  DataTexture: qa,
  DataTextureLoader: Hf,
  DefaultLoadingManager: pr,
  DepthFormat: Ba,
  DepthStencilFormat: Gs,
  DepthTexture: Ru,
  DirectionalLight: Ac,
  DirectionalLightHelper: xo,
  DirectionalLightShadow: xc,
  DiscreteInterpolant: Pc,
  DodecahedronBufferGeometry: $s,
  DodecahedronGeometry: Nu,
  DoubleSide: Io,
  DstAlphaFactor: jg,
  DstColorFactor: Vg,
  DynamicBufferAttribute: NE,
  EdgesGeometry: so,
  EdgesHelper: KE,
  EllipseCurve: Dr,
  EqualDepth: Yg,
  EquirectangularReflectionMapping: Of,
  EquirectangularRefractionMapping: cc,
  Euler: vs,
  EventDispatcher: Kn,
  ExtrudeBufferGeometry: _n,
  ExtrudeGeometry: Ja,
  Face3: Bn,
  Face4: SE,
  FaceColors: wf,
  FaceNormalsHelper: nl,
  FileLoader: en,
  FlatShading: Ef,
  Float32Attribute: qE,
  Float32BufferAttribute: ke,
  Float64Attribute: XE,
  Float64BufferAttribute: wu,
  FloatType: js,
  Fog: qs,
  FogExp2: Ws,
  Font: Kf,
  FontLoader: uy,
  FrontFaceDirectionCCW: Lx,
  FrontFaceDirectionCW: Px,
  FrontSide: _l,
  Frustum: vh,
  GammaEncoding: Uf,
  Geometry: tt,
  GeometryUtils: ew,
  GreaterDepth: Kg,
  GreaterEqualDepth: Qg,
  GridHelper: rl,
  Group: pc,
  HalfFloatType: ph,
  HemisphereLight: gc,
  HemisphereLightHelper: bo,
  IcosahedronBufferGeometry: Js,
  IcosahedronGeometry: Fu,
  ImageBitmapLoader: Nd,
  ImageLoader: Tl,
  ImageUtils: tw,
  ImmediateRenderObject: tl,
  InstancedBufferAttribute: zd,
  InstancedBufferGeometry: Vd,
  InstancedInterleavedBuffer: Hd,
  Int16Attribute: VE,
  Int16BufferAttribute: Tu,
  Int32Attribute: zE,
  Int32BufferAttribute: Eu,
  Int8Attribute: UE,
  Int8BufferAttribute: bu,
  IntType: a0,
  InterleavedBuffer: vo,
  InterleavedBufferAttribute: ep,
  Interpolant: Cr,
  InterpolateDiscrete: gu,
  InterpolateLinear: uu,
  InterpolateSmooth: ec,
  JSONLoader: Yf,
  KeyframeTrack: Si,
  LOD: Pu,
  LatheBufferGeometry: ao,
  LatheGeometry: Yu,
  Layers: Gf,
  LensFlare: aw,
  LessDepth: Xg,
  LessEqualDepth: uc,
  Light: ui,
  LightShadow: gs,
  Line: hr,
  Line3: ks,
  LineBasicMaterial: qt,
  LineCurve: fr,
  LineCurve3: Kr,
  LineDashedMaterial: os,
  LineLoop: fc,
  LinePieces: ME,
  LineSegments: Yt,
  LineStrip: CE,
  LinearEncoding: _u,
  LinearFilter: Gi,
  LinearInterpolant: $u,
  LinearMipMapLinearFilter: Al,
  LinearMipMapNearestFilter: Bf,
  LinearToneMapping: If,
  Loader: fo,
  LoaderUtils: Xf,
  LoadingManager: Vf,
  LogLuvEncoding: kx,
  LoopOnce: C0,
  LoopPingPong: D0,
  LoopRepeat: M0,
  LuminanceAlphaFormat: h0,
  LuminanceFormat: c0,
  MOUSE: Mx,
  Material: dt,
  MaterialLoader: yh,
  Math: gt,
  Matrix3: wi,
  Matrix4: at,
  MaxEquation: Sd,
  Mesh: fi,
  MeshBasicMaterial: Ei,
  MeshDepthMaterial: ha,
  MeshDistanceMaterial: da,
  MeshFaceMaterial: DE,
  MeshLambertMaterial: ss,
  MeshNormalMaterial: as,
  MeshPhongMaterial: Yr,
  MeshPhysicalMaterial: rs,
  MeshStandardMaterial: bn,
  MeshToonMaterial: ns,
  MinEquation: wd,
  MirroredRepeatWrapping: Va,
  MixOperation: Jg,
  MultiMaterial: PE,
  MultiplyBlending: Mf,
  MultiplyOperation: xl,
  NearestFilter: wr,
  NearestMipMapLinearFilter: dh,
  NearestMipMapNearestFilter: hh,
  NeverDepth: Wg,
  NoBlending: oc,
  NoColors: sh,
  NoToneMapping: $l,
  NormalBlending: bl,
  NotEqualDepth: Zg,
  NumberKeyframeTrack: co,
  Object3D: Fe,
  ObjectLoader: oy,
  OctahedronBufferGeometry: Za,
  OctahedronGeometry: Bu,
  OneFactor: Fg,
  OneMinusDstAlphaFactor: Gg,
  OneMinusDstColorFactor: Hg,
  OneMinusSrcAlphaFactor: Rf,
  OneMinusSrcColorFactor: Ug,
  OrthographicCamera: Hs,
  PCFShadowMap: Tf,
  PCFSoftShadowMap: Ig,
  ParametricBufferGeometry: Ks,
  ParametricGeometry: Iu,
  Particle: RE,
  ParticleBasicMaterial: kE,
  ParticleSystem: IE,
  ParticleSystemMaterial: BE,
  Path: Hr,
  PerspectiveCamera: oi,
  Plane: Gr,
  PlaneBufferGeometry: Ka,
  PlaneGeometry: Su,
  PlaneHelper: ol,
  PointCloud: LE,
  PointCloudMaterial: OE,
  PointLight: bc,
  PointLightHelper: yo,
  Points: Xs,
  PointsMaterial: Xr,
  PolarGridHelper: Rc,
  PolyhedronBufferGeometry: dr,
  PolyhedronGeometry: Ou,
  PositionalAudio: jd,
  Projector: iw,
  PropertyBinding: Vi,
  PropertyMixer: $f,
  QuadraticBezierCurve: Zr,
  QuadraticBezierCurve3: An,
  Quaternion: _i,
  QuaternionKeyframeTrack: Ju,
  QuaternionLinearInterpolant: Cc,
  REVISION: Pg,
  RGBADepthPacking: N0,
  RGBAFormat: gn,
  RGBA_ASTC_10x10_Format: E0,
  RGBA_ASTC_10x5_Format: x0,
  RGBA_ASTC_10x6_Format: A0,
  RGBA_ASTC_10x8_Format: T0,
  RGBA_ASTC_12x10_Format: w0,
  RGBA_ASTC_12x12_Format: S0,
  RGBA_ASTC_4x4_Format: f0,
  RGBA_ASTC_5x4_Format: p0,
  RGBA_ASTC_5x5_Format: v0,
  RGBA_ASTC_6x5_Format: m0,
  RGBA_ASTC_6x6_Format: g0,
  RGBA_ASTC_8x5_Format: y0,
  RGBA_ASTC_8x6_Format: _0,
  RGBA_ASTC_8x8_Format: b0,
  RGBA_PVRTC_2BPPV1_Format: Od,
  RGBA_PVRTC_4BPPV1_Format: Id,
  RGBA_S3TC_DXT1_Format: Md,
  RGBA_S3TC_DXT3_Format: Dd,
  RGBA_S3TC_DXT5_Format: Pd,
  RGBDEncoding: B0,
  RGBEEncoding: I0,
  RGBEFormat: Ox,
  RGBFormat: Ha,
  RGBM16Encoding: k0,
  RGBM7Encoding: O0,
  RGB_ETC1_Format: d0,
  RGB_PVRTC_2BPPV1_Format: Rd,
  RGB_PVRTC_4BPPV1_Format: Ld,
  RGB_S3TC_DXT1_Format: Cd,
  RawShaderMaterial: uo,
  Ray: ms,
  Raycaster: fy,
  RectAreaLight: Ec,
  RectAreaLightHelper: _o,
  ReinhardToneMapping: e0,
  RepeatWrapping: In,
  ReverseSubtractEquation: kg,
  RingBufferGeometry: no,
  RingGeometry: Xu,
  Scene: Mu,
  SceneUtils: nw,
  ShaderChunk: Ot,
  ShaderLib: Fa,
  ShaderMaterial: Mr,
  ShadowMaterial: is,
  Shape: ua,
  ShapeBufferGeometry: es,
  ShapeGeometry: $a,
  ShapePath: Qf,
  ShapeUtils: Fn,
  ShortType: n0,
  Skeleton: Lu,
  SkeletonHelper: go,
  SkinnedMesh: dc,
  SmoothShading: Ix,
  Sphere: qr,
  SphereBufferGeometry: pa,
  SphereGeometry: On,
  Spherical: vy,
  SphericalReflectionMapping: kf,
  Spline: ip,
  SplineCurve: Jr,
  SplineCurve3: _y,
  SpotLight: _c,
  SpotLightHelper: mo,
  SpotLightShadow: yc,
  Sprite: Du,
  SpriteMaterial: fa,
  SrcAlphaFactor: Lf,
  SrcAlphaSaturateFactor: zg,
  SrcColorFactor: Ng,
  StereoCamera: ly,
  StringKeyframeTrack: wc,
  SubtractEquation: Og,
  SubtractiveBlending: Cf,
  TetrahedronBufferGeometry: Zs,
  TetrahedronGeometry: ku,
  TextBufferGeometry: ro,
  TextGeometry: qu,
  Texture: ri,
  TextureLoader: gh,
  TorusBufferGeometry: io,
  TorusGeometry: Gu,
  TorusKnotBufferGeometry: to,
  TorusKnotGeometry: ju,
  Triangle: Sr,
  TriangleFanDrawMode: L0,
  TriangleStripDrawMode: P0,
  TrianglesDrawMode: Nf,
  TubeBufferGeometry: eo,
  TubeGeometry: Uu,
  UVMapping: oh,
  Uint16Attribute: HE,
  Uint16BufferAttribute: Xa,
  Uint32Attribute: WE,
  Uint32BufferAttribute: Ya,
  Uint8Attribute: jE,
  Uint8BufferAttribute: xu,
  Uint8ClampedAttribute: GE,
  Uint8ClampedBufferAttribute: Au,
  Uncharted2ToneMapping: t0,
  Uniform: Lc,
  UniformsLib: Xe,
  UniformsUtils: sr,
  UnsignedByteType: fh,
  UnsignedInt248Type: mu,
  UnsignedIntType: Ff,
  UnsignedShort4444Type: s0,
  UnsignedShort5551Type: o0,
  UnsignedShort565Type: u0,
  UnsignedShortType: vu,
  Vector2: ue,
  Vector3: H,
  Vector4: Ft,
  VectorKeyframeTrack: ho,
  Vertex: FE,
  VertexColors: ps,
  VertexNormalsHelper: il,
  VideoTexture: vc,
  WebGLRenderTarget: Wa,
  WebGLRenderTargetCube: Vs,
  WebGLRenderer: mh,
  WebGLUtils: J0,
  WireframeGeometry: Qs,
  WireframeHelper: ZE,
  WrapAroundEnding: yu,
  XHRLoader: JE,
  ZeroCurvatureEnding: za,
  ZeroFactor: Bg,
  ZeroSlopeEnding: Ra,
  sRGBEncoding: R0
}, Symbol.toStringTag, { value: "Module" }));
var by = { exports: {} };
/**
 * @license
 * webvr-polyfill
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function(e, t) {
  /**
   * @license
   * cardboard-vr-display
   * Copyright (c) 2015-2017 Google
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * @license
   * webvr-polyfill-dpdb 
   * Copyright (c) 2017 Google
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * @license
   * wglu-preserve-state
   * Copyright (c) 2016, Brandon Jones.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  /**
   * @license
   * nosleep.js
   * Copyright (c) 2017, Rich Tibbett
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  (function(i, n) {
    e.exports = n();
  })(ka, function() {
    var i = typeof window < "u" ? window : typeof ka < "u" ? ka : typeof self < "u" ? self : {};
    function n(m) {
      return m && m.__esModule && Object.prototype.hasOwnProperty.call(m, "default") ? m.default : m;
    }
    function r(m, x) {
      return x = { exports: {} }, m(x, x.exports), x.exports;
    }
    var a = function() {
      return /Android/i.test(navigator.userAgent) || /iPhone|iPad|iPod/i.test(navigator.userAgent);
    }, s = function(x, E) {
      for (var M = 0, C = x.length; M < C; M++)
        E[M] = x[M];
    }, o = function(x, E) {
      for (var M in E)
        E.hasOwnProperty(M) && (x[M] = E[M]);
      return x;
    }, u = r(function(m, x) {
      /**
       * @license
       * cardboard-vr-display
       * Copyright (c) 2015-2017 Google
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * gl-preserve-state
       * Copyright (c) 2016, Brandon Jones.
       *
       * Permission is hereby granted, free of charge, to any person obtaining a copy
       * of this software and associated documentation files (the "Software"), to deal
       * in the Software without restriction, including without limitation the rights
       * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       * copies of the Software, and to permit persons to whom the Software is
       * furnished to do so, subject to the following conditions:
       *
       * The above copyright notice and this permission notice shall be included in
       * all copies or substantial portions of the Software.
       *
       * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       * THE SOFTWARE.
       */
      /**
       * @license
       * webvr-polyfill-dpdb
       * Copyright (c) 2015-2017 Google
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * nosleep.js
       * Copyright (c) 2017, Rich Tibbett
       *
       * Permission is hereby granted, free of charge, to any person obtaining a copy
       * of this software and associated documentation files (the "Software"), to deal
       * in the Software without restriction, including without limitation the rights
       * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       * copies of the Software, and to permit persons to whom the Software is
       * furnished to do so, subject to the following conditions:
       *
       * The above copyright notice and this permission notice shall be included in
       * all copies or substantial portions of the Software.
       *
       * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       * THE SOFTWARE.
       */
      (function(E, M) {
        m.exports = M();
      })(i, function() {
        var E = function(A, T) {
          if (!(A instanceof T))
            throw new TypeError("Cannot call a class as a function");
        }, M = /* @__PURE__ */ function() {
          function A(T, D) {
            for (var L = 0; L < D.length; L++) {
              var U = D[L];
              U.enumerable = U.enumerable || !1, U.configurable = !0, "value" in U && (U.writable = !0), Object.defineProperty(T, U.key, U);
            }
          }
          return function(T, D, L) {
            return D && A(T.prototype, D), L && A(T, L), T;
          };
        }(), C = /* @__PURE__ */ function() {
          function A(T, D) {
            var L = [], U = !0, J = !1, re = void 0;
            try {
              for (var me = T[Symbol.iterator](), ve; !(U = (ve = me.next()).done) && (L.push(ve.value), !(D && L.length === D)); U = !0)
                ;
            } catch (ne) {
              J = !0, re = ne;
            } finally {
              try {
                !U && me.return && me.return();
              } finally {
                if (J) throw re;
              }
            }
            return L;
          }
          return function(T, D) {
            if (Array.isArray(T))
              return T;
            if (Symbol.iterator in Object(T))
              return A(T, D);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), R = 1e-3, k = 1, F = function(T, D) {
          return "data:" + T + "," + encodeURIComponent(D);
        }, B = function(T, D, L) {
          return T + (D - T) * L;
        }, I = function() {
          var A = /iPad|iPhone|iPod/.test(navigator.platform);
          return function() {
            return A;
          };
        }(), V = function() {
          var A = navigator.userAgent.indexOf("Version") !== -1 && navigator.userAgent.indexOf("Android") !== -1 && navigator.userAgent.indexOf("Chrome") !== -1;
          return function() {
            return A;
          };
        }(), Q = function() {
          var A = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          return function() {
            return A;
          };
        }(), ee = function() {
          var A = navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
          return function() {
            return A;
          };
        }(), oe = function() {
          var A = navigator.userAgent.match(/.*Chrome\/([0-9]+)/), T = A ? parseInt(A[1], 10) : null;
          return function() {
            return T;
          };
        }(), fe = function() {
          var A = !1;
          return A = I() && Q() && navigator.userAgent.indexOf("13_4") !== -1, function() {
            return A;
          };
        }(), he = function() {
          var A = !1;
          if (oe() === 65) {
            var T = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
            if (T) {
              var D = T[1].split("."), L = C(D, 4);
              L[0], L[1];
              var U = L[2], J = L[3];
              A = parseInt(U, 10) === 3325 && parseInt(J, 10) < 148;
            }
          }
          return function() {
            return A;
          };
        }(), de = function() {
          var A = navigator.userAgent.indexOf("R7 Build") !== -1;
          return function() {
            return A;
          };
        }(), G = function() {
          var T = window.orientation == 90 || window.orientation == -90;
          return de() ? !T : T;
        }, j = function(T) {
          return !(isNaN(T) || T <= R || T > k);
        }, se = function() {
          return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
        }, ie = function() {
          return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
        }, Ce = function(T) {
          if (V())
            return !1;
          if (T.requestFullscreen)
            T.requestFullscreen();
          else if (T.webkitRequestFullscreen)
            T.webkitRequestFullscreen();
          else if (T.mozRequestFullScreen)
            T.mozRequestFullScreen();
          else if (T.msRequestFullscreen)
            T.msRequestFullscreen();
          else
            return !1;
          return !0;
        }, K = function() {
          if (document.exitFullscreen)
            document.exitFullscreen();
          else if (document.webkitExitFullscreen)
            document.webkitExitFullscreen();
          else if (document.mozCancelFullScreen)
            document.mozCancelFullScreen();
          else if (document.msExitFullscreen)
            document.msExitFullscreen();
          else
            return !1;
          return !0;
        }, xe = function() {
          return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        }, pe = function(T, D, L, U) {
          var J = T.createShader(T.VERTEX_SHADER);
          T.shaderSource(J, D), T.compileShader(J);
          var re = T.createShader(T.FRAGMENT_SHADER);
          T.shaderSource(re, L), T.compileShader(re);
          var me = T.createProgram();
          T.attachShader(me, J), T.attachShader(me, re);
          for (var ve in U)
            T.bindAttribLocation(me, U[ve], ve);
          return T.linkProgram(me), T.deleteShader(J), T.deleteShader(re), me;
        }, Re = function(T, D) {
          for (var L = {}, U = T.getProgramParameter(D, T.ACTIVE_UNIFORMS), J = "", re = 0; re < U; re++) {
            var me = T.getActiveUniform(D, re);
            J = me.name.replace("[0]", ""), L[J] = T.getUniformLocation(D, J);
          }
          return L;
        }, _e = function(T, D, L, U, J, re, me) {
          var ve = 1 / (D - L), ne = 1 / (U - J), le = 1 / (re - me);
          return T[0] = -2 * ve, T[1] = 0, T[2] = 0, T[3] = 0, T[4] = 0, T[5] = -2 * ne, T[6] = 0, T[7] = 0, T[8] = 0, T[9] = 0, T[10] = 2 * le, T[11] = 0, T[12] = (D + L) * ve, T[13] = (J + U) * ne, T[14] = (me + re) * le, T[15] = 1, T;
        }, Le = function() {
          var T = !1;
          return function(D) {
            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(D) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(D.substr(0, 4))) && (T = !0);
          }(navigator.userAgent || navigator.vendor || window.opera), T;
        }, Ve = function(T, D) {
          for (var L in D)
            D.hasOwnProperty(L) && (T[L] = D[L]);
          return T;
        }, ft = function(T) {
          if (I()) {
            var D = T.style.width, L = T.style.height;
            T.style.width = parseInt(D) + 1 + "px", T.style.height = parseInt(L) + "px", setTimeout(function() {
              T.style.width = D, T.style.height = L;
            }, 100);
          }
          window.canvas = T;
        }, Ee = function() {
          var A = Math.PI / 180, T = Math.PI * 0.25;
          function D(ne, le, be, Ge) {
            var qe = Math.tan(le ? le.upDegrees * A : T), rt = Math.tan(le ? le.downDegrees * A : T), At = Math.tan(le ? le.leftDegrees * A : T), ot = Math.tan(le ? le.rightDegrees * A : T), ut = 2 / (At + ot), Ht = 2 / (qe + rt);
            return ne[0] = ut, ne[1] = 0, ne[2] = 0, ne[3] = 0, ne[4] = 0, ne[5] = Ht, ne[6] = 0, ne[7] = 0, ne[8] = -((At - ot) * ut * 0.5), ne[9] = (qe - rt) * Ht * 0.5, ne[10] = Ge / (be - Ge), ne[11] = -1, ne[12] = 0, ne[13] = 0, ne[14] = Ge * be / (be - Ge), ne[15] = 0, ne;
          }
          function L(ne, le, be) {
            var Ge = le[0], qe = le[1], rt = le[2], At = le[3], ot = Ge + Ge, ut = qe + qe, Ht = rt + rt, ni = Ge * ot, yi = Ge * ut, ti = Ge * Ht, Mi = qe * ut, qi = qe * Ht, Xi = rt * Ht, Yi = At * ot, Di = At * ut, br = At * Ht;
            return ne[0] = 1 - (Mi + Xi), ne[1] = yi + br, ne[2] = ti - Di, ne[3] = 0, ne[4] = yi - br, ne[5] = 1 - (ni + Xi), ne[6] = qi + Yi, ne[7] = 0, ne[8] = ti + Di, ne[9] = qi - Yi, ne[10] = 1 - (ni + Mi), ne[11] = 0, ne[12] = be[0], ne[13] = be[1], ne[14] = be[2], ne[15] = 1, ne;
          }
          function U(ne, le, be) {
            var Ge = be[0], qe = be[1], rt = be[2], At, ot, ut, Ht, ni, yi, ti, Mi, qi, Xi, Yi, Di;
            return le === ne ? (ne[12] = le[0] * Ge + le[4] * qe + le[8] * rt + le[12], ne[13] = le[1] * Ge + le[5] * qe + le[9] * rt + le[13], ne[14] = le[2] * Ge + le[6] * qe + le[10] * rt + le[14], ne[15] = le[3] * Ge + le[7] * qe + le[11] * rt + le[15]) : (At = le[0], ot = le[1], ut = le[2], Ht = le[3], ni = le[4], yi = le[5], ti = le[6], Mi = le[7], qi = le[8], Xi = le[9], Yi = le[10], Di = le[11], ne[0] = At, ne[1] = ot, ne[2] = ut, ne[3] = Ht, ne[4] = ni, ne[5] = yi, ne[6] = ti, ne[7] = Mi, ne[8] = qi, ne[9] = Xi, ne[10] = Yi, ne[11] = Di, ne[12] = At * Ge + ni * qe + qi * rt + le[12], ne[13] = ot * Ge + yi * qe + Xi * rt + le[13], ne[14] = ut * Ge + ti * qe + Yi * rt + le[14], ne[15] = Ht * Ge + Mi * qe + Di * rt + le[15]), ne;
          }
          function J(ne, le) {
            var be = le[0], Ge = le[1], qe = le[2], rt = le[3], At = le[4], ot = le[5], ut = le[6], Ht = le[7], ni = le[8], yi = le[9], ti = le[10], Mi = le[11], qi = le[12], Xi = le[13], Yi = le[14], Di = le[15], br = be * ot - Ge * At, _a = be * ut - qe * At, ba = be * Ht - rt * At, Sn = Ge * ut - qe * ot, xa = Ge * Ht - rt * ot, Cn = qe * Ht - rt * ut, Aa = ni * Xi - yi * qi, Ta = ni * Yi - ti * qi, Ea = ni * Di - Mi * qi, Ur = yi * Yi - ti * Xi, Lr = yi * Di - Mi * Xi, on = ti * Di - Mi * Yi, zt = br * on - _a * Lr + ba * Ur + Sn * Ea - xa * Ta + Cn * Aa;
            return zt ? (zt = 1 / zt, ne[0] = (ot * on - ut * Lr + Ht * Ur) * zt, ne[1] = (qe * Lr - Ge * on - rt * Ur) * zt, ne[2] = (Xi * Cn - Yi * xa + Di * Sn) * zt, ne[3] = (ti * xa - yi * Cn - Mi * Sn) * zt, ne[4] = (ut * Ea - At * on - Ht * Ta) * zt, ne[5] = (be * on - qe * Ea + rt * Ta) * zt, ne[6] = (Yi * ba - qi * Cn - Di * _a) * zt, ne[7] = (ni * Cn - ti * ba + Mi * _a) * zt, ne[8] = (At * Lr - ot * Ea + Ht * Aa) * zt, ne[9] = (Ge * Ea - be * Lr - rt * Aa) * zt, ne[10] = (qi * xa - Xi * ba + Di * br) * zt, ne[11] = (yi * ba - ni * xa - Mi * br) * zt, ne[12] = (ot * Ta - At * Ur - ut * Aa) * zt, ne[13] = (be * Ur - Ge * Ta + qe * Aa) * zt, ne[14] = (Xi * _a - qi * Sn - Yi * br) * zt, ne[15] = (ni * Sn - yi * _a + ti * br) * zt, ne) : null;
          }
          var re = new Float32Array([0, 0, 0, 1]), me = new Float32Array([0, 0, 0]);
          function ve(ne, le, be, Ge, qe, rt) {
            D(ne, Ge || null, rt.depthNear, rt.depthFar);
            var At = be.orientation || re, ot = be.position || me;
            L(le, At, ot), qe && U(le, le, qe), J(le, le);
          }
          return function(ne, le, be) {
            return !ne || !le ? !1 : (ne.pose = le, ne.timestamp = le.timestamp, ve(ne.leftProjectionMatrix, ne.leftViewMatrix, le, be._getFieldOfView("left"), be._getEyeOffset("left"), be), ve(ne.rightProjectionMatrix, ne.rightViewMatrix, le, be._getFieldOfView("right"), be._getEyeOffset("right"), be), !0);
          };
        }(), ct = function() {
          var T = window.self !== window.top, D = kt(document.referrer), L = kt(window.location.href);
          return T && D !== L;
        }, kt = function(T) {
          var D, L = T.indexOf("://");
          L !== -1 ? D = L + 3 : D = 0;
          var U = T.indexOf("/", D);
          return U === -1 && (U = T.length), T.substring(0, U);
        }, Mt = function(T) {
          if (T.w > 1)
            return console.warn("getQuaternionAngle: w > 1"), 0;
          var D = 2 * Math.acos(T.w);
          return D;
        }, Vt = /* @__PURE__ */ function() {
          var A = {};
          return function(T, D) {
            A[T] === void 0 && (console.warn("webvr-polyfill: " + D), A[T] = !0);
          };
        }(), yt = function(T, D) {
          var L = D ? "Please use " + D + " instead." : "";
          Vt(T, T + " has been deprecated. This may not work on native WebVR displays. " + L);
        };
        function jt(A, T, D) {
          if (!T) {
            D(A);
            return;
          }
          for (var L = [], U = null, J = 0; J < T.length; ++J) {
            var re = T[J];
            switch (re) {
              case A.TEXTURE_BINDING_2D:
              case A.TEXTURE_BINDING_CUBE_MAP:
                var me = T[++J];
                if (me < A.TEXTURE0 || me > A.TEXTURE31) {
                  console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit"), L.push(null, null);
                  break;
                }
                U || (U = A.getParameter(A.ACTIVE_TEXTURE)), A.activeTexture(me), L.push(A.getParameter(re), null);
                break;
              case A.ACTIVE_TEXTURE:
                U = A.getParameter(A.ACTIVE_TEXTURE), L.push(null);
                break;
              default:
                L.push(A.getParameter(re));
                break;
            }
          }
          D(A);
          for (var J = 0; J < T.length; ++J) {
            var re = T[J], ve = L[J];
            switch (re) {
              case A.ACTIVE_TEXTURE:
                break;
              case A.ARRAY_BUFFER_BINDING:
                A.bindBuffer(A.ARRAY_BUFFER, ve);
                break;
              case A.COLOR_CLEAR_VALUE:
                A.clearColor(ve[0], ve[1], ve[2], ve[3]);
                break;
              case A.COLOR_WRITEMASK:
                A.colorMask(ve[0], ve[1], ve[2], ve[3]);
                break;
              case A.CURRENT_PROGRAM:
                A.useProgram(ve);
                break;
              case A.ELEMENT_ARRAY_BUFFER_BINDING:
                A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, ve);
                break;
              case A.FRAMEBUFFER_BINDING:
                A.bindFramebuffer(A.FRAMEBUFFER, ve);
                break;
              case A.RENDERBUFFER_BINDING:
                A.bindRenderbuffer(A.RENDERBUFFER, ve);
                break;
              case A.TEXTURE_BINDING_2D:
                var me = T[++J];
                if (me < A.TEXTURE0 || me > A.TEXTURE31)
                  break;
                A.activeTexture(me), A.bindTexture(A.TEXTURE_2D, ve);
                break;
              case A.TEXTURE_BINDING_CUBE_MAP:
                var me = T[++J];
                if (me < A.TEXTURE0 || me > A.TEXTURE31)
                  break;
                A.activeTexture(me), A.bindTexture(A.TEXTURE_CUBE_MAP, ve);
                break;
              case A.VIEWPORT:
                A.viewport(ve[0], ve[1], ve[2], ve[3]);
                break;
              case A.BLEND:
              case A.CULL_FACE:
              case A.DEPTH_TEST:
              case A.SCISSOR_TEST:
              case A.STENCIL_TEST:
                ve ? A.enable(re) : A.disable(re);
                break;
              default:
                console.log("No GL restore behavior for 0x" + re.toString(16));
                break;
            }
            U && A.activeTexture(U);
          }
        }
        var Et = jt, gr = ["attribute vec2 position;", "attribute vec3 texCoord;", "varying vec2 vTexCoord;", "uniform vec4 viewportOffsetScale[2];", "void main() {", "  vec4 viewport = viewportOffsetScale[int(texCoord.z)];", "  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;", "  gl_Position = vec4( position, 1.0, 1.0 );", "}"].join(`
`), xt = ["precision mediump float;", "uniform sampler2D diffuse;", "varying vec2 vTexCoord;", "void main() {", "  gl_FragColor = texture2D(diffuse, vTexCoord);", "}"].join(`
`);
        function ci(A, T, D, L) {
          this.gl = A, this.cardboardUI = T, this.bufferScale = D, this.dirtySubmitFrameBindings = L, this.ctxAttribs = A.getContextAttributes(), this.instanceExt = A.getExtension("ANGLE_instanced_arrays"), this.meshWidth = 20, this.meshHeight = 20, this.bufferWidth = A.drawingBufferWidth, this.bufferHeight = A.drawingBufferHeight, this.realBindFramebuffer = A.bindFramebuffer, this.realEnable = A.enable, this.realDisable = A.disable, this.realColorMask = A.colorMask, this.realClearColor = A.clearColor, this.realViewport = A.viewport, I() || (this.realCanvasWidth = Object.getOwnPropertyDescriptor(A.canvas.__proto__, "width"), this.realCanvasHeight = Object.getOwnPropertyDescriptor(A.canvas.__proto__, "height")), this.isPatched = !1, this.lastBoundFramebuffer = null, this.cullFace = !1, this.depthTest = !1, this.blend = !1, this.scissorTest = !1, this.stencilTest = !1, this.viewport = [0, 0, 0, 0], this.colorMask = [!0, !0, !0, !0], this.clearColor = [0, 0, 0, 0], this.attribs = {
            position: 0,
            texCoord: 1
          }, this.program = pe(A, gr, xt, this.attribs), this.uniforms = Re(A, this.program), this.viewportOffsetScale = new Float32Array(8), this.setTextureBounds(), this.vertexBuffer = A.createBuffer(), this.indexBuffer = A.createBuffer(), this.indexCount = 0, this.renderTarget = A.createTexture(), this.framebuffer = A.createFramebuffer(), this.depthStencilBuffer = null, this.depthBuffer = null, this.stencilBuffer = null, this.ctxAttribs.depth && this.ctxAttribs.stencil ? this.depthStencilBuffer = A.createRenderbuffer() : this.ctxAttribs.depth ? this.depthBuffer = A.createRenderbuffer() : this.ctxAttribs.stencil && (this.stencilBuffer = A.createRenderbuffer()), this.patch(), this.onResize();
        }
        ci.prototype.destroy = function() {
          var A = this.gl;
          this.unpatch(), A.deleteProgram(this.program), A.deleteBuffer(this.vertexBuffer), A.deleteBuffer(this.indexBuffer), A.deleteTexture(this.renderTarget), A.deleteFramebuffer(this.framebuffer), this.depthStencilBuffer && A.deleteRenderbuffer(this.depthStencilBuffer), this.depthBuffer && A.deleteRenderbuffer(this.depthBuffer), this.stencilBuffer && A.deleteRenderbuffer(this.stencilBuffer), this.cardboardUI && this.cardboardUI.destroy();
        }, ci.prototype.onResize = function() {
          var A = this.gl, T = this, D = [A.RENDERBUFFER_BINDING, A.TEXTURE_BINDING_2D, A.TEXTURE0];
          Et(A, D, function(L) {
            T.realBindFramebuffer.call(L, L.FRAMEBUFFER, null), T.scissorTest && T.realDisable.call(L, L.SCISSOR_TEST), T.realColorMask.call(L, !0, !0, !0, !0), T.realViewport.call(L, 0, 0, L.drawingBufferWidth, L.drawingBufferHeight), T.realClearColor.call(L, 0, 0, 0, 1), L.clear(L.COLOR_BUFFER_BIT), T.realBindFramebuffer.call(L, L.FRAMEBUFFER, T.framebuffer), L.bindTexture(L.TEXTURE_2D, T.renderTarget), L.texImage2D(L.TEXTURE_2D, 0, T.ctxAttribs.alpha ? L.RGBA : L.RGB, T.bufferWidth, T.bufferHeight, 0, T.ctxAttribs.alpha ? L.RGBA : L.RGB, L.UNSIGNED_BYTE, null), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_MAG_FILTER, L.LINEAR), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_MIN_FILTER, L.LINEAR), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_WRAP_S, L.CLAMP_TO_EDGE), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_WRAP_T, L.CLAMP_TO_EDGE), L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, T.renderTarget, 0), T.ctxAttribs.depth && T.ctxAttribs.stencil ? (L.bindRenderbuffer(L.RENDERBUFFER, T.depthStencilBuffer), L.renderbufferStorage(L.RENDERBUFFER, L.DEPTH_STENCIL, T.bufferWidth, T.bufferHeight), L.framebufferRenderbuffer(L.FRAMEBUFFER, L.DEPTH_STENCIL_ATTACHMENT, L.RENDERBUFFER, T.depthStencilBuffer)) : T.ctxAttribs.depth ? (L.bindRenderbuffer(L.RENDERBUFFER, T.depthBuffer), L.renderbufferStorage(L.RENDERBUFFER, L.DEPTH_COMPONENT16, T.bufferWidth, T.bufferHeight), L.framebufferRenderbuffer(L.FRAMEBUFFER, L.DEPTH_ATTACHMENT, L.RENDERBUFFER, T.depthBuffer)) : T.ctxAttribs.stencil && (L.bindRenderbuffer(L.RENDERBUFFER, T.stencilBuffer), L.renderbufferStorage(L.RENDERBUFFER, L.STENCIL_INDEX8, T.bufferWidth, T.bufferHeight), L.framebufferRenderbuffer(L.FRAMEBUFFER, L.STENCIL_ATTACHMENT, L.RENDERBUFFER, T.stencilBuffer)), !L.checkFramebufferStatus(L.FRAMEBUFFER) === L.FRAMEBUFFER_COMPLETE && console.error("Framebuffer incomplete!"), T.realBindFramebuffer.call(L, L.FRAMEBUFFER, T.lastBoundFramebuffer), T.scissorTest && T.realEnable.call(L, L.SCISSOR_TEST), T.realColorMask.apply(L, T.colorMask), T.realViewport.apply(L, T.viewport), T.realClearColor.apply(L, T.clearColor);
          }), this.cardboardUI && this.cardboardUI.onResize();
        }, ci.prototype.patch = function() {
          if (!this.isPatched) {
            var A = this, T = this.gl.canvas, D = this.gl;
            I() || (T.width = se() * this.bufferScale, T.height = ie() * this.bufferScale, Object.defineProperty(T, "width", {
              configurable: !0,
              enumerable: !0,
              get: function() {
                return A.bufferWidth;
              },
              set: function(U) {
                A.bufferWidth = U, A.realCanvasWidth.set.call(T, U), A.onResize();
              }
            }), Object.defineProperty(T, "height", {
              configurable: !0,
              enumerable: !0,
              get: function() {
                return A.bufferHeight;
              },
              set: function(U) {
                A.bufferHeight = U, A.realCanvasHeight.set.call(T, U), A.onResize();
              }
            })), this.lastBoundFramebuffer = D.getParameter(D.FRAMEBUFFER_BINDING), this.lastBoundFramebuffer == null && (this.lastBoundFramebuffer = this.framebuffer, this.gl.bindFramebuffer(D.FRAMEBUFFER, this.framebuffer)), this.gl.bindFramebuffer = function(L, U) {
              A.lastBoundFramebuffer = U || A.framebuffer, A.realBindFramebuffer.call(D, L, A.lastBoundFramebuffer);
            }, this.cullFace = D.getParameter(D.CULL_FACE), this.depthTest = D.getParameter(D.DEPTH_TEST), this.blend = D.getParameter(D.BLEND), this.scissorTest = D.getParameter(D.SCISSOR_TEST), this.stencilTest = D.getParameter(D.STENCIL_TEST), D.enable = function(L) {
              switch (L) {
                case D.CULL_FACE:
                  A.cullFace = !0;
                  break;
                case D.DEPTH_TEST:
                  A.depthTest = !0;
                  break;
                case D.BLEND:
                  A.blend = !0;
                  break;
                case D.SCISSOR_TEST:
                  A.scissorTest = !0;
                  break;
                case D.STENCIL_TEST:
                  A.stencilTest = !0;
                  break;
              }
              A.realEnable.call(D, L);
            }, D.disable = function(L) {
              switch (L) {
                case D.CULL_FACE:
                  A.cullFace = !1;
                  break;
                case D.DEPTH_TEST:
                  A.depthTest = !1;
                  break;
                case D.BLEND:
                  A.blend = !1;
                  break;
                case D.SCISSOR_TEST:
                  A.scissorTest = !1;
                  break;
                case D.STENCIL_TEST:
                  A.stencilTest = !1;
                  break;
              }
              A.realDisable.call(D, L);
            }, this.colorMask = D.getParameter(D.COLOR_WRITEMASK), D.colorMask = function(L, U, J, re) {
              A.colorMask[0] = L, A.colorMask[1] = U, A.colorMask[2] = J, A.colorMask[3] = re, A.realColorMask.call(D, L, U, J, re);
            }, this.clearColor = D.getParameter(D.COLOR_CLEAR_VALUE), D.clearColor = function(L, U, J, re) {
              A.clearColor[0] = L, A.clearColor[1] = U, A.clearColor[2] = J, A.clearColor[3] = re, A.realClearColor.call(D, L, U, J, re);
            }, this.viewport = D.getParameter(D.VIEWPORT), D.viewport = function(L, U, J, re) {
              A.viewport[0] = L, A.viewport[1] = U, A.viewport[2] = J, A.viewport[3] = re, A.realViewport.call(D, L, U, J, re);
            }, this.isPatched = !0, ft(T);
          }
        }, ci.prototype.unpatch = function() {
          if (this.isPatched) {
            var A = this.gl, T = this.gl.canvas;
            I() || (Object.defineProperty(T, "width", this.realCanvasWidth), Object.defineProperty(T, "height", this.realCanvasHeight)), T.width = this.bufferWidth, T.height = this.bufferHeight, A.bindFramebuffer = this.realBindFramebuffer, A.enable = this.realEnable, A.disable = this.realDisable, A.colorMask = this.realColorMask, A.clearColor = this.realClearColor, A.viewport = this.realViewport, this.lastBoundFramebuffer == this.framebuffer && A.bindFramebuffer(A.FRAMEBUFFER, null), this.isPatched = !1, setTimeout(function() {
              ft(T);
            }, 1);
          }
        }, ci.prototype.setTextureBounds = function(A, T) {
          A || (A = [0, 0, 0.5, 1]), T || (T = [0.5, 0, 0.5, 1]), this.viewportOffsetScale[0] = A[0], this.viewportOffsetScale[1] = A[1], this.viewportOffsetScale[2] = A[2], this.viewportOffsetScale[3] = A[3], this.viewportOffsetScale[4] = T[0], this.viewportOffsetScale[5] = T[1], this.viewportOffsetScale[6] = T[2], this.viewportOffsetScale[7] = T[3];
        }, ci.prototype.submitFrame = function() {
          var A = this.gl, T = this, D = [];
          if (this.dirtySubmitFrameBindings || D.push(A.CURRENT_PROGRAM, A.ARRAY_BUFFER_BINDING, A.ELEMENT_ARRAY_BUFFER_BINDING, A.TEXTURE_BINDING_2D, A.TEXTURE0), Et(A, D, function(U) {
            T.realBindFramebuffer.call(U, U.FRAMEBUFFER, null);
            var J = 0, re = 0;
            T.instanceExt && (J = U.getVertexAttrib(T.attribs.position, T.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE), re = U.getVertexAttrib(T.attribs.texCoord, T.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)), T.cullFace && T.realDisable.call(U, U.CULL_FACE), T.depthTest && T.realDisable.call(U, U.DEPTH_TEST), T.blend && T.realDisable.call(U, U.BLEND), T.scissorTest && T.realDisable.call(U, U.SCISSOR_TEST), T.stencilTest && T.realDisable.call(U, U.STENCIL_TEST), T.realColorMask.call(U, !0, !0, !0, !0), T.realViewport.call(U, 0, 0, U.drawingBufferWidth, U.drawingBufferHeight), (T.ctxAttribs.alpha || I()) && (T.realClearColor.call(U, 0, 0, 0, 1), U.clear(U.COLOR_BUFFER_BIT)), U.useProgram(T.program), U.bindBuffer(U.ELEMENT_ARRAY_BUFFER, T.indexBuffer), U.bindBuffer(U.ARRAY_BUFFER, T.vertexBuffer), U.enableVertexAttribArray(T.attribs.position), U.enableVertexAttribArray(T.attribs.texCoord), U.vertexAttribPointer(T.attribs.position, 2, U.FLOAT, !1, 20, 0), U.vertexAttribPointer(T.attribs.texCoord, 3, U.FLOAT, !1, 20, 8), T.instanceExt && (J != 0 && T.instanceExt.vertexAttribDivisorANGLE(T.attribs.position, 0), re != 0 && T.instanceExt.vertexAttribDivisorANGLE(T.attribs.texCoord, 0)), U.activeTexture(U.TEXTURE0), U.uniform1i(T.uniforms.diffuse, 0), U.bindTexture(U.TEXTURE_2D, T.renderTarget), U.uniform4fv(T.uniforms.viewportOffsetScale, T.viewportOffsetScale), U.drawElements(U.TRIANGLES, T.indexCount, U.UNSIGNED_SHORT, 0), T.cardboardUI && T.cardboardUI.renderNoState(), T.realBindFramebuffer.call(T.gl, U.FRAMEBUFFER, T.framebuffer), T.ctxAttribs.preserveDrawingBuffer || (T.realClearColor.call(U, 0, 0, 0, 0), U.clear(U.COLOR_BUFFER_BIT)), T.dirtySubmitFrameBindings || T.realBindFramebuffer.call(U, U.FRAMEBUFFER, T.lastBoundFramebuffer), T.cullFace && T.realEnable.call(U, U.CULL_FACE), T.depthTest && T.realEnable.call(U, U.DEPTH_TEST), T.blend && T.realEnable.call(U, U.BLEND), T.scissorTest && T.realEnable.call(U, U.SCISSOR_TEST), T.stencilTest && T.realEnable.call(U, U.STENCIL_TEST), T.realColorMask.apply(U, T.colorMask), T.realViewport.apply(U, T.viewport), (T.ctxAttribs.alpha || !T.ctxAttribs.preserveDrawingBuffer) && T.realClearColor.apply(U, T.clearColor), T.instanceExt && (J != 0 && T.instanceExt.vertexAttribDivisorANGLE(T.attribs.position, J), re != 0 && T.instanceExt.vertexAttribDivisorANGLE(T.attribs.texCoord, re));
          }), I()) {
            var L = A.canvas;
            (L.width != T.bufferWidth || L.height != T.bufferHeight) && (T.bufferWidth = L.width, T.bufferHeight = L.height, T.onResize());
          }
        }, ci.prototype.updateDeviceInfo = function(A) {
          var T = this.gl, D = this, L = [T.ARRAY_BUFFER_BINDING, T.ELEMENT_ARRAY_BUFFER_BINDING];
          Et(T, L, function(U) {
            var J = D.computeMeshVertices_(D.meshWidth, D.meshHeight, A);
            if (U.bindBuffer(U.ARRAY_BUFFER, D.vertexBuffer), U.bufferData(U.ARRAY_BUFFER, J, U.STATIC_DRAW), !D.indexCount) {
              var re = D.computeMeshIndices_(D.meshWidth, D.meshHeight);
              U.bindBuffer(U.ELEMENT_ARRAY_BUFFER, D.indexBuffer), U.bufferData(U.ELEMENT_ARRAY_BUFFER, re, U.STATIC_DRAW), D.indexCount = re.length;
            }
          });
        }, ci.prototype.computeMeshVertices_ = function(A, T, D) {
          for (var L = new Float32Array(2 * A * T * 5), U = D.getLeftEyeVisibleTanAngles(), J = D.getLeftEyeNoLensTanAngles(), re = D.getLeftEyeVisibleScreenRect(J), me = 0, ve = 0; ve < 2; ve++) {
            for (var ne = 0; ne < T; ne++)
              for (var le = 0; le < A; le++, me++) {
                var be = le / (A - 1), Ge = ne / (T - 1), qe = be, rt = Ge, At = B(U[0], U[2], be), ot = B(U[3], U[1], Ge), ut = Math.sqrt(At * At + ot * ot), Ht = D.distortion.distortInverse(ut), ni = At * Ht / ut, yi = ot * Ht / ut;
                be = (ni - J[0]) / (J[2] - J[0]), Ge = (yi - J[3]) / (J[1] - J[3]), be = (re.x + be * re.width - 0.5) * 2, Ge = (re.y + Ge * re.height - 0.5) * 2, L[me * 5 + 0] = be, L[me * 5 + 1] = Ge, L[me * 5 + 2] = qe, L[me * 5 + 3] = rt, L[me * 5 + 4] = ve;
              }
            var ti = U[2] - U[0];
            U[0] = -(ti + U[0]), U[2] = ti - U[2], ti = J[2] - J[0], J[0] = -(ti + J[0]), J[2] = ti - J[2], re.x = 1 - (re.x + re.width);
          }
          return L;
        }, ci.prototype.computeMeshIndices_ = function(A, T) {
          for (var D = new Uint16Array(2 * (A - 1) * (T - 1) * 6), L = A / 2, U = T / 2, J = 0, re = 0, me = 0; me < 2; me++)
            for (var ve = 0; ve < T; ve++)
              for (var ne = 0; ne < A; ne++, J++)
                ne == 0 || ve == 0 || (ne <= L == ve <= U ? (D[re++] = J, D[re++] = J - A - 1, D[re++] = J - A, D[re++] = J - A - 1, D[re++] = J, D[re++] = J - 1) : (D[re++] = J - 1, D[re++] = J - A, D[re++] = J, D[re++] = J - A, D[re++] = J - 1, D[re++] = J - A - 1));
          return D;
        }, ci.prototype.getOwnPropertyDescriptor_ = function(A, T) {
          var D = Object.getOwnPropertyDescriptor(A, T);
          return (D.get === void 0 || D.set === void 0) && (D.configurable = !0, D.enumerable = !0, D.get = function() {
            return this.getAttribute(T);
          }, D.set = function(L) {
            this.setAttribute(T, L);
          }), D;
        };
        var Gt = ["attribute vec2 position;", "uniform mat4 projectionMat;", "void main() {", "  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );", "}"].join(`
`), yr = ["precision mediump float;", "uniform vec4 color;", "void main() {", "  gl_FragColor = color;", "}"].join(`
`), gi = Math.PI / 180, ai = 60, ae = 12, Pe = 20, Ie = 1, Je = 0.75, Be = 0.3125, st = 4, Ne = 28, vt = 1.5;
        function Rt(A) {
          this.gl = A, this.attribs = {
            position: 0
          }, this.program = pe(A, Gt, yr, this.attribs), this.uniforms = Re(A, this.program), this.vertexBuffer = A.createBuffer(), this.gearOffset = 0, this.gearVertexCount = 0, this.arrowOffset = 0, this.arrowVertexCount = 0, this.projMat = new Float32Array(16), this.listener = null, this.onResize();
        }
        Rt.prototype.destroy = function() {
          var A = this.gl;
          this.listener && A.canvas.removeEventListener("click", this.listener, !1), A.deleteProgram(this.program), A.deleteBuffer(this.vertexBuffer);
        }, Rt.prototype.listen = function(A, T) {
          var D = this.gl.canvas;
          this.listener = function(L) {
            var U = D.clientWidth / 2, J = Ne * vt;
            L.clientX > U - J && L.clientX < U + J && L.clientY > D.clientHeight - J ? A(L) : L.clientX < J && L.clientY < J && T(L);
          }, D.addEventListener("click", this.listener, !1);
        }, Rt.prototype.onResize = function() {
          var A = this.gl, T = this, D = [A.ARRAY_BUFFER_BINDING];
          Et(A, D, function(L) {
            var U = [], J = L.drawingBufferWidth / 2, re = Math.max(screen.width, screen.height) * window.devicePixelRatio, me = L.drawingBufferWidth / re, ve = me * window.devicePixelRatio, ne = st * ve / 2, le = Ne * vt * ve, be = Ne * ve / 2, Ge = (Ne * vt - Ne) * ve;
            U.push(J - ne, le), U.push(J - ne, L.drawingBufferHeight), U.push(J + ne, le), U.push(J + ne, L.drawingBufferHeight), T.gearOffset = U.length / 2;
            function qe(Ht, ni) {
              var yi = (90 - Ht) * gi, ti = Math.cos(yi), Mi = Math.sin(yi);
              U.push(Be * ti * be + J, Be * Mi * be + be), U.push(ni * ti * be + J, ni * Mi * be + be);
            }
            for (var rt = 0; rt <= 6; rt++) {
              var At = rt * ai;
              qe(At, Ie), qe(At + ae, Ie), qe(At + Pe, Je), qe(At + (ai - Pe), Je), qe(At + (ai - ae), Ie);
            }
            T.gearVertexCount = U.length / 2 - T.gearOffset, T.arrowOffset = U.length / 2;
            function ot(Ht, ni) {
              U.push(Ge + Ht, L.drawingBufferHeight - Ge - ni);
            }
            var ut = ne / Math.sin(45 * gi);
            ot(0, be), ot(be, 0), ot(be + ut, ut), ot(ut, be + ut), ot(ut, be - ut), ot(0, be), ot(be, be * 2), ot(be + ut, be * 2 - ut), ot(ut, be - ut), ot(0, be), ot(ut, be - ne), ot(Ne * ve, be - ne), ot(ut, be + ne), ot(Ne * ve, be + ne), T.arrowVertexCount = U.length / 2 - T.arrowOffset, L.bindBuffer(L.ARRAY_BUFFER, T.vertexBuffer), L.bufferData(L.ARRAY_BUFFER, new Float32Array(U), L.STATIC_DRAW);
          });
        }, Rt.prototype.render = function() {
          var A = this.gl, T = this, D = [A.CULL_FACE, A.DEPTH_TEST, A.BLEND, A.SCISSOR_TEST, A.STENCIL_TEST, A.COLOR_WRITEMASK, A.VIEWPORT, A.CURRENT_PROGRAM, A.ARRAY_BUFFER_BINDING];
          Et(A, D, function(L) {
            L.disable(L.CULL_FACE), L.disable(L.DEPTH_TEST), L.disable(L.BLEND), L.disable(L.SCISSOR_TEST), L.disable(L.STENCIL_TEST), L.colorMask(!0, !0, !0, !0), L.viewport(0, 0, L.drawingBufferWidth, L.drawingBufferHeight), T.renderNoState();
          });
        }, Rt.prototype.renderNoState = function() {
          var A = this.gl;
          A.useProgram(this.program), A.bindBuffer(A.ARRAY_BUFFER, this.vertexBuffer), A.enableVertexAttribArray(this.attribs.position), A.vertexAttribPointer(this.attribs.position, 2, A.FLOAT, !1, 8, 0), A.uniform4f(this.uniforms.color, 1, 1, 1, 1), _e(this.projMat, 0, A.drawingBufferWidth, 0, A.drawingBufferHeight, 0.1, 1024), A.uniformMatrix4fv(this.uniforms.projectionMat, !1, this.projMat), A.drawArrays(A.TRIANGLE_STRIP, 0, 4), A.drawArrays(A.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount), A.drawArrays(A.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
        };
        function ht(A) {
          this.coefficients = A;
        }
        ht.prototype.distortInverse = function(A) {
          for (var T = 0, D = 1, L = A - this.distort(T); Math.abs(D - T) > 1e-4; ) {
            var U = A - this.distort(D), J = D - U * ((D - T) / (U - L));
            T = D, D = J, L = U;
          }
          return D;
        }, ht.prototype.distort = function(A) {
          for (var T = A * A, D = 0, L = 0; L < this.coefficients.length; L++)
            D = T * (D + this.coefficients[L]);
          return (D + 1) * A;
        };
        var Ct = Math.PI / 180, Lt = 180 / Math.PI, wt = function(T, D, L) {
          this.x = T || 0, this.y = D || 0, this.z = L || 0;
        };
        wt.prototype = {
          constructor: wt,
          set: function(T, D, L) {
            return this.x = T, this.y = D, this.z = L, this;
          },
          copy: function(T) {
            return this.x = T.x, this.y = T.y, this.z = T.z, this;
          },
          length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
          },
          normalize: function() {
            var T = this.length();
            if (T !== 0) {
              var D = 1 / T;
              this.multiplyScalar(D);
            } else
              this.x = 0, this.y = 0, this.z = 0;
            return this;
          },
          multiplyScalar: function(T) {
            this.x *= T, this.y *= T, this.z *= T;
          },
          applyQuaternion: function(T) {
            var D = this.x, L = this.y, U = this.z, J = T.x, re = T.y, me = T.z, ve = T.w, ne = ve * D + re * U - me * L, le = ve * L + me * D - J * U, be = ve * U + J * L - re * D, Ge = -J * D - re * L - me * U;
            return this.x = ne * ve + Ge * -J + le * -me - be * -re, this.y = le * ve + Ge * -re + be * -J - ne * -me, this.z = be * ve + Ge * -me + ne * -re - le * -J, this;
          },
          dot: function(T) {
            return this.x * T.x + this.y * T.y + this.z * T.z;
          },
          crossVectors: function(T, D) {
            var L = T.x, U = T.y, J = T.z, re = D.x, me = D.y, ve = D.z;
            return this.x = U * ve - J * me, this.y = J * re - L * ve, this.z = L * me - U * re, this;
          }
        };
        var _t = function(T, D, L, U) {
          this.x = T || 0, this.y = D || 0, this.z = L || 0, this.w = U !== void 0 ? U : 1;
        };
        _t.prototype = {
          constructor: _t,
          set: function(T, D, L, U) {
            return this.x = T, this.y = D, this.z = L, this.w = U, this;
          },
          copy: function(T) {
            return this.x = T.x, this.y = T.y, this.z = T.z, this.w = T.w, this;
          },
          setFromEulerXYZ: function(T, D, L) {
            var U = Math.cos(T / 2), J = Math.cos(D / 2), re = Math.cos(L / 2), me = Math.sin(T / 2), ve = Math.sin(D / 2), ne = Math.sin(L / 2);
            return this.x = me * J * re + U * ve * ne, this.y = U * ve * re - me * J * ne, this.z = U * J * ne + me * ve * re, this.w = U * J * re - me * ve * ne, this;
          },
          setFromEulerYXZ: function(T, D, L) {
            var U = Math.cos(T / 2), J = Math.cos(D / 2), re = Math.cos(L / 2), me = Math.sin(T / 2), ve = Math.sin(D / 2), ne = Math.sin(L / 2);
            return this.x = me * J * re + U * ve * ne, this.y = U * ve * re - me * J * ne, this.z = U * J * ne - me * ve * re, this.w = U * J * re + me * ve * ne, this;
          },
          setFromAxisAngle: function(T, D) {
            var L = D / 2, U = Math.sin(L);
            return this.x = T.x * U, this.y = T.y * U, this.z = T.z * U, this.w = Math.cos(L), this;
          },
          multiply: function(T) {
            return this.multiplyQuaternions(this, T);
          },
          multiplyQuaternions: function(T, D) {
            var L = T.x, U = T.y, J = T.z, re = T.w, me = D.x, ve = D.y, ne = D.z, le = D.w;
            return this.x = L * le + re * me + U * ne - J * ve, this.y = U * le + re * ve + J * me - L * ne, this.z = J * le + re * ne + L * ve - U * me, this.w = re * le - L * me - U * ve - J * ne, this;
          },
          inverse: function() {
            return this.x *= -1, this.y *= -1, this.z *= -1, this.normalize(), this;
          },
          normalize: function() {
            var T = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            return T === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (T = 1 / T, this.x = this.x * T, this.y = this.y * T, this.z = this.z * T, this.w = this.w * T), this;
          },
          slerp: function(T, D) {
            if (D === 0) return this;
            if (D === 1) return this.copy(T);
            var L = this.x, U = this.y, J = this.z, re = this.w, me = re * T.w + L * T.x + U * T.y + J * T.z;
            if (me < 0 ? (this.w = -T.w, this.x = -T.x, this.y = -T.y, this.z = -T.z, me = -me) : this.copy(T), me >= 1)
              return this.w = re, this.x = L, this.y = U, this.z = J, this;
            var ve = Math.acos(me), ne = Math.sqrt(1 - me * me);
            if (Math.abs(ne) < 1e-3)
              return this.w = 0.5 * (re + this.w), this.x = 0.5 * (L + this.x), this.y = 0.5 * (U + this.y), this.z = 0.5 * (J + this.z), this;
            var le = Math.sin((1 - D) * ve) / ne, be = Math.sin(D * ve) / ne;
            return this.w = re * le + this.w * be, this.x = L * le + this.x * be, this.y = U * le + this.y * be, this.z = J * le + this.z * be, this;
          },
          setFromUnitVectors: /* @__PURE__ */ function() {
            var A, T, D = 1e-6;
            return function(L, U) {
              return A === void 0 && (A = new wt()), T = L.dot(U) + 1, T < D ? (T = 0, Math.abs(L.x) > Math.abs(L.z) ? A.set(-L.y, L.x, 0) : A.set(0, -L.z, L.y)) : A.crossVectors(L, U), this.x = A.x, this.y = A.y, this.z = A.z, this.w = T, this.normalize(), this;
            };
          }()
        };
        function Br(A) {
          this.width = A.width || se(), this.height = A.height || ie(), this.widthMeters = A.widthMeters, this.heightMeters = A.heightMeters, this.bevelMeters = A.bevelMeters;
        }
        var nr = new Br({
          widthMeters: 0.11,
          heightMeters: 0.062,
          bevelMeters: 4e-3
        }), ta = new Br({
          widthMeters: 0.1038,
          heightMeters: 0.0584,
          bevelMeters: 4e-3
        }), xi = {
          CardboardV1: new nn({
            id: "CardboardV1",
            label: "Cardboard I/O 2014",
            fov: 40,
            interLensDistance: 0.06,
            baselineLensDistance: 0.035,
            screenLensDistance: 0.042,
            distortionCoefficients: [0.441, 0.156],
            inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 1559834e-9]
          }),
          CardboardV2: new nn({
            id: "CardboardV2",
            label: "Cardboard I/O 2015",
            fov: 60,
            interLensDistance: 0.064,
            baselineLensDistance: 0.035,
            screenLensDistance: 0.039,
            distortionCoefficients: [0.34, 0.55],
            inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 9177956e-9, -9904169e-10, 6183535e-11, -16981803e-13]
          })
        };
        function Xt(A, T) {
          this.viewer = xi.CardboardV2, this.updateDeviceParams(A), this.distortion = new ht(this.viewer.distortionCoefficients);
          for (var D = 0; D < T.length; D++) {
            var L = T[D];
            xi[L.id] = new nn(L);
          }
        }
        Xt.prototype.updateDeviceParams = function(A) {
          this.device = this.determineDevice_(A) || this.device;
        }, Xt.prototype.getDevice = function() {
          return this.device;
        }, Xt.prototype.setViewer = function(A) {
          this.viewer = A, this.distortion = new ht(this.viewer.distortionCoefficients);
        }, Xt.prototype.determineDevice_ = function(A) {
          if (!A)
            return I() ? (console.warn("Using fallback iOS device measurements."), ta) : (console.warn("Using fallback Android device measurements."), nr);
          var T = 0.0254, D = T / A.xdpi, L = T / A.ydpi, U = se(), J = ie();
          return new Br({
            widthMeters: D * U,
            heightMeters: L * J,
            bevelMeters: A.bevelMm * 1e-3
          });
        }, Xt.prototype.getDistortedFieldOfViewLeftEye = function() {
          var A = this.viewer, T = this.device, D = this.distortion, L = A.screenLensDistance, U = (T.widthMeters - A.interLensDistance) / 2, J = A.interLensDistance / 2, re = A.baselineLensDistance - T.bevelMeters, me = T.heightMeters - re, ve = Lt * Math.atan(D.distort(U / L)), ne = Lt * Math.atan(D.distort(J / L)), le = Lt * Math.atan(D.distort(re / L)), be = Lt * Math.atan(D.distort(me / L));
          return {
            leftDegrees: Math.min(ve, A.fov),
            rightDegrees: Math.min(ne, A.fov),
            downDegrees: Math.min(le, A.fov),
            upDegrees: Math.min(be, A.fov)
          };
        }, Xt.prototype.getLeftEyeVisibleTanAngles = function() {
          var A = this.viewer, T = this.device, D = this.distortion, L = Math.tan(-Ct * A.fov), U = Math.tan(Ct * A.fov), J = Math.tan(Ct * A.fov), re = Math.tan(-Ct * A.fov), me = T.widthMeters / 4, ve = T.heightMeters / 2, ne = A.baselineLensDistance - T.bevelMeters - ve, le = A.interLensDistance / 2 - me, be = -ne, Ge = A.screenLensDistance, qe = D.distort((le - me) / Ge), rt = D.distort((be + ve) / Ge), At = D.distort((le + me) / Ge), ot = D.distort((be - ve) / Ge), ut = new Float32Array(4);
          return ut[0] = Math.max(L, qe), ut[1] = Math.min(U, rt), ut[2] = Math.min(J, At), ut[3] = Math.max(re, ot), ut;
        }, Xt.prototype.getLeftEyeNoLensTanAngles = function() {
          var A = this.viewer, T = this.device, D = this.distortion, L = new Float32Array(4), U = D.distortInverse(Math.tan(-Ct * A.fov)), J = D.distortInverse(Math.tan(Ct * A.fov)), re = D.distortInverse(Math.tan(Ct * A.fov)), me = D.distortInverse(Math.tan(-Ct * A.fov)), ve = T.widthMeters / 4, ne = T.heightMeters / 2, le = A.baselineLensDistance - T.bevelMeters - ne, be = A.interLensDistance / 2 - ve, Ge = -le, qe = A.screenLensDistance, rt = (be - ve) / qe, At = (Ge + ne) / qe, ot = (be + ve) / qe, ut = (Ge - ne) / qe;
          return L[0] = Math.max(U, rt), L[1] = Math.min(J, At), L[2] = Math.min(re, ot), L[3] = Math.max(me, ut), L;
        }, Xt.prototype.getLeftEyeVisibleScreenRect = function(A) {
          var T = this.viewer, D = this.device, L = T.screenLensDistance, U = (D.widthMeters - T.interLensDistance) / 2, J = T.baselineLensDistance - D.bevelMeters, re = (A[0] * L + U) / D.widthMeters, me = (A[1] * L + J) / D.heightMeters, ve = (A[2] * L + U) / D.widthMeters, ne = (A[3] * L + J) / D.heightMeters;
          return {
            x: re,
            y: ne,
            width: ve - re,
            height: me - ne
          };
        }, Xt.prototype.getFieldOfViewLeftEye = function(A) {
          return A ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
        }, Xt.prototype.getFieldOfViewRightEye = function(A) {
          var T = this.getFieldOfViewLeftEye(A);
          return {
            leftDegrees: T.rightDegrees,
            rightDegrees: T.leftDegrees,
            upDegrees: T.upDegrees,
            downDegrees: T.downDegrees
          };
        }, Xt.prototype.getUndistortedFieldOfViewLeftEye = function() {
          var A = this.getUndistortedParams_();
          return {
            leftDegrees: Lt * Math.atan(A.outerDist),
            rightDegrees: Lt * Math.atan(A.innerDist),
            downDegrees: Lt * Math.atan(A.bottomDist),
            upDegrees: Lt * Math.atan(A.topDist)
          };
        }, Xt.prototype.getUndistortedViewportLeftEye = function() {
          var A = this.getUndistortedParams_(), T = this.viewer, D = this.device, L = T.screenLensDistance, U = D.widthMeters / L, J = D.heightMeters / L, re = D.width / U, me = D.height / J, ve = Math.round((A.eyePosX - A.outerDist) * re), ne = Math.round((A.eyePosY - A.bottomDist) * me);
          return {
            x: ve,
            y: ne,
            width: Math.round((A.eyePosX + A.innerDist) * re) - ve,
            height: Math.round((A.eyePosY + A.topDist) * me) - ne
          };
        }, Xt.prototype.getUndistortedParams_ = function() {
          var A = this.viewer, T = this.device, D = this.distortion, L = A.screenLensDistance, U = A.interLensDistance / 2 / L, J = T.widthMeters / L, re = T.heightMeters / L, me = J / 2 - U, ve = (A.baselineLensDistance - T.bevelMeters) / L, ne = A.fov, le = D.distortInverse(Math.tan(Ct * ne)), be = Math.min(me, le), Ge = Math.min(U, le), qe = Math.min(ve, le), rt = Math.min(re - ve, le);
          return {
            outerDist: be,
            innerDist: Ge,
            topDist: rt,
            bottomDist: qe,
            eyePosX: me,
            eyePosY: ve
          };
        };
        function nn(A) {
          this.id = A.id, this.label = A.label, this.fov = A.fov, this.interLensDistance = A.interLensDistance, this.baselineLensDistance = A.baselineLensDistance, this.screenLensDistance = A.screenLensDistance, this.distortionCoefficients = A.distortionCoefficients, this.inverseCoefficients = A.inverseCoefficients;
        }
        Xt.Viewers = xi;
        var ia = 1, Fr = "2019-11-09T17:36:14Z", zo = [{ type: "android", rules: [{ mdmh: "asus/*/Nexus 7/*" }, { ua: "Nexus 7" }], dpi: [320.8, 323], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "asus/*/ASUS_X00PD/*" }, { ua: "ASUS_X00PD" }], dpi: 245, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "asus/*/ASUS_X008D/*" }, { ua: "ASUS_X008D" }], dpi: 282, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "asus/*/ASUS_Z00AD/*" }, { ua: "ASUS_Z00AD" }], dpi: [403, 404.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel 2 XL/*" }, { ua: "Pixel 2 XL" }], dpi: 537.9, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel 3 XL/*" }, { ua: "Pixel 3 XL" }], dpi: [558.5, 553.8], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel XL/*" }, { ua: "Pixel XL" }], dpi: [537.9, 533], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel 3/*" }, { ua: "Pixel 3" }], dpi: 442.4, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel 2/*" }, { ua: "Pixel 2" }], dpi: 441, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel/*" }, { ua: "Pixel" }], dpi: [432.6, 436.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC6435LVW/*" }, { ua: "HTC6435LVW" }], dpi: [449.7, 443.3], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC One XL/*" }, { ua: "HTC One XL" }], dpi: [315.3, 314.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "htc/*/Nexus 9/*" }, { ua: "Nexus 9" }], dpi: 289, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC One M9/*" }, { ua: "HTC One M9" }], dpi: [442.5, 443.3], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC One_M8/*" }, { ua: "HTC One_M8" }], dpi: [449.7, 447.4], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC One/*" }, { ua: "HTC One" }], dpi: 472.8, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Huawei/*/Nexus 6P/*" }, { ua: "Nexus 6P" }], dpi: [515.1, 518], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Huawei/*/BLN-L24/*" }, { ua: "HONORBLN-L24" }], dpi: 480, bw: 4, ac: 500 }, { type: "android", rules: [{ mdmh: "Huawei/*/BKL-L09/*" }, { ua: "BKL-L09" }], dpi: 403, bw: 3.47, ac: 500 }, { type: "android", rules: [{ mdmh: "LENOVO/*/Lenovo PB2-690Y/*" }, { ua: "Lenovo PB2-690Y" }], dpi: [457.2, 454.713], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "LGE/*/Nexus 5X/*" }, { ua: "Nexus 5X" }], dpi: [422, 419.9], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/LGMS345/*" }, { ua: "LGMS345" }], dpi: [221.7, 219.1], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "LGE/*/LG-D800/*" }, { ua: "LG-D800" }], dpi: [422, 424.1], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "LGE/*/LG-D850/*" }, { ua: "LG-D850" }], dpi: [537.9, 541.9], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "LGE/*/VS985 4G/*" }, { ua: "VS985 4G" }], dpi: [537.9, 535.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/Nexus 5/*" }, { ua: "Nexus 5 B" }], dpi: [442.4, 444.8], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/Nexus 4/*" }, { ua: "Nexus 4" }], dpi: [319.8, 318.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/LG-P769/*" }, { ua: "LG-P769" }], dpi: [240.6, 247.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/LGMS323/*" }, { ua: "LGMS323" }], dpi: [206.6, 204.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/LGLS996/*" }, { ua: "LGLS996" }], dpi: [403.4, 401.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Micromax/*/4560MMX/*" }, { ua: "4560MMX" }], dpi: [240, 219.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Micromax/*/A250/*" }, { ua: "Micromax A250" }], dpi: [480, 446.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Micromax/*/Micromax AQ4501/*" }, { ua: "Micromax AQ4501" }], dpi: 240, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/G5/*" }, { ua: "Moto G (5) Plus" }], dpi: [403.4, 403], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/DROID RAZR/*" }, { ua: "DROID RAZR" }], dpi: [368.1, 256.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT830C/*" }, { ua: "XT830C" }], dpi: [254, 255.9], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1021/*" }, { ua: "XT1021" }], dpi: [254, 256.7], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1023/*" }, { ua: "XT1023" }], dpi: [254, 256.7], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1028/*" }, { ua: "XT1028" }], dpi: [326.6, 327.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1034/*" }, { ua: "XT1034" }], dpi: [326.6, 328.4], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1053/*" }, { ua: "XT1053" }], dpi: [315.3, 316.1], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1562/*" }, { ua: "XT1562" }], dpi: [403.4, 402.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/Nexus 6/*" }, { ua: "Nexus 6 B" }], dpi: [494.3, 489.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1063/*" }, { ua: "XT1063" }], dpi: [295, 296.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1064/*" }, { ua: "XT1064" }], dpi: [295, 295.6], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1092/*" }, { ua: "XT1092" }], dpi: [422, 424.1], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1095/*" }, { ua: "XT1095" }], dpi: [422, 423.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/G4/*" }, { ua: "Moto G (4)" }], dpi: 401, bw: 4, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/A0001/*" }, { ua: "A0001" }], dpi: [403.4, 401], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE E1001/*" }, { ua: "ONE E1001" }], dpi: [442.4, 441.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE E1003/*" }, { ua: "ONE E1003" }], dpi: [442.4, 441.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE E1005/*" }, { ua: "ONE E1005" }], dpi: [442.4, 441.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE A2001/*" }, { ua: "ONE A2001" }], dpi: [391.9, 405.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE A2003/*" }, { ua: "ONE A2003" }], dpi: [391.9, 405.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE A2005/*" }, { ua: "ONE A2005" }], dpi: [391.9, 405.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A3000/*" }, { ua: "ONEPLUS A3000" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A3003/*" }, { ua: "ONEPLUS A3003" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A3010/*" }, { ua: "ONEPLUS A3010" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A5000/*" }, { ua: "ONEPLUS A5000 " }], dpi: [403.411, 399.737], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE A5010/*" }, { ua: "ONEPLUS A5010" }], dpi: [403, 400], bw: 2, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A6000/*" }, { ua: "ONEPLUS A6000" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A6003/*" }, { ua: "ONEPLUS A6003" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A6010/*" }, { ua: "ONEPLUS A6010" }], dpi: 401, bw: 2, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A6013/*" }, { ua: "ONEPLUS A6013" }], dpi: 401, bw: 2, ac: 500 }, { type: "android", rules: [{ mdmh: "OPPO/*/X909/*" }, { ua: "X909" }], dpi: [442.4, 444.1], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9082/*" }, { ua: "GT-I9082" }], dpi: [184.7, 185.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G360P/*" }, { ua: "SM-G360P" }], dpi: [196.7, 205.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/Nexus S/*" }, { ua: "Nexus S" }], dpi: [234.5, 229.8], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9300/*" }, { ua: "GT-I9300" }], dpi: [304.8, 303.9], bw: 5, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-T230NU/*" }, { ua: "SM-T230NU" }], dpi: 216, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SGH-T399/*" }, { ua: "SGH-T399" }], dpi: [217.7, 231.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SGH-M919/*" }, { ua: "SGH-M919" }], dpi: [440.8, 437.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N9005/*" }, { ua: "SM-N9005" }], dpi: [386.4, 387], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SAMSUNG-SM-N900A/*" }, { ua: "SAMSUNG-SM-N900A" }], dpi: [386.4, 387.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9500/*" }, { ua: "GT-I9500" }], dpi: [442.5, 443.3], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9505/*" }, { ua: "GT-I9505" }], dpi: 439.4, bw: 4, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G900F/*" }, { ua: "SM-G900F" }], dpi: [415.6, 431.6], bw: 5, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G900M/*" }, { ua: "SM-G900M" }], dpi: [415.6, 431.6], bw: 5, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G800F/*" }, { ua: "SM-G800F" }], dpi: 326.8, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G906S/*" }, { ua: "SM-G906S" }], dpi: [562.7, 572.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9300/*" }, { ua: "GT-I9300" }], dpi: [306.7, 304.8], bw: 5, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-T535/*" }, { ua: "SM-T535" }], dpi: [142.6, 136.4], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N920C/*" }, { ua: "SM-N920C" }], dpi: [515.1, 518.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N920P/*" }, { ua: "SM-N920P" }], dpi: [386.3655, 390.144], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N920W8/*" }, { ua: "SM-N920W8" }], dpi: [515.1, 518.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9300I/*" }, { ua: "GT-I9300I" }], dpi: [304.8, 305.8], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9195/*" }, { ua: "GT-I9195" }], dpi: [249.4, 256.7], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SPH-L520/*" }, { ua: "SPH-L520" }], dpi: [249.4, 255.9], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SAMSUNG-SGH-I717/*" }, { ua: "SAMSUNG-SGH-I717" }], dpi: 285.8, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SPH-D710/*" }, { ua: "SPH-D710" }], dpi: [217.7, 204.2], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-N7100/*" }, { ua: "GT-N7100" }], dpi: 265.1, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SCH-I605/*" }, { ua: "SCH-I605" }], dpi: 265.1, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/Galaxy Nexus/*" }, { ua: "Galaxy Nexus" }], dpi: [315.3, 314.2], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N910H/*" }, { ua: "SM-N910H" }], dpi: [515.1, 518], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N910C/*" }, { ua: "SM-N910C" }], dpi: [515.2, 520.2], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G130M/*" }, { ua: "SM-G130M" }], dpi: [165.9, 164.8], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G928I/*" }, { ua: "SM-G928I" }], dpi: [515.1, 518.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G920F/*" }, { ua: "SM-G920F" }], dpi: 580.6, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G920P/*" }, { ua: "SM-G920P" }], dpi: [522.5, 577], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G925F/*" }, { ua: "SM-G925F" }], dpi: 580.6, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G925V/*" }, { ua: "SM-G925V" }], dpi: [522.5, 576.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G930F/*" }, { ua: "SM-G930F" }], dpi: 576.6, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G935F/*" }, { ua: "SM-G935F" }], dpi: 533, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G950F/*" }, { ua: "SM-G950F" }], dpi: [562.707, 565.293], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G955U/*" }, { ua: "SM-G955U" }], dpi: [522.514, 525.762], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G955F/*" }, { ua: "SM-G955F" }], dpi: [522.514, 525.762], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960F/*" }, { ua: "SM-G960F" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G9600/*" }, { ua: "SM-G9600" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960T/*" }, { ua: "SM-G960T" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960N/*" }, { ua: "SM-G960N" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960U/*" }, { ua: "SM-G960U" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G9608/*" }, { ua: "SM-G9608" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960FD/*" }, { ua: "SM-G960FD" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960W/*" }, { ua: "SM-G960W" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G965F/*" }, { ua: "SM-G965F" }], dpi: 529, bw: 2, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Sony/*/C6903/*" }, { ua: "C6903" }], dpi: [442.5, 443.3], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "Sony/*/D6653/*" }, { ua: "D6653" }], dpi: [428.6, 427.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Sony/*/E6653/*" }, { ua: "E6653" }], dpi: [428.6, 425.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Sony/*/E6853/*" }, { ua: "E6853" }], dpi: [403.4, 401.9], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Sony/*/SGP321/*" }, { ua: "SGP321" }], dpi: [224.7, 224.1], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "TCT/*/ALCATEL ONE TOUCH Fierce/*" }, { ua: "ALCATEL ONE TOUCH Fierce" }], dpi: [240, 247.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "THL/*/thl 5000/*" }, { ua: "thl 5000" }], dpi: [480, 443.3], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Fly/*/IQ4412/*" }, { ua: "IQ4412" }], dpi: 307.9, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "ZTE/*/ZTE Blade L2/*" }, { ua: "ZTE Blade L2" }], dpi: 240, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "BENEVE/*/VR518/*" }, { ua: "VR518" }], dpi: 480, bw: 3, ac: 500 }, { type: "ios", rules: [{ res: [640, 960] }], dpi: [325.1, 328.4], bw: 4, ac: 1e3 }, { type: "ios", rules: [{ res: [640, 1136] }], dpi: [317.1, 320.2], bw: 3, ac: 1e3 }, { type: "ios", rules: [{ res: [750, 1334] }], dpi: 326.4, bw: 4, ac: 1e3 }, { type: "ios", rules: [{ res: [1242, 2208] }], dpi: [453.6, 458.4], bw: 4, ac: 1e3 }, { type: "ios", rules: [{ res: [1125, 2001] }], dpi: [410.9, 415.4], bw: 4, ac: 1e3 }, { type: "ios", rules: [{ res: [1125, 2436] }], dpi: 458, bw: 4, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Huawei/*/EML-L29/*" }, { ua: "EML-L29" }], dpi: 428, bw: 3.45, ac: 500 }, { type: "android", rules: [{ mdmh: "Nokia/*/Nokia 7.1/*" }, { ua: "Nokia 7.1" }], dpi: [432, 431.9], bw: 3, ac: 500 }, { type: "ios", rules: [{ res: [1242, 2688] }], dpi: 458, bw: 4, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G570M/*" }, { ua: "SM-G570M" }], dpi: 320, bw: 3.684, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G970F/*" }, { ua: "SM-G970F" }], dpi: 438, bw: 2.281, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G973F/*" }, { ua: "SM-G973F" }], dpi: 550, bw: 2.002, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G975F/*" }, { ua: "SM-G975F" }], dpi: 522, bw: 2.054, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G977F/*" }, { ua: "SM-G977F" }], dpi: 505, bw: 2.334, ac: 500 }, { type: "ios", rules: [{ res: [828, 1792] }], dpi: 326, bw: 5, ac: 500 }], bs = {
          format: ia,
          last_updated: Fr,
          devices: zo
        };
        function _r(A, T) {
          if (this.dpdb = bs, this.recalculateDeviceParams_(), A) {
            this.onDeviceParamsUpdated = T;
            var D = new XMLHttpRequest(), L = this;
            D.open("GET", A, !0), D.addEventListener("load", function() {
              L.loading = !1, D.status >= 200 && D.status <= 299 ? (L.dpdb = JSON.parse(D.response), L.recalculateDeviceParams_()) : console.error("Error loading online DPDB!");
            }), D.send();
          }
        }
        _r.prototype.getDeviceParams = function() {
          return this.deviceParams;
        }, _r.prototype.recalculateDeviceParams_ = function() {
          var A = this.calcDeviceParams_();
          A ? (this.deviceParams = A, this.onDeviceParamsUpdated && this.onDeviceParamsUpdated(this.deviceParams)) : console.error("Failed to recalculate device parameters.");
        }, _r.prototype.calcDeviceParams_ = function() {
          var A = this.dpdb;
          if (!A)
            return console.error("DPDB not available."), null;
          if (A.format != 1)
            return console.error("DPDB has unexpected format version."), null;
          if (!A.devices || !A.devices.length)
            return console.error("DPDB does not have a devices section."), null;
          var T = navigator.userAgent || navigator.vendor || window.opera, D = se(), L = ie();
          if (!A.devices)
            return console.error("DPDB has no devices section."), null;
          for (var U = 0; U < A.devices.length; U++) {
            var J = A.devices[U];
            if (!J.rules) {
              console.warn("Device[" + U + "] has no rules section.");
              continue;
            }
            if (J.type != "ios" && J.type != "android") {
              console.warn("Device[" + U + "] has invalid type.");
              continue;
            }
            if (I() == (J.type == "ios")) {
              for (var re = !1, me = 0; me < J.rules.length; me++) {
                var ve = J.rules[me];
                if (this.ruleMatches_(ve, T, D, L)) {
                  re = !0;
                  break;
                }
              }
              if (re) {
                var ne = J.dpi[0] || J.dpi, le = J.dpi[1] || J.dpi;
                return new Oi({ xdpi: ne, ydpi: le, bevelMm: J.bw });
              }
            }
          }
          return console.warn("No DPDB device match."), null;
        }, _r.prototype.ruleMatches_ = function(A, T, D, L) {
          if (!A.ua && !A.res || (A.ua && A.ua.substring(0, 2) === "SM" && (A.ua = A.ua.substring(0, 7)), A.ua && T.indexOf(A.ua) < 0)) return !1;
          if (A.res) {
            if (!A.res[0] || !A.res[1]) return !1;
            var U = A.res[0], J = A.res[1];
            if (Math.min(D, L) != Math.min(U, J) || Math.max(D, L) != Math.max(U, J))
              return !1;
          }
          return !0;
        };
        function Oi(A) {
          this.xdpi = A.xdpi, this.ydpi = A.ydpi, this.bevelMm = A.bevelMm;
        }
        function En(A, T) {
          this.set(A, T);
        }
        En.prototype.set = function(A, T) {
          this.sample = A, this.timestampS = T;
        }, En.prototype.copy = function(A) {
          this.set(A.sample, A.timestampS);
        };
        function Nr(A, T) {
          this.kFilter = A, this.isDebug = T, this.currentAccelMeasurement = new En(), this.currentGyroMeasurement = new En(), this.previousGyroMeasurement = new En(), I() ? this.filterQ = new _t(-1, 0, 0, 1) : this.filterQ = new _t(1, 0, 0, 1), this.previousFilterQ = new _t(), this.previousFilterQ.copy(this.filterQ), this.accelQ = new _t(), this.isOrientationInitialized = !1, this.estimatedGravity = new wt(), this.measuredGravity = new wt(), this.gyroIntegralQ = new _t();
        }
        Nr.prototype.addAccelMeasurement = function(A, T) {
          this.currentAccelMeasurement.set(A, T);
        }, Nr.prototype.addGyroMeasurement = function(A, T) {
          this.currentGyroMeasurement.set(A, T);
          var D = T - this.previousGyroMeasurement.timestampS;
          j(D) && this.run_(), this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
        }, Nr.prototype.run_ = function() {
          if (!this.isOrientationInitialized) {
            this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample), this.previousFilterQ.copy(this.accelQ), this.isOrientationInitialized = !0;
            return;
          }
          var A = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS, T = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, A);
          this.gyroIntegralQ.multiply(T), this.filterQ.copy(this.previousFilterQ), this.filterQ.multiply(T);
          var D = new _t();
          D.copy(this.filterQ), D.inverse(), this.estimatedGravity.set(0, 0, -1), this.estimatedGravity.applyQuaternion(D), this.estimatedGravity.normalize(), this.measuredGravity.copy(this.currentAccelMeasurement.sample), this.measuredGravity.normalize();
          var L = new _t();
          L.setFromUnitVectors(this.estimatedGravity, this.measuredGravity), L.inverse(), this.isDebug && console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)", Lt * Mt(L), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
          var U = new _t();
          U.copy(this.filterQ), U.multiply(L), this.filterQ.slerp(U, 1 - this.kFilter), this.previousFilterQ.copy(this.filterQ);
        }, Nr.prototype.getOrientation = function() {
          return this.filterQ;
        }, Nr.prototype.accelToQuaternion_ = function(A) {
          var T = new wt();
          T.copy(A), T.normalize();
          var D = new _t();
          return D.setFromUnitVectors(new wt(0, 0, -1), T), D.inverse(), D;
        }, Nr.prototype.gyroToQuaternionDelta_ = function(A, T) {
          var D = new _t(), L = new wt();
          return L.copy(A), L.normalize(), D.setFromAxisAngle(L, A.length() * T), D;
        };
        function wn(A, T) {
          this.predictionTimeS = A, this.isDebug = T, this.previousQ = new _t(), this.previousTimestampS = null, this.deltaQ = new _t(), this.outQ = new _t();
        }
        wn.prototype.getPrediction = function(A, T, D) {
          if (!this.previousTimestampS)
            return this.previousQ.copy(A), this.previousTimestampS = D, A;
          var L = new wt();
          L.copy(T), L.normalize();
          var U = T.length();
          if (U < Ct * 20)
            return this.isDebug && console.log("Moving slowly, at %s deg/s: no prediction", (Lt * U).toFixed(1)), this.outQ.copy(A), this.previousQ.copy(A), this.outQ;
          var J = U * this.predictionTimeS;
          return this.deltaQ.setFromAxisAngle(L, J), this.outQ.copy(this.previousQ), this.outQ.multiply(this.deltaQ), this.previousQ.copy(A), this.previousTimestampS = D, this.outQ;
        };
        function Jt(A, T, D, L) {
          this.yawOnly = D, this.accelerometer = new wt(), this.gyroscope = new wt(), this.filter = new Nr(A, L), this.posePredictor = new wn(T, L), this.isFirefoxAndroid = ee(), this.isIOS = I();
          var U = oe();
          this.isDeviceMotionInRadians = !this.isIOS && U && U < 66, this.isWithoutDeviceMotion = he() || fe(), this.filterToWorldQ = new _t(), I() ? this.filterToWorldQ.setFromAxisAngle(new wt(1, 0, 0), Math.PI / 2) : this.filterToWorldQ.setFromAxisAngle(new wt(1, 0, 0), -Math.PI / 2), this.inverseWorldToScreenQ = new _t(), this.worldToScreenQ = new _t(), this.originalPoseAdjustQ = new _t(), this.originalPoseAdjustQ.setFromAxisAngle(new wt(0, 0, 1), -window.orientation * Math.PI / 180), this.setScreenTransform_(), G() && this.filterToWorldQ.multiply(this.inverseWorldToScreenQ), this.resetQ = new _t(), this.orientationOut_ = new Float32Array(4), this.start();
        }
        Jt.prototype.getPosition = function() {
          return null;
        }, Jt.prototype.getOrientation = function() {
          var A = void 0;
          if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
            this.deviceOrientationFixQ = this.deviceOrientationFixQ || function() {
              var U = new _t().setFromAxisAngle(new wt(0, 0, -1), 0), J = new _t();
              return window.orientation === -90 ? J.setFromAxisAngle(new wt(0, 1, 0), Math.PI / -2) : J.setFromAxisAngle(new wt(0, 1, 0), Math.PI / 2), U.multiply(J);
            }(), this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function() {
              var U = new _t();
              return U.setFromAxisAngle(new wt(1, 0, 0), -Math.PI / 2), U;
            }(), A = this._deviceOrientationQ;
            var D = new _t();
            return D.copy(A), D.multiply(this.deviceOrientationFilterToWorldQ), D.multiply(this.resetQ), D.multiply(this.worldToScreenQ), D.multiplyQuaternions(this.deviceOrientationFixQ, D), this.yawOnly && (D.x = 0, D.z = 0, D.normalize()), this.orientationOut_[0] = D.x, this.orientationOut_[1] = D.y, this.orientationOut_[2] = D.z, this.orientationOut_[3] = D.w, this.orientationOut_;
          } else {
            var T = this.filter.getOrientation();
            A = this.posePredictor.getPrediction(T, this.gyroscope, this.previousTimestampS);
          }
          var D = new _t();
          return D.copy(this.filterToWorldQ), D.multiply(this.resetQ), D.multiply(A), D.multiply(this.worldToScreenQ), this.yawOnly && (D.x = 0, D.z = 0, D.normalize()), this.orientationOut_[0] = D.x, this.orientationOut_[1] = D.y, this.orientationOut_[2] = D.z, this.orientationOut_[3] = D.w, this.orientationOut_;
        }, Jt.prototype.resetPose = function() {
          this.resetQ.copy(this.filter.getOrientation()), this.resetQ.x = 0, this.resetQ.y = 0, this.resetQ.z *= -1, this.resetQ.normalize(), G() && this.resetQ.multiply(this.inverseWorldToScreenQ), this.resetQ.multiply(this.originalPoseAdjustQ);
        }, Jt.prototype.onDeviceOrientation_ = function(A) {
          this._deviceOrientationQ = this._deviceOrientationQ || new _t();
          var T = A.alpha, D = A.beta, L = A.gamma;
          T = (T || 0) * Math.PI / 180, D = (D || 0) * Math.PI / 180, L = (L || 0) * Math.PI / 180, this._deviceOrientationQ.setFromEulerYXZ(D, T, -L);
        }, Jt.prototype.onDeviceMotion_ = function(A) {
          this.updateDeviceMotion_(A);
        }, Jt.prototype.updateDeviceMotion_ = function(A) {
          var T = A.accelerationIncludingGravity, D = A.rotationRate, L = A.timeStamp / 1e3, U = L - this.previousTimestampS;
          if (U < 0) {
            Vt("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion"), this.previousTimestampS = L;
            return;
          } else if (U <= R || U > k) {
            Vt("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range."), this.previousTimestampS = L;
            return;
          }
          this.accelerometer.set(-T.x, -T.y, -T.z), D && (de() ? this.gyroscope.set(-D.beta, D.alpha, D.gamma) : this.gyroscope.set(D.alpha, D.beta, D.gamma), this.isDeviceMotionInRadians || this.gyroscope.multiplyScalar(Math.PI / 180), this.filter.addGyroMeasurement(this.gyroscope, L)), this.filter.addAccelMeasurement(this.accelerometer, L), this.previousTimestampS = L;
        }, Jt.prototype.onOrientationChange_ = function(A) {
          this.setScreenTransform_();
        }, Jt.prototype.onMessage_ = function(A) {
          var T = A.data;
          if (!(!T || !T.type)) {
            var D = T.type.toLowerCase();
            D === "devicemotion" && this.updateDeviceMotion_(T.deviceMotionEvent);
          }
        }, Jt.prototype.setScreenTransform_ = function() {
          switch (this.worldToScreenQ.set(0, 0, 0, 1), window.orientation) {
            case 0:
              break;
            case 90:
              this.worldToScreenQ.setFromAxisAngle(new wt(0, 0, 1), -Math.PI / 2);
              break;
            case -90:
              this.worldToScreenQ.setFromAxisAngle(new wt(0, 0, 1), Math.PI / 2);
              break;
          }
          this.inverseWorldToScreenQ.copy(this.worldToScreenQ), this.inverseWorldToScreenQ.inverse();
        }, Jt.prototype.start = function() {
          this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this), this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this), this.onMessageCallback_ = this.onMessage_.bind(this), this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this), I() && ct() && window.addEventListener("message", this.onMessageCallback_), window.addEventListener("orientationchange", this.onOrientationChangeCallback_), this.isWithoutDeviceMotion ? window.addEventListener("deviceorientation", this.onDeviceOrientationCallback_) : window.addEventListener("devicemotion", this.onDeviceMotionCallback_);
        }, Jt.prototype.stop = function() {
          window.removeEventListener("devicemotion", this.onDeviceMotionCallback_), window.removeEventListener("deviceorientation", this.onDeviceOrientationCallback_), window.removeEventListener("orientationchange", this.onOrientationChangeCallback_), window.removeEventListener("message", this.onMessageCallback_);
        };
        var O = 60, z = new wt(1, 0, 0), $ = new wt(0, 0, 1), ge = new _t();
        ge.setFromAxisAngle(z, -Math.PI / 2), ge.multiply(new _t().setFromAxisAngle($, Math.PI / 2));
        var Me = function() {
          function A(T) {
            E(this, A), this.config = T, this.sensor = null, this.fusionSensor = null, this._out = new Float32Array(4), this.api = null, this.errors = [], this._sensorQ = new _t(), this._outQ = new _t(), this._onSensorRead = this._onSensorRead.bind(this), this._onSensorError = this._onSensorError.bind(this), this.init();
          }
          return M(A, [{
            key: "init",
            value: function() {
              var D = null;
              try {
                D = new RelativeOrientationSensor({
                  frequency: O,
                  referenceFrame: "screen"
                }), D.addEventListener("error", this._onSensorError);
              } catch (L) {
                this.errors.push(L), L.name === "SecurityError" ? (console.error("Cannot construct sensors due to the Feature Policy"), console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.'), this.useDeviceMotion()) : L.name === "ReferenceError" ? this.useDeviceMotion() : console.error(L);
              }
              D && (this.api = "sensor", this.sensor = D, this.sensor.addEventListener("reading", this._onSensorRead), this.sensor.start());
            }
          }, {
            key: "useDeviceMotion",
            value: function() {
              this.api = "devicemotion", this.fusionSensor = new Jt(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG), this.sensor && (this.sensor.removeEventListener("reading", this._onSensorRead), this.sensor.removeEventListener("error", this._onSensorError), this.sensor = null);
            }
          }, {
            key: "getOrientation",
            value: function() {
              if (this.fusionSensor)
                return this.fusionSensor.getOrientation();
              if (!this.sensor || !this.sensor.quaternion)
                return this._out[0] = this._out[1] = this._out[2] = 0, this._out[3] = 1, this._out;
              var D = this.sensor.quaternion;
              this._sensorQ.set(D[0], D[1], D[2], D[3]);
              var L = this._outQ;
              return L.copy(ge), L.multiply(this._sensorQ), this.config.YAW_ONLY && (L.x = L.z = 0, L.normalize()), this._out[0] = L.x, this._out[1] = L.y, this._out[2] = L.z, this._out[3] = L.w, this._out;
            }
          }, {
            key: "_onSensorError",
            value: function(D) {
              this.errors.push(D.error), D.error.name === "NotAllowedError" ? console.error("Permission to access sensor was denied") : D.error.name === "NotReadableError" ? console.error("Sensor could not be read") : console.error(D.error), this.useDeviceMotion();
            }
          }, {
            key: "_onSensorRead",
            value: function() {
            }
          }]), A;
        }(), ze = "<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>";
        function Ke() {
          this.loadIcon_();
          var A = document.createElement("div"), re = A.style;
          re.position = "fixed", re.top = 0, re.right = 0, re.bottom = 0, re.left = 0, re.backgroundColor = "gray", re.fontFamily = "sans-serif", re.zIndex = 1e6;
          var T = document.createElement("img");
          T.src = this.icon;
          var re = T.style;
          re.marginLeft = "25%", re.marginTop = "25%", re.width = "50%", A.appendChild(T);
          var D = document.createElement("div"), re = D.style;
          re.textAlign = "center", re.fontSize = "16px", re.lineHeight = "24px", re.margin = "24px 25%", re.width = "50%", D.innerHTML = "Place your phone into your Cardboard viewer.", A.appendChild(D);
          var L = document.createElement("div"), re = L.style;
          re.backgroundColor = "#CFD8DC", re.position = "fixed", re.bottom = 0, re.width = "100%", re.height = "48px", re.padding = "14px 24px", re.boxSizing = "border-box", re.color = "#656A6B", A.appendChild(L);
          var U = document.createElement("div");
          U.style.float = "left", U.innerHTML = "No Cardboard viewer?";
          var J = document.createElement("a");
          J.href = "https://www.google.com/get/cardboard/get-cardboard/", J.innerHTML = "get one", J.target = "_blank";
          var re = J.style;
          re.float = "right", re.fontWeight = 600, re.textTransform = "uppercase", re.borderLeft = "1px solid gray", re.paddingLeft = "24px", re.textDecoration = "none", re.color = "#656A6B", L.appendChild(U), L.appendChild(J), this.overlay = A, this.text = D, this.hide();
        }
        Ke.prototype.show = function(A) {
          !A && !this.overlay.parentElement ? document.body.appendChild(this.overlay) : A && (this.overlay.parentElement && this.overlay.parentElement != A && this.overlay.parentElement.removeChild(this.overlay), A.appendChild(this.overlay)), this.overlay.style.display = "block";
          var T = this.overlay.querySelector("img"), D = T.style;
          G() ? (D.width = "20%", D.marginLeft = "40%", D.marginTop = "3%") : (D.width = "50%", D.marginLeft = "25%", D.marginTop = "25%");
        }, Ke.prototype.hide = function() {
          this.overlay.style.display = "none";
        }, Ke.prototype.showTemporarily = function(A, T) {
          this.show(T), this.timer = setTimeout(this.hide.bind(this), A);
        }, Ke.prototype.disableShowTemporarily = function() {
          clearTimeout(this.timer);
        }, Ke.prototype.update = function() {
          this.disableShowTemporarily(), !G() && Le() ? this.show() : this.hide();
        }, Ke.prototype.loadIcon_ = function() {
          this.icon = F("image/svg+xml", ze);
        };
        var we = "CardboardV1", et = "WEBVR_CARDBOARD_VIEWER", nt = "webvr-polyfill-viewer-selector";
        function it(A) {
          try {
            this.selectedKey = localStorage.getItem(et);
          } catch (T) {
            console.error("Failed to load viewer profile: %s", T);
          }
          this.selectedKey || (this.selectedKey = A || we), this.dialog = this.createDialog_(Xt.Viewers), this.root = null, this.onChangeCallbacks_ = [];
        }
        it.prototype.show = function(A) {
          this.root = A, A.appendChild(this.dialog);
          var T = this.dialog.querySelector("#" + this.selectedKey);
          T.checked = !0, this.dialog.style.display = "block";
        }, it.prototype.hide = function() {
          this.root && this.root.contains(this.dialog) && this.root.removeChild(this.dialog), this.dialog.style.display = "none";
        }, it.prototype.getCurrentViewer = function() {
          return Xt.Viewers[this.selectedKey];
        }, it.prototype.getSelectedKey_ = function() {
          var A = this.dialog.querySelector("input[name=field]:checked");
          return A ? A.id : null;
        }, it.prototype.onChange = function(A) {
          this.onChangeCallbacks_.push(A);
        }, it.prototype.fireOnChange_ = function(A) {
          for (var T = 0; T < this.onChangeCallbacks_.length; T++)
            this.onChangeCallbacks_[T](A);
        }, it.prototype.onSave_ = function() {
          if (this.selectedKey = this.getSelectedKey_(), !this.selectedKey || !Xt.Viewers[this.selectedKey]) {
            console.error("ViewerSelector.onSave_: this should never happen!");
            return;
          }
          this.fireOnChange_(Xt.Viewers[this.selectedKey]);
          try {
            localStorage.setItem(et, this.selectedKey);
          } catch (A) {
            console.error("Failed to save viewer profile: %s", A);
          }
          this.hide();
        }, it.prototype.createDialog_ = function(A) {
          var T = document.createElement("div");
          T.classList.add(nt), T.style.display = "none";
          var D = document.createElement("div"), J = D.style;
          J.position = "fixed", J.left = 0, J.top = 0, J.width = "100%", J.height = "100%", J.background = "rgba(0, 0, 0, 0.3)", D.addEventListener("click", this.hide.bind(this));
          var L = 280, U = document.createElement("div"), J = U.style;
          J.boxSizing = "border-box", J.position = "fixed", J.top = "24px", J.left = "50%", J.marginLeft = -L / 2 + "px", J.width = L + "px", J.padding = "24px", J.overflow = "hidden", J.background = "#fafafa", J.fontFamily = "'Roboto', sans-serif", J.boxShadow = "0px 5px 20px #666", U.appendChild(this.createH1_("Select your viewer"));
          for (var re in A)
            U.appendChild(this.createChoice_(re, A[re].label));
          return U.appendChild(this.createButton_("Save", this.onSave_.bind(this))), T.appendChild(D), T.appendChild(U), T;
        }, it.prototype.createH1_ = function(A) {
          var T = document.createElement("h1"), D = T.style;
          return D.color = "black", D.fontSize = "20px", D.fontWeight = "bold", D.marginTop = 0, D.marginBottom = "24px", T.innerHTML = A, T;
        }, it.prototype.createChoice_ = function(A, T) {
          var D = document.createElement("div");
          D.style.marginTop = "8px", D.style.color = "black";
          var L = document.createElement("input");
          L.style.fontSize = "30px", L.setAttribute("id", A), L.setAttribute("type", "radio"), L.setAttribute("value", A), L.setAttribute("name", "field");
          var U = document.createElement("label");
          return U.style.marginLeft = "4px", U.setAttribute("for", A), U.innerHTML = T, D.appendChild(L), D.appendChild(U), D;
        }, it.prototype.createButton_ = function(A, T) {
          var D = document.createElement("button");
          D.innerHTML = A;
          var L = D.style;
          return L.float = "right", L.textTransform = "uppercase", L.color = "#1094f7", L.fontSize = "14px", L.letterSpacing = 0, L.border = 0, L.background = "none", L.marginTop = "16px", D.addEventListener("click", T), D;
        };
        var Tt = typeof window < "u" ? window : typeof i < "u" ? i : typeof self < "u" ? self : {};
        function Qe(A) {
          return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
        }
        function Dt(A, T) {
          return T = { exports: {} }, A(T, T.exports), T.exports;
        }
        var bt = Dt(function(A, T) {
          (function(L, U) {
            A.exports = U();
          })(Tt, function() {
            return function(D) {
              var L = {};
              function U(J) {
                if (L[J])
                  return L[J].exports;
                var re = L[J] = {
                  i: J,
                  l: !1,
                  exports: {}
                };
                return D[J].call(re.exports, re, re.exports, U), re.l = !0, re.exports;
              }
              return U.m = D, U.c = L, U.d = function(J, re, me) {
                U.o(J, re) || Object.defineProperty(J, re, {
                  configurable: !1,
                  enumerable: !0,
                  get: me
                });
              }, U.n = function(J) {
                var re = J && J.__esModule ? function() {
                  return J.default;
                } : function() {
                  return J;
                };
                return U.d(re, "a", re), re;
              }, U.o = function(J, re) {
                return Object.prototype.hasOwnProperty.call(J, re);
              }, U.p = "", U(U.s = 0);
            }([
              function(D, L, U) {
                var J = /* @__PURE__ */ function() {
                  function le(be, Ge) {
                    for (var qe = 0; qe < Ge.length; qe++) {
                      var rt = Ge[qe];
                      rt.enumerable = rt.enumerable || !1, rt.configurable = !0, "value" in rt && (rt.writable = !0), Object.defineProperty(be, rt.key, rt);
                    }
                  }
                  return function(be, Ge, qe) {
                    return Ge && le(be.prototype, Ge), qe && le(be, qe), be;
                  };
                }();
                function re(le, be) {
                  if (!(le instanceof be))
                    throw new TypeError("Cannot call a class as a function");
                }
                var me = U(1), ve = typeof navigator < "u" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream, ne = function() {
                  function le() {
                    re(this, le), ve ? this.noSleepTimer = null : (this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("playsinline", ""), this.noSleepVideo.setAttribute("src", me), this.noSleepVideo.addEventListener("timeupdate", (function(be) {
                      this.noSleepVideo.currentTime > 0.5 && (this.noSleepVideo.currentTime = Math.random());
                    }).bind(this)));
                  }
                  return J(le, [{
                    key: "enable",
                    value: function() {
                      ve ? (this.disable(), this.noSleepTimer = window.setInterval(function() {
                        window.location.href = "/", window.setTimeout(window.stop, 0);
                      }, 15e3)) : this.noSleepVideo.play();
                    }
                  }, {
                    key: "disable",
                    value: function() {
                      ve ? this.noSleepTimer && (window.clearInterval(this.noSleepTimer), this.noSleepTimer = null) : this.noSleepVideo.pause();
                    }
                  }]), le;
                }();
                D.exports = ne;
              },
              function(D, L, U) {
                D.exports = "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA=";
              }
            ]);
          });
        }), $t = Qe(bt), hi = 1e3, Ni = [0, 0, 0.5, 1], Ci = [0.5, 0, 0.5, 1], an = window.requestAnimationFrame, ra = window.cancelAnimationFrame;
        function na() {
          this.leftProjectionMatrix = new Float32Array(16), this.leftViewMatrix = new Float32Array(16), this.rightProjectionMatrix = new Float32Array(16), this.rightViewMatrix = new Float32Array(16), this.pose = null;
        }
        function aa(A) {
          Object.defineProperties(this, {
            hasPosition: {
              writable: !1,
              enumerable: !0,
              value: A.hasPosition
            },
            hasExternalDisplay: {
              writable: !1,
              enumerable: !0,
              value: A.hasExternalDisplay
            },
            canPresent: {
              writable: !1,
              enumerable: !0,
              value: A.canPresent
            },
            maxLayers: {
              writable: !1,
              enumerable: !0,
              value: A.maxLayers
            },
            hasOrientation: {
              enumerable: !0,
              get: function() {
                return yt("VRDisplayCapabilities.prototype.hasOrientation", "VRDisplay.prototype.getFrameData"), A.hasOrientation;
              }
            }
          });
        }
        function It(A) {
          A = A || {};
          var T = "wakelock" in A ? A.wakelock : !0;
          this.isPolyfilled = !0, this.displayId = hi++, this.displayName = "", this.depthNear = 0.01, this.depthFar = 1e4, this.isPresenting = !1, Object.defineProperty(this, "isConnected", {
            get: function() {
              return yt("VRDisplay.prototype.isConnected", "VRDisplayCapabilities.prototype.hasExternalDisplay"), !1;
            }
          }), this.capabilities = new aa({
            hasPosition: !1,
            hasOrientation: !1,
            hasExternalDisplay: !1,
            canPresent: !1,
            maxLayers: 1
          }), this.stageParameters = null, this.waitingForPresent_ = !1, this.layer_ = null, this.originalParent_ = null, this.fullscreenElement_ = null, this.fullscreenWrapper_ = null, this.fullscreenElementCachedStyle_ = null, this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null, T && Le() && (this.wakelock_ = new $t());
        }
        It.prototype.getFrameData = function(A) {
          return Ee(A, this._getPose(), this);
        }, It.prototype.getPose = function() {
          return yt("VRDisplay.prototype.getPose", "VRDisplay.prototype.getFrameData"), this._getPose();
        }, It.prototype.resetPose = function() {
          return yt("VRDisplay.prototype.resetPose"), this._resetPose();
        }, It.prototype.getImmediatePose = function() {
          return yt("VRDisplay.prototype.getImmediatePose", "VRDisplay.prototype.getFrameData"), this._getPose();
        }, It.prototype.requestAnimationFrame = function(A) {
          return an(A);
        }, It.prototype.cancelAnimationFrame = function(A) {
          return ra(A);
        }, It.prototype.wrapForFullscreen = function(A) {
          if (I())
            return A;
          if (!this.fullscreenWrapper_) {
            this.fullscreenWrapper_ = document.createElement("div");
            var T = ["height: " + Math.min(screen.height, screen.width) + "px !important", "top: 0 !important", "left: 0 !important", "right: 0 !important", "border: 0", "margin: 0", "padding: 0", "z-index: 999999 !important", "position: fixed"];
            this.fullscreenWrapper_.setAttribute("style", T.join("; ") + ";"), this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper");
          }
          if (this.fullscreenElement_ == A)
            return this.fullscreenWrapper_;
          if (this.fullscreenElement_ && (this.originalParent_ ? this.originalParent_.appendChild(this.fullscreenElement_) : this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_)), this.fullscreenElement_ = A, this.originalParent_ = A.parentElement, this.originalParent_ || document.body.appendChild(A), !this.fullscreenWrapper_.parentElement) {
            var D = this.fullscreenElement_.parentElement;
            D.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_), D.removeChild(this.fullscreenElement_);
          }
          this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild), this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
          var L = this;
          function U() {
            if (L.fullscreenElement_) {
              var J = ["position: absolute", "top: 0", "left: 0", "width: " + Math.max(screen.width, screen.height) + "px", "height: " + Math.min(screen.height, screen.width) + "px", "border: 0", "margin: 0", "padding: 0"];
              L.fullscreenElement_.setAttribute("style", J.join("; ") + ";");
            }
          }
          return U(), this.fullscreenWrapper_;
        }, It.prototype.removeFullscreenWrapper = function() {
          if (this.fullscreenElement_) {
            var A = this.fullscreenElement_;
            this.fullscreenElementCachedStyle_ ? A.setAttribute("style", this.fullscreenElementCachedStyle_) : A.removeAttribute("style"), this.fullscreenElement_ = null, this.fullscreenElementCachedStyle_ = null;
            var T = this.fullscreenWrapper_.parentElement;
            return this.fullscreenWrapper_.removeChild(A), this.originalParent_ === T ? T.insertBefore(A, this.fullscreenWrapper_) : this.originalParent_ && this.originalParent_.appendChild(A), T.removeChild(this.fullscreenWrapper_), A;
          }
        }, It.prototype.requestPresent = function(A) {
          var T = this.isPresenting, D = this;
          return A instanceof Array || (yt("VRDisplay.prototype.requestPresent with non-array argument", "an array of VRLayers as the first argument"), A = [A]), new Promise(function(L, U) {
            if (!D.capabilities.canPresent) {
              U(new Error("VRDisplay is not capable of presenting."));
              return;
            }
            if (A.length == 0 || A.length > D.capabilities.maxLayers) {
              U(new Error("Invalid number of layers."));
              return;
            }
            var J = A[0];
            if (!J.source) {
              L();
              return;
            }
            var re = J.leftBounds || Ni, me = J.rightBounds || Ci;
            if (T) {
              var ve = D.layer_;
              ve.source !== J.source && (ve.source = J.source);
              for (var ne = 0; ne < 4; ne++)
                ve.leftBounds[ne] = re[ne], ve.rightBounds[ne] = me[ne];
              D.wrapForFullscreen(D.layer_.source), D.updatePresent_(), L();
              return;
            }
            if (D.layer_ = {
              predistorted: J.predistorted,
              source: J.source,
              leftBounds: re.slice(0),
              rightBounds: me.slice(0)
            }, D.waitingForPresent_ = !1, D.layer_ && D.layer_.source) {
              var le = D.wrapForFullscreen(D.layer_.source), be = function() {
                var rt = xe();
                D.isPresenting = le === rt, D.isPresenting ? (screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape-primary").catch(function(At) {
                  console.error("screen.orientation.lock() failed due to", At.message);
                }), D.waitingForPresent_ = !1, D.beginPresent_(), L()) : (screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), D.removeFullscreenWrapper(), D.disableWakeLock(), D.endPresent_(), D.removeFullscreenListeners_()), D.fireVRDisplayPresentChange_();
              }, Ge = function() {
                D.waitingForPresent_ && (D.removeFullscreenWrapper(), D.removeFullscreenListeners_(), D.disableWakeLock(), D.waitingForPresent_ = !1, D.isPresenting = !1, U(new Error("Unable to present.")));
              };
              D.addFullscreenListeners_(le, be, Ge), Ce(le) ? (D.enableWakeLock(), D.waitingForPresent_ = !0) : (I() || V()) && (D.enableWakeLock(), D.isPresenting = !0, D.beginPresent_(), D.fireVRDisplayPresentChange_(), L());
            }
            !D.waitingForPresent_ && !I() && (K(), U(new Error("Unable to present.")));
          });
        }, It.prototype.exitPresent = function() {
          var A = this.isPresenting, T = this;
          return this.isPresenting = !1, this.layer_ = null, this.disableWakeLock(), new Promise(function(D, L) {
            A ? (!K() && I() && (T.endPresent_(), T.fireVRDisplayPresentChange_()), V() && (T.removeFullscreenWrapper(), T.removeFullscreenListeners_(), T.endPresent_(), T.fireVRDisplayPresentChange_()), D()) : L(new Error("Was not presenting to VRDisplay."));
          });
        }, It.prototype.getLayers = function() {
          return this.layer_ ? [this.layer_] : [];
        }, It.prototype.fireVRDisplayPresentChange_ = function() {
          var A = new CustomEvent("vrdisplaypresentchange", { detail: { display: this } });
          window.dispatchEvent(A);
        }, It.prototype.fireVRDisplayConnect_ = function() {
          var A = new CustomEvent("vrdisplayconnect", { detail: { display: this } });
          window.dispatchEvent(A);
        }, It.prototype.addFullscreenListeners_ = function(A, T, D) {
          this.removeFullscreenListeners_(), this.fullscreenEventTarget_ = A, this.fullscreenChangeHandler_ = T, this.fullscreenErrorHandler_ = D, T && (document.fullscreenEnabled ? A.addEventListener("fullscreenchange", T, !1) : document.webkitFullscreenEnabled ? A.addEventListener("webkitfullscreenchange", T, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenchange", T, !1) : document.msFullscreenEnabled && A.addEventListener("msfullscreenchange", T, !1)), D && (document.fullscreenEnabled ? A.addEventListener("fullscreenerror", D, !1) : document.webkitFullscreenEnabled ? A.addEventListener("webkitfullscreenerror", D, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenerror", D, !1) : document.msFullscreenEnabled && A.addEventListener("msfullscreenerror", D, !1));
        }, It.prototype.removeFullscreenListeners_ = function() {
          if (this.fullscreenEventTarget_) {
            var A = this.fullscreenEventTarget_;
            if (this.fullscreenChangeHandler_) {
              var T = this.fullscreenChangeHandler_;
              A.removeEventListener("fullscreenchange", T, !1), A.removeEventListener("webkitfullscreenchange", T, !1), document.removeEventListener("mozfullscreenchange", T, !1), A.removeEventListener("msfullscreenchange", T, !1);
            }
            if (this.fullscreenErrorHandler_) {
              var D = this.fullscreenErrorHandler_;
              A.removeEventListener("fullscreenerror", D, !1), A.removeEventListener("webkitfullscreenerror", D, !1), document.removeEventListener("mozfullscreenerror", D, !1), A.removeEventListener("msfullscreenerror", D, !1);
            }
            this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null;
          }
        }, It.prototype.enableWakeLock = function() {
          this.wakelock_ && this.wakelock_.enable();
        }, It.prototype.disableWakeLock = function() {
          this.wakelock_ && this.wakelock_.disable();
        }, It.prototype.beginPresent_ = function() {
        }, It.prototype.endPresent_ = function() {
        }, It.prototype.submitFrame = function(A) {
        }, It.prototype.getEyeParameters = function(A) {
          return null;
        };
        var xs = {
          ADDITIONAL_VIEWERS: [],
          DEFAULT_VIEWER: "",
          MOBILE_WAKE_LOCK: !0,
          DEBUG: !1,
          DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
          K_FILTER: 0.98,
          PREDICTION_TIME_S: 0.04,
          CARDBOARD_UI_DISABLED: !1,
          ROTATE_INSTRUCTIONS_DISABLED: !1,
          YAW_ONLY: !1,
          BUFFER_SCALE: 0.5,
          DIRTY_SUBMIT_FRAME_BINDINGS: !1
        }, sn = {
          LEFT: "left",
          RIGHT: "right"
        };
        function ei(A) {
          var T = Ve({}, xs);
          A = Ve(T, A || {}), It.call(this, {
            wakelock: A.MOBILE_WAKE_LOCK
          }), this.config = A, this.displayName = "Cardboard VRDisplay", this.capabilities = new aa({
            hasPosition: !1,
            hasOrientation: !0,
            hasExternalDisplay: !1,
            canPresent: !0,
            maxLayers: 1
          }), this.stageParameters = null, this.bufferScale_ = this.config.BUFFER_SCALE, this.poseSensor_ = new Me(this.config), this.distorter_ = null, this.cardboardUI_ = null, this.dpdb_ = new _r(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this)), this.deviceInfo_ = new Xt(this.dpdb_.getDeviceParams(), A.ADDITIONAL_VIEWERS), this.viewerSelector_ = new it(A.DEFAULT_VIEWER), this.viewerSelector_.onChange(this.onViewerChanged_.bind(this)), this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer()), this.config.ROTATE_INSTRUCTIONS_DISABLED || (this.rotateInstructions_ = new Ke()), I() && window.addEventListener("resize", this.onResize_.bind(this));
        }
        return ei.prototype = Object.create(It.prototype), ei.prototype._getPose = function() {
          return {
            position: null,
            orientation: this.poseSensor_.getOrientation(),
            linearVelocity: null,
            linearAcceleration: null,
            angularVelocity: null,
            angularAcceleration: null
          };
        }, ei.prototype._resetPose = function() {
          this.poseSensor_.resetPose && this.poseSensor_.resetPose();
        }, ei.prototype._getFieldOfView = function(A) {
          var T;
          if (A == sn.LEFT)
            T = this.deviceInfo_.getFieldOfViewLeftEye();
          else if (A == sn.RIGHT)
            T = this.deviceInfo_.getFieldOfViewRightEye();
          else
            return console.error("Invalid eye provided: %s", A), null;
          return T;
        }, ei.prototype._getEyeOffset = function(A) {
          var T;
          if (A == sn.LEFT)
            T = [-this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
          else if (A == sn.RIGHT)
            T = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
          else
            return console.error("Invalid eye provided: %s", A), null;
          return T;
        }, ei.prototype.getEyeParameters = function(A) {
          var T = this._getEyeOffset(A), D = this._getFieldOfView(A), L = {
            offset: T,
            renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
            renderHeight: this.deviceInfo_.device.height * this.bufferScale_
          };
          return Object.defineProperty(L, "fieldOfView", {
            enumerable: !0,
            get: function() {
              return yt("VRFieldOfView", "VRFrameData's projection matrices"), D;
            }
          }), L;
        }, ei.prototype.onDeviceParamsUpdated_ = function(A) {
          this.config.DEBUG && console.log("DPDB reported that device params were updated."), this.deviceInfo_.updateDeviceParams(A), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_);
        }, ei.prototype.updateBounds_ = function() {
          this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds) && this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
        }, ei.prototype.beginPresent_ = function() {
          var A = this.layer_.source.getContext("webgl");
          A || (A = this.layer_.source.getContext("experimental-webgl")), A || (A = this.layer_.source.getContext("webgl2")), A && (this.layer_.predistorted ? this.config.CARDBOARD_UI_DISABLED || (A.canvas.width = se() * this.bufferScale_, A.canvas.height = ie() * this.bufferScale_, this.cardboardUI_ = new Rt(A)) : (this.config.CARDBOARD_UI_DISABLED || (this.cardboardUI_ = new Rt(A)), this.distorter_ = new ci(A, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS), this.distorter_.updateDeviceInfo(this.deviceInfo_)), this.cardboardUI_ && this.cardboardUI_.listen((function(T) {
            this.viewerSelector_.show(this.layer_.source.parentElement), T.stopPropagation(), T.preventDefault();
          }).bind(this), (function(T) {
            this.exitPresent(), T.stopPropagation(), T.preventDefault();
          }).bind(this)), this.rotateInstructions_ && (G() && Le() ? this.rotateInstructions_.showTemporarily(3e3, this.layer_.source.parentElement) : this.rotateInstructions_.update()), this.orientationHandler = this.onOrientationChange_.bind(this), window.addEventListener("orientationchange", this.orientationHandler), this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this), window.addEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler), this.fireVRDisplayDeviceParamsChange_());
        }, ei.prototype.endPresent_ = function() {
          this.distorter_ && (this.distorter_.destroy(), this.distorter_ = null), this.cardboardUI_ && (this.cardboardUI_.destroy(), this.cardboardUI_ = null), this.rotateInstructions_ && this.rotateInstructions_.hide(), this.viewerSelector_.hide(), window.removeEventListener("orientationchange", this.orientationHandler), window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
        }, ei.prototype.updatePresent_ = function() {
          this.endPresent_(), this.beginPresent_();
        }, ei.prototype.submitFrame = function(A) {
          if (this.distorter_)
            this.updateBounds_(), this.distorter_.submitFrame();
          else if (this.cardboardUI_ && this.layer_) {
            var T = this.layer_.source.getContext("webgl");
            T || (T = this.layer_.source.getContext("experimental-webgl")), T || (T = this.layer_.source.getContext("webgl2"));
            var D = T.canvas;
            (D.width != this.lastWidth || D.height != this.lastHeight) && this.cardboardUI_.onResize(), this.lastWidth = D.width, this.lastHeight = D.height, this.cardboardUI_.render();
          }
        }, ei.prototype.onOrientationChange_ = function(A) {
          this.viewerSelector_.hide(), this.rotateInstructions_ && this.rotateInstructions_.update(), this.onResize_();
        }, ei.prototype.onResize_ = function(A) {
          if (this.layer_) {
            var T = this.layer_.source.getContext("webgl");
            T || (T = this.layer_.source.getContext("experimental-webgl")), T || (T = this.layer_.source.getContext("webgl2"));
            var D = [
              "position: absolute",
              "top: 0",
              "left: 0",
              "width: 100vw",
              "height: 100vh",
              "border: 0",
              "margin: 0",
              "padding: 0px",
              "box-sizing: content-box"
            ];
            T.canvas.setAttribute("style", D.join("; ") + ";"), ft(T.canvas);
          }
        }, ei.prototype.onViewerChanged_ = function(A) {
          this.deviceInfo_.setViewer(A), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_), this.fireVRDisplayDeviceParamsChange_();
        }, ei.prototype.fireVRDisplayDeviceParamsChange_ = function() {
          var A = new CustomEvent("vrdisplaydeviceparamschange", {
            detail: {
              vrdisplay: this,
              deviceInfo: this.deviceInfo_
            }
          });
          window.dispatchEvent(A);
        }, ei.VRFrameData = na, ei.VRDisplay = It, ei;
      });
    }), l = n(u), c = "0.10.12", h = {
      ADDITIONAL_VIEWERS: [],
      DEFAULT_VIEWER: "",
      PROVIDE_MOBILE_VRDISPLAY: !0,
      MOBILE_WAKE_LOCK: !0,
      DEBUG: !1,
      DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
      K_FILTER: 0.98,
      PREDICTION_TIME_S: 0.04,
      CARDBOARD_UI_DISABLED: !1,
      ROTATE_INSTRUCTIONS_DISABLED: !1,
      YAW_ONLY: !1,
      BUFFER_SCALE: 0.5,
      DIRTY_SUBMIT_FRAME_BINDINGS: !1
    };
    function d(m) {
      this.config = o(o({}, h), m), this.polyfillDisplays = [], this.enabled = !1, this.hasNative = "getVRDisplays" in navigator, this.native = {}, this.native.getVRDisplays = navigator.getVRDisplays, this.native.VRFrameData = window.VRFrameData, this.native.VRDisplay = window.VRDisplay, (!this.hasNative || this.config.PROVIDE_MOBILE_VRDISPLAY && a()) && (this.enable(), this.getVRDisplays().then(function(x) {
        x && x[0] && x[0].fireVRDisplayConnect_ && x[0].fireVRDisplayConnect_();
      }));
    }
    d.prototype.getPolyfillDisplays = function() {
      if (this._polyfillDisplaysPopulated)
        return this.polyfillDisplays;
      if (a()) {
        var m = new l({
          ADDITIONAL_VIEWERS: this.config.ADDITIONAL_VIEWERS,
          DEFAULT_VIEWER: this.config.DEFAULT_VIEWER,
          MOBILE_WAKE_LOCK: this.config.MOBILE_WAKE_LOCK,
          DEBUG: this.config.DEBUG,
          DPDB_URL: this.config.DPDB_URL,
          CARDBOARD_UI_DISABLED: this.config.CARDBOARD_UI_DISABLED,
          K_FILTER: this.config.K_FILTER,
          PREDICTION_TIME_S: this.config.PREDICTION_TIME_S,
          ROTATE_INSTRUCTIONS_DISABLED: this.config.ROTATE_INSTRUCTIONS_DISABLED,
          YAW_ONLY: this.config.YAW_ONLY,
          BUFFER_SCALE: this.config.BUFFER_SCALE,
          DIRTY_SUBMIT_FRAME_BINDINGS: this.config.DIRTY_SUBMIT_FRAME_BINDINGS
        });
        this.polyfillDisplays.push(m);
      }
      return this._polyfillDisplaysPopulated = !0, this.polyfillDisplays;
    }, d.prototype.enable = function() {
      if (this.enabled = !0, this.hasNative && this.native.VRFrameData) {
        var m = this.native.VRFrameData, x = new this.native.VRFrameData(), E = this.native.VRDisplay.prototype.getFrameData;
        window.VRDisplay.prototype.getFrameData = function(M) {
          if (M instanceof m) {
            E.call(this, M);
            return;
          }
          E.call(this, x), M.pose = x.pose, s(x.leftProjectionMatrix, M.leftProjectionMatrix), s(x.rightProjectionMatrix, M.rightProjectionMatrix), s(x.leftViewMatrix, M.leftViewMatrix), s(x.rightViewMatrix, M.rightViewMatrix);
        };
      }
      navigator.getVRDisplays = this.getVRDisplays.bind(this), window.VRDisplay = l.VRDisplay, window.VRFrameData = l.VRFrameData;
    }, d.prototype.getVRDisplays = function() {
      var m = this;
      return this.config, this.hasNative ? this.native.getVRDisplays.call(navigator).then(function(x) {
        return x.length > 0 ? x : m.getPolyfillDisplays();
      }) : Promise.resolve(this.getPolyfillDisplays());
    }, d.version = c, d.VRFrameData = l.VRFrameData, d.VRDisplay = l.VRDisplay;
    var f = Object.freeze({
      default: d
    }), p = f && d || f;
    typeof i < "u" && i.window && (i.document || (i.document = i.window.document), i.navigator || (i.navigator = i.window.navigator));
    var _ = p;
    return _;
  });
})(by);
var sw = by.exports;
const $h = /* @__PURE__ */ Yn(sw);
function xy() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (xy = function() {
    return !!e;
  })();
}
function Ay(e, t, i) {
  if (xy()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, t);
  var r = new (e.bind.apply(e, n))();
  return i && Us(r, i.prototype), r;
}
function kr() {
  return kr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var i = arguments[t];
      for (var n in i) ({}).hasOwnProperty.call(i, n) && (e[n] = i[n]);
    }
    return e;
  }, kr.apply(null, arguments);
}
const ow = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get default() {
    return kr;
  }
}, Symbol.toStringTag, { value: "Module" }));
function uw(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Us(e, t);
}
function qd(e) {
  return qd = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, qd(e);
}
function lw(e) {
  try {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  } catch {
    return typeof e == "function";
  }
}
function Xd(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Xd = function(n) {
    if (n === null || !lw(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (t !== void 0) {
      if (t.has(n)) return t.get(n);
      t.set(n, r);
    }
    function r() {
      return Ay(n, arguments, qd(this).constructor);
    }
    return r.prototype = Object.create(n.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Us(r, n);
  }, Xd(e);
}
var cw = function(t) {
  return t.toString(2).length;
}, hw = function(t) {
  return Math.ceil(cw(t) / 8);
}, Ty = function(t) {
  return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer;
}, dw = function(t) {
  return Ty(t);
}, Ze = function(t) {
  return t instanceof Uint8Array ? t : (!Array.isArray(t) && !dw(t) && !(t instanceof ArrayBuffer) && (typeof t != "number" || typeof t == "number" && t !== t ? t = 0 : t = [t]), new Uint8Array(t && t.buffer || t, t && t.byteOffset || 0, t && t.byteLength || 0));
}, ki = W.BigInt || Number, Yd = [ki("0x1"), ki("0x100"), ki("0x10000"), ki("0x1000000"), ki("0x100000000"), ki("0x10000000000"), ki("0x1000000000000"), ki("0x100000000000000"), ki("0x10000000000000000")];
(function() {
  var e = new Uint16Array([65484]), t = new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
  return t[0] === 255 ? "big" : t[0] === 204 ? "little" : "unknown";
})();
var fw = function(t, i) {
  var n = i === void 0 ? {} : i, r = n.signed, a = r === void 0 ? !1 : r, s = n.le, o = s === void 0 ? !1 : s;
  t = Ze(t);
  var u = o ? "reduce" : "reduceRight", l = t[u] ? t[u] : Array.prototype[u], c = l.call(t, function(d, f, p) {
    var _ = o ? p : Math.abs(p + 1 - t.length);
    return d + ki(f) * Yd[_];
  }, ki(0));
  if (a) {
    var h = Yd[t.length] / ki(2) - ki(1);
    c = ki(c), c > h && (c -= h, c -= h, c -= ki(2));
  }
  return Number(c);
}, pw = function(t, i) {
  var n = {}, r = n.le, a = r === void 0 ? !1 : r;
  (typeof t != "bigint" && typeof t != "number" || typeof t == "number" && t !== t) && (t = 0), t = ki(t);
  for (var s = hw(t), o = new Uint8Array(new ArrayBuffer(s)), u = 0; u < s; u++) {
    var l = a ? u : Math.abs(u + 1 - o.length);
    o[l] = Number(t / Yd[u] & ki(255)), t < 0 && (o[l] = Math.abs(~o[l]), o[l] -= u === 0 ? 1 : 2);
  }
  return o;
}, Ey = function(t, i) {
  if (typeof t != "string" && t && typeof t.toString == "function" && (t = t.toString()), typeof t != "string")
    return new Uint8Array();
  i || (t = unescape(encodeURIComponent(t)));
  for (var n = new Uint8Array(t.length), r = 0; r < t.length; r++)
    n[r] = t.charCodeAt(r);
  return n;
}, vw = function() {
  for (var t = arguments.length, i = new Array(t), n = 0; n < t; n++)
    i[n] = arguments[n];
  if (i = i.filter(function(o) {
    return o && (o.byteLength || o.length) && typeof o != "string";
  }), i.length <= 1)
    return Ze(i[0]);
  var r = i.reduce(function(o, u, l) {
    return o + (u.byteLength || u.length);
  }, 0), a = new Uint8Array(r), s = 0;
  return i.forEach(function(o) {
    o = Ze(o), a.set(o, s), s += o.byteLength;
  }), a;
}, ii = function(t, i, n) {
  var r = n === void 0 ? {} : n, a = r.offset, s = a === void 0 ? 0 : a, o = r.mask, u = o === void 0 ? [] : o;
  t = Ze(t), i = Ze(i);
  var l = i.every ? i.every : Array.prototype.every;
  return i.length && t.length - s >= i.length && // ie 11 doesn't support every on uin8
  l.call(i, function(c, h) {
    var d = u[h] ? u[h] & t[s + h] : t[s + h];
    return c === d;
  });
}, Na = {
  // to determine mime types
  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
  // to determine if a codec is audio or video
  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
  text: /^(stpp.ttml.im1t)/,
  // mux.js support regex
  muxerVideo: /^(avc0?1)/,
  muxerAudio: /^(mp4a)/,
  // match nothing as muxer does not support text right now.
  // there cannot never be a character before the start of a string
  // so this matches nothing.
  muxerText: /a^/
}, mw = ["video", "audio", "text"], em = ["Video", "Audio", "Text"], wy = function(t) {
  return t && t.replace(/avc1\.(\d+)\.(\d+)/i, function(i, n, r) {
    var a = ("00" + Number(n).toString(16)).slice(-2), s = ("00" + Number(r).toString(16)).slice(-2);
    return "avc1." + a + "00" + s;
  });
}, ln = function(t) {
  t === void 0 && (t = "");
  var i = t.split(","), n = [];
  return i.forEach(function(r) {
    r = r.trim();
    var a;
    mw.forEach(function(s) {
      var o = Na[s].exec(r.toLowerCase());
      if (!(!o || o.length <= 1)) {
        a = s;
        var u = r.substring(0, o[1].length), l = r.replace(u, "");
        n.push({
          type: u,
          details: l,
          mediaType: s
        });
      }
    }), a || n.push({
      type: r,
      details: "",
      mediaType: "unknown"
    });
  }), n;
}, gw = function(t, i) {
  if (!t.mediaGroups.AUDIO || !i)
    return null;
  var n = t.mediaGroups.AUDIO[i];
  if (!n)
    return null;
  for (var r in n) {
    var a = n[r];
    if (a.default && a.playlists)
      return ln(a.playlists[0].attributes.CODECS);
  }
  return null;
}, Sy = function(t) {
  return t === void 0 && (t = ""), Na.audio.test(t.trim().toLowerCase());
}, yw = function(t) {
  return t === void 0 && (t = ""), Na.text.test(t.trim().toLowerCase());
}, ll = function(t) {
  if (!(!t || typeof t != "string")) {
    var i = t.toLowerCase().split(",").map(function(a) {
      return wy(a.trim());
    }), n = "video";
    i.length === 1 && Sy(i[0]) ? n = "audio" : i.length === 1 && yw(i[0]) && (n = "application");
    var r = "mp4";
    return i.every(function(a) {
      return Na.mp4.test(a);
    }) ? r = "mp4" : i.every(function(a) {
      return Na.webm.test(a);
    }) ? r = "webm" : i.every(function(a) {
      return Na.ogg.test(a);
    }) && (r = "ogg"), n + "/" + r + ';codecs="' + t + '"';
  }
}, tc = function(t) {
  return t === void 0 && (t = ""), W.MediaSource && W.MediaSource.isTypeSupported && W.MediaSource.isTypeSupported(ll(t)) || !1;
}, ed = function(t) {
  return t === void 0 && (t = ""), t.toLowerCase().split(",").every(function(i) {
    i = i.trim();
    for (var n = 0; n < em.length; n++) {
      var r = em[n];
      if (Na["muxer" + r].test(i))
        return !0;
    }
    return !1;
  });
}, tm = "mp4a.40.2", _w = "avc1.4d400d", im = function(t) {
  return typeof t == "string" ? Ey(t) : t;
}, bw = function(t) {
  return Array.isArray(t) ? t.map(function(i) {
    return im(i);
  }) : [im(t)];
}, xw = function e(t, i, n) {
  n === void 0 && (n = !1), i = bw(i), t = Ze(t);
  var r = [];
  if (!i.length)
    return r;
  for (var a = 0; a < t.length; ) {
    var s = (t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3]) >>> 0, o = t.subarray(a + 4, a + 8);
    if (s === 0)
      break;
    var u = a + s;
    if (u > t.length) {
      if (n)
        break;
      u = t.length;
    }
    var l = t.subarray(a + 8, u);
    ii(o, i[0]) && (i.length === 1 ? r.push(l) : r.push.apply(r, e(l, i.slice(1), n))), a = u;
  }
  return r;
}, Vl = {
  EBML: Ze([26, 69, 223, 163]),
  DocType: Ze([66, 130]),
  Segment: Ze([24, 83, 128, 103]),
  SegmentInfo: Ze([21, 73, 169, 102]),
  Tracks: Ze([22, 84, 174, 107]),
  Track: Ze([174]),
  TrackNumber: Ze([215]),
  DefaultDuration: Ze([35, 227, 131]),
  TrackEntry: Ze([174]),
  TrackType: Ze([131]),
  FlagDefault: Ze([136]),
  CodecID: Ze([134]),
  CodecPrivate: Ze([99, 162]),
  VideoTrack: Ze([224]),
  AudioTrack: Ze([225]),
  // Not used yet, but will be used for live webm/mkv
  // see https://www.matroska.org/technical/basics.html#block-structure
  // see https://www.matroska.org/technical/basics.html#simpleblock-structure
  Cluster: Ze([31, 67, 182, 117]),
  Timestamp: Ze([231]),
  TimestampScale: Ze([42, 215, 177]),
  BlockGroup: Ze([160]),
  BlockDuration: Ze([155]),
  Block: Ze([161]),
  SimpleBlock: Ze([163])
}, Qd = [128, 64, 32, 16, 8, 4, 2, 1], Aw = function(t) {
  for (var i = 1, n = 0; n < Qd.length && !(t & Qd[n]); n++)
    i++;
  return i;
}, Ic = function(t, i, n, r) {
  n === void 0 && (n = !0), r === void 0 && (r = !1);
  var a = Aw(t[i]), s = t.subarray(i, i + a);
  return n && (s = Array.prototype.slice.call(t, i, i + a), s[0] ^= Qd[a - 1]), {
    length: a,
    value: fw(s, {
      signed: r
    }),
    bytes: s
  };
}, rm = function e(t) {
  return typeof t == "string" ? t.match(/.{1,2}/g).map(function(i) {
    return e(i);
  }) : typeof t == "number" ? pw(t) : t;
}, Tw = function(t) {
  return Array.isArray(t) ? t.map(function(i) {
    return rm(i);
  }) : [rm(t)];
}, Ew = function e(t, i, n) {
  if (n >= i.length)
    return i.length;
  var r = Ic(i, n, !1);
  if (ii(t.bytes, r.bytes))
    return n;
  var a = Ic(i, n + r.length);
  return e(t, i, n + a.length + a.value + r.length);
}, nm = function e(t, i) {
  i = Tw(i), t = Ze(t);
  var n = [];
  if (!i.length)
    return n;
  for (var r = 0; r < t.length; ) {
    var a = Ic(t, r, !1), s = Ic(t, r + a.length), o = r + a.length + s.length;
    s.value === 127 && (s.value = Ew(a, t, o), s.value !== t.length && (s.value -= o));
    var u = o + s.value > t.length ? t.length : o + s.value, l = t.subarray(o, u);
    ii(i[0], a.bytes) && (i.length === 1 ? n.push(l) : n = n.concat(e(l, i.slice(1))));
    var c = a.length + s.length + l.length;
    r += c;
  }
  return n;
}, ww = Ze([73, 68, 51]), Sw = function(t, i) {
  i === void 0 && (i = 0), t = Ze(t);
  var n = t[i + 5], r = t[i + 6] << 21 | t[i + 7] << 14 | t[i + 8] << 7 | t[i + 9], a = (n & 16) >> 4;
  return a ? r + 20 : r + 10;
}, nu = function e(t, i) {
  return i === void 0 && (i = 0), t = Ze(t), t.length - i < 10 || !ii(t, ww, {
    offset: i
  }) ? i : (i += Sw(t, i), e(t, i));
}, Cw = Ze([0, 0, 0, 1]), Mw = Ze([0, 0, 1]), Dw = Ze([0, 0, 3]), Pw = function(t) {
  for (var i = [], n = 1; n < t.length - 2; )
    ii(t.subarray(n, n + 3), Dw) && (i.push(n + 2), n++), n++;
  if (i.length === 0)
    return t;
  var r = t.length - i.length, a = new Uint8Array(r), s = 0;
  for (n = 0; n < r; s++, n++)
    s === i[0] && (s++, i.shift()), a[n] = t[s];
  return a;
}, Cy = function(t, i, n, r) {
  t = Ze(t), n = [].concat(n);
  for (var a = 0, s, o = 0; a < t.length && (o < r || s); ) {
    var u = void 0;
    if (ii(t.subarray(a), Cw) ? u = 4 : ii(t.subarray(a), Mw) && (u = 3), !u) {
      a++;
      continue;
    }
    if (o++, s)
      return Pw(t.subarray(s, a));
    var l = void 0;
    i === "h264" ? l = t[a + u] & 31 : i === "h265" && (l = t[a + u] >> 1 & 63), n.indexOf(l) !== -1 && (s = a + u), a += u + (i === "h264" ? 1 : 2);
  }
  return t.subarray(0, 0);
}, Lw = function(t, i, n) {
  return Cy(t, "h264", i, n);
}, Rw = function(t, i, n) {
  return Cy(t, "h265", i, n);
}, Zi = {
  // "webm" string literal in hex
  webm: Ze([119, 101, 98, 109]),
  // "matroska" string literal in hex
  matroska: Ze([109, 97, 116, 114, 111, 115, 107, 97]),
  // "fLaC" string literal in hex
  flac: Ze([102, 76, 97, 67]),
  // "OggS" string literal in hex
  ogg: Ze([79, 103, 103, 83]),
  // ac-3 sync byte, also works for ec-3 as that is simply a codec
  // of ac-3
  ac3: Ze([11, 119]),
  // "RIFF" string literal in hex used for wav and avi
  riff: Ze([82, 73, 70, 70]),
  // "AVI" string literal in hex
  avi: Ze([65, 86, 73]),
  // "WAVE" string literal in hex
  wav: Ze([87, 65, 86, 69]),
  // "ftyp3g" string literal in hex
  "3gp": Ze([102, 116, 121, 112, 51, 103]),
  // "ftyp" string literal in hex
  mp4: Ze([102, 116, 121, 112]),
  // "styp" string literal in hex
  fmp4: Ze([115, 116, 121, 112]),
  // "ftypqt" string literal in hex
  mov: Ze([102, 116, 121, 112, 113, 116]),
  // moov string literal in hex
  moov: Ze([109, 111, 111, 118]),
  // moof string literal in hex
  moof: Ze([109, 111, 111, 102])
}, Ao = {
  aac: function(t) {
    var i = nu(t);
    return ii(t, [255, 16], {
      offset: i,
      mask: [255, 22]
    });
  },
  mp3: function(t) {
    var i = nu(t);
    return ii(t, [255, 2], {
      offset: i,
      mask: [255, 6]
    });
  },
  webm: function(t) {
    var i = nm(t, [Vl.EBML, Vl.DocType])[0];
    return ii(i, Zi.webm);
  },
  mkv: function(t) {
    var i = nm(t, [Vl.EBML, Vl.DocType])[0];
    return ii(i, Zi.matroska);
  },
  mp4: function(t) {
    if (Ao["3gp"](t) || Ao.mov(t))
      return !1;
    if (ii(t, Zi.mp4, {
      offset: 4
    }) || ii(t, Zi.fmp4, {
      offset: 4
    }) || ii(t, Zi.moof, {
      offset: 4
    }) || ii(t, Zi.moov, {
      offset: 4
    }))
      return !0;
  },
  mov: function(t) {
    return ii(t, Zi.mov, {
      offset: 4
    });
  },
  "3gp": function(t) {
    return ii(t, Zi["3gp"], {
      offset: 4
    });
  },
  ac3: function(t) {
    var i = nu(t);
    return ii(t, Zi.ac3, {
      offset: i
    });
  },
  ts: function(t) {
    if (t.length < 189 && t.length >= 1)
      return t[0] === 71;
    for (var i = 0; i + 188 < t.length && i < 188; ) {
      if (t[i] === 71 && t[i + 188] === 71)
        return !0;
      i += 1;
    }
    return !1;
  },
  flac: function(t) {
    var i = nu(t);
    return ii(t, Zi.flac, {
      offset: i
    });
  },
  ogg: function(t) {
    return ii(t, Zi.ogg);
  },
  avi: function(t) {
    return ii(t, Zi.riff) && ii(t, Zi.avi, {
      offset: 8
    });
  },
  wav: function(t) {
    return ii(t, Zi.riff) && ii(t, Zi.wav, {
      offset: 8
    });
  },
  h264: function(t) {
    return Lw(t, 7, 3).length;
  },
  h265: function(t) {
    return Rw(t, [32, 33], 3).length;
  }
}, Kd = Object.keys(Ao).filter(function(e) {
  return e !== "ts" && e !== "h264" && e !== "h265";
}).concat(["ts", "h264", "h265"]);
Kd.forEach(function(e) {
  var t = Ao[e];
  Ao[e] = function(i) {
    return t(Ze(i));
  };
});
var Iw = Ao, rp = function(t) {
  t = Ze(t);
  for (var i = 0; i < Kd.length; i++) {
    var n = Kd[i];
    if (Iw[n](t))
      return n;
  }
  return "";
}, Ow = function(t) {
  return xw(t, ["moof"]).length > 0;
}, kw = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i, Bw = /^application\/dash\+xml/i, My = function(t) {
  return kw.test(t) ? "hls" : Bw.test(t) ? "dash" : t === "application/vnd.videojs.vhs+json" ? "vhs-json" : null;
}, Dy = { exports: {} };
(function(e, t) {
  (function(i) {
    var n = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, r = /^(?=([^\/?#]*))\1([^]*)$/, a = /(?:\/|^)\.(?=\/)/g, s = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = {
      // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
      // E.g
      // With opts.alwaysNormalize = false (default, spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
      // With opts.alwaysNormalize = true (not spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
      buildAbsoluteURL: function(u, l, c) {
        if (c = c || {}, u = u.trim(), l = l.trim(), !l) {
          if (!c.alwaysNormalize)
            return u;
          var h = o.parseURL(u);
          if (!h)
            throw new Error("Error trying to parse base URL.");
          return h.path = o.normalizePath(
            h.path
          ), o.buildURLFromParts(h);
        }
        var d = o.parseURL(l);
        if (!d)
          throw new Error("Error trying to parse relative URL.");
        if (d.scheme)
          return c.alwaysNormalize ? (d.path = o.normalizePath(d.path), o.buildURLFromParts(d)) : l;
        var f = o.parseURL(u);
        if (!f)
          throw new Error("Error trying to parse base URL.");
        if (!f.netLoc && f.path && f.path[0] !== "/") {
          var p = r.exec(f.path);
          f.netLoc = p[1], f.path = p[2];
        }
        f.netLoc && !f.path && (f.path = "/");
        var _ = {
          // 2c) Otherwise, the embedded URL inherits the scheme of
          // the base URL.
          scheme: f.scheme,
          netLoc: d.netLoc,
          path: null,
          params: d.params,
          query: d.query,
          fragment: d.fragment
        };
        if (!d.netLoc && (_.netLoc = f.netLoc, d.path[0] !== "/"))
          if (!d.path)
            _.path = f.path, d.params || (_.params = f.params, d.query || (_.query = f.query));
          else {
            var m = f.path, x = m.substring(0, m.lastIndexOf("/") + 1) + d.path;
            _.path = o.normalizePath(x);
          }
        return _.path === null && (_.path = c.alwaysNormalize ? o.normalizePath(d.path) : d.path), o.buildURLFromParts(_);
      },
      parseURL: function(u) {
        var l = n.exec(u);
        return l ? {
          scheme: l[1] || "",
          netLoc: l[2] || "",
          path: l[3] || "",
          params: l[4] || "",
          query: l[5] || "",
          fragment: l[6] || ""
        } : null;
      },
      normalizePath: function(u) {
        for (u = u.split("").reverse().join("").replace(a, ""); u.length !== (u = u.replace(s, "")).length; )
          ;
        return u.split("").reverse().join("");
      },
      buildURLFromParts: function(u) {
        return u.scheme + u.netLoc + u.path + u.params + u.query + u.fragment;
      }
    };
    e.exports = o;
  })();
})(Dy);
var Fw = Dy.exports;
const am = /* @__PURE__ */ Yn(Fw);
var sm = "http://example.com", bh = function(t, i) {
  if (/^[a-z]+:/i.test(i))
    return i;
  /^data:/.test(t) && (t = W.location && W.location.href || "");
  var n = typeof W.URL == "function", r = /^\/\//.test(t), a = !W.location && !/\/\//i.test(t);
  if (n ? t = new W.URL(t, W.location || sm) : /\/\//i.test(t) || (t = am.buildAbsoluteURL(W.location && W.location.href || "", t)), n) {
    var s = new URL(i, t);
    return a ? s.href.slice(sm.length) : r ? s.href.slice(s.protocol.length) : s.href;
  }
  return am.buildAbsoluteURL(t, i);
}, np = { exports: {} };
const Nw = /* @__PURE__ */ Mg(ow);
var Uw = Gw, jw = Object.prototype.toString;
function Gw(e) {
  if (!e)
    return !1;
  var t = jw.call(e);
  return t === "[object Function]" || typeof e == "function" && t !== "[object RegExp]" || typeof window < "u" && // IE8 and below
  (e === window.setTimeout || e === window.alert || e === window.confirm || e === window.prompt);
}
var Vw = ah, Hw = function(t, i) {
  return i === void 0 && (i = !1), function(n, r, a) {
    if (n) {
      t(n);
      return;
    }
    if (r.statusCode >= 400 && r.statusCode <= 599) {
      var s = a;
      if (i)
        if (Vw.TextDecoder) {
          var o = zw(r.headers && r.headers["content-type"]);
          try {
            s = new TextDecoder(o).decode(a);
          } catch {
          }
        } else
          s = String.fromCharCode.apply(null, new Uint8Array(a));
      t({
        cause: s
      });
      return;
    }
    t(null, a);
  };
};
function zw(e) {
  return e === void 0 && (e = ""), e.toLowerCase().split(";").reduce(function(t, i) {
    var n = i.split("="), r = n[0], a = n[1];
    return r.trim() === "charset" ? a.trim() : t;
  }, "utf-8");
}
var Ww = Hw, Py = ah, qw = Nw, Xw = Uw;
pn.httpHandler = Ww;
/**
 * @license
 * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
 * Copyright (c) 2014 David Bjrklund
 * Available under the MIT license
 * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
 */
var Yw = function(t) {
  var i = {};
  return t && t.trim().split(`
`).forEach(function(n) {
    var r = n.indexOf(":"), a = n.slice(0, r).trim().toLowerCase(), s = n.slice(r + 1).trim();
    typeof i[a] > "u" ? i[a] = s : Array.isArray(i[a]) ? i[a].push(s) : i[a] = [i[a], s];
  }), i;
};
np.exports = pn;
np.exports.default = pn;
pn.XMLHttpRequest = Py.XMLHttpRequest || Jw;
pn.XDomainRequest = "withCredentials" in new pn.XMLHttpRequest() ? pn.XMLHttpRequest : Py.XDomainRequest;
Qw(["get", "put", "post", "patch", "head", "delete"], function(e) {
  pn[e === "delete" ? "del" : e] = function(t, i, n) {
    return i = Ly(t, i, n), i.method = e.toUpperCase(), Ry(i);
  };
});
function Qw(e, t) {
  for (var i = 0; i < e.length; i++)
    t(e[i]);
}
function Kw(e) {
  for (var t in e)
    if (e.hasOwnProperty(t)) return !1;
  return !0;
}
function Ly(e, t, i) {
  var n = e;
  return Xw(t) ? (i = t, typeof e == "string" && (n = {
    uri: e
  })) : n = qw({}, t, {
    uri: e
  }), n.callback = i, n;
}
function pn(e, t, i) {
  return t = Ly(e, t, i), Ry(t);
}
function Ry(e) {
  if (typeof e.callback > "u")
    throw new Error("callback argument missing");
  var t = !1, i = function(M, C, R) {
    t || (t = !0, e.callback(M, C, R));
  };
  function n() {
    o.readyState === 4 && setTimeout(s, 0);
  }
  function r() {
    var E = void 0;
    if (o.response ? E = o.response : E = o.responseText || Zw(o), _)
      try {
        E = JSON.parse(E);
      } catch {
      }
    return E;
  }
  function a(E) {
    return clearTimeout(m), E instanceof Error || (E = new Error("" + (E || "Unknown XMLHttpRequest Error"))), E.statusCode = 0, i(E, x);
  }
  function s() {
    if (!l) {
      var E;
      clearTimeout(m), e.useXDR && o.status === void 0 ? E = 200 : E = o.status === 1223 ? 204 : o.status;
      var M = x, C = null;
      return E !== 0 ? (M = {
        body: r(),
        statusCode: E,
        method: h,
        headers: {},
        url: c,
        rawRequest: o
      }, o.getAllResponseHeaders && (M.headers = Yw(o.getAllResponseHeaders()))) : C = new Error("Internal XMLHttpRequest Error"), i(C, M, M.body);
    }
  }
  var o = e.xhr || null;
  o || (e.cors || e.useXDR ? o = new pn.XDomainRequest() : o = new pn.XMLHttpRequest());
  var u, l, c = o.url = e.uri || e.url, h = o.method = e.method || "GET", d = e.body || e.data, f = o.headers = e.headers || {}, p = !!e.sync, _ = !1, m, x = {
    body: void 0,
    headers: {},
    statusCode: 0,
    method: h,
    url: c,
    rawRequest: o
  };
  if ("json" in e && e.json !== !1 && (_ = !0, f.accept || f.Accept || (f.Accept = "application/json"), h !== "GET" && h !== "HEAD" && (f["content-type"] || f["Content-Type"] || (f["Content-Type"] = "application/json"), d = JSON.stringify(e.json === !0 ? d : e.json))), o.onreadystatechange = n, o.onload = s, o.onerror = a, o.onprogress = function() {
  }, o.onabort = function() {
    l = !0;
  }, o.ontimeout = a, o.open(h, c, !p, e.username, e.password), p || (o.withCredentials = !!e.withCredentials), !p && e.timeout > 0 && (m = setTimeout(function() {
    if (!l) {
      l = !0, o.abort("timeout");
      var E = new Error("XMLHttpRequest timeout");
      E.code = "ETIMEDOUT", a(E);
    }
  }, e.timeout)), o.setRequestHeader)
    for (u in f)
      f.hasOwnProperty(u) && o.setRequestHeader(u, f[u]);
  else if (e.headers && !Kw(e.headers))
    throw new Error("Headers cannot be set on an XDomainRequest object");
  return "responseType" in e && (o.responseType = e.responseType), "beforeSend" in e && typeof e.beforeSend == "function" && e.beforeSend(o), o.send(d || null), o;
}
function Zw(e) {
  try {
    if (e.responseType === "document")
      return e.responseXML;
    var t = e.responseXML && e.responseXML.documentElement.nodeName === "parsererror";
    if (e.responseType === "" && !t)
      return e.responseXML;
  } catch {
  }
  return null;
}
function Jw() {
}
var $w = np.exports;
const Iy = /* @__PURE__ */ Yn($w);
var Zd = { exports: {} };
(function(e, t) {
  function i(u) {
    if (u && typeof u == "object") {
      var l = u.which || u.keyCode || u.charCode;
      l && (u = l);
    }
    if (typeof u == "number") return s[u];
    var c = String(u), h = n[c.toLowerCase()];
    if (h) return h;
    var h = r[c.toLowerCase()];
    if (h) return h;
    if (c.length === 1) return c.charCodeAt(0);
  }
  i.isEventKey = function(l, c) {
    if (l && typeof l == "object") {
      var h = l.which || l.keyCode || l.charCode;
      if (h == null)
        return !1;
      if (typeof c == "string") {
        var d = n[c.toLowerCase()];
        if (d)
          return d === h;
        var d = r[c.toLowerCase()];
        if (d)
          return d === h;
      } else if (typeof c == "number")
        return c === h;
      return !1;
    }
  }, t = e.exports = i;
  var n = t.code = t.codes = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    "pause/break": 19,
    "caps lock": 20,
    esc: 27,
    space: 32,
    "page up": 33,
    "page down": 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    delete: 46,
    command: 91,
    "left command": 91,
    "right command": 93,
    "numpad *": 106,
    "numpad +": 107,
    "numpad -": 109,
    "numpad .": 110,
    "numpad /": 111,
    "num lock": 144,
    "scroll lock": 145,
    "my computer": 182,
    "my calculator": 183,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  }, r = t.aliases = {
    windows: 91,
    "": 16,
    "": 18,
    "": 17,
    "": 91,
    ctl: 17,
    control: 17,
    option: 18,
    pause: 19,
    break: 19,
    caps: 20,
    return: 13,
    escape: 27,
    spc: 32,
    spacebar: 32,
    pgup: 33,
    pgdn: 34,
    ins: 45,
    del: 46,
    cmd: 91
  };
  /*!
   * Programatically add the following
   */
  for (a = 97; a < 123; a++) n[String.fromCharCode(a)] = a - 32;
  for (var a = 48; a < 58; a++) n[a - 48] = a;
  for (a = 1; a < 13; a++) n["f" + a] = a + 111;
  for (a = 0; a < 10; a++) n["numpad " + a] = a + 96;
  var s = t.names = t.title = {};
  for (a in n) s[n[a]] = a;
  for (var o in r)
    n[o] = r[o];
})(Zd, Zd.exports);
var eS = Zd.exports;
const lt = /* @__PURE__ */ Yn(eS);
var ap = /* @__PURE__ */ function() {
  function e() {
    this.listeners = {};
  }
  var t = e.prototype;
  return t.on = function(n, r) {
    this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push(r);
  }, t.off = function(n, r) {
    if (!this.listeners[n])
      return !1;
    var a = this.listeners[n].indexOf(r);
    return this.listeners[n] = this.listeners[n].slice(0), this.listeners[n].splice(a, 1), a > -1;
  }, t.trigger = function(n) {
    var r = this.listeners[n];
    if (r)
      if (arguments.length === 2)
        for (var a = r.length, s = 0; s < a; ++s)
          r[s].call(this, arguments[1]);
      else
        for (var o = Array.prototype.slice.call(arguments, 1), u = r.length, l = 0; l < u; ++l)
          r[l].apply(this, o);
  }, t.dispose = function() {
    this.listeners = {};
  }, t.pipe = function(n) {
    this.on("data", function(r) {
      n.push(r);
    });
  }, e;
}(), tS = function(t) {
  return W.atob ? W.atob(t) : Buffer.from(t, "base64").toString("binary");
};
function Oy(e) {
  for (var t = tS(e), i = new Uint8Array(t.length), n = 0; n < t.length; n++)
    i[n] = t.charCodeAt(n);
  return i;
}
/*! @name m3u8-parser @version 4.8.0 @license Apache-2.0 */
var iS = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    var n;
    return n = e.call(this) || this, n.buffer = "", n;
  }
  var i = t.prototype;
  return i.push = function(r) {
    var a;
    for (this.buffer += r, a = this.buffer.indexOf(`
`); a > -1; a = this.buffer.indexOf(`
`))
      this.trigger("data", this.buffer.substring(0, a)), this.buffer = this.buffer.substring(a + 1);
  }, t;
}(ap), rS = "	", td = function(t) {
  var i = /([0-9.]*)?@?([0-9.]*)?/.exec(t || ""), n = {};
  return i[1] && (n.length = parseInt(i[1], 10)), i[2] && (n.offset = parseInt(i[2], 10)), n;
}, nS = function() {
  var t = "[^=]*", i = '"[^"]*"|[^,]*', n = "(?:" + t + ")=(?:" + i + ")";
  return new RegExp("(?:^|,)(" + n + ")");
}, jr = function(t) {
  for (var i = t.split(nS()), n = {}, r = i.length, a; r--; )
    i[r] !== "" && (a = /([^=]*)=(.*)/.exec(i[r]).slice(1), a[0] = a[0].replace(/^\s+|\s+$/g, ""), a[1] = a[1].replace(/^\s+|\s+$/g, ""), a[1] = a[1].replace(/^['"](.*)['"]$/g, "$1"), n[a[0]] = a[1]);
  return n;
}, aS = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    var n;
    return n = e.call(this) || this, n.customParsers = [], n.tagMappers = [], n;
  }
  var i = t.prototype;
  return i.push = function(r) {
    var a = this, s, o;
    if (r = r.trim(), r.length !== 0) {
      if (r[0] !== "#") {
        this.trigger("data", {
          type: "uri",
          uri: r
        });
        return;
      }
      var u = this.tagMappers.reduce(function(l, c) {
        var h = c(r);
        return h === r ? l : l.concat([h]);
      }, [r]);
      u.forEach(function(l) {
        for (var c = 0; c < a.customParsers.length; c++)
          if (a.customParsers[c].call(a, l))
            return;
        if (l.indexOf("#EXT") !== 0) {
          a.trigger("data", {
            type: "comment",
            text: l.slice(1)
          });
          return;
        }
        if (l = l.replace("\r", ""), s = /^#EXTM3U/.exec(l), s) {
          a.trigger("data", {
            type: "tag",
            tagType: "m3u"
          });
          return;
        }
        if (s = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "inf"
          }, s[1] && (o.duration = parseFloat(s[1])), s[2] && (o.title = s[2]), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "targetduration"
          }, s[1] && (o.duration = parseInt(s[1], 10)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "version"
          }, s[1] && (o.version = parseInt(s[1], 10)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "media-sequence"
          }, s[1] && (o.number = parseInt(s[1], 10)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "discontinuity-sequence"
          }, s[1] && (o.number = parseInt(s[1], 10)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "playlist-type"
          }, s[1] && (o.playlistType = s[1]), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(l), s) {
          o = kr(td(s[1]), {
            type: "tag",
            tagType: "byterange"
          }), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "allow-cache"
          }, s[1] && (o.allowed = !/NO/.test(s[1])), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-MAP:?(.*)$/.exec(l), s) {
          if (o = {
            type: "tag",
            tagType: "map"
          }, s[1]) {
            var h = jr(s[1]);
            h.URI && (o.uri = h.URI), h.BYTERANGE && (o.byterange = td(h.BYTERANGE));
          }
          a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-STREAM-INF:?(.*)$/.exec(l), s) {
          if (o = {
            type: "tag",
            tagType: "stream-inf"
          }, s[1]) {
            if (o.attributes = jr(s[1]), o.attributes.RESOLUTION) {
              var d = o.attributes.RESOLUTION.split("x"), f = {};
              d[0] && (f.width = parseInt(d[0], 10)), d[1] && (f.height = parseInt(d[1], 10)), o.attributes.RESOLUTION = f;
            }
            o.attributes.BANDWIDTH && (o.attributes.BANDWIDTH = parseInt(o.attributes.BANDWIDTH, 10)), o.attributes["FRAME-RATE"] && (o.attributes["FRAME-RATE"] = parseFloat(o.attributes["FRAME-RATE"])), o.attributes["PROGRAM-ID"] && (o.attributes["PROGRAM-ID"] = parseInt(o.attributes["PROGRAM-ID"], 10));
          }
          a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-MEDIA:?(.*)$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "media"
          }, s[1] && (o.attributes = jr(s[1])), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-ENDLIST/.exec(l), s) {
          a.trigger("data", {
            type: "tag",
            tagType: "endlist"
          });
          return;
        }
        if (s = /^#EXT-X-DISCONTINUITY/.exec(l), s) {
          a.trigger("data", {
            type: "tag",
            tagType: "discontinuity"
          });
          return;
        }
        if (s = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "program-date-time"
          }, s[1] && (o.dateTimeString = s[1], o.dateTimeObject = new Date(s[1])), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-KEY:?(.*)$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "key"
          }, s[1] && (o.attributes = jr(s[1]), o.attributes.IV && (o.attributes.IV.substring(0, 2).toLowerCase() === "0x" && (o.attributes.IV = o.attributes.IV.substring(2)), o.attributes.IV = o.attributes.IV.match(/.{8}/g), o.attributes.IV[0] = parseInt(o.attributes.IV[0], 16), o.attributes.IV[1] = parseInt(o.attributes.IV[1], 16), o.attributes.IV[2] = parseInt(o.attributes.IV[2], 16), o.attributes.IV[3] = parseInt(o.attributes.IV[3], 16), o.attributes.IV = new Uint32Array(o.attributes.IV))), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-START:?(.*)$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "start"
          }, s[1] && (o.attributes = jr(s[1]), o.attributes["TIME-OFFSET"] = parseFloat(o.attributes["TIME-OFFSET"]), o.attributes.PRECISE = /YES/.test(o.attributes.PRECISE)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "cue-out-cont"
          }, s[1] ? o.data = s[1] : o.data = "", a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "cue-out"
          }, s[1] ? o.data = s[1] : o.data = "", a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-CUE-IN:?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "cue-in"
          }, s[1] ? o.data = s[1] : o.data = "", a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-SKIP:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "skip"
          }, o.attributes = jr(s[1]), o.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (o.attributes["SKIPPED-SEGMENTS"] = parseInt(o.attributes["SKIPPED-SEGMENTS"], 10)), o.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (o.attributes["RECENTLY-REMOVED-DATERANGES"] = o.attributes["RECENTLY-REMOVED-DATERANGES"].split(rS)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-PART:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "part"
          }, o.attributes = jr(s[1]), ["DURATION"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = parseFloat(o.attributes[p]));
          }), ["INDEPENDENT", "GAP"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = /YES/.test(o.attributes[p]));
          }), o.attributes.hasOwnProperty("BYTERANGE") && (o.attributes.byterange = td(o.attributes.BYTERANGE)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "server-control"
          }, o.attributes = jr(s[1]), ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = parseFloat(o.attributes[p]));
          }), ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = /YES/.test(o.attributes[p]));
          }), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-PART-INF:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "part-inf"
          }, o.attributes = jr(s[1]), ["PART-TARGET"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = parseFloat(o.attributes[p]));
          }), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "preload-hint"
          }, o.attributes = jr(s[1]), ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(p) {
            if (o.attributes.hasOwnProperty(p)) {
              o.attributes[p] = parseInt(o.attributes[p], 10);
              var _ = p === "BYTERANGE-LENGTH" ? "length" : "offset";
              o.attributes.byterange = o.attributes.byterange || {}, o.attributes.byterange[_] = o.attributes[p], delete o.attributes[p];
            }
          }), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "rendition-report"
          }, o.attributes = jr(s[1]), ["LAST-MSN", "LAST-PART"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = parseInt(o.attributes[p], 10));
          }), a.trigger("data", o);
          return;
        }
        a.trigger("data", {
          type: "tag",
          data: l.slice(4)
        });
      });
    }
  }, i.addParser = function(r) {
    var a = this, s = r.expression, o = r.customType, u = r.dataParser, l = r.segment;
    typeof u != "function" && (u = function(h) {
      return h;
    }), this.customParsers.push(function(c) {
      var h = s.exec(c);
      if (h)
        return a.trigger("data", {
          type: "custom",
          data: u(c),
          customType: o,
          segment: l
        }), !0;
    });
  }, i.addTagMapper = function(r) {
    var a = r.expression, s = r.map, o = function(l) {
      return a.test(l) ? s(l) : l;
    };
    this.tagMappers.push(o);
  }, t;
}(ap), sS = function(t) {
  return t.toLowerCase().replace(/-(\w)/g, function(i) {
    return i[1].toUpperCase();
  });
}, Ts = function(t) {
  var i = {};
  return Object.keys(t).forEach(function(n) {
    i[sS(n)] = t[n];
  }), i;
}, id = function(t) {
  var i = t.serverControl, n = t.targetDuration, r = t.partTargetDuration;
  if (i) {
    var a = "#EXT-X-SERVER-CONTROL", s = "holdBack", o = "partHoldBack", u = n && n * 3, l = r && r * 2;
    n && !i.hasOwnProperty(s) && (i[s] = u, this.trigger("info", {
      message: a + " defaulting HOLD-BACK to targetDuration * 3 (" + u + ")."
    })), u && i[s] < u && (this.trigger("warn", {
      message: a + " clamping HOLD-BACK (" + i[s] + ") to targetDuration * 3 (" + u + ")"
    }), i[s] = u), r && !i.hasOwnProperty(o) && (i[o] = r * 3, this.trigger("info", {
      message: a + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + i[o] + ")."
    })), r && i[o] < l && (this.trigger("warn", {
      message: a + " clamping PART-HOLD-BACK (" + i[o] + ") to partTargetDuration * 2 (" + l + ")."
    }), i[o] = l);
  }
}, oS = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    var n;
    n = e.call(this) || this, n.lineStream = new iS(), n.parseStream = new aS(), n.lineStream.pipe(n.parseStream);
    var r = He(n), a = [], s = {}, o, u, l = !1, c = function() {
    }, h = {
      AUDIO: {},
      VIDEO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {}
    }, d = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", f = 0;
    n.manifest = {
      allowCache: !0,
      discontinuityStarts: [],
      segments: []
    };
    var p = 0, _ = 0;
    return n.on("end", function() {
      s.uri || !s.parts && !s.preloadHints || (!s.map && o && (s.map = o), !s.key && u && (s.key = u), !s.timeline && typeof f == "number" && (s.timeline = f), n.manifest.preloadSegment = s);
    }), n.parseStream.on("data", function(m) {
      var x, E;
      ({
        tag: function() {
          ({
            version: function() {
              m.version && (this.manifest.version = m.version);
            },
            "allow-cache": function() {
              this.manifest.allowCache = m.allowed, "allowed" in m || (this.trigger("info", {
                message: "defaulting allowCache to YES"
              }), this.manifest.allowCache = !0);
            },
            byterange: function() {
              var R = {};
              "length" in m && (s.byterange = R, R.length = m.length, "offset" in m || (m.offset = p)), "offset" in m && (s.byterange = R, R.offset = m.offset), p = R.offset + R.length;
            },
            endlist: function() {
              this.manifest.endList = !0;
            },
            inf: function() {
              "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", {
                message: "defaulting media sequence to zero"
              })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", {
                message: "defaulting discontinuity sequence to zero"
              })), m.duration > 0 && (s.duration = m.duration), m.duration === 0 && (s.duration = 0.01, this.trigger("info", {
                message: "updating zero segment duration to a small value"
              })), this.manifest.segments = a;
            },
            key: function() {
              if (!m.attributes) {
                this.trigger("warn", {
                  message: "ignoring key declaration without attribute list"
                });
                return;
              }
              if (m.attributes.METHOD === "NONE") {
                u = null;
                return;
              }
              if (!m.attributes.URI) {
                this.trigger("warn", {
                  message: "ignoring key declaration without URI"
                });
                return;
              }
              if (m.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.apple.fps.1_0"] = {
                  attributes: m.attributes
                };
                return;
              }
              if (m.attributes.KEYFORMAT === "com.microsoft.playready") {
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.microsoft.playready"] = {
                  uri: m.attributes.URI
                };
                return;
              }
              if (m.attributes.KEYFORMAT === d) {
                var R = ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"];
                if (R.indexOf(m.attributes.METHOD) === -1) {
                  this.trigger("warn", {
                    message: "invalid key method provided for Widevine"
                  });
                  return;
                }
                if (m.attributes.METHOD === "SAMPLE-AES-CENC" && this.trigger("warn", {
                  message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                }), m.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                  this.trigger("warn", {
                    message: "invalid key URI provided for Widevine"
                  });
                  return;
                }
                if (!(m.attributes.KEYID && m.attributes.KEYID.substring(0, 2) === "0x")) {
                  this.trigger("warn", {
                    message: "invalid key ID provided for Widevine"
                  });
                  return;
                }
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.widevine.alpha"] = {
                  attributes: {
                    schemeIdUri: m.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: m.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: Oy(m.attributes.URI.split(",")[1])
                };
                return;
              }
              m.attributes.METHOD || this.trigger("warn", {
                message: "defaulting key method to AES-128"
              }), u = {
                method: m.attributes.METHOD || "AES-128",
                uri: m.attributes.URI
              }, typeof m.attributes.IV < "u" && (u.iv = m.attributes.IV);
            },
            "media-sequence": function() {
              if (!isFinite(m.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid media sequence: " + m.number
                });
                return;
              }
              this.manifest.mediaSequence = m.number;
            },
            "discontinuity-sequence": function() {
              if (!isFinite(m.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid discontinuity sequence: " + m.number
                });
                return;
              }
              this.manifest.discontinuitySequence = m.number, f = m.number;
            },
            "playlist-type": function() {
              if (!/VOD|EVENT/.test(m.playlistType)) {
                this.trigger("warn", {
                  message: "ignoring unknown playlist type: " + m.playlist
                });
                return;
              }
              this.manifest.playlistType = m.playlistType;
            },
            map: function() {
              o = {}, m.uri && (o.uri = m.uri), m.byterange && (o.byterange = m.byterange), u && (o.key = u);
            },
            "stream-inf": function() {
              if (this.manifest.playlists = a, this.manifest.mediaGroups = this.manifest.mediaGroups || h, !m.attributes) {
                this.trigger("warn", {
                  message: "ignoring empty stream-inf attributes"
                });
                return;
              }
              s.attributes || (s.attributes = {}), kr(s.attributes, m.attributes);
            },
            media: function() {
              if (this.manifest.mediaGroups = this.manifest.mediaGroups || h, !(m.attributes && m.attributes.TYPE && m.attributes["GROUP-ID"] && m.attributes.NAME)) {
                this.trigger("warn", {
                  message: "ignoring incomplete or missing media group"
                });
                return;
              }
              var R = this.manifest.mediaGroups[m.attributes.TYPE];
              R[m.attributes["GROUP-ID"]] = R[m.attributes["GROUP-ID"]] || {}, x = R[m.attributes["GROUP-ID"]], E = {
                default: /yes/i.test(m.attributes.DEFAULT)
              }, E.default ? E.autoselect = !0 : E.autoselect = /yes/i.test(m.attributes.AUTOSELECT), m.attributes.LANGUAGE && (E.language = m.attributes.LANGUAGE), m.attributes.URI && (E.uri = m.attributes.URI), m.attributes["INSTREAM-ID"] && (E.instreamId = m.attributes["INSTREAM-ID"]), m.attributes.CHARACTERISTICS && (E.characteristics = m.attributes.CHARACTERISTICS), m.attributes.FORCED && (E.forced = /yes/i.test(m.attributes.FORCED)), x[m.attributes.NAME] = E;
            },
            discontinuity: function() {
              f += 1, s.discontinuity = !0, this.manifest.discontinuityStarts.push(a.length);
            },
            "program-date-time": function() {
              typeof this.manifest.dateTimeString > "u" && (this.manifest.dateTimeString = m.dateTimeString, this.manifest.dateTimeObject = m.dateTimeObject), s.dateTimeString = m.dateTimeString, s.dateTimeObject = m.dateTimeObject;
            },
            targetduration: function() {
              if (!isFinite(m.duration) || m.duration < 0) {
                this.trigger("warn", {
                  message: "ignoring invalid target duration: " + m.duration
                });
                return;
              }
              this.manifest.targetDuration = m.duration, id.call(this, this.manifest);
            },
            start: function() {
              if (!m.attributes || isNaN(m.attributes["TIME-OFFSET"])) {
                this.trigger("warn", {
                  message: "ignoring start declaration without appropriate attribute list"
                });
                return;
              }
              this.manifest.start = {
                timeOffset: m.attributes["TIME-OFFSET"],
                precise: m.attributes.PRECISE
              };
            },
            "cue-out": function() {
              s.cueOut = m.data;
            },
            "cue-out-cont": function() {
              s.cueOutCont = m.data;
            },
            "cue-in": function() {
              s.cueIn = m.data;
            },
            skip: function() {
              this.manifest.skip = Ts(m.attributes), this.warnOnMissingAttributes_("#EXT-X-SKIP", m.attributes, ["SKIPPED-SEGMENTS"]);
            },
            part: function() {
              var R = this;
              l = !0;
              var k = this.manifest.segments.length, F = Ts(m.attributes);
              s.parts = s.parts || [], s.parts.push(F), F.byterange && (F.byterange.hasOwnProperty("offset") || (F.byterange.offset = _), _ = F.byterange.offset + F.byterange.length);
              var B = s.parts.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PART #" + B + " for segment #" + k, m.attributes, ["URI", "DURATION"]), this.manifest.renditionReports && this.manifest.renditionReports.forEach(function(I, V) {
                I.hasOwnProperty("lastPart") || R.trigger("warn", {
                  message: "#EXT-X-RENDITION-REPORT #" + V + " lacks required attribute(s): LAST-PART"
                });
              });
            },
            "server-control": function() {
              var R = this.manifest.serverControl = Ts(m.attributes);
              R.hasOwnProperty("canBlockReload") || (R.canBlockReload = !1, this.trigger("info", {
                message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
              })), id.call(this, this.manifest), R.canSkipDateranges && !R.hasOwnProperty("canSkipUntil") && this.trigger("warn", {
                message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
              });
            },
            "preload-hint": function() {
              var R = this.manifest.segments.length, k = Ts(m.attributes), F = k.type && k.type === "PART";
              s.preloadHints = s.preloadHints || [], s.preloadHints.push(k), k.byterange && (k.byterange.hasOwnProperty("offset") || (k.byterange.offset = F ? _ : 0, F && (_ = k.byterange.offset + k.byterange.length)));
              var B = s.preloadHints.length - 1;
              if (this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + B + " for segment #" + R, m.attributes, ["TYPE", "URI"]), !!k.type)
                for (var I = 0; I < s.preloadHints.length - 1; I++) {
                  var V = s.preloadHints[I];
                  V.type && V.type === k.type && this.trigger("warn", {
                    message: "#EXT-X-PRELOAD-HINT #" + B + " for segment #" + R + " has the same TYPE " + k.type + " as preload hint #" + I
                  });
                }
            },
            "rendition-report": function() {
              var R = Ts(m.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [], this.manifest.renditionReports.push(R);
              var k = this.manifest.renditionReports.length - 1, F = ["LAST-MSN", "URI"];
              l && F.push("LAST-PART"), this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + k, m.attributes, F);
            },
            "part-inf": function() {
              this.manifest.partInf = Ts(m.attributes), this.warnOnMissingAttributes_("#EXT-X-PART-INF", m.attributes, ["PART-TARGET"]), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), id.call(this, this.manifest);
            }
          }[m.tagType] || c).call(r);
        },
        uri: function() {
          s.uri = m.uri, a.push(s), this.manifest.targetDuration && !("duration" in s) && (this.trigger("warn", {
            message: "defaulting segment duration to the target duration"
          }), s.duration = this.manifest.targetDuration), u && (s.key = u), s.timeline = f, o && (s.map = o), _ = 0, s = {};
        },
        comment: function() {
        },
        custom: function() {
          m.segment ? (s.custom = s.custom || {}, s.custom[m.customType] = m.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[m.customType] = m.data);
        }
      })[m.type].call(r);
    }), n;
  }
  var i = t.prototype;
  return i.warnOnMissingAttributes_ = function(r, a, s) {
    var o = [];
    s.forEach(function(u) {
      a.hasOwnProperty(u) || o.push(u);
    }), o.length && this.trigger("warn", {
      message: r + " lacks required attribute(s): " + o.join(", ")
    });
  }, i.push = function(r) {
    this.lineStream.push(r);
  }, i.end = function() {
    this.lineStream.push(`
`), this.trigger("end");
  }, i.addParser = function(r) {
    this.parseStream.addParser(r);
  }, i.addTagMapper = function(r) {
    this.parseStream.addTagMapper(r);
  }, t;
}(ap), uS = function(t, i, n) {
  i.forEach(function(r) {
    for (var a in t.mediaGroups[r])
      for (var s in t.mediaGroups[r][a]) {
        var o = t.mediaGroups[r][a][s];
        n(o, r, a, s);
      }
  });
}, ya = {}, Zn = {};
function lS(e, t, i) {
  if (i === void 0 && (i = Array.prototype), e && typeof i.find == "function")
    return i.find.call(e, t);
  for (var n = 0; n < e.length; n++)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      var r = e[n];
      if (t.call(void 0, r, n, e))
        return r;
    }
}
function sp(e, t) {
  return t === void 0 && (t = Object), t && typeof t.freeze == "function" ? t.freeze(e) : e;
}
function cS(e, t) {
  if (e === null || typeof e != "object")
    throw new TypeError("target is not an object");
  for (var i in t)
    Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
  return e;
}
var ky = sp({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: "text/html",
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function(e) {
    return e === ky.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: "application/xml",
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: "text/xml",
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: "image/svg+xml"
}), By = sp({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: "http://www.w3.org/1999/xhtml",
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function(e) {
    return e === By.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: "http://www.w3.org/2000/svg",
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: "http://www.w3.org/XML/1998/namespace",
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
Zn.assign = cS;
Zn.find = lS;
Zn.freeze = sp;
Zn.MIME_TYPE = ky;
Zn.NAMESPACE = By;
var Fy = Zn, vn = Fy.find, cl = Fy.NAMESPACE;
function hS(e) {
  return e !== "";
}
function dS(e) {
  return e ? e.split(/[\t\n\f\r ]+/).filter(hS) : [];
}
function fS(e, t) {
  return e.hasOwnProperty(t) || (e[t] = !0), e;
}
function om(e) {
  if (!e) return [];
  var t = dS(e);
  return Object.keys(t.reduce(fS, {}));
}
function pS(e) {
  return function(t) {
    return e && e.indexOf(t) !== -1;
  };
}
function El(e, t) {
  for (var i in e)
    Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
}
function vr(e, t) {
  var i = e.prototype;
  if (!(i instanceof t)) {
    let n = function() {
    };
    n.prototype = t.prototype, n = new n(), El(i, n), e.prototype = i = n;
  }
  i.constructor != e && (typeof e != "function" && console.error("unknown Class:" + e), i.constructor = e);
}
var mr = {}, zr = mr.ELEMENT_NODE = 1, To = mr.ATTRIBUTE_NODE = 2, Oc = mr.TEXT_NODE = 3, Ny = mr.CDATA_SECTION_NODE = 4, Uy = mr.ENTITY_REFERENCE_NODE = 5, vS = mr.ENTITY_NODE = 6, jy = mr.PROCESSING_INSTRUCTION_NODE = 7, Gy = mr.COMMENT_NODE = 8, Vy = mr.DOCUMENT_NODE = 9, Hy = mr.DOCUMENT_TYPE_NODE = 10, Hn = mr.DOCUMENT_FRAGMENT_NODE = 11, mS = mr.NOTATION_NODE = 12, Wi = {}, Ri = {};
Wi.INDEX_SIZE_ERR = (Ri[1] = "Index size error", 1);
Wi.DOMSTRING_SIZE_ERR = (Ri[2] = "DOMString size error", 2);
var ur = Wi.HIERARCHY_REQUEST_ERR = (Ri[3] = "Hierarchy request error", 3);
Wi.WRONG_DOCUMENT_ERR = (Ri[4] = "Wrong document", 4);
Wi.INVALID_CHARACTER_ERR = (Ri[5] = "Invalid character", 5);
Wi.NO_DATA_ALLOWED_ERR = (Ri[6] = "No data allowed", 6);
Wi.NO_MODIFICATION_ALLOWED_ERR = (Ri[7] = "No modification allowed", 7);
var zy = Wi.NOT_FOUND_ERR = (Ri[8] = "Not found", 8);
Wi.NOT_SUPPORTED_ERR = (Ri[9] = "Not supported", 9);
var um = Wi.INUSE_ATTRIBUTE_ERR = (Ri[10] = "Attribute in use", 10);
Wi.INVALID_STATE_ERR = (Ri[11] = "Invalid state", 11);
Wi.SYNTAX_ERR = (Ri[12] = "Syntax error", 12);
Wi.INVALID_MODIFICATION_ERR = (Ri[13] = "Invalid modification", 13);
Wi.NAMESPACE_ERR = (Ri[14] = "Invalid namespace", 14);
Wi.INVALID_ACCESS_ERR = (Ri[15] = "Invalid access", 15);
function mi(e, t) {
  if (t instanceof Error)
    var i = t;
  else
    i = this, Error.call(this, Ri[e]), this.message = Ri[e], Error.captureStackTrace && Error.captureStackTrace(this, mi);
  return i.code = e, t && (this.message = this.message + ": " + t), i;
}
mi.prototype = Error.prototype;
El(Wi, mi);
function Nn() {
}
Nn.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function(e) {
    return e >= 0 && e < this.length ? this[e] : null;
  },
  toString: function(e, t) {
    for (var i = [], n = 0; n < this.length; n++)
      Ls(this[n], i, e, t);
    return i.join("");
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function(e) {
    return Array.prototype.filter.call(this, e);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function(e) {
    return Array.prototype.indexOf.call(this, e);
  }
};
function Eo(e, t) {
  this._node = e, this._refresh = t, op(this);
}
function op(e) {
  var t = e._node._inc || e._node.ownerDocument._inc;
  if (e._inc !== t) {
    var i = e._refresh(e._node);
    if (i_(e, "length", i.length), !e.$$length || i.length < e.$$length)
      for (var n = i.length; n in e; n++)
        Object.prototype.hasOwnProperty.call(e, n) && delete e[n];
    El(i, e), e._inc = t;
  }
}
Eo.prototype.item = function(e) {
  return op(this), this[e] || null;
};
vr(Eo, Nn);
function kc() {
}
function Wy(e, t) {
  for (var i = e.length; i--; )
    if (e[i] === t)
      return i;
}
function lm(e, t, i, n) {
  if (n ? t[Wy(t, n)] = i : t[t.length++] = i, e) {
    i.ownerElement = e;
    var r = e.ownerDocument;
    r && (n && Yy(r, e, n), gS(r, e, i));
  }
}
function cm(e, t, i) {
  var n = Wy(t, i);
  if (n >= 0) {
    for (var r = t.length - 1; n < r; )
      t[n] = t[++n];
    if (t.length = r, e) {
      var a = e.ownerDocument;
      a && (Yy(a, e, i), i.ownerElement = null);
    }
  } else
    throw new mi(zy, new Error(e.tagName + "@" + i));
}
kc.prototype = {
  length: 0,
  item: Nn.prototype.item,
  getNamedItem: function(e) {
    for (var t = this.length; t--; ) {
      var i = this[t];
      if (i.nodeName == e)
        return i;
    }
  },
  setNamedItem: function(e) {
    var t = e.ownerElement;
    if (t && t != this._ownerElement)
      throw new mi(um);
    var i = this.getNamedItem(e.nodeName);
    return lm(this._ownerElement, this, e, i), i;
  },
  /* returns Node */
  setNamedItemNS: function(e) {
    var t = e.ownerElement, i;
    if (t && t != this._ownerElement)
      throw new mi(um);
    return i = this.getNamedItemNS(e.namespaceURI, e.localName), lm(this._ownerElement, this, e, i), i;
  },
  /* returns Node */
  removeNamedItem: function(e) {
    var t = this.getNamedItem(e);
    return cm(this._ownerElement, this, t), t;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  //for level2
  removeNamedItemNS: function(e, t) {
    var i = this.getNamedItemNS(e, t);
    return cm(this._ownerElement, this, i), i;
  },
  getNamedItemNS: function(e, t) {
    for (var i = this.length; i--; ) {
      var n = this[i];
      if (n.localName == t && n.namespaceURI == e)
        return n;
    }
    return null;
  }
};
function qy() {
}
qy.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function(e, t) {
    return !0;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function(e, t, i) {
    var n = new wl();
    if (n.implementation = this, n.childNodes = new Nn(), n.doctype = i || null, i && n.appendChild(i), t) {
      var r = n.createElementNS(e, t);
      n.appendChild(r);
    }
    return n;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function(e, t, i) {
    var n = new xh();
    return n.name = e, n.nodeName = e, n.publicId = t || "", n.systemId = i || "", n;
  }
};
function Nt() {
}
Nt.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function(e, t) {
    return Bc(this, e, t);
  },
  replaceChild: function(e, t) {
    Bc(this, e, t, Ky), t && this.removeChild(t);
  },
  removeChild: function(e) {
    return Qy(this, e);
  },
  appendChild: function(e) {
    return this.insertBefore(e, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(e) {
    return Jd(this.ownerDocument || this, this, e);
  },
  // Modified in DOM Level 2:
  normalize: function() {
    for (var e = this.firstChild; e; ) {
      var t = e.nextSibling;
      t && t.nodeType == Oc && e.nodeType == Oc ? (this.removeChild(t), e.appendData(t.data)) : (e.normalize(), e = t);
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function(e, t) {
    return this.ownerDocument.implementation.hasFeature(e, t);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function(e) {
    for (var t = this; t; ) {
      var i = t._nsMap;
      if (i) {
        for (var n in i)
          if (Object.prototype.hasOwnProperty.call(i, n) && i[n] === e)
            return n;
      }
      t = t.nodeType == To ? t.ownerDocument : t.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function(e) {
    for (var t = this; t; ) {
      var i = t._nsMap;
      if (i && Object.prototype.hasOwnProperty.call(i, e))
        return i[e];
      t = t.nodeType == To ? t.ownerDocument : t.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function(e) {
    var t = this.lookupPrefix(e);
    return t == null;
  }
};
function Xy(e) {
  return e == "<" && "&lt;" || e == ">" && "&gt;" || e == "&" && "&amp;" || e == '"' && "&quot;" || "&#" + e.charCodeAt() + ";";
}
El(mr, Nt);
El(mr, Nt.prototype);
function hl(e, t) {
  if (t(e))
    return !0;
  if (e = e.firstChild)
    do
      if (hl(e, t))
        return !0;
    while (e = e.nextSibling);
}
function wl() {
  this.ownerDocument = this;
}
function gS(e, t, i) {
  e && e._inc++;
  var n = i.namespaceURI;
  n === cl.XMLNS && (t._nsMap[i.prefix ? i.localName : ""] = i.value);
}
function Yy(e, t, i, n) {
  e && e._inc++;
  var r = i.namespaceURI;
  r === cl.XMLNS && delete t._nsMap[i.prefix ? i.localName : ""];
}
function up(e, t, i) {
  if (e && e._inc) {
    e._inc++;
    var n = t.childNodes;
    if (i)
      n[n.length++] = i;
    else {
      for (var r = t.firstChild, a = 0; r; )
        n[a++] = r, r = r.nextSibling;
      n.length = a, delete n[n.length];
    }
  }
}
function Qy(e, t) {
  var i = t.previousSibling, n = t.nextSibling;
  return i ? i.nextSibling = n : e.firstChild = n, n ? n.previousSibling = i : e.lastChild = i, t.parentNode = null, t.previousSibling = null, t.nextSibling = null, up(e.ownerDocument, e), t;
}
function yS(e) {
  return e && (e.nodeType === Nt.DOCUMENT_NODE || e.nodeType === Nt.DOCUMENT_FRAGMENT_NODE || e.nodeType === Nt.ELEMENT_NODE);
}
function _S(e) {
  return e && (mn(e) || lp(e) || zn(e) || e.nodeType === Nt.DOCUMENT_FRAGMENT_NODE || e.nodeType === Nt.COMMENT_NODE || e.nodeType === Nt.PROCESSING_INSTRUCTION_NODE);
}
function zn(e) {
  return e && e.nodeType === Nt.DOCUMENT_TYPE_NODE;
}
function mn(e) {
  return e && e.nodeType === Nt.ELEMENT_NODE;
}
function lp(e) {
  return e && e.nodeType === Nt.TEXT_NODE;
}
function hm(e, t) {
  var i = e.childNodes || [];
  if (vn(i, mn) || zn(t))
    return !1;
  var n = vn(i, zn);
  return !(t && n && i.indexOf(n) > i.indexOf(t));
}
function dm(e, t) {
  var i = e.childNodes || [];
  function n(a) {
    return mn(a) && a !== t;
  }
  if (vn(i, n))
    return !1;
  var r = vn(i, zn);
  return !(t && r && i.indexOf(r) > i.indexOf(t));
}
function bS(e, t, i) {
  if (!yS(e))
    throw new mi(ur, "Unexpected parent node type " + e.nodeType);
  if (i && i.parentNode !== e)
    throw new mi(zy, "child not in parent");
  if (
    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
    !_S(t) || // 5. If either `node` is a Text node and `parent` is a document,
    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
    // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
    zn(t) && e.nodeType !== Nt.DOCUMENT_NODE
  )
    throw new mi(
      ur,
      "Unexpected node type " + t.nodeType + " for parent node type " + e.nodeType
    );
}
function xS(e, t, i) {
  var n = e.childNodes || [], r = t.childNodes || [];
  if (t.nodeType === Nt.DOCUMENT_FRAGMENT_NODE) {
    var a = r.filter(mn);
    if (a.length > 1 || vn(r, lp))
      throw new mi(ur, "More than one element or text in fragment");
    if (a.length === 1 && !hm(e, i))
      throw new mi(ur, "Element in fragment can not be inserted before doctype");
  }
  if (mn(t) && !hm(e, i))
    throw new mi(ur, "Only one element can be added and only after doctype");
  if (zn(t)) {
    if (vn(n, zn))
      throw new mi(ur, "Only one doctype is allowed");
    var s = vn(n, mn);
    if (i && n.indexOf(s) < n.indexOf(i))
      throw new mi(ur, "Doctype can only be inserted before an element");
    if (!i && s)
      throw new mi(ur, "Doctype can not be appended since element is present");
  }
}
function Ky(e, t, i) {
  var n = e.childNodes || [], r = t.childNodes || [];
  if (t.nodeType === Nt.DOCUMENT_FRAGMENT_NODE) {
    var a = r.filter(mn);
    if (a.length > 1 || vn(r, lp))
      throw new mi(ur, "More than one element or text in fragment");
    if (a.length === 1 && !dm(e, i))
      throw new mi(ur, "Element in fragment can not be inserted before doctype");
  }
  if (mn(t) && !dm(e, i))
    throw new mi(ur, "Only one element can be added and only after doctype");
  if (zn(t)) {
    if (vn(n, function(u) {
      return zn(u) && u !== i;
    }))
      throw new mi(ur, "Only one doctype is allowed");
    var s = vn(n, mn);
    if (i && n.indexOf(s) < n.indexOf(i))
      throw new mi(ur, "Doctype can only be inserted before an element");
  }
}
function Bc(e, t, i, n) {
  bS(e, t, i), e.nodeType === Nt.DOCUMENT_NODE && (n || xS)(e, t, i);
  var r = t.parentNode;
  if (r && r.removeChild(t), t.nodeType === Hn) {
    var a = t.firstChild;
    if (a == null)
      return t;
    var s = t.lastChild;
  } else
    a = s = t;
  var o = i ? i.previousSibling : e.lastChild;
  a.previousSibling = o, s.nextSibling = i, o ? o.nextSibling = a : e.firstChild = a, i == null ? e.lastChild = s : i.previousSibling = s;
  do
    a.parentNode = e;
  while (a !== s && (a = a.nextSibling));
  return up(e.ownerDocument || e, e), t.nodeType == Hn && (t.firstChild = t.lastChild = null), t;
}
function AS(e, t) {
  return t.parentNode && t.parentNode.removeChild(t), t.parentNode = e, t.previousSibling = e.lastChild, t.nextSibling = null, t.previousSibling ? t.previousSibling.nextSibling = t : e.firstChild = t, e.lastChild = t, up(e.ownerDocument, e, t), t;
}
wl.prototype = {
  //implementation : null,
  nodeName: "#document",
  nodeType: Vy,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(e, t) {
    if (e.nodeType == Hn) {
      for (var i = e.firstChild; i; ) {
        var n = i.nextSibling;
        this.insertBefore(i, t), i = n;
      }
      return e;
    }
    return Bc(this, e, t), e.ownerDocument = this, this.documentElement === null && e.nodeType === zr && (this.documentElement = e), e;
  },
  removeChild: function(e) {
    return this.documentElement == e && (this.documentElement = null), Qy(this, e);
  },
  replaceChild: function(e, t) {
    Bc(this, e, t, Ky), e.ownerDocument = this, t && this.removeChild(t), mn(e) && (this.documentElement = e);
  },
  // Introduced in DOM Level 2:
  importNode: function(e, t) {
    return t_(this, e, t);
  },
  // Introduced in DOM Level 2:
  getElementById: function(e) {
    var t = null;
    return hl(this.documentElement, function(i) {
      if (i.nodeType == zr && i.getAttribute("id") == e)
        return t = i, !0;
    }), t;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function(e) {
    var t = om(e);
    return new Eo(this, function(i) {
      var n = [];
      return t.length > 0 && hl(i.documentElement, function(r) {
        if (r !== i && r.nodeType === zr) {
          var a = r.getAttribute("class");
          if (a) {
            var s = e === a;
            if (!s) {
              var o = om(a);
              s = t.every(pS(o));
            }
            s && n.push(r);
          }
        }
      }), n;
    });
  },
  //document factory method:
  createElement: function(e) {
    var t = new hs();
    t.ownerDocument = this, t.nodeName = e, t.tagName = e, t.localName = e, t.childNodes = new Nn();
    var i = t.attributes = new kc();
    return i._ownerElement = t, t;
  },
  createDocumentFragment: function() {
    var e = new Ah();
    return e.ownerDocument = this, e.childNodes = new Nn(), e;
  },
  createTextNode: function(e) {
    var t = new cp();
    return t.ownerDocument = this, t.appendData(e), t;
  },
  createComment: function(e) {
    var t = new hp();
    return t.ownerDocument = this, t.appendData(e), t;
  },
  createCDATASection: function(e) {
    var t = new dp();
    return t.ownerDocument = this, t.appendData(e), t;
  },
  createProcessingInstruction: function(e, t) {
    var i = new pp();
    return i.ownerDocument = this, i.tagName = i.nodeName = i.target = e, i.nodeValue = i.data = t, i;
  },
  createAttribute: function(e) {
    var t = new Fc();
    return t.ownerDocument = this, t.name = e, t.nodeName = e, t.localName = e, t.specified = !0, t;
  },
  createEntityReference: function(e) {
    var t = new fp();
    return t.ownerDocument = this, t.nodeName = e, t;
  },
  // Introduced in DOM Level 2:
  createElementNS: function(e, t) {
    var i = new hs(), n = t.split(":"), r = i.attributes = new kc();
    return i.childNodes = new Nn(), i.ownerDocument = this, i.nodeName = t, i.tagName = t, i.namespaceURI = e, n.length == 2 ? (i.prefix = n[0], i.localName = n[1]) : i.localName = t, r._ownerElement = i, i;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function(e, t) {
    var i = new Fc(), n = t.split(":");
    return i.ownerDocument = this, i.nodeName = t, i.name = t, i.namespaceURI = e, i.specified = !0, n.length == 2 ? (i.prefix = n[0], i.localName = n[1]) : i.localName = t, i;
  }
};
vr(wl, Nt);
function hs() {
  this._nsMap = {};
}
hs.prototype = {
  nodeType: zr,
  hasAttribute: function(e) {
    return this.getAttributeNode(e) != null;
  },
  getAttribute: function(e) {
    var t = this.getAttributeNode(e);
    return t && t.value || "";
  },
  getAttributeNode: function(e) {
    return this.attributes.getNamedItem(e);
  },
  setAttribute: function(e, t) {
    var i = this.ownerDocument.createAttribute(e);
    i.value = i.nodeValue = "" + t, this.setAttributeNode(i);
  },
  removeAttribute: function(e) {
    var t = this.getAttributeNode(e);
    t && this.removeAttributeNode(t);
  },
  //four real opeartion method
  appendChild: function(e) {
    return e.nodeType === Hn ? this.insertBefore(e, null) : AS(this, e);
  },
  setAttributeNode: function(e) {
    return this.attributes.setNamedItem(e);
  },
  setAttributeNodeNS: function(e) {
    return this.attributes.setNamedItemNS(e);
  },
  removeAttributeNode: function(e) {
    return this.attributes.removeNamedItem(e.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function(e, t) {
    var i = this.getAttributeNodeNS(e, t);
    i && this.removeAttributeNode(i);
  },
  hasAttributeNS: function(e, t) {
    return this.getAttributeNodeNS(e, t) != null;
  },
  getAttributeNS: function(e, t) {
    var i = this.getAttributeNodeNS(e, t);
    return i && i.value || "";
  },
  setAttributeNS: function(e, t, i) {
    var n = this.ownerDocument.createAttributeNS(e, t);
    n.value = n.nodeValue = "" + i, this.setAttributeNode(n);
  },
  getAttributeNodeNS: function(e, t) {
    return this.attributes.getNamedItemNS(e, t);
  },
  getElementsByTagName: function(e) {
    return new Eo(this, function(t) {
      var i = [];
      return hl(t, function(n) {
        n !== t && n.nodeType == zr && (e === "*" || n.tagName == e) && i.push(n);
      }), i;
    });
  },
  getElementsByTagNameNS: function(e, t) {
    return new Eo(this, function(i) {
      var n = [];
      return hl(i, function(r) {
        r !== i && r.nodeType === zr && (e === "*" || r.namespaceURI === e) && (t === "*" || r.localName == t) && n.push(r);
      }), n;
    });
  }
};
wl.prototype.getElementsByTagName = hs.prototype.getElementsByTagName;
wl.prototype.getElementsByTagNameNS = hs.prototype.getElementsByTagNameNS;
vr(hs, Nt);
function Fc() {
}
Fc.prototype.nodeType = To;
vr(Fc, Nt);
function Sl() {
}
Sl.prototype = {
  data: "",
  substringData: function(e, t) {
    return this.data.substring(e, e + t);
  },
  appendData: function(e) {
    e = this.data + e, this.nodeValue = this.data = e, this.length = e.length;
  },
  insertData: function(e, t) {
    this.replaceData(e, 0, t);
  },
  appendChild: function(e) {
    throw new Error(Ri[ur]);
  },
  deleteData: function(e, t) {
    this.replaceData(e, t, "");
  },
  replaceData: function(e, t, i) {
    var n = this.data.substring(0, e), r = this.data.substring(e + t);
    i = n + i + r, this.nodeValue = this.data = i, this.length = i.length;
  }
};
vr(Sl, Nt);
function cp() {
}
cp.prototype = {
  nodeName: "#text",
  nodeType: Oc,
  splitText: function(e) {
    var t = this.data, i = t.substring(e);
    t = t.substring(0, e), this.data = this.nodeValue = t, this.length = t.length;
    var n = this.ownerDocument.createTextNode(i);
    return this.parentNode && this.parentNode.insertBefore(n, this.nextSibling), n;
  }
};
vr(cp, Sl);
function hp() {
}
hp.prototype = {
  nodeName: "#comment",
  nodeType: Gy
};
vr(hp, Sl);
function dp() {
}
dp.prototype = {
  nodeName: "#cdata-section",
  nodeType: Ny
};
vr(dp, Sl);
function xh() {
}
xh.prototype.nodeType = Hy;
vr(xh, Nt);
function Zy() {
}
Zy.prototype.nodeType = mS;
vr(Zy, Nt);
function Jy() {
}
Jy.prototype.nodeType = vS;
vr(Jy, Nt);
function fp() {
}
fp.prototype.nodeType = Uy;
vr(fp, Nt);
function Ah() {
}
Ah.prototype.nodeName = "#document-fragment";
Ah.prototype.nodeType = Hn;
vr(Ah, Nt);
function pp() {
}
pp.prototype.nodeType = jy;
vr(pp, Nt);
function $y() {
}
$y.prototype.serializeToString = function(e, t, i) {
  return e_.call(e, t, i);
};
Nt.prototype.toString = e_;
function e_(e, t) {
  var i = [], n = this.nodeType == 9 && this.documentElement || this, r = n.prefix, a = n.namespaceURI;
  if (a && r == null) {
    var r = n.lookupPrefix(a);
    if (r == null)
      var s = [
        { namespace: a, prefix: null }
        //{namespace:uri,prefix:''}
      ];
  }
  return Ls(this, i, e, t, s), i.join("");
}
function fm(e, t, i) {
  var n = e.prefix || "", r = e.namespaceURI;
  if (!r || n === "xml" && r === cl.XML || r === cl.XMLNS)
    return !1;
  for (var a = i.length; a--; ) {
    var s = i[a];
    if (s.prefix === n)
      return s.namespace !== r;
  }
  return !0;
}
function rd(e, t, i) {
  e.push(" ", t, '="', i.replace(/[<>&"\t\n\r]/g, Xy), '"');
}
function Ls(e, t, i, n, r) {
  if (r || (r = []), n)
    if (e = n(e), e) {
      if (typeof e == "string") {
        t.push(e);
        return;
      }
    } else
      return;
  switch (e.nodeType) {
    case zr:
      var a = e.attributes, s = a.length, x = e.firstChild, o = e.tagName;
      i = cl.isHTML(e.namespaceURI) || i;
      var u = o;
      if (!i && !e.prefix && e.namespaceURI) {
        for (var l, c = 0; c < a.length; c++)
          if (a.item(c).name === "xmlns") {
            l = a.item(c).value;
            break;
          }
        if (!l)
          for (var h = r.length - 1; h >= 0; h--) {
            var d = r[h];
            if (d.prefix === "" && d.namespace === e.namespaceURI) {
              l = d.namespace;
              break;
            }
          }
        if (l !== e.namespaceURI)
          for (var h = r.length - 1; h >= 0; h--) {
            var d = r[h];
            if (d.namespace === e.namespaceURI) {
              d.prefix && (u = d.prefix + ":" + o);
              break;
            }
          }
      }
      t.push("<", u);
      for (var f = 0; f < s; f++) {
        var p = a.item(f);
        p.prefix == "xmlns" ? r.push({ prefix: p.localName, namespace: p.value }) : p.nodeName == "xmlns" && r.push({ prefix: "", namespace: p.value });
      }
      for (var f = 0; f < s; f++) {
        var p = a.item(f);
        if (fm(p, i, r)) {
          var _ = p.prefix || "", m = p.namespaceURI;
          rd(t, _ ? "xmlns:" + _ : "xmlns", m), r.push({ prefix: _, namespace: m });
        }
        Ls(p, t, i, n, r);
      }
      if (o === u && fm(e, i, r)) {
        var _ = e.prefix || "", m = e.namespaceURI;
        rd(t, _ ? "xmlns:" + _ : "xmlns", m), r.push({ prefix: _, namespace: m });
      }
      if (x || i && !/^(?:meta|link|img|br|hr|input)$/i.test(o)) {
        if (t.push(">"), i && /^script$/i.test(o))
          for (; x; )
            x.data ? t.push(x.data) : Ls(x, t, i, n, r.slice()), x = x.nextSibling;
        else
          for (; x; )
            Ls(x, t, i, n, r.slice()), x = x.nextSibling;
        t.push("</", u, ">");
      } else
        t.push("/>");
      return;
    case Vy:
    case Hn:
      for (var x = e.firstChild; x; )
        Ls(x, t, i, n, r.slice()), x = x.nextSibling;
      return;
    case To:
      return rd(t, e.name, e.value);
    case Oc:
      return t.push(
        e.data.replace(/[<&>]/g, Xy)
      );
    case Ny:
      return t.push("<![CDATA[", e.data, "]]>");
    case Gy:
      return t.push("<!--", e.data, "-->");
    case Hy:
      var E = e.publicId, M = e.systemId;
      if (t.push("<!DOCTYPE ", e.name), E)
        t.push(" PUBLIC ", E), M && M != "." && t.push(" ", M), t.push(">");
      else if (M && M != ".")
        t.push(" SYSTEM ", M, ">");
      else {
        var C = e.internalSubset;
        C && t.push(" [", C, "]"), t.push(">");
      }
      return;
    case jy:
      return t.push("<?", e.target, " ", e.data, "?>");
    case Uy:
      return t.push("&", e.nodeName, ";");
    default:
      t.push("??", e.nodeName);
  }
}
function t_(e, t, i) {
  var n;
  switch (t.nodeType) {
    case zr:
      n = t.cloneNode(!1), n.ownerDocument = e;
    case Hn:
      break;
    case To:
      i = !0;
      break;
  }
  if (n || (n = t.cloneNode(!1)), n.ownerDocument = e, n.parentNode = null, i)
    for (var r = t.firstChild; r; )
      n.appendChild(t_(e, r, i)), r = r.nextSibling;
  return n;
}
function Jd(e, t, i) {
  var n = new t.constructor();
  for (var r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      var a = t[r];
      typeof a != "object" && a != n[r] && (n[r] = a);
    }
  switch (t.childNodes && (n.childNodes = new Nn()), n.ownerDocument = e, n.nodeType) {
    case zr:
      var s = t.attributes, o = n.attributes = new kc(), u = s.length;
      o._ownerElement = n;
      for (var l = 0; l < u; l++)
        n.setAttributeNode(Jd(e, s.item(l), !0));
      break;
    case To:
      i = !0;
  }
  if (i)
    for (var c = t.firstChild; c; )
      n.appendChild(Jd(e, c, i)), c = c.nextSibling;
  return n;
}
function i_(e, t, i) {
  e[t] = i;
}
try {
  if (Object.defineProperty) {
    let e = function(t) {
      switch (t.nodeType) {
        case zr:
        case Hn:
          var i = [];
          for (t = t.firstChild; t; )
            t.nodeType !== 7 && t.nodeType !== 8 && i.push(e(t)), t = t.nextSibling;
          return i.join("");
        default:
          return t.nodeValue;
      }
    };
    Object.defineProperty(Eo.prototype, "length", {
      get: function() {
        return op(this), this.$$length;
      }
    }), Object.defineProperty(Nt.prototype, "textContent", {
      get: function() {
        return e(this);
      },
      set: function(t) {
        switch (this.nodeType) {
          case zr:
          case Hn:
            for (; this.firstChild; )
              this.removeChild(this.firstChild);
            (t || String(t)) && this.appendChild(this.ownerDocument.createTextNode(t));
            break;
          default:
            this.data = t, this.value = t, this.nodeValue = t;
        }
      }
    }), i_ = function(t, i, n) {
      t["$$" + i] = n;
    };
  }
} catch {
}
ya.DocumentType = xh;
ya.DOMException = mi;
ya.DOMImplementation = qy;
ya.Element = hs;
ya.Node = Nt;
ya.NodeList = Nn;
ya.XMLSerializer = $y;
var Th = {}, r_ = {};
(function(e) {
  var t = Zn.freeze;
  e.XML_ENTITIES = t({
    amp: "&",
    apos: "'",
    gt: ">",
    lt: "<",
    quot: '"'
  }), e.HTML_ENTITIES = t({
    Aacute: "",
    aacute: "",
    Abreve: "",
    abreve: "",
    ac: "",
    acd: "",
    acE: "",
    Acirc: "",
    acirc: "",
    acute: "",
    Acy: "",
    acy: "",
    AElig: "",
    aelig: "",
    af: "",
    Afr: "",
    afr: "",
    Agrave: "",
    agrave: "",
    alefsym: "",
    aleph: "",
    Alpha: "",
    alpha: "",
    Amacr: "",
    amacr: "",
    amalg: "",
    AMP: "&",
    amp: "&",
    And: "",
    and: "",
    andand: "",
    andd: "",
    andslope: "",
    andv: "",
    ang: "",
    ange: "",
    angle: "",
    angmsd: "",
    angmsdaa: "",
    angmsdab: "",
    angmsdac: "",
    angmsdad: "",
    angmsdae: "",
    angmsdaf: "",
    angmsdag: "",
    angmsdah: "",
    angrt: "",
    angrtvb: "",
    angrtvbd: "",
    angsph: "",
    angst: "",
    angzarr: "",
    Aogon: "",
    aogon: "",
    Aopf: "",
    aopf: "",
    ap: "",
    apacir: "",
    apE: "",
    ape: "",
    apid: "",
    apos: "'",
    ApplyFunction: "",
    approx: "",
    approxeq: "",
    Aring: "",
    aring: "",
    Ascr: "",
    ascr: "",
    Assign: "",
    ast: "*",
    asymp: "",
    asympeq: "",
    Atilde: "",
    atilde: "",
    Auml: "",
    auml: "",
    awconint: "",
    awint: "",
    backcong: "",
    backepsilon: "",
    backprime: "",
    backsim: "",
    backsimeq: "",
    Backslash: "",
    Barv: "",
    barvee: "",
    Barwed: "",
    barwed: "",
    barwedge: "",
    bbrk: "",
    bbrktbrk: "",
    bcong: "",
    Bcy: "",
    bcy: "",
    bdquo: "",
    becaus: "",
    Because: "",
    because: "",
    bemptyv: "",
    bepsi: "",
    bernou: "",
    Bernoullis: "",
    Beta: "",
    beta: "",
    beth: "",
    between: "",
    Bfr: "",
    bfr: "",
    bigcap: "",
    bigcirc: "",
    bigcup: "",
    bigodot: "",
    bigoplus: "",
    bigotimes: "",
    bigsqcup: "",
    bigstar: "",
    bigtriangledown: "",
    bigtriangleup: "",
    biguplus: "",
    bigvee: "",
    bigwedge: "",
    bkarow: "",
    blacklozenge: "",
    blacksquare: "",
    blacktriangle: "",
    blacktriangledown: "",
    blacktriangleleft: "",
    blacktriangleright: "",
    blank: "",
    blk12: "",
    blk14: "",
    blk34: "",
    block: "",
    bne: "=",
    bnequiv: "",
    bNot: "",
    bnot: "",
    Bopf: "",
    bopf: "",
    bot: "",
    bottom: "",
    bowtie: "",
    boxbox: "",
    boxDL: "",
    boxDl: "",
    boxdL: "",
    boxdl: "",
    boxDR: "",
    boxDr: "",
    boxdR: "",
    boxdr: "",
    boxH: "",
    boxh: "",
    boxHD: "",
    boxHd: "",
    boxhD: "",
    boxhd: "",
    boxHU: "",
    boxHu: "",
    boxhU: "",
    boxhu: "",
    boxminus: "",
    boxplus: "",
    boxtimes: "",
    boxUL: "",
    boxUl: "",
    boxuL: "",
    boxul: "",
    boxUR: "",
    boxUr: "",
    boxuR: "",
    boxur: "",
    boxV: "",
    boxv: "",
    boxVH: "",
    boxVh: "",
    boxvH: "",
    boxvh: "",
    boxVL: "",
    boxVl: "",
    boxvL: "",
    boxvl: "",
    boxVR: "",
    boxVr: "",
    boxvR: "",
    boxvr: "",
    bprime: "",
    Breve: "",
    breve: "",
    brvbar: "",
    Bscr: "",
    bscr: "",
    bsemi: "",
    bsim: "",
    bsime: "",
    bsol: "\\",
    bsolb: "",
    bsolhsub: "",
    bull: "",
    bullet: "",
    bump: "",
    bumpE: "",
    bumpe: "",
    Bumpeq: "",
    bumpeq: "",
    Cacute: "",
    cacute: "",
    Cap: "",
    cap: "",
    capand: "",
    capbrcup: "",
    capcap: "",
    capcup: "",
    capdot: "",
    CapitalDifferentialD: "",
    caps: "",
    caret: "",
    caron: "",
    Cayleys: "",
    ccaps: "",
    Ccaron: "",
    ccaron: "",
    Ccedil: "",
    ccedil: "",
    Ccirc: "",
    ccirc: "",
    Cconint: "",
    ccups: "",
    ccupssm: "",
    Cdot: "",
    cdot: "",
    cedil: "",
    Cedilla: "",
    cemptyv: "",
    cent: "",
    CenterDot: "",
    centerdot: "",
    Cfr: "",
    cfr: "",
    CHcy: "",
    chcy: "",
    check: "",
    checkmark: "",
    Chi: "",
    chi: "",
    cir: "",
    circ: "",
    circeq: "",
    circlearrowleft: "",
    circlearrowright: "",
    circledast: "",
    circledcirc: "",
    circleddash: "",
    CircleDot: "",
    circledR: "",
    circledS: "",
    CircleMinus: "",
    CirclePlus: "",
    CircleTimes: "",
    cirE: "",
    cire: "",
    cirfnint: "",
    cirmid: "",
    cirscir: "",
    ClockwiseContourIntegral: "",
    CloseCurlyDoubleQuote: "",
    CloseCurlyQuote: "",
    clubs: "",
    clubsuit: "",
    Colon: "",
    colon: ":",
    Colone: "",
    colone: "",
    coloneq: "",
    comma: ",",
    commat: "@",
    comp: "",
    compfn: "",
    complement: "",
    complexes: "",
    cong: "",
    congdot: "",
    Congruent: "",
    Conint: "",
    conint: "",
    ContourIntegral: "",
    Copf: "",
    copf: "",
    coprod: "",
    Coproduct: "",
    COPY: "",
    copy: "",
    copysr: "",
    CounterClockwiseContourIntegral: "",
    crarr: "",
    Cross: "",
    cross: "",
    Cscr: "",
    cscr: "",
    csub: "",
    csube: "",
    csup: "",
    csupe: "",
    ctdot: "",
    cudarrl: "",
    cudarrr: "",
    cuepr: "",
    cuesc: "",
    cularr: "",
    cularrp: "",
    Cup: "",
    cup: "",
    cupbrcap: "",
    CupCap: "",
    cupcap: "",
    cupcup: "",
    cupdot: "",
    cupor: "",
    cups: "",
    curarr: "",
    curarrm: "",
    curlyeqprec: "",
    curlyeqsucc: "",
    curlyvee: "",
    curlywedge: "",
    curren: "",
    curvearrowleft: "",
    curvearrowright: "",
    cuvee: "",
    cuwed: "",
    cwconint: "",
    cwint: "",
    cylcty: "",
    Dagger: "",
    dagger: "",
    daleth: "",
    Darr: "",
    dArr: "",
    darr: "",
    dash: "",
    Dashv: "",
    dashv: "",
    dbkarow: "",
    dblac: "",
    Dcaron: "",
    dcaron: "",
    Dcy: "",
    dcy: "",
    DD: "",
    dd: "",
    ddagger: "",
    ddarr: "",
    DDotrahd: "",
    ddotseq: "",
    deg: "",
    Del: "",
    Delta: "",
    delta: "",
    demptyv: "",
    dfisht: "",
    Dfr: "",
    dfr: "",
    dHar: "",
    dharl: "",
    dharr: "",
    DiacriticalAcute: "",
    DiacriticalDot: "",
    DiacriticalDoubleAcute: "",
    DiacriticalGrave: "`",
    DiacriticalTilde: "",
    diam: "",
    Diamond: "",
    diamond: "",
    diamondsuit: "",
    diams: "",
    die: "",
    DifferentialD: "",
    digamma: "",
    disin: "",
    div: "",
    divide: "",
    divideontimes: "",
    divonx: "",
    DJcy: "",
    djcy: "",
    dlcorn: "",
    dlcrop: "",
    dollar: "$",
    Dopf: "",
    dopf: "",
    Dot: "",
    dot: "",
    DotDot: "",
    doteq: "",
    doteqdot: "",
    DotEqual: "",
    dotminus: "",
    dotplus: "",
    dotsquare: "",
    doublebarwedge: "",
    DoubleContourIntegral: "",
    DoubleDot: "",
    DoubleDownArrow: "",
    DoubleLeftArrow: "",
    DoubleLeftRightArrow: "",
    DoubleLeftTee: "",
    DoubleLongLeftArrow: "",
    DoubleLongLeftRightArrow: "",
    DoubleLongRightArrow: "",
    DoubleRightArrow: "",
    DoubleRightTee: "",
    DoubleUpArrow: "",
    DoubleUpDownArrow: "",
    DoubleVerticalBar: "",
    DownArrow: "",
    Downarrow: "",
    downarrow: "",
    DownArrowBar: "",
    DownArrowUpArrow: "",
    DownBreve: "",
    downdownarrows: "",
    downharpoonleft: "",
    downharpoonright: "",
    DownLeftRightVector: "",
    DownLeftTeeVector: "",
    DownLeftVector: "",
    DownLeftVectorBar: "",
    DownRightTeeVector: "",
    DownRightVector: "",
    DownRightVectorBar: "",
    DownTee: "",
    DownTeeArrow: "",
    drbkarow: "",
    drcorn: "",
    drcrop: "",
    Dscr: "",
    dscr: "",
    DScy: "",
    dscy: "",
    dsol: "",
    Dstrok: "",
    dstrok: "",
    dtdot: "",
    dtri: "",
    dtrif: "",
    duarr: "",
    duhar: "",
    dwangle: "",
    DZcy: "",
    dzcy: "",
    dzigrarr: "",
    Eacute: "",
    eacute: "",
    easter: "",
    Ecaron: "",
    ecaron: "",
    ecir: "",
    Ecirc: "",
    ecirc: "",
    ecolon: "",
    Ecy: "",
    ecy: "",
    eDDot: "",
    Edot: "",
    eDot: "",
    edot: "",
    ee: "",
    efDot: "",
    Efr: "",
    efr: "",
    eg: "",
    Egrave: "",
    egrave: "",
    egs: "",
    egsdot: "",
    el: "",
    Element: "",
    elinters: "",
    ell: "",
    els: "",
    elsdot: "",
    Emacr: "",
    emacr: "",
    empty: "",
    emptyset: "",
    EmptySmallSquare: "",
    emptyv: "",
    EmptyVerySmallSquare: "",
    emsp: "",
    emsp13: "",
    emsp14: "",
    ENG: "",
    eng: "",
    ensp: "",
    Eogon: "",
    eogon: "",
    Eopf: "",
    eopf: "",
    epar: "",
    eparsl: "",
    eplus: "",
    epsi: "",
    Epsilon: "",
    epsilon: "",
    epsiv: "",
    eqcirc: "",
    eqcolon: "",
    eqsim: "",
    eqslantgtr: "",
    eqslantless: "",
    Equal: "",
    equals: "=",
    EqualTilde: "",
    equest: "",
    Equilibrium: "",
    equiv: "",
    equivDD: "",
    eqvparsl: "",
    erarr: "",
    erDot: "",
    Escr: "",
    escr: "",
    esdot: "",
    Esim: "",
    esim: "",
    Eta: "",
    eta: "",
    ETH: "",
    eth: "",
    Euml: "",
    euml: "",
    euro: "",
    excl: "!",
    exist: "",
    Exists: "",
    expectation: "",
    ExponentialE: "",
    exponentiale: "",
    fallingdotseq: "",
    Fcy: "",
    fcy: "",
    female: "",
    ffilig: "",
    fflig: "",
    ffllig: "",
    Ffr: "",
    ffr: "",
    filig: "",
    FilledSmallSquare: "",
    FilledVerySmallSquare: "",
    fjlig: "fj",
    flat: "",
    fllig: "",
    fltns: "",
    fnof: "",
    Fopf: "",
    fopf: "",
    ForAll: "",
    forall: "",
    fork: "",
    forkv: "",
    Fouriertrf: "",
    fpartint: "",
    frac12: "",
    frac13: "",
    frac14: "",
    frac15: "",
    frac16: "",
    frac18: "",
    frac23: "",
    frac25: "",
    frac34: "",
    frac35: "",
    frac38: "",
    frac45: "",
    frac56: "",
    frac58: "",
    frac78: "",
    frasl: "",
    frown: "",
    Fscr: "",
    fscr: "",
    gacute: "",
    Gamma: "",
    gamma: "",
    Gammad: "",
    gammad: "",
    gap: "",
    Gbreve: "",
    gbreve: "",
    Gcedil: "",
    Gcirc: "",
    gcirc: "",
    Gcy: "",
    gcy: "",
    Gdot: "",
    gdot: "",
    gE: "",
    ge: "",
    gEl: "",
    gel: "",
    geq: "",
    geqq: "",
    geqslant: "",
    ges: "",
    gescc: "",
    gesdot: "",
    gesdoto: "",
    gesdotol: "",
    gesl: "",
    gesles: "",
    Gfr: "",
    gfr: "",
    Gg: "",
    gg: "",
    ggg: "",
    gimel: "",
    GJcy: "",
    gjcy: "",
    gl: "",
    gla: "",
    glE: "",
    glj: "",
    gnap: "",
    gnapprox: "",
    gnE: "",
    gne: "",
    gneq: "",
    gneqq: "",
    gnsim: "",
    Gopf: "",
    gopf: "",
    grave: "`",
    GreaterEqual: "",
    GreaterEqualLess: "",
    GreaterFullEqual: "",
    GreaterGreater: "",
    GreaterLess: "",
    GreaterSlantEqual: "",
    GreaterTilde: "",
    Gscr: "",
    gscr: "",
    gsim: "",
    gsime: "",
    gsiml: "",
    Gt: "",
    GT: ">",
    gt: ">",
    gtcc: "",
    gtcir: "",
    gtdot: "",
    gtlPar: "",
    gtquest: "",
    gtrapprox: "",
    gtrarr: "",
    gtrdot: "",
    gtreqless: "",
    gtreqqless: "",
    gtrless: "",
    gtrsim: "",
    gvertneqq: "",
    gvnE: "",
    Hacek: "",
    hairsp: "",
    half: "",
    hamilt: "",
    HARDcy: "",
    hardcy: "",
    hArr: "",
    harr: "",
    harrcir: "",
    harrw: "",
    Hat: "^",
    hbar: "",
    Hcirc: "",
    hcirc: "",
    hearts: "",
    heartsuit: "",
    hellip: "",
    hercon: "",
    Hfr: "",
    hfr: "",
    HilbertSpace: "",
    hksearow: "",
    hkswarow: "",
    hoarr: "",
    homtht: "",
    hookleftarrow: "",
    hookrightarrow: "",
    Hopf: "",
    hopf: "",
    horbar: "",
    HorizontalLine: "",
    Hscr: "",
    hscr: "",
    hslash: "",
    Hstrok: "",
    hstrok: "",
    HumpDownHump: "",
    HumpEqual: "",
    hybull: "",
    hyphen: "",
    Iacute: "",
    iacute: "",
    ic: "",
    Icirc: "",
    icirc: "",
    Icy: "",
    icy: "",
    Idot: "",
    IEcy: "",
    iecy: "",
    iexcl: "",
    iff: "",
    Ifr: "",
    ifr: "",
    Igrave: "",
    igrave: "",
    ii: "",
    iiiint: "",
    iiint: "",
    iinfin: "",
    iiota: "",
    IJlig: "",
    ijlig: "",
    Im: "",
    Imacr: "",
    imacr: "",
    image: "",
    ImaginaryI: "",
    imagline: "",
    imagpart: "",
    imath: "",
    imof: "",
    imped: "",
    Implies: "",
    in: "",
    incare: "",
    infin: "",
    infintie: "",
    inodot: "",
    Int: "",
    int: "",
    intcal: "",
    integers: "",
    Integral: "",
    intercal: "",
    Intersection: "",
    intlarhk: "",
    intprod: "",
    InvisibleComma: "",
    InvisibleTimes: "",
    IOcy: "",
    iocy: "",
    Iogon: "",
    iogon: "",
    Iopf: "",
    iopf: "",
    Iota: "",
    iota: "",
    iprod: "",
    iquest: "",
    Iscr: "",
    iscr: "",
    isin: "",
    isindot: "",
    isinE: "",
    isins: "",
    isinsv: "",
    isinv: "",
    it: "",
    Itilde: "",
    itilde: "",
    Iukcy: "",
    iukcy: "",
    Iuml: "",
    iuml: "",
    Jcirc: "",
    jcirc: "",
    Jcy: "",
    jcy: "",
    Jfr: "",
    jfr: "",
    jmath: "",
    Jopf: "",
    jopf: "",
    Jscr: "",
    jscr: "",
    Jsercy: "",
    jsercy: "",
    Jukcy: "",
    jukcy: "",
    Kappa: "",
    kappa: "",
    kappav: "",
    Kcedil: "",
    kcedil: "",
    Kcy: "",
    kcy: "",
    Kfr: "",
    kfr: "",
    kgreen: "",
    KHcy: "",
    khcy: "",
    KJcy: "",
    kjcy: "",
    Kopf: "",
    kopf: "",
    Kscr: "",
    kscr: "",
    lAarr: "",
    Lacute: "",
    lacute: "",
    laemptyv: "",
    lagran: "",
    Lambda: "",
    lambda: "",
    Lang: "",
    lang: "",
    langd: "",
    langle: "",
    lap: "",
    Laplacetrf: "",
    laquo: "",
    Larr: "",
    lArr: "",
    larr: "",
    larrb: "",
    larrbfs: "",
    larrfs: "",
    larrhk: "",
    larrlp: "",
    larrpl: "",
    larrsim: "",
    larrtl: "",
    lat: "",
    lAtail: "",
    latail: "",
    late: "",
    lates: "",
    lBarr: "",
    lbarr: "",
    lbbrk: "",
    lbrace: "{",
    lbrack: "[",
    lbrke: "",
    lbrksld: "",
    lbrkslu: "",
    Lcaron: "",
    lcaron: "",
    Lcedil: "",
    lcedil: "",
    lceil: "",
    lcub: "{",
    Lcy: "",
    lcy: "",
    ldca: "",
    ldquo: "",
    ldquor: "",
    ldrdhar: "",
    ldrushar: "",
    ldsh: "",
    lE: "",
    le: "",
    LeftAngleBracket: "",
    LeftArrow: "",
    Leftarrow: "",
    leftarrow: "",
    LeftArrowBar: "",
    LeftArrowRightArrow: "",
    leftarrowtail: "",
    LeftCeiling: "",
    LeftDoubleBracket: "",
    LeftDownTeeVector: "",
    LeftDownVector: "",
    LeftDownVectorBar: "",
    LeftFloor: "",
    leftharpoondown: "",
    leftharpoonup: "",
    leftleftarrows: "",
    LeftRightArrow: "",
    Leftrightarrow: "",
    leftrightarrow: "",
    leftrightarrows: "",
    leftrightharpoons: "",
    leftrightsquigarrow: "",
    LeftRightVector: "",
    LeftTee: "",
    LeftTeeArrow: "",
    LeftTeeVector: "",
    leftthreetimes: "",
    LeftTriangle: "",
    LeftTriangleBar: "",
    LeftTriangleEqual: "",
    LeftUpDownVector: "",
    LeftUpTeeVector: "",
    LeftUpVector: "",
    LeftUpVectorBar: "",
    LeftVector: "",
    LeftVectorBar: "",
    lEg: "",
    leg: "",
    leq: "",
    leqq: "",
    leqslant: "",
    les: "",
    lescc: "",
    lesdot: "",
    lesdoto: "",
    lesdotor: "",
    lesg: "",
    lesges: "",
    lessapprox: "",
    lessdot: "",
    lesseqgtr: "",
    lesseqqgtr: "",
    LessEqualGreater: "",
    LessFullEqual: "",
    LessGreater: "",
    lessgtr: "",
    LessLess: "",
    lesssim: "",
    LessSlantEqual: "",
    LessTilde: "",
    lfisht: "",
    lfloor: "",
    Lfr: "",
    lfr: "",
    lg: "",
    lgE: "",
    lHar: "",
    lhard: "",
    lharu: "",
    lharul: "",
    lhblk: "",
    LJcy: "",
    ljcy: "",
    Ll: "",
    ll: "",
    llarr: "",
    llcorner: "",
    Lleftarrow: "",
    llhard: "",
    lltri: "",
    Lmidot: "",
    lmidot: "",
    lmoust: "",
    lmoustache: "",
    lnap: "",
    lnapprox: "",
    lnE: "",
    lne: "",
    lneq: "",
    lneqq: "",
    lnsim: "",
    loang: "",
    loarr: "",
    lobrk: "",
    LongLeftArrow: "",
    Longleftarrow: "",
    longleftarrow: "",
    LongLeftRightArrow: "",
    Longleftrightarrow: "",
    longleftrightarrow: "",
    longmapsto: "",
    LongRightArrow: "",
    Longrightarrow: "",
    longrightarrow: "",
    looparrowleft: "",
    looparrowright: "",
    lopar: "",
    Lopf: "",
    lopf: "",
    loplus: "",
    lotimes: "",
    lowast: "",
    lowbar: "_",
    LowerLeftArrow: "",
    LowerRightArrow: "",
    loz: "",
    lozenge: "",
    lozf: "",
    lpar: "(",
    lparlt: "",
    lrarr: "",
    lrcorner: "",
    lrhar: "",
    lrhard: "",
    lrm: "",
    lrtri: "",
    lsaquo: "",
    Lscr: "",
    lscr: "",
    Lsh: "",
    lsh: "",
    lsim: "",
    lsime: "",
    lsimg: "",
    lsqb: "[",
    lsquo: "",
    lsquor: "",
    Lstrok: "",
    lstrok: "",
    Lt: "",
    LT: "<",
    lt: "<",
    ltcc: "",
    ltcir: "",
    ltdot: "",
    lthree: "",
    ltimes: "",
    ltlarr: "",
    ltquest: "",
    ltri: "",
    ltrie: "",
    ltrif: "",
    ltrPar: "",
    lurdshar: "",
    luruhar: "",
    lvertneqq: "",
    lvnE: "",
    macr: "",
    male: "",
    malt: "",
    maltese: "",
    Map: "",
    map: "",
    mapsto: "",
    mapstodown: "",
    mapstoleft: "",
    mapstoup: "",
    marker: "",
    mcomma: "",
    Mcy: "",
    mcy: "",
    mdash: "",
    mDDot: "",
    measuredangle: "",
    MediumSpace: "",
    Mellintrf: "",
    Mfr: "",
    mfr: "",
    mho: "",
    micro: "",
    mid: "",
    midast: "*",
    midcir: "",
    middot: "",
    minus: "",
    minusb: "",
    minusd: "",
    minusdu: "",
    MinusPlus: "",
    mlcp: "",
    mldr: "",
    mnplus: "",
    models: "",
    Mopf: "",
    mopf: "",
    mp: "",
    Mscr: "",
    mscr: "",
    mstpos: "",
    Mu: "",
    mu: "",
    multimap: "",
    mumap: "",
    nabla: "",
    Nacute: "",
    nacute: "",
    nang: "",
    nap: "",
    napE: "",
    napid: "",
    napos: "",
    napprox: "",
    natur: "",
    natural: "",
    naturals: "",
    nbsp: "",
    nbump: "",
    nbumpe: "",
    ncap: "",
    Ncaron: "",
    ncaron: "",
    Ncedil: "",
    ncedil: "",
    ncong: "",
    ncongdot: "",
    ncup: "",
    Ncy: "",
    ncy: "",
    ndash: "",
    ne: "",
    nearhk: "",
    neArr: "",
    nearr: "",
    nearrow: "",
    nedot: "",
    NegativeMediumSpace: "",
    NegativeThickSpace: "",
    NegativeThinSpace: "",
    NegativeVeryThinSpace: "",
    nequiv: "",
    nesear: "",
    nesim: "",
    NestedGreaterGreater: "",
    NestedLessLess: "",
    NewLine: `
`,
    nexist: "",
    nexists: "",
    Nfr: "",
    nfr: "",
    ngE: "",
    nge: "",
    ngeq: "",
    ngeqq: "",
    ngeqslant: "",
    nges: "",
    nGg: "",
    ngsim: "",
    nGt: "",
    ngt: "",
    ngtr: "",
    nGtv: "",
    nhArr: "",
    nharr: "",
    nhpar: "",
    ni: "",
    nis: "",
    nisd: "",
    niv: "",
    NJcy: "",
    njcy: "",
    nlArr: "",
    nlarr: "",
    nldr: "",
    nlE: "",
    nle: "",
    nLeftarrow: "",
    nleftarrow: "",
    nLeftrightarrow: "",
    nleftrightarrow: "",
    nleq: "",
    nleqq: "",
    nleqslant: "",
    nles: "",
    nless: "",
    nLl: "",
    nlsim: "",
    nLt: "",
    nlt: "",
    nltri: "",
    nltrie: "",
    nLtv: "",
    nmid: "",
    NoBreak: "",
    NonBreakingSpace: "",
    Nopf: "",
    nopf: "",
    Not: "",
    not: "",
    NotCongruent: "",
    NotCupCap: "",
    NotDoubleVerticalBar: "",
    NotElement: "",
    NotEqual: "",
    NotEqualTilde: "",
    NotExists: "",
    NotGreater: "",
    NotGreaterEqual: "",
    NotGreaterFullEqual: "",
    NotGreaterGreater: "",
    NotGreaterLess: "",
    NotGreaterSlantEqual: "",
    NotGreaterTilde: "",
    NotHumpDownHump: "",
    NotHumpEqual: "",
    notin: "",
    notindot: "",
    notinE: "",
    notinva: "",
    notinvb: "",
    notinvc: "",
    NotLeftTriangle: "",
    NotLeftTriangleBar: "",
    NotLeftTriangleEqual: "",
    NotLess: "",
    NotLessEqual: "",
    NotLessGreater: "",
    NotLessLess: "",
    NotLessSlantEqual: "",
    NotLessTilde: "",
    NotNestedGreaterGreater: "",
    NotNestedLessLess: "",
    notni: "",
    notniva: "",
    notnivb: "",
    notnivc: "",
    NotPrecedes: "",
    NotPrecedesEqual: "",
    NotPrecedesSlantEqual: "",
    NotReverseElement: "",
    NotRightTriangle: "",
    NotRightTriangleBar: "",
    NotRightTriangleEqual: "",
    NotSquareSubset: "",
    NotSquareSubsetEqual: "",
    NotSquareSuperset: "",
    NotSquareSupersetEqual: "",
    NotSubset: "",
    NotSubsetEqual: "",
    NotSucceeds: "",
    NotSucceedsEqual: "",
    NotSucceedsSlantEqual: "",
    NotSucceedsTilde: "",
    NotSuperset: "",
    NotSupersetEqual: "",
    NotTilde: "",
    NotTildeEqual: "",
    NotTildeFullEqual: "",
    NotTildeTilde: "",
    NotVerticalBar: "",
    npar: "",
    nparallel: "",
    nparsl: "",
    npart: "",
    npolint: "",
    npr: "",
    nprcue: "",
    npre: "",
    nprec: "",
    npreceq: "",
    nrArr: "",
    nrarr: "",
    nrarrc: "",
    nrarrw: "",
    nRightarrow: "",
    nrightarrow: "",
    nrtri: "",
    nrtrie: "",
    nsc: "",
    nsccue: "",
    nsce: "",
    Nscr: "",
    nscr: "",
    nshortmid: "",
    nshortparallel: "",
    nsim: "",
    nsime: "",
    nsimeq: "",
    nsmid: "",
    nspar: "",
    nsqsube: "",
    nsqsupe: "",
    nsub: "",
    nsubE: "",
    nsube: "",
    nsubset: "",
    nsubseteq: "",
    nsubseteqq: "",
    nsucc: "",
    nsucceq: "",
    nsup: "",
    nsupE: "",
    nsupe: "",
    nsupset: "",
    nsupseteq: "",
    nsupseteqq: "",
    ntgl: "",
    Ntilde: "",
    ntilde: "",
    ntlg: "",
    ntriangleleft: "",
    ntrianglelefteq: "",
    ntriangleright: "",
    ntrianglerighteq: "",
    Nu: "",
    nu: "",
    num: "#",
    numero: "",
    numsp: "",
    nvap: "",
    nVDash: "",
    nVdash: "",
    nvDash: "",
    nvdash: "",
    nvge: "",
    nvgt: ">",
    nvHarr: "",
    nvinfin: "",
    nvlArr: "",
    nvle: "",
    nvlt: "<",
    nvltrie: "",
    nvrArr: "",
    nvrtrie: "",
    nvsim: "",
    nwarhk: "",
    nwArr: "",
    nwarr: "",
    nwarrow: "",
    nwnear: "",
    Oacute: "",
    oacute: "",
    oast: "",
    ocir: "",
    Ocirc: "",
    ocirc: "",
    Ocy: "",
    ocy: "",
    odash: "",
    Odblac: "",
    odblac: "",
    odiv: "",
    odot: "",
    odsold: "",
    OElig: "",
    oelig: "",
    ofcir: "",
    Ofr: "",
    ofr: "",
    ogon: "",
    Ograve: "",
    ograve: "",
    ogt: "",
    ohbar: "",
    ohm: "",
    oint: "",
    olarr: "",
    olcir: "",
    olcross: "",
    oline: "",
    olt: "",
    Omacr: "",
    omacr: "",
    Omega: "",
    omega: "",
    Omicron: "",
    omicron: "",
    omid: "",
    ominus: "",
    Oopf: "",
    oopf: "",
    opar: "",
    OpenCurlyDoubleQuote: "",
    OpenCurlyQuote: "",
    operp: "",
    oplus: "",
    Or: "",
    or: "",
    orarr: "",
    ord: "",
    order: "",
    orderof: "",
    ordf: "",
    ordm: "",
    origof: "",
    oror: "",
    orslope: "",
    orv: "",
    oS: "",
    Oscr: "",
    oscr: "",
    Oslash: "",
    oslash: "",
    osol: "",
    Otilde: "",
    otilde: "",
    Otimes: "",
    otimes: "",
    otimesas: "",
    Ouml: "",
    ouml: "",
    ovbar: "",
    OverBar: "",
    OverBrace: "",
    OverBracket: "",
    OverParenthesis: "",
    par: "",
    para: "",
    parallel: "",
    parsim: "",
    parsl: "",
    part: "",
    PartialD: "",
    Pcy: "",
    pcy: "",
    percnt: "%",
    period: ".",
    permil: "",
    perp: "",
    pertenk: "",
    Pfr: "",
    pfr: "",
    Phi: "",
    phi: "",
    phiv: "",
    phmmat: "",
    phone: "",
    Pi: "",
    pi: "",
    pitchfork: "",
    piv: "",
    planck: "",
    planckh: "",
    plankv: "",
    plus: "+",
    plusacir: "",
    plusb: "",
    pluscir: "",
    plusdo: "",
    plusdu: "",
    pluse: "",
    PlusMinus: "",
    plusmn: "",
    plussim: "",
    plustwo: "",
    pm: "",
    Poincareplane: "",
    pointint: "",
    Popf: "",
    popf: "",
    pound: "",
    Pr: "",
    pr: "",
    prap: "",
    prcue: "",
    prE: "",
    pre: "",
    prec: "",
    precapprox: "",
    preccurlyeq: "",
    Precedes: "",
    PrecedesEqual: "",
    PrecedesSlantEqual: "",
    PrecedesTilde: "",
    preceq: "",
    precnapprox: "",
    precneqq: "",
    precnsim: "",
    precsim: "",
    Prime: "",
    prime: "",
    primes: "",
    prnap: "",
    prnE: "",
    prnsim: "",
    prod: "",
    Product: "",
    profalar: "",
    profline: "",
    profsurf: "",
    prop: "",
    Proportion: "",
    Proportional: "",
    propto: "",
    prsim: "",
    prurel: "",
    Pscr: "",
    pscr: "",
    Psi: "",
    psi: "",
    puncsp: "",
    Qfr: "",
    qfr: "",
    qint: "",
    Qopf: "",
    qopf: "",
    qprime: "",
    Qscr: "",
    qscr: "",
    quaternions: "",
    quatint: "",
    quest: "?",
    questeq: "",
    QUOT: '"',
    quot: '"',
    rAarr: "",
    race: "",
    Racute: "",
    racute: "",
    radic: "",
    raemptyv: "",
    Rang: "",
    rang: "",
    rangd: "",
    range: "",
    rangle: "",
    raquo: "",
    Rarr: "",
    rArr: "",
    rarr: "",
    rarrap: "",
    rarrb: "",
    rarrbfs: "",
    rarrc: "",
    rarrfs: "",
    rarrhk: "",
    rarrlp: "",
    rarrpl: "",
    rarrsim: "",
    Rarrtl: "",
    rarrtl: "",
    rarrw: "",
    rAtail: "",
    ratail: "",
    ratio: "",
    rationals: "",
    RBarr: "",
    rBarr: "",
    rbarr: "",
    rbbrk: "",
    rbrace: "}",
    rbrack: "]",
    rbrke: "",
    rbrksld: "",
    rbrkslu: "",
    Rcaron: "",
    rcaron: "",
    Rcedil: "",
    rcedil: "",
    rceil: "",
    rcub: "}",
    Rcy: "",
    rcy: "",
    rdca: "",
    rdldhar: "",
    rdquo: "",
    rdquor: "",
    rdsh: "",
    Re: "",
    real: "",
    realine: "",
    realpart: "",
    reals: "",
    rect: "",
    REG: "",
    reg: "",
    ReverseElement: "",
    ReverseEquilibrium: "",
    ReverseUpEquilibrium: "",
    rfisht: "",
    rfloor: "",
    Rfr: "",
    rfr: "",
    rHar: "",
    rhard: "",
    rharu: "",
    rharul: "",
    Rho: "",
    rho: "",
    rhov: "",
    RightAngleBracket: "",
    RightArrow: "",
    Rightarrow: "",
    rightarrow: "",
    RightArrowBar: "",
    RightArrowLeftArrow: "",
    rightarrowtail: "",
    RightCeiling: "",
    RightDoubleBracket: "",
    RightDownTeeVector: "",
    RightDownVector: "",
    RightDownVectorBar: "",
    RightFloor: "",
    rightharpoondown: "",
    rightharpoonup: "",
    rightleftarrows: "",
    rightleftharpoons: "",
    rightrightarrows: "",
    rightsquigarrow: "",
    RightTee: "",
    RightTeeArrow: "",
    RightTeeVector: "",
    rightthreetimes: "",
    RightTriangle: "",
    RightTriangleBar: "",
    RightTriangleEqual: "",
    RightUpDownVector: "",
    RightUpTeeVector: "",
    RightUpVector: "",
    RightUpVectorBar: "",
    RightVector: "",
    RightVectorBar: "",
    ring: "",
    risingdotseq: "",
    rlarr: "",
    rlhar: "",
    rlm: "",
    rmoust: "",
    rmoustache: "",
    rnmid: "",
    roang: "",
    roarr: "",
    robrk: "",
    ropar: "",
    Ropf: "",
    ropf: "",
    roplus: "",
    rotimes: "",
    RoundImplies: "",
    rpar: ")",
    rpargt: "",
    rppolint: "",
    rrarr: "",
    Rrightarrow: "",
    rsaquo: "",
    Rscr: "",
    rscr: "",
    Rsh: "",
    rsh: "",
    rsqb: "]",
    rsquo: "",
    rsquor: "",
    rthree: "",
    rtimes: "",
    rtri: "",
    rtrie: "",
    rtrif: "",
    rtriltri: "",
    RuleDelayed: "",
    ruluhar: "",
    rx: "",
    Sacute: "",
    sacute: "",
    sbquo: "",
    Sc: "",
    sc: "",
    scap: "",
    Scaron: "",
    scaron: "",
    sccue: "",
    scE: "",
    sce: "",
    Scedil: "",
    scedil: "",
    Scirc: "",
    scirc: "",
    scnap: "",
    scnE: "",
    scnsim: "",
    scpolint: "",
    scsim: "",
    Scy: "",
    scy: "",
    sdot: "",
    sdotb: "",
    sdote: "",
    searhk: "",
    seArr: "",
    searr: "",
    searrow: "",
    sect: "",
    semi: ";",
    seswar: "",
    setminus: "",
    setmn: "",
    sext: "",
    Sfr: "",
    sfr: "",
    sfrown: "",
    sharp: "",
    SHCHcy: "",
    shchcy: "",
    SHcy: "",
    shcy: "",
    ShortDownArrow: "",
    ShortLeftArrow: "",
    shortmid: "",
    shortparallel: "",
    ShortRightArrow: "",
    ShortUpArrow: "",
    shy: "",
    Sigma: "",
    sigma: "",
    sigmaf: "",
    sigmav: "",
    sim: "",
    simdot: "",
    sime: "",
    simeq: "",
    simg: "",
    simgE: "",
    siml: "",
    simlE: "",
    simne: "",
    simplus: "",
    simrarr: "",
    slarr: "",
    SmallCircle: "",
    smallsetminus: "",
    smashp: "",
    smeparsl: "",
    smid: "",
    smile: "",
    smt: "",
    smte: "",
    smtes: "",
    SOFTcy: "",
    softcy: "",
    sol: "/",
    solb: "",
    solbar: "",
    Sopf: "",
    sopf: "",
    spades: "",
    spadesuit: "",
    spar: "",
    sqcap: "",
    sqcaps: "",
    sqcup: "",
    sqcups: "",
    Sqrt: "",
    sqsub: "",
    sqsube: "",
    sqsubset: "",
    sqsubseteq: "",
    sqsup: "",
    sqsupe: "",
    sqsupset: "",
    sqsupseteq: "",
    squ: "",
    Square: "",
    square: "",
    SquareIntersection: "",
    SquareSubset: "",
    SquareSubsetEqual: "",
    SquareSuperset: "",
    SquareSupersetEqual: "",
    SquareUnion: "",
    squarf: "",
    squf: "",
    srarr: "",
    Sscr: "",
    sscr: "",
    ssetmn: "",
    ssmile: "",
    sstarf: "",
    Star: "",
    star: "",
    starf: "",
    straightepsilon: "",
    straightphi: "",
    strns: "",
    Sub: "",
    sub: "",
    subdot: "",
    subE: "",
    sube: "",
    subedot: "",
    submult: "",
    subnE: "",
    subne: "",
    subplus: "",
    subrarr: "",
    Subset: "",
    subset: "",
    subseteq: "",
    subseteqq: "",
    SubsetEqual: "",
    subsetneq: "",
    subsetneqq: "",
    subsim: "",
    subsub: "",
    subsup: "",
    succ: "",
    succapprox: "",
    succcurlyeq: "",
    Succeeds: "",
    SucceedsEqual: "",
    SucceedsSlantEqual: "",
    SucceedsTilde: "",
    succeq: "",
    succnapprox: "",
    succneqq: "",
    succnsim: "",
    succsim: "",
    SuchThat: "",
    Sum: "",
    sum: "",
    sung: "",
    Sup: "",
    sup: "",
    sup1: "",
    sup2: "",
    sup3: "",
    supdot: "",
    supdsub: "",
    supE: "",
    supe: "",
    supedot: "",
    Superset: "",
    SupersetEqual: "",
    suphsol: "",
    suphsub: "",
    suplarr: "",
    supmult: "",
    supnE: "",
    supne: "",
    supplus: "",
    Supset: "",
    supset: "",
    supseteq: "",
    supseteqq: "",
    supsetneq: "",
    supsetneqq: "",
    supsim: "",
    supsub: "",
    supsup: "",
    swarhk: "",
    swArr: "",
    swarr: "",
    swarrow: "",
    swnwar: "",
    szlig: "",
    Tab: "	",
    target: "",
    Tau: "",
    tau: "",
    tbrk: "",
    Tcaron: "",
    tcaron: "",
    Tcedil: "",
    tcedil: "",
    Tcy: "",
    tcy: "",
    tdot: "",
    telrec: "",
    Tfr: "",
    tfr: "",
    there4: "",
    Therefore: "",
    therefore: "",
    Theta: "",
    theta: "",
    thetasym: "",
    thetav: "",
    thickapprox: "",
    thicksim: "",
    ThickSpace: "",
    thinsp: "",
    ThinSpace: "",
    thkap: "",
    thksim: "",
    THORN: "",
    thorn: "",
    Tilde: "",
    tilde: "",
    TildeEqual: "",
    TildeFullEqual: "",
    TildeTilde: "",
    times: "",
    timesb: "",
    timesbar: "",
    timesd: "",
    tint: "",
    toea: "",
    top: "",
    topbot: "",
    topcir: "",
    Topf: "",
    topf: "",
    topfork: "",
    tosa: "",
    tprime: "",
    TRADE: "",
    trade: "",
    triangle: "",
    triangledown: "",
    triangleleft: "",
    trianglelefteq: "",
    triangleq: "",
    triangleright: "",
    trianglerighteq: "",
    tridot: "",
    trie: "",
    triminus: "",
    TripleDot: "",
    triplus: "",
    trisb: "",
    tritime: "",
    trpezium: "",
    Tscr: "",
    tscr: "",
    TScy: "",
    tscy: "",
    TSHcy: "",
    tshcy: "",
    Tstrok: "",
    tstrok: "",
    twixt: "",
    twoheadleftarrow: "",
    twoheadrightarrow: "",
    Uacute: "",
    uacute: "",
    Uarr: "",
    uArr: "",
    uarr: "",
    Uarrocir: "",
    Ubrcy: "",
    ubrcy: "",
    Ubreve: "",
    ubreve: "",
    Ucirc: "",
    ucirc: "",
    Ucy: "",
    ucy: "",
    udarr: "",
    Udblac: "",
    udblac: "",
    udhar: "",
    ufisht: "",
    Ufr: "",
    ufr: "",
    Ugrave: "",
    ugrave: "",
    uHar: "",
    uharl: "",
    uharr: "",
    uhblk: "",
    ulcorn: "",
    ulcorner: "",
    ulcrop: "",
    ultri: "",
    Umacr: "",
    umacr: "",
    uml: "",
    UnderBar: "_",
    UnderBrace: "",
    UnderBracket: "",
    UnderParenthesis: "",
    Union: "",
    UnionPlus: "",
    Uogon: "",
    uogon: "",
    Uopf: "",
    uopf: "",
    UpArrow: "",
    Uparrow: "",
    uparrow: "",
    UpArrowBar: "",
    UpArrowDownArrow: "",
    UpDownArrow: "",
    Updownarrow: "",
    updownarrow: "",
    UpEquilibrium: "",
    upharpoonleft: "",
    upharpoonright: "",
    uplus: "",
    UpperLeftArrow: "",
    UpperRightArrow: "",
    Upsi: "",
    upsi: "",
    upsih: "",
    Upsilon: "",
    upsilon: "",
    UpTee: "",
    UpTeeArrow: "",
    upuparrows: "",
    urcorn: "",
    urcorner: "",
    urcrop: "",
    Uring: "",
    uring: "",
    urtri: "",
    Uscr: "",
    uscr: "",
    utdot: "",
    Utilde: "",
    utilde: "",
    utri: "",
    utrif: "",
    uuarr: "",
    Uuml: "",
    uuml: "",
    uwangle: "",
    vangrt: "",
    varepsilon: "",
    varkappa: "",
    varnothing: "",
    varphi: "",
    varpi: "",
    varpropto: "",
    vArr: "",
    varr: "",
    varrho: "",
    varsigma: "",
    varsubsetneq: "",
    varsubsetneqq: "",
    varsupsetneq: "",
    varsupsetneqq: "",
    vartheta: "",
    vartriangleleft: "",
    vartriangleright: "",
    Vbar: "",
    vBar: "",
    vBarv: "",
    Vcy: "",
    vcy: "",
    VDash: "",
    Vdash: "",
    vDash: "",
    vdash: "",
    Vdashl: "",
    Vee: "",
    vee: "",
    veebar: "",
    veeeq: "",
    vellip: "",
    Verbar: "",
    verbar: "|",
    Vert: "",
    vert: "|",
    VerticalBar: "",
    VerticalLine: "|",
    VerticalSeparator: "",
    VerticalTilde: "",
    VeryThinSpace: "",
    Vfr: "",
    vfr: "",
    vltri: "",
    vnsub: "",
    vnsup: "",
    Vopf: "",
    vopf: "",
    vprop: "",
    vrtri: "",
    Vscr: "",
    vscr: "",
    vsubnE: "",
    vsubne: "",
    vsupnE: "",
    vsupne: "",
    Vvdash: "",
    vzigzag: "",
    Wcirc: "",
    wcirc: "",
    wedbar: "",
    Wedge: "",
    wedge: "",
    wedgeq: "",
    weierp: "",
    Wfr: "",
    wfr: "",
    Wopf: "",
    wopf: "",
    wp: "",
    wr: "",
    wreath: "",
    Wscr: "",
    wscr: "",
    xcap: "",
    xcirc: "",
    xcup: "",
    xdtri: "",
    Xfr: "",
    xfr: "",
    xhArr: "",
    xharr: "",
    Xi: "",
    xi: "",
    xlArr: "",
    xlarr: "",
    xmap: "",
    xnis: "",
    xodot: "",
    Xopf: "",
    xopf: "",
    xoplus: "",
    xotime: "",
    xrArr: "",
    xrarr: "",
    Xscr: "",
    xscr: "",
    xsqcup: "",
    xuplus: "",
    xutri: "",
    xvee: "",
    xwedge: "",
    Yacute: "",
    yacute: "",
    YAcy: "",
    yacy: "",
    Ycirc: "",
    ycirc: "",
    Ycy: "",
    ycy: "",
    yen: "",
    Yfr: "",
    yfr: "",
    YIcy: "",
    yicy: "",
    Yopf: "",
    yopf: "",
    Yscr: "",
    yscr: "",
    YUcy: "",
    yucy: "",
    Yuml: "",
    yuml: "",
    Zacute: "",
    zacute: "",
    Zcaron: "",
    zcaron: "",
    Zcy: "",
    zcy: "",
    Zdot: "",
    zdot: "",
    zeetrf: "",
    ZeroWidthSpace: "",
    Zeta: "",
    zeta: "",
    Zfr: "",
    zfr: "",
    ZHcy: "",
    zhcy: "",
    zigrarr: "",
    Zopf: "",
    zopf: "",
    Zscr: "",
    zscr: "",
    zwj: "",
    zwnj: ""
  }), e.entityMap = e.HTML_ENTITIES;
})(r_);
var vp = {}, dl = Zn.NAMESPACE, $d = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, pm = new RegExp("[\\-\\.0-9" + $d.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), vm = new RegExp("^" + $d.source + pm.source + "*(?::" + $d.source + pm.source + "*)?$"), Yo = 0, sa = 1, Es = 2, Qo = 3, ws = 4, Ss = 5, Ko = 6, Hl = 7;
function wo(e, t) {
  this.message = e, this.locator = t, Error.captureStackTrace && Error.captureStackTrace(this, wo);
}
wo.prototype = new Error();
wo.prototype.name = wo.name;
function n_() {
}
n_.prototype = {
  parse: function(e, t, i) {
    var n = this.domBuilder;
    n.startDocument(), a_(t, t = {}), TS(
      e,
      t,
      i,
      n,
      this.errorHandler
    ), n.endDocument();
  }
};
function TS(e, t, i, n, r) {
  function a(de) {
    if (de > 65535) {
      de -= 65536;
      var G = 55296 + (de >> 10), j = 56320 + (de & 1023);
      return String.fromCharCode(G, j);
    } else
      return String.fromCharCode(de);
  }
  function s(de) {
    var G = de.slice(1, -1);
    return Object.hasOwnProperty.call(i, G) ? i[G] : G.charAt(0) === "#" ? a(parseInt(G.substr(1).replace("x", "0x"))) : (r.error("entity not found:" + de), de);
  }
  function o(de) {
    if (de > _) {
      var G = e.substring(_, de).replace(/&#?\w+;/g, s);
      d && u(_), n.characters(G, 0, de - _), _ = de;
    }
  }
  function u(de, G) {
    for (; de >= c && (G = h.exec(e)); )
      l = G.index, c = l + G[0].length, d.lineNumber++;
    d.columnNumber = de - l + 1;
  }
  for (var l = 0, c = 0, h = /.*(?:\r\n?|\n)|.*$/g, d = n.locator, f = [{ currentNSMap: t }], p = {}, _ = 0; ; ) {
    try {
      var m = e.indexOf("<", _);
      if (m < 0) {
        if (!e.substr(_).match(/^\s*$/)) {
          var x = n.doc, E = x.createTextNode(e.substr(_));
          x.appendChild(E), n.currentElement = E;
        }
        return;
      }
      switch (m > _ && o(m), e.charAt(m + 1)) {
        case "/":
          var Q = e.indexOf(">", m + 3), M = e.substring(m + 2, Q).replace(/[ \t\n\r]+$/g, ""), C = f.pop();
          Q < 0 ? (M = e.substring(m + 2).replace(/[\s<].*/, ""), r.error("end tag name: " + M + " is not complete:" + C.tagName), Q = m + 1 + M.length) : M.match(/\s</) && (M = M.replace(/[\s<].*/, ""), r.error("end tag name: " + M + " maybe not complete"), Q = m + 1 + M.length);
          var R = C.localNSMap, k = C.tagName == M, F = k || C.tagName && C.tagName.toLowerCase() == M.toLowerCase();
          if (F) {
            if (n.endElement(C.uri, C.localName, M), R)
              for (var B in R)
                Object.prototype.hasOwnProperty.call(R, B) && n.endPrefixMapping(B);
            k || r.fatalError("end tag name: " + M + " is not match the current start tagName:" + C.tagName);
          } else
            f.push(C);
          Q++;
          break;
        case "?":
          d && u(m), Q = MS(e, m, n);
          break;
        case "!":
          d && u(m), Q = CS(e, m, n, r);
          break;
        default:
          d && u(m);
          var I = new s_(), V = f[f.length - 1].currentNSMap, Q = ES(e, m, I, V, s, r), ee = I.length;
          if (!I.closed && SS(e, Q, I.tagName, p) && (I.closed = !0, i.nbsp || r.warning("unclosed xml attribute")), d && ee) {
            for (var oe = mm(d, {}), fe = 0; fe < ee; fe++) {
              var he = I[fe];
              u(he.offset), he.locator = mm(d, {});
            }
            n.locator = oe, gm(I, n, V) && f.push(I), n.locator = d;
          } else
            gm(I, n, V) && f.push(I);
          dl.isHTML(I.uri) && !I.closed ? Q = wS(e, Q, I.tagName, s, n) : Q++;
      }
    } catch (de) {
      if (de instanceof wo)
        throw de;
      r.error("element parse error: " + de), Q = -1;
    }
    Q > _ ? _ = Q : o(Math.max(m, _) + 1);
  }
}
function mm(e, t) {
  return t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber, t;
}
function ES(e, t, i, n, r, a) {
  function s(d, f, p) {
    i.attributeNames.hasOwnProperty(d) && a.fatalError("Attribute " + d + " redefined"), i.addValue(
      d,
      // @see https://www.w3.org/TR/xml/#AVNormalize
      // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
      // - recursive replacement of (DTD) entity references
      // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
      f.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, r),
      p
    );
  }
  for (var o, u, l = ++t, c = Yo; ; ) {
    var h = e.charAt(l);
    switch (h) {
      case "=":
        if (c === sa)
          o = e.slice(t, l), c = Qo;
        else if (c === Es)
          c = Qo;
        else
          throw new Error("attribute equal must after attrName");
        break;
      case "'":
      case '"':
        if (c === Qo || c === sa)
          if (c === sa && (a.warning('attribute value must after "="'), o = e.slice(t, l)), t = l + 1, l = e.indexOf(h, t), l > 0)
            u = e.slice(t, l), s(o, u, t - 1), c = Ss;
          else
            throw new Error("attribute value no end '" + h + "' match");
        else if (c == ws)
          u = e.slice(t, l), s(o, u, t), a.warning('attribute "' + o + '" missed start quot(' + h + ")!!"), t = l + 1, c = Ss;
        else
          throw new Error('attribute value must after "="');
        break;
      case "/":
        switch (c) {
          case Yo:
            i.setTagName(e.slice(t, l));
          case Ss:
          case Ko:
          case Hl:
            c = Hl, i.closed = !0;
          case ws:
          case sa:
            break;
          case Es:
            i.closed = !0;
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        return a.error("unexpected end of input"), c == Yo && i.setTagName(e.slice(t, l)), l;
      case ">":
        switch (c) {
          case Yo:
            i.setTagName(e.slice(t, l));
          case Ss:
          case Ko:
          case Hl:
            break;
          case ws:
          case sa:
            u = e.slice(t, l), u.slice(-1) === "/" && (i.closed = !0, u = u.slice(0, -1));
          case Es:
            c === Es && (u = o), c == ws ? (a.warning('attribute "' + u + '" missed quot(")!'), s(o, u, t)) : ((!dl.isHTML(n[""]) || !u.match(/^(?:disabled|checked|selected)$/i)) && a.warning('attribute "' + u + '" missed value!! "' + u + '" instead!!'), s(u, u, t));
            break;
          case Qo:
            throw new Error("attribute value missed!!");
        }
        return l;
      case "":
        h = " ";
      default:
        if (h <= " ")
          switch (c) {
            case Yo:
              i.setTagName(e.slice(t, l)), c = Ko;
              break;
            case sa:
              o = e.slice(t, l), c = Es;
              break;
            case ws:
              var u = e.slice(t, l);
              a.warning('attribute "' + u + '" missed quot(")!!'), s(o, u, t);
            case Ss:
              c = Ko;
              break;
          }
        else
          switch (c) {
            case Es:
              i.tagName, (!dl.isHTML(n[""]) || !o.match(/^(?:disabled|checked|selected)$/i)) && a.warning('attribute "' + o + '" missed value!! "' + o + '" instead2!!'), s(o, o, t), t = l, c = sa;
              break;
            case Ss:
              a.warning('attribute space is required"' + o + '"!!');
            case Ko:
              c = sa, t = l;
              break;
            case Qo:
              c = ws, t = l;
              break;
            case Hl:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
    }
    l++;
  }
}
function gm(e, t, i) {
  for (var n = e.tagName, r = null, h = e.length; h--; ) {
    var a = e[h], s = a.qName, o = a.value, d = s.indexOf(":");
    if (d > 0)
      var u = a.prefix = s.slice(0, d), l = s.slice(d + 1), c = u === "xmlns" && l;
    else
      l = s, u = null, c = s === "xmlns" && "";
    a.localName = l, c !== !1 && (r == null && (r = {}, a_(i, i = {})), i[c] = r[c] = o, a.uri = dl.XMLNS, t.startPrefixMapping(c, o));
  }
  for (var h = e.length; h--; ) {
    a = e[h];
    var u = a.prefix;
    u && (u === "xml" && (a.uri = dl.XML), u !== "xmlns" && (a.uri = i[u || ""]));
  }
  var d = n.indexOf(":");
  d > 0 ? (u = e.prefix = n.slice(0, d), l = e.localName = n.slice(d + 1)) : (u = null, l = e.localName = n);
  var f = e.uri = i[u || ""];
  if (t.startElement(f, l, n, e), e.closed) {
    if (t.endElement(f, l, n), r)
      for (u in r)
        Object.prototype.hasOwnProperty.call(r, u) && t.endPrefixMapping(u);
  } else
    return e.currentNSMap = i, e.localNSMap = r, !0;
}
function wS(e, t, i, n, r) {
  if (/^(?:script|textarea)$/i.test(i)) {
    var a = e.indexOf("</" + i + ">", t), s = e.substring(t + 1, a);
    if (/[&<]/.test(s))
      return /^script$/i.test(i) ? (r.characters(s, 0, s.length), a) : (s = s.replace(/&#?\w+;/g, n), r.characters(s, 0, s.length), a);
  }
  return t + 1;
}
function SS(e, t, i, n) {
  var r = n[i];
  return r == null && (r = e.lastIndexOf("</" + i + ">"), r < t && (r = e.lastIndexOf("</" + i)), n[i] = r), r < t;
}
function a_(e, t) {
  for (var i in e)
    Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
}
function CS(e, t, i, n) {
  var r = e.charAt(t + 2);
  switch (r) {
    case "-":
      if (e.charAt(t + 3) === "-") {
        var a = e.indexOf("-->", t + 4);
        return a > t ? (i.comment(e, t + 4, a - t - 4), a + 3) : (n.error("Unclosed comment"), -1);
      } else
        return -1;
    default:
      if (e.substr(t + 3, 6) == "CDATA[") {
        var a = e.indexOf("]]>", t + 9);
        return i.startCDATA(), i.characters(e, t + 9, a - t - 9), i.endCDATA(), a + 3;
      }
      var s = DS(e, t), o = s.length;
      if (o > 1 && /!doctype/i.test(s[0][0])) {
        var u = s[1][0], l = !1, c = !1;
        o > 3 && (/^public$/i.test(s[2][0]) ? (l = s[3][0], c = o > 4 && s[4][0]) : /^system$/i.test(s[2][0]) && (c = s[3][0]));
        var h = s[o - 1];
        return i.startDTD(u, l, c), i.endDTD(), h.index + h[0].length;
      }
  }
  return -1;
}
function MS(e, t, i) {
  var n = e.indexOf("?>", t);
  if (n) {
    var r = e.substring(t, n).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    return r ? (r[0].length, i.processingInstruction(r[1], r[2]), n + 2) : -1;
  }
  return -1;
}
function s_() {
  this.attributeNames = {};
}
s_.prototype = {
  setTagName: function(e) {
    if (!vm.test(e))
      throw new Error("invalid tagName:" + e);
    this.tagName = e;
  },
  addValue: function(e, t, i) {
    if (!vm.test(e))
      throw new Error("invalid attribute:" + e);
    this.attributeNames[e] = this.length, this[this.length++] = { qName: e, value: t, offset: i };
  },
  length: 0,
  getLocalName: function(e) {
    return this[e].localName;
  },
  getLocator: function(e) {
    return this[e].locator;
  },
  getQName: function(e) {
    return this[e].qName;
  },
  getURI: function(e) {
    return this[e].uri;
  },
  getValue: function(e) {
    return this[e].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};
function DS(e, t) {
  var i, n = [], r = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  for (r.lastIndex = t, r.exec(e); i = r.exec(e); )
    if (n.push(i), i[1]) return n;
}
vp.XMLReader = n_;
vp.ParseError = wo;
var PS = Zn, LS = ya, ym = r_, o_ = vp, RS = LS.DOMImplementation, _m = PS.NAMESPACE, IS = o_.ParseError, OS = o_.XMLReader;
function u_(e) {
  return e.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
}
function l_(e) {
  this.options = e || { locator: {} };
}
l_.prototype.parseFromString = function(e, t) {
  var i = this.options, n = new OS(), r = i.domBuilder || new Cl(), a = i.errorHandler, s = i.locator, o = i.xmlns || {}, u = /\/x?html?$/.test(t), l = u ? ym.HTML_ENTITIES : ym.XML_ENTITIES;
  s && r.setDocumentLocator(s), n.errorHandler = kS(a, r, s), n.domBuilder = i.domBuilder || r, u && (o[""] = _m.HTML), o.xml = o.xml || _m.XML;
  var c = i.normalizeLineEndings || u_;
  return e && typeof e == "string" ? n.parse(
    c(e),
    o,
    l
  ) : n.errorHandler.error("invalid doc source"), r.doc;
};
function kS(e, t, i) {
  if (!e) {
    if (t instanceof Cl)
      return t;
    e = t;
  }
  var n = {}, r = e instanceof Function;
  i = i || {};
  function a(s) {
    var o = e[s];
    !o && r && (o = e.length == 2 ? function(u) {
      e(s, u);
    } : e), n[s] = o && function(u) {
      o("[xmldom " + s + "]	" + u + ef(i));
    } || function() {
    };
  }
  return a("warning"), a("error"), a("fatalError"), n;
}
function Cl() {
  this.cdata = !1;
}
function Cs(e, t) {
  t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber;
}
Cl.prototype = {
  startDocument: function() {
    this.doc = new RS().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
  },
  startElement: function(e, t, i, n) {
    var r = this.doc, a = r.createElementNS(e, i || t), s = n.length;
    zl(this, a), this.currentElement = a, this.locator && Cs(this.locator, a);
    for (var o = 0; o < s; o++) {
      var e = n.getURI(o), u = n.getValue(o), i = n.getQName(o), l = r.createAttributeNS(e, i);
      this.locator && Cs(n.getLocator(o), l), l.value = l.nodeValue = u, a.setAttributeNode(l);
    }
  },
  endElement: function(e, t, i) {
    var n = this.currentElement;
    n.tagName, this.currentElement = n.parentNode;
  },
  startPrefixMapping: function(e, t) {
  },
  endPrefixMapping: function(e) {
  },
  processingInstruction: function(e, t) {
    var i = this.doc.createProcessingInstruction(e, t);
    this.locator && Cs(this.locator, i), zl(this, i);
  },
  ignorableWhitespace: function(e, t, i) {
  },
  characters: function(e, t, i) {
    if (e = bm.apply(this, arguments), e) {
      if (this.cdata)
        var n = this.doc.createCDATASection(e);
      else
        var n = this.doc.createTextNode(e);
      this.currentElement ? this.currentElement.appendChild(n) : /^\s*$/.test(e) && this.doc.appendChild(n), this.locator && Cs(this.locator, n);
    }
  },
  skippedEntity: function(e) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(e) {
    (this.locator = e) && (e.lineNumber = 0);
  },
  //LexicalHandler
  comment: function(e, t, i) {
    e = bm.apply(this, arguments);
    var n = this.doc.createComment(e);
    this.locator && Cs(this.locator, n), zl(this, n);
  },
  startCDATA: function() {
    this.cdata = !0;
  },
  endCDATA: function() {
    this.cdata = !1;
  },
  startDTD: function(e, t, i) {
    var n = this.doc.implementation;
    if (n && n.createDocumentType) {
      var r = n.createDocumentType(e, t, i);
      this.locator && Cs(this.locator, r), zl(this, r), this.doc.doctype = r;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function(e) {
    console.warn("[xmldom warning]	" + e, ef(this.locator));
  },
  error: function(e) {
    console.error("[xmldom error]	" + e, ef(this.locator));
  },
  fatalError: function(e) {
    throw new IS(e, this.locator);
  }
};
function ef(e) {
  if (e)
    return `
@` + (e.systemId || "") + "#[line:" + e.lineNumber + ",col:" + e.columnNumber + "]";
}
function bm(e, t, i) {
  return typeof e == "string" ? e.substr(t, i) : e.length >= t + i || t ? new java.lang.String(e, t, i) + "" : e;
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(e) {
  Cl.prototype[e] = function() {
    return null;
  };
});
function zl(e, t) {
  e.currentElement ? e.currentElement.appendChild(t) : e.doc.appendChild(t);
}
Th.__DOMHandler = Cl;
Th.normalizeLineEndings = u_;
Th.DOMParser = l_;
var BS = Th.DOMParser;
/*! @name mpd-parser @version 0.22.1 @license Apache-2.0 */
var xm = function(t) {
  return !!t && typeof t == "object";
}, er = function e() {
  for (var t = arguments.length, i = new Array(t), n = 0; n < t; n++)
    i[n] = arguments[n];
  return i.reduce(function(r, a) {
    return typeof a != "object" || Object.keys(a).forEach(function(s) {
      Array.isArray(r[s]) && Array.isArray(a[s]) ? r[s] = r[s].concat(a[s]) : xm(r[s]) && xm(a[s]) ? r[s] = e(r[s], a[s]) : r[s] = a[s];
    }), r;
  }, {});
}, c_ = function(t) {
  return Object.keys(t).map(function(i) {
    return t[i];
  });
}, FS = function(t, i) {
  for (var n = [], r = t; r < i; r++)
    n.push(r);
  return n;
}, Eh = function(t) {
  return t.reduce(function(i, n) {
    return i.concat(n);
  }, []);
}, h_ = function(t) {
  if (!t.length)
    return [];
  for (var i = [], n = 0; n < t.length; n++)
    i.push(t[n]);
  return i;
}, NS = function(t, i) {
  return t.reduce(function(n, r, a) {
    return r[i] && n.push(a), n;
  }, []);
}, tf = function(t, i) {
  for (var n = 0; n < t.length; n++)
    if (i(t[n]))
      return n;
  return -1;
}, US = function(t, i) {
  return c_(t.reduce(function(n, r) {
    return r.forEach(function(a) {
      n[i(a)] = a;
    }), n;
  }, {}));
}, So = {
  INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
  DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
  DASH_INVALID_XML: "DASH_INVALID_XML",
  NO_BASE_URL: "NO_BASE_URL",
  MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
  SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
  UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
}, fl = function(t) {
  var i = t.baseUrl, n = i === void 0 ? "" : i, r = t.source, a = r === void 0 ? "" : r, s = t.range, o = s === void 0 ? "" : s, u = t.indexRange, l = u === void 0 ? "" : u, c = {
    uri: a,
    resolvedUri: bh(n || "", a)
  };
  if (o || l) {
    var h = o || l, d = h.split("-"), f = W.BigInt ? W.BigInt(d[0]) : parseInt(d[0], 10), p = W.BigInt ? W.BigInt(d[1]) : parseInt(d[1], 10);
    f < Number.MAX_SAFE_INTEGER && typeof f == "bigint" && (f = Number(f)), p < Number.MAX_SAFE_INTEGER && typeof p == "bigint" && (p = Number(p));
    var _;
    typeof p == "bigint" || typeof f == "bigint" ? _ = W.BigInt(p) - W.BigInt(f) + W.BigInt(1) : _ = p - f + 1, typeof _ == "bigint" && _ < Number.MAX_SAFE_INTEGER && (_ = Number(_)), c.byterange = {
      length: _,
      offset: f
    };
  }
  return c;
}, jS = function(t) {
  var i;
  return typeof t.offset == "bigint" || typeof t.length == "bigint" ? i = W.BigInt(t.offset) + W.BigInt(t.length) - W.BigInt(1) : i = t.offset + t.length - 1, t.offset + "-" + i;
}, Am = function(t) {
  return t && typeof t != "number" && (t = parseInt(t, 10)), isNaN(t) ? null : t;
}, GS = {
  /**
   * Returns the entire range of available segments for a static MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  static: function(t) {
    var i = t.duration, n = t.timescale, r = n === void 0 ? 1 : n, a = t.sourceDuration, s = t.periodDuration, o = Am(t.endNumber), u = i / r;
    return typeof o == "number" ? {
      start: 0,
      end: o
    } : typeof s == "number" ? {
      start: 0,
      end: s / u
    } : {
      start: 0,
      end: a / u
    };
  },
  /**
   * Returns the current live window range of available segments for a dynamic MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  dynamic: function(t) {
    var i = t.NOW, n = t.clientOffset, r = t.availabilityStartTime, a = t.timescale, s = a === void 0 ? 1 : a, o = t.duration, u = t.periodStart, l = u === void 0 ? 0 : u, c = t.minimumUpdatePeriod, h = c === void 0 ? 0 : c, d = t.timeShiftBufferDepth, f = d === void 0 ? 1 / 0 : d, p = Am(t.endNumber), _ = (i + n) / 1e3, m = r + l, x = _ + h, E = x - m, M = Math.ceil(E * s / o), C = Math.floor((_ - m - f) * s / o), R = Math.floor((_ - m) * s / o);
    return {
      start: Math.max(0, C),
      end: typeof p == "number" ? p : Math.min(M, R)
    };
  }
}, VS = function(t) {
  return function(i) {
    var n = t.duration, r = t.timescale, a = r === void 0 ? 1 : r, s = t.periodStart, o = t.startNumber, u = o === void 0 ? 1 : o;
    return {
      number: u + i,
      duration: n / a,
      timeline: s,
      time: i * n
    };
  };
}, mp = function(t) {
  var i = t.type, n = t.duration, r = t.timescale, a = r === void 0 ? 1 : r, s = t.periodDuration, o = t.sourceDuration, u = GS[i](t), l = u.start, c = u.end, h = FS(l, c).map(VS(t));
  if (i === "static") {
    var d = h.length - 1, f = typeof s == "number" ? s : o;
    h[d].duration = f - n / a * d;
  }
  return h;
}, d_ = function(t) {
  var i = t.baseUrl, n = t.initialization, r = n === void 0 ? {} : n, a = t.sourceDuration, s = t.indexRange, o = s === void 0 ? "" : s, u = t.periodStart, l = t.presentationTime, c = t.number, h = c === void 0 ? 0 : c, d = t.duration;
  if (!i)
    throw new Error(So.NO_BASE_URL);
  var f = fl({
    baseUrl: i,
    source: r.sourceURL,
    range: r.range
  }), p = fl({
    baseUrl: i,
    source: i,
    indexRange: o
  });
  if (p.map = f, d) {
    var _ = mp(t);
    _.length && (p.duration = _[0].duration, p.timeline = _[0].timeline);
  } else a && (p.duration = a, p.timeline = u);
  return p.presentationTime = l || u, p.number = h, [p];
}, gp = function(t, i, n) {
  var r = t.sidx.map ? t.sidx.map : null, a = t.sidx.duration, s = t.timeline || 0, o = t.sidx.byterange, u = o.offset + o.length, l = i.timescale, c = i.references.filter(function(I) {
    return I.referenceType !== 1;
  }), h = [], d = t.endList ? "static" : "dynamic", f = t.sidx.timeline, p = f, _ = t.mediaSequence || 0, m;
  typeof i.firstOffset == "bigint" ? m = W.BigInt(u) + i.firstOffset : m = u + i.firstOffset;
  for (var x = 0; x < c.length; x++) {
    var E = i.references[x], M = E.referencedSize, C = E.subsegmentDuration, R = void 0;
    typeof m == "bigint" ? R = m + W.BigInt(M) - W.BigInt(1) : R = m + M - 1;
    var k = m + "-" + R, F = {
      baseUrl: n,
      timescale: l,
      timeline: s,
      periodStart: f,
      presentationTime: p,
      number: _,
      duration: C,
      sourceDuration: a,
      indexRange: k,
      type: d
    }, B = d_(F)[0];
    r && (B.map = r), h.push(B), typeof m == "bigint" ? m += W.BigInt(M) : m += M, p += C / l, _++;
  }
  return t.segments = h, t;
}, HS = ["AUDIO", "SUBTITLES"], zS = 1 / 60, f_ = function(t) {
  return US(t, function(i) {
    var n = i.timeline;
    return n;
  }).sort(function(i, n) {
    return i.timeline > n.timeline ? 1 : -1;
  });
}, WS = function(t, i) {
  for (var n = 0; n < t.length; n++)
    if (t[n].attributes.NAME === i)
      return t[n];
  return null;
}, Tm = function(t) {
  var i = [];
  return uS(t, HS, function(n, r, a, s) {
    i = i.concat(n.playlists || []);
  }), i;
}, Em = function(t) {
  var i = t.playlist, n = t.mediaSequence;
  i.mediaSequence = n, i.segments.forEach(function(r, a) {
    r.number = i.mediaSequence + a;
  });
}, qS = function(t) {
  var i = t.oldPlaylists, n = t.newPlaylists, r = t.timelineStarts;
  n.forEach(function(a) {
    a.discontinuitySequence = tf(r, function(c) {
      var h = c.timeline;
      return h === a.timeline;
    });
    var s = WS(i, a.attributes.NAME);
    if (s && !a.sidx) {
      var o = a.segments[0], u = tf(s.segments, function(c) {
        return Math.abs(c.presentationTime - o.presentationTime) < zS;
      });
      if (u === -1) {
        Em({
          playlist: a,
          mediaSequence: s.mediaSequence + s.segments.length
        }), a.segments[0].discontinuity = !0, a.discontinuityStarts.unshift(0), (!s.segments.length && a.timeline > s.timeline || s.segments.length && a.timeline > s.segments[s.segments.length - 1].timeline) && a.discontinuitySequence--;
        return;
      }
      var l = s.segments[u];
      l.discontinuity && !o.discontinuity && (o.discontinuity = !0, a.discontinuityStarts.unshift(0), a.discontinuitySequence--), Em({
        playlist: a,
        mediaSequence: s.segments[u].number
      });
    }
  });
}, XS = function(t) {
  var i = t.oldManifest, n = t.newManifest, r = i.playlists.concat(Tm(i)), a = n.playlists.concat(Tm(n));
  return n.timelineStarts = f_([i.timelineStarts, n.timelineStarts]), qS({
    oldPlaylists: r,
    newPlaylists: a,
    timelineStarts: n.timelineStarts
  }), n;
}, wh = function(t) {
  return t && t.uri + "-" + jS(t.byterange);
}, nd = function(t) {
  var i = c_(t.reduce(function(n, r) {
    var a = r.attributes.id + (r.attributes.lang || "");
    if (!n[a])
      n[a] = r, n[a].attributes.timelineStarts = [];
    else {
      if (r.segments) {
        var s;
        r.segments[0] && (r.segments[0].discontinuity = !0), (s = n[a].segments).push.apply(s, r.segments);
      }
      r.attributes.contentProtection && (n[a].attributes.contentProtection = r.attributes.contentProtection);
    }
    return n[a].attributes.timelineStarts.push({
      // Although they represent the same number, it's important to have both to make it
      // compatible with HLS potentially having a similar attribute.
      start: r.attributes.periodStart,
      timeline: r.attributes.periodStart
    }), n;
  }, {}));
  return i.map(function(n) {
    return n.discontinuityStarts = NS(n.segments || [], "discontinuity"), n;
  });
}, yp = function(t, i) {
  var n = wh(t.sidx), r = n && i[n] && i[n].sidx;
  return r && gp(t, r, t.sidx.resolvedUri), t;
}, YS = function(t, i) {
  if (i === void 0 && (i = {}), !Object.keys(i).length)
    return t;
  for (var n in t)
    t[n] = yp(t[n], i);
  return t;
}, QS = function(t, i) {
  var n, r = t.attributes, a = t.segments, s = t.sidx, o = t.mediaSequence, u = t.discontinuitySequence, l = t.discontinuityStarts, c = {
    attributes: (n = {
      NAME: r.id,
      BANDWIDTH: r.bandwidth,
      CODECS: r.codecs
    }, n["PROGRAM-ID"] = 1, n),
    uri: "",
    endList: r.type === "static",
    timeline: r.periodStart,
    resolvedUri: "",
    targetDuration: r.duration,
    discontinuitySequence: u,
    discontinuityStarts: l,
    timelineStarts: r.timelineStarts,
    mediaSequence: o,
    segments: a
  };
  return r.contentProtection && (c.contentProtection = r.contentProtection), s && (c.sidx = s), i && (c.attributes.AUDIO = "audio", c.attributes.SUBTITLES = "subs"), c;
}, KS = function(t) {
  var i, n = t.attributes, r = t.segments, a = t.mediaSequence, s = t.discontinuityStarts, o = t.discontinuitySequence;
  typeof r > "u" && (r = [{
    uri: n.baseUrl,
    timeline: n.periodStart,
    resolvedUri: n.baseUrl || "",
    duration: n.sourceDuration,
    number: 0
  }], n.duration = n.sourceDuration);
  var u = (i = {
    NAME: n.id,
    BANDWIDTH: n.bandwidth
  }, i["PROGRAM-ID"] = 1, i);
  return n.codecs && (u.CODECS = n.codecs), {
    attributes: u,
    uri: "",
    endList: n.type === "static",
    timeline: n.periodStart,
    resolvedUri: n.baseUrl || "",
    targetDuration: n.duration,
    timelineStarts: n.timelineStarts,
    discontinuityStarts: s,
    discontinuitySequence: o,
    mediaSequence: a,
    segments: r
  };
}, ZS = function(t, i, n) {
  i === void 0 && (i = {}), n === void 0 && (n = !1);
  var r, a = t.reduce(function(o, u) {
    var l = u.attributes.role && u.attributes.role.value || "", c = u.attributes.lang || "", h = u.attributes.label || "main";
    if (c && !u.attributes.label) {
      var d = l ? " (" + l + ")" : "";
      h = "" + u.attributes.lang + d;
    }
    o[h] || (o[h] = {
      language: c,
      autoselect: !0,
      default: l === "main",
      playlists: [],
      uri: ""
    });
    var f = yp(QS(u, n), i);
    return o[h].playlists.push(f), typeof r > "u" && l === "main" && (r = u, r.default = !0), o;
  }, {});
  if (!r) {
    var s = Object.keys(a)[0];
    a[s].default = !0;
  }
  return a;
}, JS = function(t, i) {
  return i === void 0 && (i = {}), t.reduce(function(n, r) {
    var a = r.attributes.lang || "text";
    return n[a] || (n[a] = {
      language: a,
      default: !1,
      autoselect: !1,
      playlists: [],
      uri: ""
    }), n[a].playlists.push(yp(KS(r), i)), n;
  }, {});
}, $S = function(t) {
  return t.reduce(function(i, n) {
    return n && n.forEach(function(r) {
      var a = r.channel, s = r.language;
      i[s] = {
        autoselect: !1,
        default: !1,
        instreamId: a,
        language: s
      }, r.hasOwnProperty("aspectRatio") && (i[s].aspectRatio = r.aspectRatio), r.hasOwnProperty("easyReader") && (i[s].easyReader = r.easyReader), r.hasOwnProperty("3D") && (i[s]["3D"] = r["3D"]);
    }), i;
  }, {});
}, eC = function(t) {
  var i, n = t.attributes, r = t.segments, a = t.sidx, s = t.discontinuityStarts, o = {
    attributes: (i = {
      NAME: n.id,
      AUDIO: "audio",
      SUBTITLES: "subs",
      RESOLUTION: {
        width: n.width,
        height: n.height
      },
      CODECS: n.codecs,
      BANDWIDTH: n.bandwidth
    }, i["PROGRAM-ID"] = 1, i),
    uri: "",
    endList: n.type === "static",
    timeline: n.periodStart,
    resolvedUri: "",
    targetDuration: n.duration,
    discontinuityStarts: s,
    timelineStarts: n.timelineStarts,
    segments: r
  };
  return n.frameRate && (o.attributes["FRAME-RATE"] = n.frameRate), n.contentProtection && (o.contentProtection = n.contentProtection), a && (o.sidx = a), o;
}, tC = function(t) {
  var i = t.attributes;
  return i.mimeType === "video/mp4" || i.mimeType === "video/webm" || i.contentType === "video";
}, iC = function(t) {
  var i = t.attributes;
  return i.mimeType === "audio/mp4" || i.mimeType === "audio/webm" || i.contentType === "audio";
}, rC = function(t) {
  var i = t.attributes;
  return i.mimeType === "text/vtt" || i.contentType === "text";
}, nC = function(t, i) {
  t.forEach(function(n) {
    n.mediaSequence = 0, n.discontinuitySequence = tf(i, function(r) {
      var a = r.timeline;
      return a === n.timeline;
    }), n.segments && n.segments.forEach(function(r, a) {
      r.number = a;
    });
  });
}, wm = function(t) {
  return t ? Object.keys(t).reduce(function(i, n) {
    var r = t[n];
    return i.concat(r.playlists);
  }, []) : [];
}, aC = function(t) {
  var i, n = t.dashPlaylists, r = t.locations, a = t.sidxMapping, s = a === void 0 ? {} : a, o = t.previousManifest;
  if (!n.length)
    return {};
  var u = n[0].attributes, l = u.sourceDuration, c = u.type, h = u.suggestedPresentationDelay, d = u.minimumUpdatePeriod, f = nd(n.filter(tC)).map(eC), p = nd(n.filter(iC)), _ = nd(n.filter(rC)), m = n.map(function(F) {
    return F.attributes.captionServices;
  }).filter(Boolean), x = {
    allowCache: !0,
    discontinuityStarts: [],
    segments: [],
    endList: !0,
    mediaGroups: (i = {
      AUDIO: {},
      VIDEO: {}
    }, i["CLOSED-CAPTIONS"] = {}, i.SUBTITLES = {}, i),
    uri: "",
    duration: l,
    playlists: YS(f, s)
  };
  d >= 0 && (x.minimumUpdatePeriod = d * 1e3), r && (x.locations = r), c === "dynamic" && (x.suggestedPresentationDelay = h);
  var E = x.playlists.length === 0, M = p.length ? ZS(p, s, E) : null, C = _.length ? JS(_, s) : null, R = f.concat(wm(M), wm(C)), k = R.map(function(F) {
    var B = F.timelineStarts;
    return B;
  });
  return x.timelineStarts = f_(k), nC(R, x.timelineStarts), M && (x.mediaGroups.AUDIO.audio = M), C && (x.mediaGroups.SUBTITLES.subs = C), m.length && (x.mediaGroups["CLOSED-CAPTIONS"].cc = $S(m)), o ? XS({
    oldManifest: o,
    newManifest: x
  }) : x;
}, sC = function(t, i, n) {
  var r = t.NOW, a = t.clientOffset, s = t.availabilityStartTime, o = t.timescale, u = o === void 0 ? 1 : o, l = t.periodStart, c = l === void 0 ? 0 : l, h = t.minimumUpdatePeriod, d = h === void 0 ? 0 : h, f = (r + a) / 1e3, p = s + c, _ = f + d, m = _ - p;
  return Math.ceil((m * u - i) / n);
}, p_ = function(t, i) {
  for (var n = t.type, r = t.minimumUpdatePeriod, a = r === void 0 ? 0 : r, s = t.media, o = s === void 0 ? "" : s, u = t.sourceDuration, l = t.timescale, c = l === void 0 ? 1 : l, h = t.startNumber, d = h === void 0 ? 1 : h, f = t.periodStart, p = [], _ = -1, m = 0; m < i.length; m++) {
    var x = i[m], E = x.d, M = x.r || 0, C = x.t || 0;
    _ < 0 && (_ = C), C && C > _ && (_ = C);
    var R = void 0;
    if (M < 0) {
      var k = m + 1;
      k === i.length ? n === "dynamic" && a > 0 && o.indexOf("$Number$") > 0 ? R = sC(t, _, E) : R = (u * c - _) / E : R = (i[k].t - _) / E;
    } else
      R = M + 1;
    for (var F = d + p.length + R, B = d + p.length; B < F; )
      p.push({
        number: B,
        duration: E / c,
        time: _,
        timeline: f
      }), _ += E, B++;
  }
  return p;
}, oC = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g, uC = function(t) {
  return function(i, n, r, a) {
    if (i === "$$")
      return "$";
    if (typeof t[n] > "u")
      return i;
    var s = "" + t[n];
    return n === "RepresentationID" || (r ? a = parseInt(a, 10) : a = 1, s.length >= a) ? s : "" + new Array(a - s.length + 1).join("0") + s;
  };
}, Sm = function(t, i) {
  return t.replace(oC, uC(i));
}, lC = function(t, i) {
  return !t.duration && !i ? [{
    number: t.startNumber || 1,
    duration: t.sourceDuration,
    time: 0,
    timeline: t.periodStart
  }] : t.duration ? mp(t) : p_(t, i);
}, cC = function(t, i) {
  var n = {
    RepresentationID: t.id,
    Bandwidth: t.bandwidth || 0
  }, r = t.initialization, a = r === void 0 ? {
    sourceURL: "",
    range: ""
  } : r, s = fl({
    baseUrl: t.baseUrl,
    source: Sm(a.sourceURL, n),
    range: a.range
  }), o = lC(t, i);
  return o.map(function(u) {
    n.Number = u.number, n.Time = u.time;
    var l = Sm(t.media || "", n), c = t.timescale || 1, h = t.presentationTimeOffset || 0, d = (
      // Even if the @t attribute is not specified for the segment, segment.time is
      // calculated in mpd-parser prior to this, so it's assumed to be available.
      t.periodStart + (u.time - h) / c
    ), f = {
      uri: l,
      timeline: u.timeline,
      duration: u.duration,
      resolvedUri: bh(t.baseUrl || "", l),
      map: s,
      number: u.number,
      presentationTime: d
    };
    return f;
  });
}, hC = function(t, i) {
  var n = t.baseUrl, r = t.initialization, a = r === void 0 ? {} : r, s = fl({
    baseUrl: n,
    source: a.sourceURL,
    range: a.range
  }), o = fl({
    baseUrl: n,
    source: i.media,
    range: i.mediaRange
  });
  return o.map = s, o;
}, dC = function(t, i) {
  var n = t.duration, r = t.segmentUrls, a = r === void 0 ? [] : r, s = t.periodStart;
  if (!n && !i || n && i)
    throw new Error(So.SEGMENT_TIME_UNSPECIFIED);
  var o = a.map(function(c) {
    return hC(t, c);
  }), u;
  n && (u = mp(t)), i && (u = p_(t, i));
  var l = u.map(function(c, h) {
    if (o[h]) {
      var d = o[h], f = t.timescale || 1, p = t.presentationTimeOffset || 0;
      return d.timeline = c.timeline, d.duration = c.duration, d.number = c.number, d.presentationTime = s + (c.time - p) / f, d;
    }
  }).filter(function(c) {
    return c;
  });
  return l;
}, fC = function(t) {
  var i = t.attributes, n = t.segmentInfo, r, a;
  n.template ? (a = cC, r = er(i, n.template)) : n.base ? (a = d_, r = er(i, n.base)) : n.list && (a = dC, r = er(i, n.list));
  var s = {
    attributes: i
  };
  if (!a)
    return s;
  var o = a(r, n.segmentTimeline);
  if (r.duration) {
    var u = r, l = u.duration, c = u.timescale, h = c === void 0 ? 1 : c;
    r.duration = l / h;
  } else o.length ? r.duration = o.reduce(function(d, f) {
    return Math.max(d, Math.ceil(f.duration));
  }, 0) : r.duration = 0;
  return s.attributes = r, s.segments = o, n.base && r.indexRange && (s.sidx = o[0], s.segments = []), s;
}, pC = function(t) {
  return t.map(fC);
}, pi = function(t, i) {
  return h_(t.childNodes).filter(function(n) {
    var r = n.tagName;
    return r === i;
  });
}, _p = function(t) {
  return t.textContent.trim();
}, vC = function(t) {
  return parseFloat(t.split("/").reduce(function(i, n) {
    return i / n;
  }));
}, Ms = function(t) {
  var i = 31536e3, n = 30 * 24 * 60 * 60, r = 24 * 60 * 60, a = 60 * 60, s = 60, o = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/, u = o.exec(t);
  if (!u)
    return 0;
  var l = u.slice(1), c = l[0], h = l[1], d = l[2], f = l[3], p = l[4], _ = l[5];
  return parseFloat(c || 0) * i + parseFloat(h || 0) * n + parseFloat(d || 0) * r + parseFloat(f || 0) * a + parseFloat(p || 0) * s + parseFloat(_ || 0);
}, mC = function(t) {
  var i = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
  return i.test(t) && (t += "Z"), Date.parse(t);
}, Cm = {
  /**
   * Specifies the duration of the entire Media Presentation. Format is a duration string
   * as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  mediaPresentationDuration: function(t) {
    return Ms(t);
  },
  /**
   * Specifies the Segment availability start time for all Segments referred to in this
   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability
   * time. Format is a date string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The date as seconds from unix epoch
   */
  availabilityStartTime: function(t) {
    return mC(t) / 1e3;
  },
  /**
   * Specifies the smallest period between potential changes to the MPD. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  minimumUpdatePeriod: function(t) {
    return Ms(t);
  },
  /**
   * Specifies the suggested presentation delay. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  suggestedPresentationDelay: function(t) {
    return Ms(t);
  },
  /**
   * specifices the type of mpd. Can be either "static" or "dynamic"
   *
   * @param {string} value
   *        value of attribute as a string
   *
   * @return {string}
   *         The type as a string
   */
  type: function(t) {
    return t;
  },
  /**
   * Specifies the duration of the smallest time shifting buffer for any Representation
   * in the MPD. Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  timeShiftBufferDepth: function(t) {
    return Ms(t);
  },
  /**
   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.
   * Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  start: function(t) {
    return Ms(t);
  },
  /**
   * Specifies the width of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed width
   */
  width: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the height of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed height
   */
  height: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the bitrate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed bandwidth
   */
  bandwidth: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the frame rate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed frame rate
   */
  frameRate: function(t) {
    return vC(t);
  },
  /**
   * Specifies the number of the first Media Segment in this Representation in the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  startNumber: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the timescale in units per seconds
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed timescale
   */
  timescale: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the presentationTimeOffset.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTimeOffset
   */
  presentationTimeOffset: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the constant approximate Segment duration
   * NOTE: The <Period> element also contains an @duration attribute. This duration
   *       specifies the duration of the Period. This attribute is currently not
   *       supported by the rest of the parser, however we still check for it to prevent
   *       errors.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  duration: function(t) {
    var i = parseInt(t, 10);
    return isNaN(i) ? Ms(t) : i;
  },
  /**
   * Specifies the Segment duration, in units of the value of the @timescale.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  d: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the MPD start time, in @timescale units, the first Segment in the series
   * starts relative to the beginning of the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed time
   */
  t: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the repeat count of the number of following contiguous Segments with the
   * same duration expressed by the value of @d
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  r: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Default parser for all other attributes. Acts as a no-op and just returns the value
   * as a string
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {string}
   *         Unparsed value
   */
  DEFAULT: function(t) {
    return t;
  }
}, Ui = function(t) {
  return t && t.attributes ? h_(t.attributes).reduce(function(i, n) {
    var r = Cm[n.name] || Cm.DEFAULT;
    return i[n.name] = r(n.value), i;
  }, {}) : {};
}, gC = {
  "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
  "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
  "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
  "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
}, Sh = function(t, i) {
  return i.length ? Eh(t.map(function(n) {
    return i.map(function(r) {
      return bh(n, _p(r));
    });
  })) : t;
}, bp = function(t) {
  var i = pi(t, "SegmentTemplate")[0], n = pi(t, "SegmentList")[0], r = n && pi(n, "SegmentURL").map(function(d) {
    return er({
      tag: "SegmentURL"
    }, Ui(d));
  }), a = pi(t, "SegmentBase")[0], s = n || i, o = s && pi(s, "SegmentTimeline")[0], u = n || a || i, l = u && pi(u, "Initialization")[0], c = i && Ui(i);
  c && l ? c.initialization = l && Ui(l) : c && c.initialization && (c.initialization = {
    sourceURL: c.initialization
  });
  var h = {
    template: c,
    segmentTimeline: o && pi(o, "S").map(function(d) {
      return Ui(d);
    }),
    list: n && er(Ui(n), {
      segmentUrls: r,
      initialization: Ui(l)
    }),
    base: a && er(Ui(a), {
      initialization: Ui(l)
    })
  };
  return Object.keys(h).forEach(function(d) {
    h[d] || delete h[d];
  }), h;
}, yC = function(t, i, n) {
  return function(r) {
    var a = pi(r, "BaseURL"), s = Sh(i, a), o = er(t, Ui(r)), u = bp(r);
    return s.map(function(l) {
      return {
        segmentInfo: er(n, u),
        attributes: er(o, {
          baseUrl: l
        })
      };
    });
  };
}, _C = function(t) {
  return t.reduce(function(i, n) {
    var r = Ui(n);
    r.schemeIdUri && (r.schemeIdUri = r.schemeIdUri.toLowerCase());
    var a = gC[r.schemeIdUri];
    if (a) {
      i[a] = {
        attributes: r
      };
      var s = pi(n, "cenc:pssh")[0];
      if (s) {
        var o = _p(s);
        i[a].pssh = o && Oy(o);
      }
    }
    return i;
  }, {});
}, bC = function(t) {
  if (t.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
    var i = typeof t.value != "string" ? [] : t.value.split(";");
    return i.map(function(r) {
      var a, s;
      if (s = r, /^CC\d=/.test(r)) {
        var o = r.split("=");
        a = o[0], s = o[1];
      } else /^CC\d$/.test(r) && (a = r);
      return {
        channel: a,
        language: s
      };
    });
  } else if (t.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
    var n = typeof t.value != "string" ? [] : t.value.split(";");
    return n.map(function(r) {
      var a = {
        // service or channel number 1-63
        channel: void 0,
        // language is a 3ALPHA per ISO 639.2/B
        // field is required
        language: void 0,
        // BIT 1/0 or ?
        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown
        aspectRatio: 1,
        // BIT 1/0
        // easy reader flag indicated the text is tailed to the needs of beginning readers
        // default 0, or off
        easyReader: 0,
        // BIT 1/0
        // If 3d metadata is present (CEA-708.1) then 1
        // default 0
        "3D": 0
      };
      if (/=/.test(r)) {
        var s = r.split("="), o = s[0], u = s[1], l = u === void 0 ? "" : u;
        a.channel = o, a.language = r, l.split(",").forEach(function(c) {
          var h = c.split(":"), d = h[0], f = h[1];
          d === "lang" ? a.language = f : d === "er" ? a.easyReader = Number(f) : d === "war" ? a.aspectRatio = Number(f) : d === "3D" && (a["3D"] = Number(f));
        });
      } else
        a.language = r;
      return a.channel && (a.channel = "SERVICE" + a.channel), a;
    });
  }
}, xC = function(t, i, n) {
  return function(r) {
    var a = Ui(r), s = Sh(i, pi(r, "BaseURL")), o = pi(r, "Role")[0], u = {
      role: Ui(o)
    }, l = er(t, a, u), c = pi(r, "Accessibility")[0], h = bC(Ui(c));
    h && (l = er(l, {
      captionServices: h
    }));
    var d = pi(r, "Label")[0];
    if (d && d.childNodes.length) {
      var f = d.childNodes[0].nodeValue.trim();
      l = er(l, {
        label: f
      });
    }
    var p = _C(pi(r, "ContentProtection"));
    Object.keys(p).length && (l = er(l, {
      contentProtection: p
    }));
    var _ = bp(r), m = pi(r, "Representation"), x = er(n, _);
    return Eh(m.map(yC(l, s, x)));
  };
}, AC = function(t, i) {
  return function(n, r) {
    var a = Sh(i, pi(n.node, "BaseURL")), s = er(t, {
      periodStart: n.attributes.start
    });
    typeof n.attributes.duration == "number" && (s.periodDuration = n.attributes.duration);
    var o = pi(n.node, "AdaptationSet"), u = bp(n.node);
    return Eh(o.map(xC(s, a, u)));
  };
}, TC = function(t) {
  var i = t.attributes, n = t.priorPeriodAttributes, r = t.mpdType;
  return typeof i.start == "number" ? i.start : n && typeof n.start == "number" && typeof n.duration == "number" ? n.start + n.duration : !n && r === "static" ? 0 : null;
}, EC = function(t, i) {
  i === void 0 && (i = {});
  var n = i, r = n.manifestUri, a = r === void 0 ? "" : r, s = n.NOW, o = s === void 0 ? Date.now() : s, u = n.clientOffset, l = u === void 0 ? 0 : u, c = pi(t, "Period");
  if (!c.length)
    throw new Error(So.INVALID_NUMBER_OF_PERIOD);
  var h = pi(t, "Location"), d = Ui(t), f = Sh([a], pi(t, "BaseURL"));
  d.type = d.type || "static", d.sourceDuration = d.mediaPresentationDuration || 0, d.NOW = o, d.clientOffset = l, h.length && (d.locations = h.map(_p));
  var p = [];
  return c.forEach(function(_, m) {
    var x = Ui(_), E = p[m - 1];
    x.start = TC({
      attributes: x,
      priorPeriodAttributes: E ? E.attributes : null,
      mpdType: d.type
    }), p.push({
      node: _,
      attributes: x
    });
  }), {
    locations: d.locations,
    representationInfo: Eh(p.map(AC(d, f)))
  };
}, v_ = function(t) {
  if (t === "")
    throw new Error(So.DASH_EMPTY_MANIFEST);
  var i = new BS(), n, r;
  try {
    n = i.parseFromString(t, "application/xml"), r = n && n.documentElement.tagName === "MPD" ? n.documentElement : null;
  } catch {
  }
  if (!r || r && r.getElementsByTagName("parsererror").length > 0)
    throw new Error(So.DASH_INVALID_XML);
  return r;
}, wC = function(t) {
  var i = pi(t, "UTCTiming")[0];
  if (!i)
    return null;
  var n = Ui(i);
  switch (n.schemeIdUri) {
    case "urn:mpeg:dash:utc:http-head:2014":
    case "urn:mpeg:dash:utc:http-head:2012":
      n.method = "HEAD";
      break;
    case "urn:mpeg:dash:utc:http-xsdate:2014":
    case "urn:mpeg:dash:utc:http-iso:2014":
    case "urn:mpeg:dash:utc:http-xsdate:2012":
    case "urn:mpeg:dash:utc:http-iso:2012":
      n.method = "GET";
      break;
    case "urn:mpeg:dash:utc:direct:2014":
    case "urn:mpeg:dash:utc:direct:2012":
      n.method = "DIRECT", n.value = Date.parse(n.value);
      break;
    case "urn:mpeg:dash:utc:http-ntp:2014":
    case "urn:mpeg:dash:utc:ntp:2014":
    case "urn:mpeg:dash:utc:sntp:2014":
    default:
      throw new Error(So.UNSUPPORTED_UTC_TIMING_SCHEME);
  }
  return n;
}, SC = function(t, i) {
  i === void 0 && (i = {});
  var n = EC(v_(t), i), r = pC(n.representationInfo);
  return aC({
    dashPlaylists: r,
    locations: n.locations,
    sidxMapping: i.sidxMapping,
    previousManifest: i.previousManifest
  });
}, CC = function(t) {
  return wC(v_(t));
}, m_ = Math.pow(2, 32), MC = function(e) {
  var t = new DataView(e.buffer, e.byteOffset, e.byteLength), i;
  return t.getBigUint64 ? (i = t.getBigUint64(0), i < Number.MAX_SAFE_INTEGER ? Number(i) : i) : t.getUint32(0) * m_ + t.getUint32(4);
}, DC = {
  getUint64: MC,
  MAX_UINT32: m_
}, Mm = DC.getUint64, PC = function(e) {
  var t = new DataView(e.buffer, e.byteOffset, e.byteLength), i = {
    version: e[0],
    flags: new Uint8Array(e.subarray(1, 4)),
    references: [],
    referenceId: t.getUint32(4),
    timescale: t.getUint32(8)
  }, n = 12;
  i.version === 0 ? (i.earliestPresentationTime = t.getUint32(n), i.firstOffset = t.getUint32(n + 4), n += 8) : (i.earliestPresentationTime = Mm(e.subarray(n)), i.firstOffset = Mm(e.subarray(n + 8)), n += 16), n += 2;
  var r = t.getUint16(n);
  for (n += 2; r > 0; n += 12, r--)
    i.references.push({
      referenceType: (e[n] & 128) >>> 7,
      referencedSize: t.getUint32(n) & 2147483647,
      subsegmentDuration: t.getUint32(n + 4),
      startsWithSap: !!(e[n + 8] & 128),
      sapType: (e[n + 8] & 112) >>> 4,
      sapDeltaTime: t.getUint32(n + 8) & 268435455
    });
  return i;
}, LC = PC;
const RC = /* @__PURE__ */ Yn(LC);
var xp = 9e4, Ap, Tp, Ch, Ep, g_, y_, __;
Ap = function(e) {
  return e * xp;
};
Tp = function(e, t) {
  return e * t;
};
Ch = function(e) {
  return e / xp;
};
Ep = function(e, t) {
  return e / t;
};
g_ = function(e, t) {
  return Ap(Ep(e, t));
};
y_ = function(e, t) {
  return Tp(Ch(e), t);
};
__ = function(e, t, i) {
  return Ch(i ? e : e - t);
};
var Nc = {
  ONE_SECOND_IN_TS: xp,
  secondsToVideoTs: Ap,
  secondsToAudioTs: Tp,
  videoTsToSeconds: Ch,
  audioTsToSeconds: Ep,
  audioTsToVideoTs: g_,
  videoTsToAudioTs: y_,
  metadataTsToSeconds: __
}, IC = OC;
function OC(e, t) {
  var i, n = null;
  try {
    i = JSON.parse(e, t);
  } catch (r) {
    n = r;
  }
  return [n, i];
}
const kC = /* @__PURE__ */ Yn(IC);
var b_ = { exports: {} }, Dm = Dg, wp = Object.create || /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (arguments.length !== 1)
      throw new Error("Object.create shim only accepts one parameter.");
    return e.prototype = t, new e();
  };
}();
function Tr(e, t) {
  this.name = "ParsingError", this.code = e.code, this.message = t || e.message;
}
Tr.prototype = wp(Error.prototype);
Tr.prototype.constructor = Tr;
Tr.Errors = {
  BadSignature: {
    code: 0,
    message: "Malformed WebVTT signature."
  },
  BadTimeStamp: {
    code: 1,
    message: "Malformed time stamp."
  }
};
function Sp(e) {
  function t(n, r, a, s) {
    return (n | 0) * 3600 + (r | 0) * 60 + (a | 0) + (s | 0) / 1e3;
  }
  var i = e.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
  return i ? i[3] ? t(i[1], i[2], i[3].replace(":", ""), i[4]) : i[1] > 59 ? t(i[1], i[2], 0, i[4]) : t(0, i[1], i[2], i[4]) : null;
}
function hu() {
  this.values = wp(null);
}
hu.prototype = {
  // Only accept the first assignment to any key.
  set: function(e, t) {
    !this.get(e) && t !== "" && (this.values[e] = t);
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function(e, t, i) {
    return i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t;
  },
  // Check whether we have a value for a key.
  has: function(e) {
    return e in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function(e, t, i) {
    for (var n = 0; n < i.length; ++n)
      if (t === i[n]) {
        this.set(e, t);
        break;
      }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function(e, t) {
    /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10));
  },
  // Accept a setting if its a valid percentage.
  percent: function(e, t) {
    return t.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (t = parseFloat(t), t >= 0 && t <= 100) ? (this.set(e, t), !0) : !1;
  }
};
function au(e, t, i, n) {
  var r = n ? e.split(n) : [e];
  for (var a in r)
    if (typeof r[a] == "string") {
      var s = r[a].split(i);
      if (s.length === 2) {
        var o = s[0].trim(), u = s[1].trim();
        t(o, u);
      }
    }
}
function BC(e, t, i) {
  var n = e;
  function r() {
    var o = Sp(e);
    if (o === null)
      throw new Tr(
        Tr.Errors.BadTimeStamp,
        "Malformed timestamp: " + n
      );
    return e = e.replace(/^[^\sa-zA-Z-]+/, ""), o;
  }
  function a(o, u) {
    var l = new hu();
    au(o, function(c, h) {
      switch (c) {
        case "region":
          for (var d = i.length - 1; d >= 0; d--)
            if (i[d].id === h) {
              l.set(c, i[d].region);
              break;
            }
          break;
        case "vertical":
          l.alt(c, h, ["rl", "lr"]);
          break;
        case "line":
          var f = h.split(","), p = f[0];
          l.integer(c, p), l.percent(c, p) && l.set("snapToLines", !1), l.alt(c, p, ["auto"]), f.length === 2 && l.alt("lineAlign", f[1], ["start", "center", "end"]);
          break;
        case "position":
          f = h.split(","), l.percent(c, f[0]), f.length === 2 && l.alt("positionAlign", f[1], ["start", "center", "end"]);
          break;
        case "size":
          l.percent(c, h);
          break;
        case "align":
          l.alt(c, h, ["start", "center", "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/), u.region = l.get("region", null), u.vertical = l.get("vertical", "");
    try {
      u.line = l.get("line", "auto");
    } catch {
    }
    u.lineAlign = l.get("lineAlign", "start"), u.snapToLines = l.get("snapToLines", !0), u.size = l.get("size", 100);
    try {
      u.align = l.get("align", "center");
    } catch {
      u.align = l.get("align", "middle");
    }
    try {
      u.position = l.get("position", "auto");
    } catch {
      u.position = l.get("position", {
        start: 0,
        left: 0,
        center: 50,
        middle: 50,
        end: 100,
        right: 100
      }, u.align);
    }
    u.positionAlign = l.get("positionAlign", {
      start: "start",
      left: "start",
      center: "center",
      middle: "center",
      end: "end",
      right: "end"
    }, u.align);
  }
  function s() {
    e = e.replace(/^\s+/, "");
  }
  if (s(), t.startTime = r(), s(), e.substr(0, 3) !== "-->")
    throw new Tr(
      Tr.Errors.BadTimeStamp,
      "Malformed time stamp (time stamps must be separated by '-->'): " + n
    );
  e = e.substr(3), s(), t.endTime = r(), s(), a(e, t);
}
var ad = Dm.createElement && Dm.createElement("textarea"), FC = {
  c: "span",
  i: "i",
  b: "b",
  u: "u",
  ruby: "ruby",
  rt: "rt",
  v: "span",
  lang: "span"
}, Pm = {
  white: "rgba(255,255,255,1)",
  lime: "rgba(0,255,0,1)",
  cyan: "rgba(0,255,255,1)",
  red: "rgba(255,0,0,1)",
  yellow: "rgba(255,255,0,1)",
  magenta: "rgba(255,0,255,1)",
  blue: "rgba(0,0,255,1)",
  black: "rgba(0,0,0,1)"
}, NC = {
  v: "title",
  lang: "lang"
}, Lm = {
  rt: "ruby"
};
function x_(e, t) {
  function i() {
    if (!t)
      return null;
    function p(m) {
      return t = t.substr(m.length), m;
    }
    var _ = t.match(/^([^<]*)(<[^>]*>?)?/);
    return p(_[1] ? _[1] : _[2]);
  }
  function n(p) {
    return ad.innerHTML = p, p = ad.textContent, ad.textContent = "", p;
  }
  function r(p, _) {
    return !Lm[_.localName] || Lm[_.localName] === p.localName;
  }
  function a(p, _) {
    var m = FC[p];
    if (!m)
      return null;
    var x = e.document.createElement(m), E = NC[p];
    return E && _ && (x[E] = _.trim()), x;
  }
  for (var s = e.document.createElement("div"), o = s, u, l = []; (u = i()) !== null; ) {
    if (u[0] === "<") {
      if (u[1] === "/") {
        l.length && l[l.length - 1] === u.substr(2).replace(">", "") && (l.pop(), o = o.parentNode);
        continue;
      }
      var c = Sp(u.substr(1, u.length - 2)), h;
      if (c) {
        h = e.document.createProcessingInstruction("timestamp", c), o.appendChild(h);
        continue;
      }
      var d = u.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
      if (!d || (h = a(d[1], d[3]), !h) || !r(o, h))
        continue;
      if (d[2]) {
        var f = d[2].split(".");
        f.forEach(function(p) {
          var _ = /^bg_/.test(p), m = _ ? p.slice(3) : p;
          if (Pm.hasOwnProperty(m)) {
            var x = _ ? "background-color" : "color", E = Pm[m];
            h.style[x] = E;
          }
        }), h.className = f.join(" ");
      }
      l.push(d[1]), o.appendChild(h), o = h;
      continue;
    }
    o.appendChild(e.document.createTextNode(n(u)));
  }
  return s;
}
var Rm = [
  [1470, 1470],
  [1472, 1472],
  [1475, 1475],
  [1478, 1478],
  [1488, 1514],
  [1520, 1524],
  [1544, 1544],
  [1547, 1547],
  [1549, 1549],
  [1563, 1563],
  [1566, 1610],
  [1645, 1647],
  [1649, 1749],
  [1765, 1766],
  [1774, 1775],
  [1786, 1805],
  [1807, 1808],
  [1810, 1839],
  [1869, 1957],
  [1969, 1969],
  [1984, 2026],
  [2036, 2037],
  [2042, 2042],
  [2048, 2069],
  [2074, 2074],
  [2084, 2084],
  [2088, 2088],
  [2096, 2110],
  [2112, 2136],
  [2142, 2142],
  [2208, 2208],
  [2210, 2220],
  [8207, 8207],
  [64285, 64285],
  [64287, 64296],
  [64298, 64310],
  [64312, 64316],
  [64318, 64318],
  [64320, 64321],
  [64323, 64324],
  [64326, 64449],
  [64467, 64829],
  [64848, 64911],
  [64914, 64967],
  [65008, 65020],
  [65136, 65140],
  [65142, 65276],
  [67584, 67589],
  [67592, 67592],
  [67594, 67637],
  [67639, 67640],
  [67644, 67644],
  [67647, 67669],
  [67671, 67679],
  [67840, 67867],
  [67872, 67897],
  [67903, 67903],
  [67968, 68023],
  [68030, 68031],
  [68096, 68096],
  [68112, 68115],
  [68117, 68119],
  [68121, 68147],
  [68160, 68167],
  [68176, 68184],
  [68192, 68223],
  [68352, 68405],
  [68416, 68437],
  [68440, 68466],
  [68472, 68479],
  [68608, 68680],
  [126464, 126467],
  [126469, 126495],
  [126497, 126498],
  [126500, 126500],
  [126503, 126503],
  [126505, 126514],
  [126516, 126519],
  [126521, 126521],
  [126523, 126523],
  [126530, 126530],
  [126535, 126535],
  [126537, 126537],
  [126539, 126539],
  [126541, 126543],
  [126545, 126546],
  [126548, 126548],
  [126551, 126551],
  [126553, 126553],
  [126555, 126555],
  [126557, 126557],
  [126559, 126559],
  [126561, 126562],
  [126564, 126564],
  [126567, 126570],
  [126572, 126578],
  [126580, 126583],
  [126585, 126588],
  [126590, 126590],
  [126592, 126601],
  [126603, 126619],
  [126625, 126627],
  [126629, 126633],
  [126635, 126651],
  [1114109, 1114109]
];
function UC(e) {
  for (var t = 0; t < Rm.length; t++) {
    var i = Rm[t];
    if (e >= i[0] && e <= i[1])
      return !0;
  }
  return !1;
}
function jC(e) {
  var t = [], i = "", n;
  if (!e || !e.childNodes)
    return "ltr";
  function r(o, u) {
    for (var l = u.childNodes.length - 1; l >= 0; l--)
      o.push(u.childNodes[l]);
  }
  function a(o) {
    if (!o || !o.length)
      return null;
    var u = o.pop(), l = u.textContent || u.innerText;
    if (l) {
      var c = l.match(/^.*(\n|\r)/);
      return c ? (o.length = 0, c[0]) : l;
    }
    if (u.tagName === "ruby")
      return a(o);
    if (u.childNodes)
      return r(o, u), a(o);
  }
  for (r(t, e); i = a(t); )
    for (var s = 0; s < i.length; s++)
      if (n = i.charCodeAt(s), UC(n))
        return "rtl";
  return "ltr";
}
function GC(e) {
  if (typeof e.line == "number" && (e.snapToLines || e.line >= 0 && e.line <= 100))
    return e.line;
  if (!e.track || !e.track.textTrackList || !e.track.textTrackList.mediaElement)
    return -1;
  for (var t = e.track, i = t.textTrackList, n = 0, r = 0; r < i.length && i[r] !== t; r++)
    i[r].mode === "showing" && n++;
  return ++n * -1;
}
function Mh() {
}
Mh.prototype.applyStyles = function(e, t) {
  t = t || this.div;
  for (var i in e)
    e.hasOwnProperty(i) && (t.style[i] = e[i]);
};
Mh.prototype.formatStyle = function(e, t) {
  return e === 0 ? 0 : e + t;
};
function Uc(e, t, i) {
  Mh.call(this), this.cue = t, this.cueDiv = x_(e, t.text);
  var n = {
    color: "rgba(255, 255, 255, 1)",
    backgroundColor: "rgba(0, 0, 0, 0.8)",
    position: "relative",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    display: "inline",
    writingMode: t.vertical === "" ? "horizontal-tb" : t.vertical === "lr" ? "vertical-lr" : "vertical-rl",
    unicodeBidi: "plaintext"
  };
  this.applyStyles(n, this.cueDiv), this.div = e.document.createElement("div"), n = {
    direction: jC(this.cueDiv),
    writingMode: t.vertical === "" ? "horizontal-tb" : t.vertical === "lr" ? "vertical-lr" : "vertical-rl",
    unicodeBidi: "plaintext",
    textAlign: t.align === "middle" ? "center" : t.align,
    font: i.font,
    whiteSpace: "pre-line",
    position: "absolute"
  }, this.applyStyles(n), this.div.appendChild(this.cueDiv);
  var r = 0;
  switch (t.positionAlign) {
    case "start":
    case "line-left":
      r = t.position;
      break;
    case "center":
      r = t.position - t.size / 2;
      break;
    case "end":
    case "line-right":
      r = t.position - t.size;
      break;
  }
  t.vertical === "" ? this.applyStyles({
    left: this.formatStyle(r, "%"),
    width: this.formatStyle(t.size, "%")
  }) : this.applyStyles({
    top: this.formatStyle(r, "%"),
    height: this.formatStyle(t.size, "%")
  }), this.move = function(a) {
    this.applyStyles({
      top: this.formatStyle(a.top, "px"),
      bottom: this.formatStyle(a.bottom, "px"),
      left: this.formatStyle(a.left, "px"),
      right: this.formatStyle(a.right, "px"),
      height: this.formatStyle(a.height, "px"),
      width: this.formatStyle(a.width, "px")
    });
  };
}
Uc.prototype = wp(Mh.prototype);
Uc.prototype.constructor = Uc;
function tr(e) {
  var t, i, n, r;
  if (e.div) {
    i = e.div.offsetHeight, n = e.div.offsetWidth, r = e.div.offsetTop;
    var a = (a = e.div.childNodes) && (a = a[0]) && a.getClientRects && a.getClientRects();
    e = e.div.getBoundingClientRect(), t = a ? Math.max(a[0] && a[0].height || 0, e.height / a.length) : 0;
  }
  this.left = e.left, this.right = e.right, this.top = e.top || r, this.height = e.height || i, this.bottom = e.bottom || r + (e.height || i), this.width = e.width || n, this.lineHeight = t !== void 0 ? t : e.lineHeight;
}
tr.prototype.move = function(e, t) {
  switch (t = t !== void 0 ? t : this.lineHeight, e) {
    case "+x":
      this.left += t, this.right += t;
      break;
    case "-x":
      this.left -= t, this.right -= t;
      break;
    case "+y":
      this.top += t, this.bottom += t;
      break;
    case "-y":
      this.top -= t, this.bottom -= t;
      break;
  }
};
tr.prototype.overlaps = function(e) {
  return this.left < e.right && this.right > e.left && this.top < e.bottom && this.bottom > e.top;
};
tr.prototype.overlapsAny = function(e) {
  for (var t = 0; t < e.length; t++)
    if (this.overlaps(e[t]))
      return !0;
  return !1;
};
tr.prototype.within = function(e) {
  return this.top >= e.top && this.bottom <= e.bottom && this.left >= e.left && this.right <= e.right;
};
tr.prototype.overlapsOppositeAxis = function(e, t) {
  switch (t) {
    case "+x":
      return this.left < e.left;
    case "-x":
      return this.right > e.right;
    case "+y":
      return this.top < e.top;
    case "-y":
      return this.bottom > e.bottom;
  }
};
tr.prototype.intersectPercentage = function(e) {
  var t = Math.max(0, Math.min(this.right, e.right) - Math.max(this.left, e.left)), i = Math.max(0, Math.min(this.bottom, e.bottom) - Math.max(this.top, e.top)), n = t * i;
  return n / (this.height * this.width);
};
tr.prototype.toCSSCompatValues = function(e) {
  return {
    top: this.top - e.top,
    bottom: e.bottom - this.bottom,
    left: this.left - e.left,
    right: e.right - this.right,
    height: this.height,
    width: this.width
  };
};
tr.getSimpleBoxPosition = function(e) {
  var t = e.div ? e.div.offsetHeight : e.tagName ? e.offsetHeight : 0, i = e.div ? e.div.offsetWidth : e.tagName ? e.offsetWidth : 0, n = e.div ? e.div.offsetTop : e.tagName ? e.offsetTop : 0;
  e = e.div ? e.div.getBoundingClientRect() : e.tagName ? e.getBoundingClientRect() : e;
  var r = {
    left: e.left,
    right: e.right,
    top: e.top || n,
    height: e.height || t,
    bottom: e.bottom || n + (e.height || t),
    width: e.width || i
  };
  return r;
};
function VC(e, t, i, n) {
  function r(m, x) {
    for (var E, M = new tr(m), C = 1, R = 0; R < x.length; R++) {
      for (; m.overlapsOppositeAxis(i, x[R]) || m.within(i) && m.overlapsAny(n); )
        m.move(x[R]);
      if (m.within(i))
        return m;
      var k = m.intersectPercentage(i);
      C > k && (E = new tr(m), C = k), m = new tr(M);
    }
    return E || M;
  }
  var a = new tr(t), s = t.cue, o = GC(s), u = [];
  if (s.snapToLines) {
    var l;
    switch (s.vertical) {
      case "":
        u = ["+y", "-y"], l = "height";
        break;
      case "rl":
        u = ["+x", "-x"], l = "width";
        break;
      case "lr":
        u = ["-x", "+x"], l = "width";
        break;
    }
    var c = a.lineHeight, h = c * Math.round(o), d = i[l] + c, f = u[0];
    Math.abs(h) > d && (h = h < 0 ? -1 : 1, h *= Math.ceil(d / c) * c), o < 0 && (h += s.vertical === "" ? i.height : i.width, u = u.reverse()), a.move(f, h);
  } else {
    var p = a.lineHeight / i.height * 100;
    switch (s.lineAlign) {
      case "center":
        o -= p / 2;
        break;
      case "end":
        o -= p;
        break;
    }
    switch (s.vertical) {
      case "":
        t.applyStyles({
          top: t.formatStyle(o, "%")
        });
        break;
      case "rl":
        t.applyStyles({
          left: t.formatStyle(o, "%")
        });
        break;
      case "lr":
        t.applyStyles({
          right: t.formatStyle(o, "%")
        });
        break;
    }
    u = ["+y", "-x", "+x", "-y"], a = new tr(t);
  }
  var _ = r(a, u);
  t.move(_.toCSSCompatValues(i));
}
function ko() {
}
ko.StringDecoder = function() {
  return {
    decode: function(e) {
      if (!e)
        return "";
      if (typeof e != "string")
        throw new Error("Error - expected string data.");
      return decodeURIComponent(encodeURIComponent(e));
    }
  };
};
ko.convertCueToDOMTree = function(e, t) {
  return !e || !t ? null : x_(e, t);
};
var HC = 0.05, zC = "sans-serif", WC = "1.5%";
ko.processCues = function(e, t, i) {
  if (!e || !t || !i)
    return null;
  for (; i.firstChild; )
    i.removeChild(i.firstChild);
  var n = e.document.createElement("div");
  n.style.position = "absolute", n.style.left = "0", n.style.right = "0", n.style.top = "0", n.style.bottom = "0", n.style.margin = WC, i.appendChild(n);
  function r(c) {
    for (var h = 0; h < c.length; h++)
      if (c[h].hasBeenReset || !c[h].displayState)
        return !0;
    return !1;
  }
  if (!r(t)) {
    for (var a = 0; a < t.length; a++)
      n.appendChild(t[a].displayState);
    return;
  }
  var s = [], o = tr.getSimpleBoxPosition(n), u = Math.round(o.height * HC * 100) / 100, l = {
    font: u + "px " + zC
  };
  (function() {
    for (var c, h, d = 0; d < t.length; d++)
      h = t[d], c = new Uc(e, h, l), n.appendChild(c.div), VC(e, c, o, s), h.displayState = c.div, s.push(tr.getSimpleBoxPosition(c));
  })();
};
ko.Parser = function(e, t, i) {
  i || (i = t, t = {}), t || (t = {}), this.window = e, this.vttjs = t, this.state = "INITIAL", this.buffer = "", this.decoder = i || new TextDecoder("utf8"), this.regionList = [];
};
ko.Parser.prototype = {
  // If the error is a ParsingError then report it to the consumer if
  // possible. If it's not a ParsingError then throw it like normal.
  reportOrThrowError: function(e) {
    if (e instanceof Tr)
      this.onparsingerror && this.onparsingerror(e);
    else
      throw e;
  },
  parse: function(e) {
    var t = this;
    e && (t.buffer += t.decoder.decode(e, { stream: !0 }));
    function i() {
      for (var c = t.buffer, h = 0; h < c.length && c[h] !== "\r" && c[h] !== `
`; )
        ++h;
      var d = c.substr(0, h);
      return c[h] === "\r" && ++h, c[h] === `
` && ++h, t.buffer = c.substr(h), d;
    }
    function n(c) {
      var h = new hu();
      if (au(c, function(f, p) {
        switch (f) {
          case "id":
            h.set(f, p);
            break;
          case "width":
            h.percent(f, p);
            break;
          case "lines":
            h.integer(f, p);
            break;
          case "regionanchor":
          case "viewportanchor":
            var _ = p.split(",");
            if (_.length !== 2)
              break;
            var m = new hu();
            if (m.percent("x", _[0]), m.percent("y", _[1]), !m.has("x") || !m.has("y"))
              break;
            h.set(f + "X", m.get("x")), h.set(f + "Y", m.get("y"));
            break;
          case "scroll":
            h.alt(f, p, ["up"]);
            break;
        }
      }, /=/, /\s/), h.has("id")) {
        var d = new (t.vttjs.VTTRegion || t.window.VTTRegion)();
        d.width = h.get("width", 100), d.lines = h.get("lines", 3), d.regionAnchorX = h.get("regionanchorX", 0), d.regionAnchorY = h.get("regionanchorY", 100), d.viewportAnchorX = h.get("viewportanchorX", 0), d.viewportAnchorY = h.get("viewportanchorY", 100), d.scroll = h.get("scroll", ""), t.onregion && t.onregion(d), t.regionList.push({
          id: h.get("id"),
          region: d
        });
      }
    }
    function r(c) {
      var h = new hu();
      au(c, function(d, f) {
        switch (d) {
          case "MPEGT":
            h.integer(d + "S", f);
            break;
          case "LOCA":
            h.set(d + "L", Sp(f));
            break;
        }
      }, /[^\d]:/, /,/), t.ontimestampmap && t.ontimestampmap({
        MPEGTS: h.get("MPEGTS"),
        LOCAL: h.get("LOCAL")
      });
    }
    function a(c) {
      c.match(/X-TIMESTAMP-MAP/) ? au(c, function(h, d) {
        switch (h) {
          case "X-TIMESTAMP-MAP":
            r(d);
            break;
        }
      }, /=/) : au(c, function(h, d) {
        switch (h) {
          case "Region":
            n(d);
            break;
        }
      }, /:/);
    }
    try {
      var s;
      if (t.state === "INITIAL") {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        s = i();
        var o = s.match(/^WEBVTT([ \t].*)?$/);
        if (!o || !o[0])
          throw new Tr(Tr.Errors.BadSignature);
        t.state = "HEADER";
      }
      for (var u = !1; t.buffer; ) {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        switch (u ? u = !1 : s = i(), t.state) {
          case "HEADER":
            /:/.test(s) ? a(s) : s || (t.state = "ID");
            continue;
          case "NOTE":
            s || (t.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(s)) {
              t.state = "NOTE";
              break;
            }
            if (!s)
              continue;
            t.cue = new (t.vttjs.VTTCue || t.window.VTTCue)(0, 0, "");
            try {
              t.cue.align = "center";
            } catch {
              t.cue.align = "middle";
            }
            if (t.state = "CUE", s.indexOf("-->") === -1) {
              t.cue.id = s;
              continue;
            }
          case "CUE":
            try {
              BC(s, t.cue, t.regionList);
            } catch (c) {
              t.reportOrThrowError(c), t.cue = null, t.state = "BADCUE";
              continue;
            }
            t.state = "CUETEXT";
            continue;
          case "CUETEXT":
            var l = s.indexOf("-->") !== -1;
            if (!s || l && (u = !0)) {
              t.oncue && t.oncue(t.cue), t.cue = null, t.state = "ID";
              continue;
            }
            t.cue.text && (t.cue.text += `
`), t.cue.text += s.replace(/\u2028/g, `
`).replace(/u2029/g, `
`);
            continue;
          case "BADCUE":
            s || (t.state = "ID");
            continue;
        }
      }
    } catch (c) {
      t.reportOrThrowError(c), t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  },
  flush: function() {
    var e = this;
    try {
      if (e.buffer += e.decoder.decode(), (e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL")
        throw new Tr(Tr.Errors.BadSignature);
    } catch (t) {
      e.reportOrThrowError(t);
    }
    return e.onflush && e.onflush(), this;
  }
};
var qC = ko, XC = "auto", YC = {
  "": 1,
  lr: 1,
  rl: 1
}, QC = {
  start: 1,
  center: 1,
  end: 1,
  left: 1,
  right: 1,
  auto: 1,
  "line-left": 1,
  "line-right": 1
};
function KC(e) {
  if (typeof e != "string")
    return !1;
  var t = YC[e.toLowerCase()];
  return t ? e.toLowerCase() : !1;
}
function sd(e) {
  if (typeof e != "string")
    return !1;
  var t = QC[e.toLowerCase()];
  return t ? e.toLowerCase() : !1;
}
function A_(e, t, i) {
  this.hasBeenReset = !1;
  var n = "", r = !1, a = e, s = t, o = i, u = null, l = "", c = !0, h = "auto", d = "start", f = "auto", p = "auto", _ = 100, m = "center";
  Object.defineProperties(this, {
    id: {
      enumerable: !0,
      get: function() {
        return n;
      },
      set: function(x) {
        n = "" + x;
      }
    },
    pauseOnExit: {
      enumerable: !0,
      get: function() {
        return r;
      },
      set: function(x) {
        r = !!x;
      }
    },
    startTime: {
      enumerable: !0,
      get: function() {
        return a;
      },
      set: function(x) {
        if (typeof x != "number")
          throw new TypeError("Start time must be set to a number.");
        a = x, this.hasBeenReset = !0;
      }
    },
    endTime: {
      enumerable: !0,
      get: function() {
        return s;
      },
      set: function(x) {
        if (typeof x != "number")
          throw new TypeError("End time must be set to a number.");
        s = x, this.hasBeenReset = !0;
      }
    },
    text: {
      enumerable: !0,
      get: function() {
        return o;
      },
      set: function(x) {
        o = "" + x, this.hasBeenReset = !0;
      }
    },
    region: {
      enumerable: !0,
      get: function() {
        return u;
      },
      set: function(x) {
        u = x, this.hasBeenReset = !0;
      }
    },
    vertical: {
      enumerable: !0,
      get: function() {
        return l;
      },
      set: function(x) {
        var E = KC(x);
        if (E === !1)
          throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
        l = E, this.hasBeenReset = !0;
      }
    },
    snapToLines: {
      enumerable: !0,
      get: function() {
        return c;
      },
      set: function(x) {
        c = !!x, this.hasBeenReset = !0;
      }
    },
    line: {
      enumerable: !0,
      get: function() {
        return h;
      },
      set: function(x) {
        if (typeof x != "number" && x !== XC)
          throw new SyntaxError("Line: an invalid number or illegal string was specified.");
        h = x, this.hasBeenReset = !0;
      }
    },
    lineAlign: {
      enumerable: !0,
      get: function() {
        return d;
      },
      set: function(x) {
        var E = sd(x);
        E ? (d = E, this.hasBeenReset = !0) : console.warn("lineAlign: an invalid or illegal string was specified.");
      }
    },
    position: {
      enumerable: !0,
      get: function() {
        return f;
      },
      set: function(x) {
        if (x < 0 || x > 100)
          throw new Error("Position must be between 0 and 100.");
        f = x, this.hasBeenReset = !0;
      }
    },
    positionAlign: {
      enumerable: !0,
      get: function() {
        return p;
      },
      set: function(x) {
        var E = sd(x);
        E ? (p = E, this.hasBeenReset = !0) : console.warn("positionAlign: an invalid or illegal string was specified.");
      }
    },
    size: {
      enumerable: !0,
      get: function() {
        return _;
      },
      set: function(x) {
        if (x < 0 || x > 100)
          throw new Error("Size must be between 0 and 100.");
        _ = x, this.hasBeenReset = !0;
      }
    },
    align: {
      enumerable: !0,
      get: function() {
        return m;
      },
      set: function(x) {
        var E = sd(x);
        if (!E)
          throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
        m = E, this.hasBeenReset = !0;
      }
    }
  }), this.displayState = void 0;
}
A_.prototype.getCueAsHTML = function() {
  return WebVTT.convertCueToDOMTree(window, this.text);
};
var ZC = A_, JC = {
  "": !0,
  up: !0
};
function $C(e) {
  if (typeof e != "string")
    return !1;
  var t = JC[e.toLowerCase()];
  return t ? e.toLowerCase() : !1;
}
function Zo(e) {
  return typeof e == "number" && e >= 0 && e <= 100;
}
function eM() {
  var e = 100, t = 3, i = 0, n = 100, r = 0, a = 100, s = "";
  Object.defineProperties(this, {
    width: {
      enumerable: !0,
      get: function() {
        return e;
      },
      set: function(o) {
        if (!Zo(o))
          throw new Error("Width must be between 0 and 100.");
        e = o;
      }
    },
    lines: {
      enumerable: !0,
      get: function() {
        return t;
      },
      set: function(o) {
        if (typeof o != "number")
          throw new TypeError("Lines must be set to a number.");
        t = o;
      }
    },
    regionAnchorY: {
      enumerable: !0,
      get: function() {
        return n;
      },
      set: function(o) {
        if (!Zo(o))
          throw new Error("RegionAnchorX must be between 0 and 100.");
        n = o;
      }
    },
    regionAnchorX: {
      enumerable: !0,
      get: function() {
        return i;
      },
      set: function(o) {
        if (!Zo(o))
          throw new Error("RegionAnchorY must be between 0 and 100.");
        i = o;
      }
    },
    viewportAnchorY: {
      enumerable: !0,
      get: function() {
        return a;
      },
      set: function(o) {
        if (!Zo(o))
          throw new Error("ViewportAnchorY must be between 0 and 100.");
        a = o;
      }
    },
    viewportAnchorX: {
      enumerable: !0,
      get: function() {
        return r;
      },
      set: function(o) {
        if (!Zo(o))
          throw new Error("ViewportAnchorX must be between 0 and 100.");
        r = o;
      }
    },
    scroll: {
      enumerable: !0,
      get: function() {
        return s;
      },
      set: function(o) {
        var u = $C(o);
        u === !1 ? console.warn("Scroll: an invalid or illegal string was specified.") : s = u;
      }
    }
  });
}
var tM = eM, Wn = ah, ys = b_.exports = {
  WebVTT: qC,
  VTTCue: ZC,
  VTTRegion: tM
};
Wn.vttjs = ys;
Wn.WebVTT = ys.WebVTT;
var iM = ys.VTTCue, rM = ys.VTTRegion, nM = Wn.VTTCue, aM = Wn.VTTRegion;
ys.shim = function() {
  Wn.VTTCue = iM, Wn.VTTRegion = rM;
};
ys.restore = function() {
  Wn.VTTCue = nM, Wn.VTTRegion = aM;
};
Wn.VTTCue || ys.shim();
var sM = b_.exports;
const Im = /* @__PURE__ */ Yn(sM);
/**
 * @license
 * Video.js 7.21.4 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
var T_ = "7.21.4", Ln = {}, va = function(t, i) {
  return Ln[t] = Ln[t] || [], i && (Ln[t] = Ln[t].concat(i)), Ln[t];
}, oM = function(t, i) {
  va(t, i);
}, E_ = function(t, i) {
  var n = va(t).indexOf(i);
  return n <= -1 ? !1 : (Ln[t] = Ln[t].slice(), Ln[t].splice(n, 1), !0);
}, uM = function(t, i) {
  va(
    t,
    [].concat(i).map(function(n) {
      var r = function a() {
        return E_(t, a), n.apply(void 0, arguments);
      };
      return r;
    })
  );
}, jc = {
  prefixed: !0
}, ic = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror",
    "fullscreen"
  ],
  // WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror",
    "-webkit-full-screen"
  ],
  // Mozilla
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror",
    "-moz-full-screen"
  ],
  // Microsoft
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError",
    "-ms-fullscreen"
  ]
], Om = ic[0], su;
for (var Wl = 0; Wl < ic.length; Wl++)
  if (ic[Wl][1] in Te) {
    su = ic[Wl];
    break;
  }
if (su) {
  for (var ql = 0; ql < su.length; ql++)
    jc[Om[ql]] = su[ql];
  jc.prefixed = su[0] !== Om[0];
}
var or = [], lM = function(t, i) {
  return function(n, r, a) {
    var s = i.levels[r], o = new RegExp("^(" + s + ")$");
    if (n !== "log" && a.unshift(n.toUpperCase() + ":"), a.unshift(t + ":"), or) {
      or.push([].concat(a));
      var u = or.length - 1e3;
      or.splice(0, u > 0 ? u : 0);
    }
    if (W.console) {
      var l = W.console[n];
      !l && n === "debug" && (l = W.console.info || W.console.log), !(!l || !s || !o.test(n)) && l[Array.isArray(a) ? "apply" : "call"](W.console, a);
    }
  };
};
function w_(e) {
  var t = "info", i, n = function() {
    for (var a = arguments.length, s = new Array(a), o = 0; o < a; o++)
      s[o] = arguments[o];
    i("log", t, s);
  };
  return i = lM(e, n), n.createLogger = function(r) {
    return w_(e + ": " + r);
  }, n.levels = {
    DEFAULT: t,
    all: "debug|log|warn|error",
    debug: "debug|log|warn|error",
    error: "error",
    info: "log|warn|error",
    off: "",
    warn: "warn|error"
  }, n.level = function(r) {
    if (typeof r == "string") {
      if (!n.levels.hasOwnProperty(r))
        throw new Error('"' + r + '" in not a valid log level');
      t = r;
    }
    return t;
  }, n.history = function() {
    return or ? [].concat(or) : [];
  }, n.history.filter = function(r) {
    return (or || []).filter(function(a) {
      return new RegExp(".*" + r + ".*").test(a[0]);
    });
  }, n.history.clear = function() {
    or && (or.length = 0);
  }, n.history.disable = function() {
    or !== null && (or.length = 0, or = null);
  }, n.history.enable = function() {
    or === null && (or = []);
  }, n.error = function() {
    for (var r = arguments.length, a = new Array(r), s = 0; s < r; s++)
      a[s] = arguments[s];
    return i("error", t, a);
  }, n.warn = function() {
    for (var r = arguments.length, a = new Array(r), s = 0; s < r; s++)
      a[s] = arguments[s];
    return i("warn", t, a);
  }, n.debug = function() {
    for (var r = arguments.length, a = new Array(r), s = 0; s < r; s++)
      a[s] = arguments[s];
    return i("debug", t, a);
  }, n;
}
var mt = w_("VIDEOJS"), S_ = mt.createLogger, cM = Object.prototype.toString, C_ = function(t) {
  return qn(t) ? Object.keys(t) : [];
};
function Bs(e, t) {
  C_(e).forEach(function(i) {
    return t(e[i], i);
  });
}
function hM(e, t, i) {
  return i === void 0 && (i = 0), C_(e).reduce(function(n, r) {
    return t(n, e[r], r);
  }, i);
}
function si(e) {
  for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    i[n - 1] = arguments[n];
  return Object.assign ? kr.apply(void 0, [e].concat(i)) : (i.forEach(function(r) {
    r && Bs(r, function(a, s) {
      e[s] = a;
    });
  }), e);
}
function qn(e) {
  return !!e && typeof e == "object";
}
function pl(e) {
  return qn(e) && cM.call(e) === "[object Object]" && e.constructor === Object;
}
function vl(e, t) {
  if (!e || !t)
    return "";
  if (typeof W.getComputedStyle == "function") {
    var i;
    try {
      i = W.getComputedStyle(e);
    } catch {
      return "";
    }
    return i ? i.getPropertyValue(t) || i[t] : "";
  }
  return "";
}
var Li = W.navigator && W.navigator.userAgent || "", km = /AppleWebKit\/([\d.]+)/i.exec(Li), dM = km ? parseFloat(km.pop()) : null, M_ = /iPod/i.test(Li), fM = function() {
  var e = Li.match(/OS (\d+)_/i);
  return e && e[1] ? e[1] : null;
}(), Jn = /Android/i.test(Li), Cp = function() {
  var e = Li.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
  if (!e)
    return null;
  var t = e[1] && parseFloat(e[1]), i = e[2] && parseFloat(e[2]);
  return t && i ? parseFloat(e[1] + "." + e[2]) : t || null;
}(), D_ = Jn && Cp < 5 && dM < 537, P_ = /Firefox/i.test(Li), Ml = /Edg/i.test(Li), $n = !Ml && (/Chrome/i.test(Li) || /CriOS/i.test(Li)), L_ = function() {
  var e = Li.match(/(Chrome|CriOS)\/(\d+)/);
  return e && e[2] ? parseFloat(e[2]) : null;
}(), Dl = function() {
  var e = /MSIE\s(\d+)\.\d/.exec(Li), t = e && parseFloat(e[1]);
  return !t && /Trident\/7.0/i.test(Li) && /rv:11.0/.test(Li) && (t = 11), t;
}(), Mp = /Safari/i.test(Li) && !$n && !Jn && !Ml, R_ = /Windows/i.test(Li), Co = !!(Bo() && ("ontouchstart" in W || W.navigator.maxTouchPoints || W.DocumentTouch && W.document instanceof W.DocumentTouch)), Dp = /iPad/i.test(Li) || Mp && Co && !/iPhone/i.test(Li), Pp = /iPhone/i.test(Li) && !Dp, cr = Pp || Dp || M_, Dh = (Mp || cr) && !$n, pM = /* @__PURE__ */ Object.freeze({
  ANDROID_VERSION: Cp,
  CHROME_VERSION: L_,
  IOS_VERSION: fM,
  IE_VERSION: Dl,
  IS_ANDROID: Jn,
  IS_CHROME: $n,
  IS_EDGE: Ml,
  IS_FIREFOX: P_,
  IS_IPOD: M_,
  IS_ANY_SAFARI: Dh,
  __proto__: null,
  IS_IOS: cr,
  IS_IPAD: Dp,
  IS_IPHONE: Pp,
  IS_NATIVE_ANDROID: D_,
  IS_SAFARI: Mp,
  IS_WINDOWS: R_,
  TOUCH_ENABLED: Co
});
function Bm(e) {
  return typeof e == "string" && !!e.trim();
}
function I_(e) {
  if (e.indexOf(" ") >= 0)
    throw new Error("class has illegal whitespace characters");
}
function vM(e) {
  return new RegExp("(^|\\s)" + e + "($|\\s)");
}
function Bo() {
  return Te === W.document;
}
function Fo(e) {
  return qn(e) && e.nodeType === 1;
}
function O_() {
  try {
    return W.parent !== W.self;
  } catch {
    return !0;
  }
}
function k_(e) {
  return function(t, i) {
    if (!Bm(t))
      return Te[e](null);
    Bm(i) && (i = Te.querySelector(i));
    var n = Fo(i) ? i : Te;
    return n[e] && n[e](t);
  };
}
function St(e, t, i, n) {
  e === void 0 && (e = "div"), t === void 0 && (t = {}), i === void 0 && (i = {});
  var r = Te.createElement(e);
  return Object.getOwnPropertyNames(t).forEach(function(a) {
    var s = t[a];
    a.indexOf("aria-") !== -1 || a === "role" || a === "type" ? (mt.warn(
      `Setting attributes in the second argument of createEl()
has been deprecated. Use the third argument instead.
` + ("createEl(type, properties, attributes). Attempting to set " + a + " to " + s + ".")
    ), r.setAttribute(a, s)) : a === "textContent" ? _s(r, s) : (r[a] !== s || a === "tabIndex") && (r[a] = s);
  }), Object.getOwnPropertyNames(i).forEach(function(a) {
    r.setAttribute(a, i[a]);
  }), n && Rp(r, n), r;
}
function tn(e) {
  return e.tagName === "CX-TOOLTIP" ? e.children[0] : e;
}
function _s(e, t) {
  return typeof e.textContent > "u" ? e.innerText = t : e.textContent = t, e;
}
function rf(e, t) {
  t.firstChild ? t.insertBefore(e, t.firstChild) : t.appendChild(e);
}
function Ua(e, t) {
  const i = tn(e);
  return I_(t), i.classList ? i.classList.contains(t) : vM(t).test(i.className);
}
function Un(e, t) {
  const i = tn(e);
  return i.classList ? i.classList.add(t) : Ua(i, t) || (i.className = (i.className + " " + t).trim()), i;
}
function Pl(e, t) {
  const i = tn(e);
  return i ? (i.classList ? i.classList.remove(t) : (I_(t), i.className = i.className.split(/\s+/).filter(function(n) {
    return n !== t;
  }).join(" ")), i) : (mt.warn("removeClass was called with an element that doesn't exist"), null);
}
function B_(e, t, i) {
  const n = tn(e);
  var r = Ua(n, t);
  if (typeof i == "function" && (i = i(n, t)), typeof i != "boolean" && (i = !r), i !== r)
    return i ? Un(n, t) : Pl(n, t), n;
}
function F_(e, t) {
  const i = tn(e);
  Object.getOwnPropertyNames(t).forEach(function(n) {
    var r = t[n];
    r === null || typeof r > "u" || r === !1 ? i.removeAttribute(n) : i.setAttribute(n, r === !0 ? "" : r);
  });
}
function Pn(e) {
  var t = {}, i = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,";
  if (e && e.attributes && e.attributes.length > 0)
    for (var n = e.attributes, r = n.length - 1; r >= 0; r--) {
      var a = n[r].name, s = n[r].value;
      (typeof e[a] == "boolean" || i.indexOf("," + a + ",") !== -1) && (s = s !== null), t[a] = s;
    }
  return t;
}
function N_(e, t) {
  return tn(e).getAttribute(t);
}
function Mo(e, t, i) {
  tn(e).setAttribute(t, i);
}
function Ph(e, t) {
  tn(e).removeAttribute(t);
}
function U_() {
  Te.body.focus(), Te.onselectstart = function() {
    return !1;
  };
}
function j_() {
  Te.onselectstart = function() {
    return !0;
  };
}
function Do(e) {
  if (e && e.getBoundingClientRect && e.parentNode) {
    var t = e.getBoundingClientRect(), i = {};
    return ["bottom", "height", "left", "right", "top", "width"].forEach(function(n) {
      t[n] !== void 0 && (i[n] = t[n]);
    }), i.height || (i.height = parseFloat(vl(e, "height"))), i.width || (i.width = parseFloat(vl(e, "width"))), i;
  }
}
function ml(e) {
  if (!e || e && !e.offsetParent)
    return {
      height: 0,
      left: 0,
      top: 0,
      width: 0
    };
  for (var t = e.offsetWidth, i = e.offsetHeight, n = 0, r = 0; e.offsetParent && e !== Te[jc.fullscreenElement]; )
    n += e.offsetLeft, r += e.offsetTop, e = e.offsetParent;
  return {
    height: i,
    left: n,
    top: r,
    width: t
  };
}
function Lh(e, t) {
  var i = {
    x: 0,
    y: 0
  };
  if (cr)
    for (var n = e; n && n.nodeName.toLowerCase() !== "html"; ) {
      var r = vl(n, "transform");
      if (/^matrix/.test(r)) {
        var a = r.slice(7, -1).split(/,\s/).map(Number);
        i.x += a[4], i.y += a[5];
      } else if (/^matrix3d/.test(r)) {
        var s = r.slice(9, -1).split(/,\s/).map(Number);
        i.x += s[12], i.y += s[13];
      }
      n = n.parentNode;
    }
  var o = {}, u = ml(t.target), l = ml(e), c = l.width, h = l.height, d = t.offsetY - (l.top - u.top), f = t.offsetX - (l.left - u.left);
  return t.changedTouches && (f = t.changedTouches[0].pageX - l.left, d = t.changedTouches[0].pageY + l.top, cr && (f -= i.x, d -= i.y)), o.y = 1 - Math.max(0, Math.min(1, d / h)), o.x = Math.max(0, Math.min(1, f / c)), o;
}
function G_(e) {
  return qn(e) && e.nodeType === 3;
}
function Lp(e) {
  const t = tn(e);
  for (; t.firstChild; )
    t.removeChild(t.firstChild);
  return t;
}
function V_(e) {
  return typeof e == "function" && (e = e()), (Array.isArray(e) ? e : [e]).map(function(t) {
    if (typeof t == "function" && (t = t()), Fo(t) || G_(t))
      return t;
    if (typeof t == "string" && /\S/.test(t))
      return Te.createTextNode(t);
  }).filter(function(t) {
    return t;
  });
}
function Rp(e, t) {
  const i = tn(e);
  return V_(t).forEach(function(n) {
    return i.appendChild(n);
  }), i;
}
function H_(e, t) {
  const i = tn(e);
  return Rp(Lp(i), t);
}
function gl(e) {
  return e.button === void 0 && e.buttons === void 0 || e.button === 0 && e.buttons === void 0 || e.type === "mouseup" && e.button === 0 && e.buttons === 0 ? !0 : !(e.button !== 0 || e.buttons !== 1);
}
var ma = k_("querySelector"), z_ = k_("querySelectorAll"), W_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  addClass: Un,
  createEl: St,
  hasClass: Ua,
  getAttribute: N_,
  isEl: Fo,
  getAttributes: Pn,
  isInFrame: O_,
  blockTextSelection: U_,
  isReal: Bo,
  getBoundingClientRect: Do,
  prependTo: rf,
  findPosition: ml,
  removeClass: Pl,
  emptyEl: Lp,
  textContent: _s,
  appendContent: Rp,
  getPointerPosition: Lh,
  setAttributes: F_,
  $: ma,
  toggleClass: B_,
  $$: z_,
  removeAttribute: Ph,
  insertContent: H_,
  setAttribute: Mo,
  isSingleLeftClick: gl,
  isTextNode: G_,
  unblockTextSelection: j_,
  normalizeContent: V_
}), q_ = !1, nf, mM = function() {
  if (nf.options.autoSetup !== !1) {
    var t = Array.prototype.slice.call(Te.getElementsByTagName("video")), i = Array.prototype.slice.call(
      Te.getElementsByTagName("audio")
    ), n = Array.prototype.slice.call(
      Te.getElementsByTagName("video-js")
    ), r = t.concat(i, n);
    if (r && r.length > 0)
      for (var a = 0, s = r.length; a < s; a++) {
        var o = r[a];
        if (o && o.getAttribute) {
          if (o.player === void 0) {
            var u = o.getAttribute("data-setup");
            u !== null && nf(o);
          }
        } else {
          af(1);
          break;
        }
      }
    else q_ || af(1);
  }
};
function af(e, t) {
  Bo() && (t && (nf = t), W.setTimeout(mM, e));
}
function sf() {
  q_ = !0, W.removeEventListener("load", sf);
}
Bo() && (Te.readyState === "complete" ? sf() : W.addEventListener("load", sf));
var X_ = function(t) {
  var i = Te.createElement("style");
  return i.className = t, i;
}, Y_ = function(t, i) {
  t.styleSheet ? t.styleSheet.cssText = i : t.textContent = i;
}, gM = 3, yM = gM;
function ea() {
  return yM++;
}
var Q_;
W.WeakMap || (Q_ = /* @__PURE__ */ function() {
  function e() {
    this.vdata = "vdata" + Math.floor(
      W.performance && W.performance.now() || Date.now()
    ), this.data = {};
  }
  var t = e.prototype;
  return t.set = function(n, r) {
    var a = n[this.vdata] || ea();
    return n[this.vdata] || (n[this.vdata] = a), this.data[a] = r, this;
  }, t.get = function(n) {
    var r = n[this.vdata];
    if (r)
      return this.data[r];
    mt("We have no data for this element", n);
  }, t.has = function(n) {
    var r = n[this.vdata];
    return r in this.data;
  }, t.delete = function(n) {
    var r = n[this.vdata];
    r && (delete this.data[r], delete n[this.vdata]);
  }, e;
}());
var ir = W.WeakMap ? /* @__PURE__ */ new WeakMap() : new Q_();
function Fm(e, t) {
  if (ir.has(e)) {
    var i = ir.get(e);
    i.handlers[t].length === 0 && (delete i.handlers[t], e.removeEventListener ? e.removeEventListener(t, i.dispatcher, !1) : e.detachEvent && e.detachEvent("on" + t, i.dispatcher)), Object.getOwnPropertyNames(i.handlers).length <= 0 && (delete i.handlers, delete i.dispatcher, delete i.disabled), Object.getOwnPropertyNames(i).length === 0 && ir.delete(e);
  }
}
function Ip(e, t, i, n) {
  i.forEach(function(r) {
    e(t, r, n);
  });
}
function Rh(e) {
  if (e.fixed_)
    return e;
  function t() {
    return !0;
  }
  function i() {
    return !1;
  }
  if (!e || !e.isPropagationStopped || !e.isImmediatePropagationStopped) {
    var n = e || W.event;
    e = {};
    for (var r in n)
      r !== "layerX" && r !== "layerY" && r !== "keyLocation" && r !== "webkitMovementX" && r !== "webkitMovementY" && r !== "path" && (r === "returnValue" && n.preventDefault || (e[r] = n[r]));
    if (e.target || (e.target = e.srcElement || Te), e.relatedTarget || (e.relatedTarget = e.fromElement === e.target ? e.toElement : e.fromElement), e.preventDefault = function() {
      n.preventDefault && n.preventDefault(), e.returnValue = !1, n.returnValue = !1, e.defaultPrevented = !0;
    }, e.defaultPrevented = !1, e.stopPropagation = function() {
      n.stopPropagation && n.stopPropagation(), e.cancelBubble = !0, n.cancelBubble = !0, e.isPropagationStopped = t;
    }, e.isPropagationStopped = i, e.stopImmediatePropagation = function() {
      n.stopImmediatePropagation && n.stopImmediatePropagation(), e.isImmediatePropagationStopped = t, e.stopPropagation();
    }, e.isImmediatePropagationStopped = i, e.clientX !== null && e.clientX !== void 0) {
      var a = Te.documentElement, s = Te.body;
      e.pageX = e.clientX + (a && a.scrollLeft || s && s.scrollLeft || 0) - (a && a.clientLeft || s && s.clientLeft || 0), e.pageY = e.clientY + (a && a.scrollTop || s && s.scrollTop || 0) - (a && a.clientTop || s && s.clientTop || 0);
    }
    e.which = e.charCode || e.keyCode, e.button !== null && e.button !== void 0 && (e.button = e.button & 1 ? 0 : e.button & 4 ? 1 : e.button & 2 ? 2 : 0);
  }
  return e.fixed_ = !0, e;
}
var Xl, _M = function() {
  if (typeof Xl != "boolean") {
    Xl = !1;
    try {
      var t = Object.defineProperty({}, "passive", {
        get: function() {
          Xl = !0;
        }
      });
      W.addEventListener("test", null, t), W.removeEventListener("test", null, t);
    } catch {
    }
  }
  return Xl;
}, bM = ["touchstart", "touchmove"];
function Pr(e, t, i) {
  if (Array.isArray(t))
    return Ip(Pr, e, t, i);
  ir.has(e) || ir.set(e, {});
  var n = ir.get(e);
  if (n.handlers || (n.handlers = {}), n.handlers[t] || (n.handlers[t] = []), i.guid || (i.guid = ea()), n.handlers[t].push(i), n.dispatcher || (n.disabled = !1, n.dispatcher = function(a, s) {
    if (!n.disabled) {
      a = Rh(a);
      var o = n.handlers[a.type];
      if (o)
        for (var u = o.slice(0), l = 0, c = u.length; l < c && !a.isImmediatePropagationStopped(); l++)
          try {
            u[l].call(e, a, s);
          } catch (h) {
            mt.error(h);
          }
    }
  }), n.handlers[t].length === 1)
    if (e.addEventListener) {
      var r = !1;
      _M() && bM.indexOf(t) > -1 && (r = {
        passive: !0
      }), e.addEventListener(t, n.dispatcher, r);
    } else e.attachEvent && e.attachEvent("on" + t, n.dispatcher);
}
function Hi(e, t, i) {
  if (ir.has(e)) {
    var n = ir.get(e);
    if (n.handlers) {
      if (Array.isArray(t))
        return Ip(Hi, e, t, i);
      var r = function(l, c) {
        n.handlers[c] = [], Fm(l, c);
      };
      if (t === void 0) {
        for (var a in n.handlers)
          Object.prototype.hasOwnProperty.call(n.handlers || {}, a) && r(e, a);
        return;
      }
      var s = n.handlers[t];
      if (s) {
        if (!i) {
          r(e, t);
          return;
        }
        if (i.guid)
          for (var o = 0; o < s.length; o++)
            s[o].guid === i.guid && s.splice(o--, 1);
        Fm(e, t);
      }
    }
  }
}
function No(e, t, i) {
  var n = ir.has(e) ? ir.get(e) : {}, r = e.parentNode || e.ownerDocument;
  if (typeof t == "string" ? t = {
    target: e,
    type: t
  } : t.target || (t.target = e), t = Rh(t), n.dispatcher && n.dispatcher.call(e, t, i), r && !t.isPropagationStopped() && t.bubbles === !0)
    No.call(null, r, t, i);
  else if (!r && !t.defaultPrevented && t.target && t.target[t.type]) {
    ir.has(t.target) || ir.set(t.target, {});
    var a = ir.get(t.target);
    t.target[t.type] && (a.disabled = !0, typeof t.target[t.type] == "function" && t.target[t.type](), a.disabled = !1);
  }
  return !t.defaultPrevented;
}
function Ih(e, t, i) {
  if (Array.isArray(t))
    return Ip(Ih, e, t, i);
  var n = function r() {
    Hi(e, t, r), i.apply(this, arguments);
  };
  n.guid = i.guid = i.guid || ea(), Pr(e, t, n);
}
function K_(e, t, i) {
  var n = function r() {
    Hi(e, t, r), i.apply(this, arguments);
  };
  n.guid = i.guid = i.guid || ea(), Pr(e, t, n);
}
var xM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  any: K_,
  fixEvent: Rh,
  off: Hi,
  on: Pr,
  one: Ih,
  trigger: No
}), $r = 30, Zt = function(t, i, n) {
  i.guid || (i.guid = ea());
  var r = i.bind(t);
  return r.guid = n ? n + "_" + i.guid : i.guid, r;
}, Xn = function(t, i) {
  var n = W.performance.now(), r = function() {
    var s = W.performance.now();
    s - n >= i && (t.apply(void 0, arguments), n = s);
  };
  return r;
}, AM = function(t, i, n, r) {
  r === void 0 && (r = W);
  var a, s = function() {
    r.clearTimeout(a), a = null;
  }, o = function() {
    var l = this, c = arguments, h = function() {
      a = null, h = null, t.apply(l, c);
    };
    r.clearTimeout(a), a = r.setTimeout(h, i);
  };
  return o.cancel = s, o;
}, Ii = function() {
};
Ii.prototype.allowedEvents_ = {};
Ii.prototype.on = function(e, t) {
  var i = this.addEventListener;
  this.addEventListener = function() {
  }, Pr(this, e, t), this.addEventListener = i;
};
Ii.prototype.addEventListener = Ii.prototype.on;
Ii.prototype.off = function(e, t) {
  Hi(this, e, t);
};
Ii.prototype.removeEventListener = Ii.prototype.off;
Ii.prototype.one = function(e, t) {
  var i = this.addEventListener;
  this.addEventListener = function() {
  }, Ih(this, e, t), this.addEventListener = i;
};
Ii.prototype.any = function(e, t) {
  var i = this.addEventListener;
  this.addEventListener = function() {
  }, K_(this, e, t), this.addEventListener = i;
};
Ii.prototype.trigger = function(e) {
  var t = e.type || e;
  typeof e == "string" && (e = {
    type: t
  }), e = Rh(e), this.allowedEvents_[t] && this["on" + t] && this["on" + t](e), No(this, e);
};
Ii.prototype.dispatchEvent = Ii.prototype.trigger;
var Jo;
Ii.prototype.queueTrigger = function(e) {
  var t = this;
  Jo || (Jo = /* @__PURE__ */ new Map());
  var i = e.type || e, n = Jo.get(this);
  n || (n = /* @__PURE__ */ new Map(), Jo.set(this, n));
  var r = n.get(i);
  n.delete(i), W.clearTimeout(r);
  var a = W.setTimeout(function() {
    n.delete(i), n.size === 0 && (n = null, Jo.delete(t)), t.trigger(e);
  }, 0);
  n.set(i, a);
};
var Oh = function(t) {
  return typeof t.name == "function" ? t.name() : typeof t.name == "string" ? t.name : t.name_ ? t.name_ : t.constructor && t.constructor.name ? t.constructor.name : typeof t;
}, jn = function(t) {
  return t instanceof Ii || !!t.eventBusEl_ && ["on", "one", "off", "trigger"].every(function(i) {
    return typeof t[i] == "function";
  });
}, TM = function(t, i) {
  jn(t) ? i() : (t.eventedCallbacks || (t.eventedCallbacks = []), t.eventedCallbacks.push(i));
}, of = function(t) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof t == "string" && /\S/.test(t) || Array.isArray(t) && !!t.length
  );
}, Gc = function(t, i, n) {
  if (!t || !t.nodeName && !jn(t))
    throw new Error(
      "Invalid target for " + Oh(i) + "#" + n + "; must be a DOM node or evented object."
    );
}, Z_ = function(t, i, n) {
  if (!of(t))
    throw new Error(
      "Invalid event type for " + Oh(i) + "#" + n + "; must be a non-empty string or array."
    );
}, J_ = function(t, i, n) {
  if (typeof t != "function")
    throw new Error(
      "Invalid listener for " + Oh(i) + "#" + n + "; must be a function."
    );
}, od = function(t, i, n) {
  var r = i.length < 3 || i[0] === t || i[0] === t.eventBusEl_, a, s, o;
  return r ? (a = t.eventBusEl_, i.length >= 3 && i.shift(), s = i[0], o = i[1]) : (a = i[0], s = i[1], o = i[2]), Gc(a, t, n), Z_(s, t, n), J_(o, t, n), o = Zt(t, o), {
    isTargetingSelf: r,
    listener: o,
    target: a,
    type: s
  };
}, Da = function(t, i, n, r) {
  Gc(t, t, i), t.nodeName ? xM[i](t, n, r) : t[i](n, r);
}, EM = {
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once for the first event that is triggered
   * then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  any: function() {
    for (var t = this, i = arguments.length, n = new Array(i), r = 0; r < i; r++)
      n[r] = arguments[r];
    var a = od(this, n, "any"), s = a.isTargetingSelf, o = a.target, u = a.type, l = a.listener;
    if (s)
      Da(o, "any", u, l);
    else {
      var c = function h() {
        t.off(o, u, h);
        for (var d = arguments.length, f = new Array(d), p = 0; p < d; p++)
          f[p] = arguments[p];
        l.apply(null, f);
      };
      c.guid = l.guid, Da(o, "any", u, c);
    }
  },
  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function(t, i, n) {
    if (!t || of(t))
      Hi(this.eventBusEl_, t, i);
    else {
      var r = t, a = i;
      Gc(r, this, "off"), Z_(a, this, "off"), J_(n, this, "off"), n = Zt(this, n), this.off("dispose", n), r.nodeName ? (Hi(r, a, n), Hi(r, "dispose", n)) : jn(r) && (r.off(a, n), r.off("dispose", n));
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function() {
    for (var t = this, i = arguments.length, n = new Array(i), r = 0; r < i; r++)
      n[r] = arguments[r];
    var a = od(this, n, "on"), s = a.isTargetingSelf, o = a.target, u = a.type, l = a.listener;
    if (Da(o, "on", u, l), !s) {
      var c = function() {
        return t.off(o, u, l);
      };
      c.guid = l.guid;
      var h = function() {
        return t.off("dispose", c);
      };
      h.guid = l.guid, Da(this, "on", "dispose", c), Da(o, "on", "dispose", h);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will be called once per event and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function() {
    for (var t = this, i = arguments.length, n = new Array(i), r = 0; r < i; r++)
      n[r] = arguments[r];
    var a = od(this, n, "one"), s = a.isTargetingSelf, o = a.target, u = a.type, l = a.listener;
    if (s)
      Da(o, "one", u, l);
    else {
      var c = function h() {
        t.off(o, u, h);
        for (var d = arguments.length, f = new Array(d), p = 0; p < d; p++)
          f[p] = arguments[p];
        l.apply(null, f);
      };
      c.guid = l.guid, Da(o, "one", u, c);
    }
  },
  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @return {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function(t, i) {
    Gc(this.eventBusEl_, this, "trigger");
    var n = t && typeof t != "string" ? t.type : t;
    if (!of(n)) {
      var r = "Invalid event type for " + Oh(this) + "#trigger; must be a non-empty string or object with a type key that has a non-empty value.";
      if (t)
        (this.log || mt).error(r);
      else
        throw new Error(r);
    }
    return No(this.eventBusEl_, t, i);
  }
};
function Op(e, t) {
  t === void 0 && (t = {});
  var i = t, n = i.eventBusKey;
  if (n) {
    if (!e[n].nodeName)
      throw new Error(
        'The eventBusKey "' + n + '" does not refer to an element.'
      );
    e.eventBusEl_ = e[n];
  } else
    e.eventBusEl_ = St("span", {
      className: "vjs-event-bus"
    });
  return si(e, EM), e.eventedCallbacks && e.eventedCallbacks.forEach(function(r) {
    r();
  }), e.on("dispose", function() {
    e.off(), [e, e.el_, e.eventBusEl_].forEach(function(r) {
      r && ir.has(r) && ir.delete(r);
    }), W.setTimeout(function() {
      e.eventBusEl_ = null;
    }, 0);
  }), e;
}
var wM = {
  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @return {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function(t) {
    var i = this;
    typeof t == "function" && (t = t());
    var n;
    return Bs(t, function(r, a) {
      i.state[a] !== r && (n = n || {}, n[a] = {
        from: i.state[a],
        to: r
      }), i.state[a] = r;
    }), n && jn(this) && this.trigger({
      changes: n,
      type: "statechanged"
    }), n;
  },
  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {}
};
function $_(e, t) {
  return si(e, wM), e.state = si({}, e.state, t), typeof e.handleStateChanged == "function" && jn(e) && e.on("statechanged", e.handleStateChanged), e;
}
var rc = function(t) {
  return typeof t != "string" ? t : t.replace(/./, function(i) {
    return i.toLowerCase();
  });
}, vi = function(t) {
  return typeof t != "string" ? t : t.replace(/./, function(i) {
    return i.toUpperCase();
  });
}, SM = function(t, i) {
  return vi(t) === vi(i);
};
function Kt() {
  for (var e = {}, t = arguments.length, i = new Array(t), n = 0; n < t; n++)
    i[n] = arguments[n];
  return i.forEach(function(r) {
    r && Bs(r, function(a, s) {
      if (!pl(a)) {
        e[s] = a;
        return;
      }
      pl(e[s]) || (e[s] = {}), e[s] = Kt(e[s], a);
    });
  }), e;
}
var CM = /* @__PURE__ */ function() {
  function e() {
    this.map_ = {};
  }
  var t = e.prototype;
  return t.has = function(n) {
    return n in this.map_;
  }, t.delete = function(n) {
    var r = this.has(n);
    return delete this.map_[n], r;
  }, t.set = function(n, r) {
    return this.map_[n] = r, this;
  }, t.forEach = function(n, r) {
    for (var a in this.map_)
      n.call(r, this.map_[a], a, this);
  }, e;
}(), MM = W.Map ? W.Map : CM, DM = /* @__PURE__ */ function() {
  function e() {
    this.set_ = {};
  }
  var t = e.prototype;
  return t.has = function(n) {
    return n in this.set_;
  }, t.delete = function(n) {
    var r = this.has(n);
    return delete this.set_[n], r;
  }, t.add = function(n) {
    return this.set_[n] = 1, this;
  }, t.forEach = function(n, r) {
    for (var a in this.set_)
      n.call(r, a, a, this);
  }, e;
}(), ud = W.Set ? W.Set : DM, ye = /* @__PURE__ */ function() {
  function e(i, n, r) {
    var a = this;
    if (!i && this.play ? this.player_ = i = this : this.player_ = i, this.isDisposed_ = !1, this.parentComponent_ = null, this.options_ = Kt({}, this.options_), n = this.options_ = Kt(this.options_, n), this.id_ = n.id || n.el && n.el.id, !this.id_) {
      var s = i && i.id && i.id() || "no_player";
      this.id_ = s + "_component_" + ea();
    }
    this.name_ = n.name || null, n.el ? this.el_ = n.el : n.createEl !== !1 && (this.el_ = this.createEl()), n.className && this.el_ && n.className.split(" ").forEach(function(o) {
      return a.addClass(o);
    }), n.evented !== !1 && (Op(this, {
      eventBusKey: this.el_ ? "el_" : null
    }), this.handleLanguagechange = this.handleLanguagechange.bind(this), this.on(this.player_, "languagechange", this.handleLanguagechange)), $_(this, this.constructor.defaultState), this.children_ = [], this.childIndex_ = {}, this.childNameIndex_ = {}, this.setTimeoutIds_ = new ud(), this.setIntervalIds_ = new ud(), this.rafIds_ = new ud(), this.namedRafs_ = new MM(), this.clearingTimersOnDispose_ = !1, n.initChildren !== !1 && this.initChildren(), this.ready(r), n.reportTouchActivity !== !1 && this.enableTouchActivity();
  }
  var t = e.prototype;
  return t.dispose = function(n) {
    if (n === void 0 && (n = {}), !this.isDisposed_) {
      if (this.readyQueue_ && (this.readyQueue_.length = 0), this.trigger({
        bubbles: !1,
        type: "dispose"
      }), this.isDisposed_ = !0, this.children_)
        for (var r = this.children_.length - 1; r >= 0; r--)
          this.children_[r].dispose && this.children_[r].dispose();
      this.children_ = null, this.childIndex_ = null, this.childNameIndex_ = null, this.parentComponent_ = null, this.el_ && (this.el_.parentNode && (n.restoreEl ? this.el_.parentNode.replaceChild(n.restoreEl, this.el_) : this.el_.parentNode.removeChild(this.el_)), this.el_ = null), this.player_ = null;
    }
  }, t.isDisposed = function() {
    return !!this.isDisposed_;
  }, t.player = function() {
    return this.player_;
  }, t.options = function(n) {
    return n ? (this.options_ = Kt(this.options_, n), this.options_) : this.options_;
  }, t.el = function() {
    return this.el_;
  }, t.createEl = function(n, r, a) {
    return St(n, r, a);
  }, t.localize = function(n, r, a) {
    a === void 0 && (a = n);
    var s = this.player_.language && this.player_.language(), o = this.player_.languages && this.player_.languages(), u = o && o[s], l = s && s.split("-")[0], c = o && o[l], h = a;
    return u && u[n] ? h = u[n] : c && c[n] && (h = c[n]), r && (h = h.replace(
      /\{(\d+)\}/g,
      function(d, f) {
        var p = r[f - 1], _ = p;
        return typeof p > "u" && (_ = d), _;
      }
    )), h;
  }, t.handleLanguagechange = function() {
  }, t.contentEl = function() {
    return this.contentEl_ || this.el_;
  }, t.id = function() {
    return this.id_;
  }, t.name = function() {
    return this.name_;
  }, t.children = function() {
    return this.children_;
  }, t.getChildById = function(n) {
    return this.childIndex_[n];
  }, t.getChild = function(n) {
    if (n)
      return this.childNameIndex_[n];
  }, t.getDescendant = function() {
    for (var n = arguments.length, r = new Array(n), a = 0; a < n; a++)
      r[a] = arguments[a];
    r = r.reduce(function(u, l) {
      return u.concat(l);
    }, []);
    for (var s = this, o = 0; o < r.length; o++)
      if (s = s.getChild(r[o]), !s || !s.getChild)
        return;
    return s;
  }, t.addChild = function(n, r, a) {
    r === void 0 && (r = {}), a === void 0 && (a = this.children_.length);
    var s, o;
    if (typeof n == "string") {
      o = vi(n);
      var u = r.componentClass || o;
      r.name = o;
      var l = e.getComponent(u);
      if (!l)
        throw new Error("Component " + u + " does not exist");
      if (typeof l != "function")
        return null;
      s = new l(this.player_ || this, r);
    } else
      s = n;
    if (s.parentComponent_ && s.parentComponent_.removeChild(s), this.children_.splice(a, 0, s), s.parentComponent_ = this, typeof s.id == "function" && (this.childIndex_[s.id()] = s), o = o || s.name && vi(s.name()), o && (this.childNameIndex_[o] = s, this.childNameIndex_[rc(o)] = s), typeof s.el == "function" && s.el()) {
      var c = null;
      this.children_[a + 1] && (this.children_[a + 1].el_ ? c = this.children_[a + 1].el_ : Fo(this.children_[a + 1]) && (c = this.children_[a + 1])), this.contentEl().insertBefore(s.el(), c);
    }
    return s;
  }, t.removeChild = function(n) {
    if (typeof n == "string" && (n = this.getChild(n)), !(!n || !this.children_)) {
      for (var r = !1, a = this.children_.length - 1; a >= 0; a--)
        if (this.children_[a] === n) {
          r = !0, this.children_.splice(a, 1);
          break;
        }
      if (r) {
        n.parentComponent_ = null, this.childIndex_[n.id()] = null, this.childNameIndex_[vi(n.name())] = null, this.childNameIndex_[rc(n.name())] = null;
        var s = n.el();
        s && s.parentNode === this.contentEl() && this.contentEl().removeChild(n.el());
      }
    }
  }, t.initChildren = function() {
    var n = this, r = this.options_.children;
    if (r) {
      var a = this.options_, s = function(c) {
        var h = c.name, d = c.opts;
        if (a[h] !== void 0 && (d = a[h]), d !== !1) {
          d === !0 && (d = {}), d.playerOptions = n.options_.playerOptions;
          var f = n.addChild(h, d);
          f && (n[h] = f);
        }
      }, o, u = e.getComponent("Tech");
      Array.isArray(r) ? o = r : o = Object.keys(r), o.concat(
        Object.keys(this.options_).filter(function(l) {
          return !o.some(function(c) {
            return typeof c == "string" ? l === c : l === c.name;
          });
        })
      ).map(function(l) {
        var c, h;
        return typeof l == "string" ? (c = l, h = r[c] || n.options_[c] || {}) : (c = l.name, h = l), {
          name: c,
          opts: h
        };
      }).filter(function(l) {
        var c = e.getComponent(
          l.opts.componentClass || vi(l.name)
        );
        return c && !u.isTech(c);
      }).forEach(s);
    }
  }, t.buildCSSClass = function() {
    return "";
  }, t.ready = function(n, r) {
    if (r === void 0 && (r = !1), !!n) {
      if (!this.isReady_) {
        this.readyQueue_ = this.readyQueue_ || [], this.readyQueue_.push(n);
        return;
      }
      r ? n.call(this) : this.setTimeout(n, 1);
    }
  }, t.triggerReady = function() {
    this.isReady_ = !0, this.setTimeout(function() {
      var n = this.readyQueue_;
      this.readyQueue_ = [], n && n.length > 0 && n.forEach(function(r) {
        r.call(this);
      }, this), this.trigger("ready");
    }, 1);
  }, t.$ = function(n, r) {
    return ma(n, r || this.contentEl());
  }, t.$$ = function(n, r) {
    return z_(n, r || this.contentEl());
  }, t.hasClass = function(n) {
    return Ua(this.el_, n);
  }, t.addClass = function(n) {
    Un(this.el_, n);
  }, t.removeClass = function(n) {
    Pl(this.el_, n);
  }, t.toggleClass = function(n, r) {
    B_(this.el_, n, r);
  }, t.show = function() {
    this.removeClass("vjs-hidden");
  }, t.hide = function() {
    this.addClass("vjs-hidden");
  }, t.lockShowing = function() {
    this.addClass("vjs-lock-showing");
  }, t.unlockShowing = function() {
    this.removeClass("vjs-lock-showing");
  }, t.getAttribute = function(n) {
    return N_(this.el_, n);
  }, t.setAttribute = function(n, r) {
    Mo(this.el_, n, r);
  }, t.removeAttribute = function(n) {
    Ph(this.el_, n);
  }, t.width = function(n, r) {
    return this.dimension("width", n, r);
  }, t.height = function(n, r) {
    return this.dimension("height", n, r);
  }, t.dimensions = function(n, r) {
    this.width(n, !0), this.height(r);
  }, t.dimension = function(n, r, a) {
    if (r !== void 0) {
      (r === null || r !== r) && (r = 0), ("" + r).indexOf("%") !== -1 || ("" + r).indexOf("px") !== -1 ? this.el_.style[n] = r : r === "auto" ? this.el_.style[n] = "" : this.el_.style[n] = r + "px", a || this.trigger("componentresize");
      return;
    }
    if (!this.el_)
      return 0;
    var s = this.el_.style[n], o = s.indexOf("px");
    return parseInt(o !== -1 ? s.slice(0, o) : this.el_["offset" + vi(n)], 10);
  }, t.currentDimension = function(n) {
    var r = 0;
    if (n !== "width" && n !== "height")
      throw new Error("currentDimension only accepts width or height value");
    if (r = vl(this.el_, n), r = parseFloat(r), r === 0 || isNaN(r)) {
      var a = "offset" + vi(n);
      r = this.el_[a];
    }
    return r;
  }, t.currentDimensions = function() {
    return {
      height: this.currentDimension("height"),
      width: this.currentDimension("width")
    };
  }, t.currentWidth = function() {
    return this.currentDimension("width");
  }, t.currentHeight = function() {
    return this.currentDimension("height");
  }, t.focus = function() {
    this.el_.focus();
  }, t.blur = function() {
    this.el_.blur();
  }, t.handleKeyDown = function(n) {
    this.player_ && (lt.isEventKey(n, "Tab") || n.stopPropagation(), this.player_.handleKeyDown(n));
  }, t.handleKeyPress = function(n) {
    this.handleKeyDown(n);
  }, t.emitTapEvents = function() {
    var n = 0, r = null, a = 10, s = 200, o;
    this.on("touchstart", function(l) {
      l.touches.length === 1 && (r = {
        pageX: l.touches[0].pageX,
        pageY: l.touches[0].pageY
      }, n = W.performance.now(), o = !0);
    }), this.on("touchmove", function(l) {
      if (l.touches.length > 1)
        o = !1;
      else if (r) {
        var c = l.touches[0].pageX - r.pageX, h = l.touches[0].pageY - r.pageY, d = Math.sqrt(c * c + h * h);
        d > a && (o = !1);
      }
    });
    var u = function() {
      o = !1;
    };
    this.on("touchleave", u), this.on("touchcancel", u), this.on("touchend", function(l) {
      if (r = null, o === !0) {
        var c = W.performance.now() - n;
        c < s && (l.preventDefault(), this.trigger("tap"));
      }
    });
  }, t.enableTouchActivity = function() {
    if (!(!this.player() || !this.player().reportUserActivity)) {
      var n = Zt(this.player(), this.player().reportUserActivity), r;
      this.on("touchstart", function() {
        n(), this.clearInterval(r), r = this.setInterval(n, 250);
      });
      var a = function(o) {
        n(), this.clearInterval(r);
      };
      this.on("touchmove", n), this.on("touchend", a), this.on("touchcancel", a);
    }
  }, t.setTimeout = function(n, r) {
    var a = this, s;
    return n = Zt(this, n), this.clearTimersOnDispose_(), s = W.setTimeout(function() {
      a.setTimeoutIds_.has(s) && a.setTimeoutIds_.delete(s), n();
    }, r), this.setTimeoutIds_.add(s), s;
  }, t.clearTimeout = function(n) {
    return this.setTimeoutIds_.has(n) && (this.setTimeoutIds_.delete(n), W.clearTimeout(n)), n;
  }, t.setInterval = function(n, r) {
    n = Zt(this, n), this.clearTimersOnDispose_();
    var a = W.setInterval(n, r);
    return this.setIntervalIds_.add(a), a;
  }, t.clearInterval = function(n) {
    return this.setIntervalIds_.has(n) && (this.setIntervalIds_.delete(n), W.clearInterval(n)), n;
  }, t.requestAnimationFrame = function(n) {
    var r = this;
    if (!this.supportsRaf_)
      return this.setTimeout(n, 1e3 / 60);
    this.clearTimersOnDispose_();
    var a;
    return n = Zt(this, n), a = W.requestAnimationFrame(function() {
      r.rafIds_.has(a) && r.rafIds_.delete(a), n();
    }), this.rafIds_.add(a), a;
  }, t.requestNamedAnimationFrame = function(n, r) {
    var a = this;
    if (!this.namedRafs_.has(n)) {
      this.clearTimersOnDispose_(), r = Zt(this, r);
      var s = this.requestAnimationFrame(function() {
        r(), a.namedRafs_.has(n) && a.namedRafs_.delete(n);
      });
      return this.namedRafs_.set(n, s), n;
    }
  }, t.cancelNamedAnimationFrame = function(n) {
    this.namedRafs_.has(n) && (this.cancelAnimationFrame(this.namedRafs_.get(n)), this.namedRafs_.delete(n));
  }, t.cancelAnimationFrame = function(n) {
    return this.supportsRaf_ ? (this.rafIds_.has(n) && (this.rafIds_.delete(n), W.cancelAnimationFrame(n)), n) : this.clearTimeout(n);
  }, t.clearTimersOnDispose_ = function() {
    var n = this;
    this.clearingTimersOnDispose_ || (this.clearingTimersOnDispose_ = !0, this.one("dispose", function() {
      [
        ["namedRafs_", "cancelNamedAnimationFrame"],
        ["rafIds_", "cancelAnimationFrame"],
        ["setTimeoutIds_", "clearTimeout"],
        ["setIntervalIds_", "clearInterval"]
      ].forEach(function(r) {
        var a = r[0], s = r[1];
        n[a].forEach(function(o, u) {
          return n[s](u);
        });
      }), n.clearingTimersOnDispose_ = !1;
    }));
  }, e.registerComponent = function(n, r) {
    if (typeof n != "string" || !n)
      throw new Error(
        'Illegal component name, "' + n + '"; must be a non-empty string.'
      );
    var a = e.getComponent("Tech"), s = a && a.isTech(r), o = e === r || e.prototype.isPrototypeOf(r.prototype);
    if (s || !o) {
      var u;
      throw s ? u = "techs must be registered using Tech.registerTech()" : u = "must be a Component subclass", new Error('Illegal component, "' + n + '"; ' + u + ".");
    }
    n = vi(n), e.components_ || (e.components_ = {});
    var l = e.getComponent("Player");
    if (n === "Player" && l && l.players) {
      var c = l.players, h = Object.keys(c);
      if (c && h.length > 0 && h.map(function(d) {
        return c[d];
      }).every(Boolean))
        throw new Error(
          "Can not register Player component after player has been created."
        );
    }
    return e.components_[n] = r, e.components_[rc(n)] = r, r;
  }, e.getComponent = function(n) {
    if (!(!n || !e.components_))
      return e.components_[n];
  }, e;
}();
ye.prototype.supportsRaf_ = typeof W.requestAnimationFrame == "function" && typeof W.cancelAnimationFrame == "function";
ye.registerComponent("Component", ye);
function PM(e, t, i) {
  if (typeof t != "number" || t < 0 || t > i)
    throw new Error(
      "Failed to execute '" + e + "' on 'TimeRanges': The index provided (" + t + ") is non-numeric or out of bounds (0-" + i + ")."
    );
}
function Nm(e, t, i, n) {
  return PM(e, n, i.length - 1), i[n][t];
}
function ld(e) {
  var t;
  return e === void 0 || e.length === 0 ? t = {
    end: function() {
      throw new Error("This TimeRanges object is empty");
    },
    length: 0,
    start: function() {
      throw new Error("This TimeRanges object is empty");
    }
  } : t = {
    end: Nm.bind(null, "end", 1, e),
    length: e.length,
    start: Nm.bind(null, "start", 0, e)
  }, W.Symbol && W.Symbol.iterator && (t[W.Symbol.iterator] = function() {
    return (e || []).values();
  }), t;
}
function ja(e, t) {
  return Array.isArray(e) ? ld(e) : e === void 0 || t === void 0 ? ld() : ld([[e, t]]);
}
function eb(e, t) {
  var i = 0, n, r;
  if (!t)
    return 0;
  (!e || !e.length) && (e = ja(0, 0));
  for (var a = 0; a < e.length; a++)
    n = e.start(a), r = e.end(a), r > t && (r = t), i += r - n;
  return i / t;
}
function rr(e) {
  if (e instanceof rr)
    return e;
  typeof e == "number" ? this.code = e : typeof e == "string" ? this.message = e : qn(e) && (typeof e.code == "number" && (this.code = e.code), si(this, e)), this.message || (this.message = rr.defaultMessages[this.code] || "");
}
rr.prototype.code = 0;
rr.prototype.message = "";
rr.prototype.status = null;
rr.errorTypes = [
  "MEDIA_ERR_CUSTOM",
  "MEDIA_ERR_ABORTED",
  "MEDIA_ERR_NETWORK",
  "MEDIA_ERR_DECODE",
  "MEDIA_ERR_SRC_NOT_SUPPORTED",
  "MEDIA_ERR_ENCRYPTED"
];
rr.defaultMessages = {
  1: "You aborted the media playback",
  2: "A network error caused the media download to fail part-way.",
  3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
  4: "The media could not be loaded, either because the server or network failed, or because the format is not supported, or asset is still processing.",
  5: "The media is encrypted and we do not have the keys to decrypt it."
};
for (var Ds = 0; Ds < rr.errorTypes.length; Ds++)
  rr[rr.errorTypes[Ds]] = Ds, rr.prototype[rr.errorTypes[Ds]] = Ds;
function du(e) {
  return e != null && typeof e.then == "function";
}
function hn(e) {
  du(e) && e.then(null, function(t) {
  });
}
var uf = function(t) {
  var i = [
    "kind",
    "label",
    "language",
    "id",
    "inBandMetadataTrackDispatchType",
    "mode",
    "src"
  ].reduce(
    function(n, r, a) {
      return t[r] && (n[r] = t[r]), n;
    },
    {
      cues: t.cues && Array.prototype.map.call(t.cues, function(n) {
        return {
          endTime: n.endTime,
          id: n.id,
          startTime: n.startTime,
          text: n.text
        };
      })
    }
  );
  return i;
}, LM = function(t) {
  var i = t.$$("track"), n = Array.prototype.map.call(i, function(a) {
    return a.track;
  }), r = Array.prototype.map.call(i, function(a) {
    var s = uf(a.track);
    return a.src && (s.src = a.src), s;
  });
  return r.concat(
    Array.prototype.filter.call(t.textTracks(), function(a) {
      return n.indexOf(a) === -1;
    }).map(uf)
  );
}, RM = function(t, i) {
  return t.forEach(function(n) {
    var r = i.addRemoteTextTrack(n).track;
    !n.src && n.cues && n.cues.forEach(function(a) {
      return r.addCue(a);
    });
  }), i.textTracks();
}, Um = {
  jsonToTextTracks: RM,
  textTracksToJson: LM,
  trackToJson_: uf
}, cd = "vjs-modal-dialog", Uo = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.handleKeyDown_ = function(s) {
      return a.handleKeyDown(s);
    }, a.close_ = function(s) {
      return a.close(s);
    }, a.opened_ = a.hasBeenOpened_ = a.hasBeenFilled_ = !1, a.closeable(!a.options_.uncloseable), a.content(a.options_.content), a.contentEl_ = St(
      "div",
      {
        className: cd + "-content"
      },
      {
        role: "document"
      }
    ), a.descEl_ = St("p", {
      className: cd + "-description vjs-control-text",
      id: a.el().getAttribute("aria-describedby")
    }), _s(a.descEl_, a.description()), a.el_.appendChild(a.descEl_), a.el_.appendChild(a.contentEl_), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: this.buildCSSClass(),
        tabIndex: -1
      },
      {
        "aria-describedby": this.id() + "_description",
        "aria-hidden": "true",
        "aria-label": this.label(),
        role: "dialog"
      }
    );
  }, i.dispose = function() {
    this.contentEl_ = null, this.descEl_ = null, this.previouslyActiveEl_ = null, e.prototype.dispose.call(this);
  }, i.buildCSSClass = function() {
    return cd + " vjs-hidden " + e.prototype.buildCSSClass.call(this);
  }, i.label = function() {
    return this.localize(this.options_.label || "Modal Window");
  }, i.description = function() {
    var r = this.options_.description || this.localize("This is a modal window.");
    return this.closeable() && (r += " " + this.localize(
      "This modal can be closed by pressing the Escape key or activating the close button."
    )), r;
  }, i.open = function() {
    if (!this.opened_) {
      var r = this.player();
      this.trigger("beforemodalopen"), this.opened_ = !0, (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) && this.fill(), this.wasPlaying_ = !r.paused(), this.options_.pauseOnOpen && this.wasPlaying_ && r.pause(), this.on("keydown", this.handleKeyDown_), this.hadControls_ = r.controls(), r.controls(!1), this.show(), this.conditionalFocus_(), this.el().setAttribute("aria-hidden", "false"), this.trigger("modalopen"), this.hasBeenOpened_ = !0;
    }
  }, i.opened = function(r) {
    return typeof r == "boolean" && this[r ? "open" : "close"](), this.opened_;
  }, i.close = function() {
    if (this.opened_) {
      var r = this.player();
      this.trigger("beforemodalclose"), this.opened_ = !1, this.wasPlaying_ && this.options_.pauseOnOpen && r.play(), this.off("keydown", this.handleKeyDown_), this.hadControls_ && r.controls(!0), this.hide(), this.el().setAttribute("aria-hidden", "true"), this.trigger("modalclose"), this.conditionalBlur_(), this.options_.temporary && this.dispose();
    }
  }, i.closeable = function(r) {
    if (typeof r == "boolean") {
      var a = this.closeable_ = !!r, s = this.getChild("closeButton");
      if (a && !s) {
        var o = this.contentEl_;
        this.contentEl_ = this.el_, s = this.addChild("closeButton", {
          controlText: "Close Modal Dialog"
        }), this.contentEl_ = o, this.on(s, "close", this.close_);
      }
      !a && s && (this.off(s, "close", this.close_), this.removeChild(s), s.dispose());
    }
    return this.closeable_;
  }, i.fill = function() {
    this.fillWith(this.content());
  }, i.fillWith = function(r) {
    var a = this.contentEl(), s = a.parentNode, o = a.nextSibling;
    this.trigger("beforemodalfill"), this.hasBeenFilled_ = !0, s.removeChild(a), this.empty(), H_(a, r), this.trigger("modalfill"), o ? s.insertBefore(a, o) : s.appendChild(a);
    var u = this.getChild("closeButton");
    u && s.appendChild(u.el_);
  }, i.empty = function() {
    this.trigger("beforemodalempty"), Lp(this.contentEl()), this.trigger("modalempty");
  }, i.content = function(r) {
    return typeof r < "u" && (this.content_ = r), this.content_;
  }, i.conditionalFocus_ = function() {
    var r = Te.activeElement, a = this.player_.el_;
    this.previouslyActiveEl_ = null, (a.contains(r) || a === r) && (this.previouslyActiveEl_ = r, this.focus());
  }, i.conditionalBlur_ = function() {
    this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(), this.previouslyActiveEl_ = null);
  }, i.handleKeyDown = function(r) {
    if (r.stopPropagation(), lt.isEventKey(r, "Escape") && this.closeable()) {
      r.preventDefault(), this.close();
      return;
    }
    if (lt.isEventKey(r, "Tab")) {
      for (var a = this.focusableEls_(), s = this.el_.querySelector(":focus"), o, u = 0; u < a.length; u++)
        if (s === a[u]) {
          o = u;
          break;
        }
      Te.activeElement === this.el_ && (o = 0), r.shiftKey && o === 0 ? (a[a.length - 1].focus(), r.preventDefault()) : !r.shiftKey && o === a.length - 1 && (a[0].focus(), r.preventDefault());
    }
  }, i.focusableEls_ = function() {
    var r = this.el_.querySelectorAll("*");
    return Array.prototype.filter.call(r, function(a) {
      return (a instanceof W.HTMLAnchorElement || a instanceof W.HTMLAreaElement) && a.hasAttribute("href") || (a instanceof W.HTMLInputElement || a instanceof W.HTMLSelectElement || a instanceof W.HTMLTextAreaElement || a instanceof W.HTMLButtonElement) && !a.hasAttribute("disabled") || a instanceof W.HTMLIFrameElement || a instanceof W.HTMLObjectElement || a instanceof W.HTMLEmbedElement || a.hasAttribute("tabindex") && a.getAttribute("tabindex") !== -1 || a.hasAttribute("contenteditable");
    });
  }, t;
}(ye);
Uo.prototype.options_ = {
  pauseOnOpen: !0,
  temporary: !0
};
ye.registerComponent("ModalDialog", Uo);
var Po = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var r;
    n === void 0 && (n = []), r = e.call(this) || this, r.tracks_ = [], Object.defineProperty(He(r), "length", {
      get: function() {
        return this.tracks_.length;
      }
    });
    for (var a = 0; a < n.length; a++)
      r.addTrack(n[a]);
    return r;
  }
  var i = t.prototype;
  return i.addTrack = function(r) {
    var a = this, s = this.tracks_.length;
    "" + s in this || Object.defineProperty(this, s, {
      get: function() {
        return this.tracks_[s];
      }
    }), this.tracks_.indexOf(r) === -1 && (this.tracks_.push(r), this.trigger({
      target: this,
      track: r,
      type: "addtrack"
    })), r.labelchange_ = function() {
      a.trigger({
        target: a,
        track: r,
        type: "labelchange"
      });
    }, jn(r) && r.addEventListener("labelchange", r.labelchange_);
  }, i.removeTrack = function(r) {
    for (var a, s = 0, o = this.length; s < o; s++)
      if (this[s] === r) {
        a = this[s], a.off && a.off(), this.tracks_.splice(s, 1);
        break;
      }
    a && this.trigger({
      target: this,
      track: a,
      type: "removetrack"
    });
  }, i.getTrackById = function(r) {
    for (var a = null, s = 0, o = this.length; s < o; s++) {
      var u = this[s];
      if (u.id === r) {
        a = u;
        break;
      }
    }
    return a;
  }, t;
}(Ii);
Po.prototype.allowedEvents_ = {
  addtrack: "addtrack",
  change: "change",
  labelchange: "labelchange",
  removetrack: "removetrack"
};
for (var IM in Po.prototype.allowedEvents_)
  Po.prototype["on" + IM] = null;
var hd = function(t, i) {
  for (var n = 0; n < t.length; n++)
    !Object.keys(t[n]).length || i.id === t[n].id || (t[n].enabled = !1);
}, OM = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var r;
    n === void 0 && (n = []);
    for (var a = n.length - 1; a >= 0; a--)
      if (n[a].enabled) {
        hd(n, n[a]);
        break;
      }
    return r = e.call(this, n) || this, r.changing_ = !1, r;
  }
  var i = t.prototype;
  return i.addTrack = function(r) {
    var a = this;
    r.enabled && hd(this, r), e.prototype.addTrack.call(this, r), r.addEventListener && (r.enabledChange_ = function() {
      a.changing_ || (a.changing_ = !0, hd(a, r), a.changing_ = !1, a.trigger("change"));
    }, r.addEventListener("enabledchange", r.enabledChange_));
  }, i.removeTrack = function(r) {
    e.prototype.removeTrack.call(this, r), r.removeEventListener && r.enabledChange_ && (r.removeEventListener("enabledchange", r.enabledChange_), r.enabledChange_ = null);
  }, t;
}(Po), dd = function(t, i) {
  for (var n = 0; n < t.length; n++)
    !Object.keys(t[n]).length || i.id === t[n].id || (t[n].selected = !1);
}, kM = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var r;
    n === void 0 && (n = []);
    for (var a = n.length - 1; a >= 0; a--)
      if (n[a].selected) {
        dd(n, n[a]);
        break;
      }
    return r = e.call(this, n) || this, r.changing_ = !1, Object.defineProperty(He(r), "selectedIndex", {
      get: function() {
        for (var o = 0; o < this.length; o++)
          if (this[o].selected)
            return o;
        return -1;
      },
      set: function() {
      }
    }), r;
  }
  var i = t.prototype;
  return i.addTrack = function(r) {
    var a = this;
    r.selected && dd(this, r), e.prototype.addTrack.call(this, r), r.addEventListener && (r.selectedChange_ = function() {
      a.changing_ || (a.changing_ = !0, dd(a, r), a.changing_ = !1, a.trigger("change"));
    }, r.addEventListener("selectedchange", r.selectedChange_));
  }, i.removeTrack = function(r) {
    e.prototype.removeTrack.call(this, r), r.removeEventListener && r.selectedChange_ && (r.removeEventListener("selectedchange", r.selectedChange_), r.selectedChange_ = null);
  }, t;
}(Po), tb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.addTrack = function(r) {
    var a = this;
    e.prototype.addTrack.call(this, r), this.queueChange_ || (this.queueChange_ = function() {
      return a.queueTrigger("change");
    }), this.triggerSelectedlanguagechange || (this.triggerSelectedlanguagechange_ = function() {
      return a.trigger("selectedlanguagechange");
    }), r.addEventListener("modechange", this.queueChange_);
    var s = ["metadata", "chapters"];
    s.indexOf(r.kind) === -1 && r.addEventListener("modechange", this.triggerSelectedlanguagechange_);
  }, i.removeTrack = function(r) {
    e.prototype.removeTrack.call(this, r), r.removeEventListener && (this.queueChange_ && r.removeEventListener("modechange", this.queueChange_), this.selectedlanguagechange_ && r.removeEventListener(
      "modechange",
      this.triggerSelectedlanguagechange_
    ));
  }, t;
}(Po), BM = /* @__PURE__ */ function() {
  function e(i) {
    i === void 0 && (i = []), this.trackElements_ = [], Object.defineProperty(this, "length", {
      get: function() {
        return this.trackElements_.length;
      }
    });
    for (var n = 0, r = i.length; n < r; n++)
      this.addTrackElement_(i[n]);
  }
  var t = e.prototype;
  return t.addTrackElement_ = function(n) {
    var r = this.trackElements_.length;
    "" + r in this || Object.defineProperty(this, r, {
      get: function() {
        return this.trackElements_[r];
      }
    }), this.trackElements_.indexOf(n) === -1 && this.trackElements_.push(n);
  }, t.getTrackElementByTrack_ = function(n) {
    for (var r, a = 0, s = this.trackElements_.length; a < s; a++)
      if (n === this.trackElements_[a].track) {
        r = this.trackElements_[a];
        break;
      }
    return r;
  }, t.removeTrackElement_ = function(n) {
    for (var r = 0, a = this.trackElements_.length; r < a; r++)
      if (n === this.trackElements_[r]) {
        this.trackElements_[r].track && typeof this.trackElements_[r].track.off == "function" && this.trackElements_[r].track.off(), typeof this.trackElements_[r].off == "function" && this.trackElements_[r].off(), this.trackElements_.splice(r, 1);
        break;
      }
  }, e;
}(), jm = /* @__PURE__ */ function() {
  function e(i) {
    e.prototype.setCues_.call(this, i), Object.defineProperty(this, "length", {
      get: function() {
        return this.length_;
      }
    });
  }
  var t = e.prototype;
  return t.setCues_ = function(n) {
    var r = this.length || 0, a = 0, s = n.length;
    this.cues_ = n, this.length_ = n.length;
    var o = function(l) {
      "" + l in this || Object.defineProperty(this, "" + l, {
        get: function() {
          return this.cues_[l];
        }
      });
    };
    if (r < s)
      for (a = r; a < s; a++)
        o.call(this, a);
  }, t.getCueById = function(n) {
    for (var r = null, a = 0, s = this.length; a < s; a++) {
      var o = this[a];
      if (o.id === n) {
        r = o;
        break;
      }
    }
    return r;
  }, e;
}(), FM = {
  alternative: "alternative",
  captions: "captions",
  commentary: "commentary",
  main: "main",
  sign: "sign",
  subtitles: "subtitles"
}, NM = {
  alternative: "alternative",
  commentary: "commentary",
  descriptions: "descriptions",
  main: "main",
  "main-desc": "main-desc",
  translation: "translation"
}, UM = {
  captions: "captions",
  chapters: "chapters",
  descriptions: "descriptions",
  metadata: "metadata",
  subtitles: "subtitles"
}, Gm = {
  disabled: "disabled",
  hidden: "hidden",
  showing: "showing"
}, kp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(i) {
    var n;
    i === void 0 && (i = {}), n = e.call(this) || this;
    var r = {
      id: i.id || "vjs_track_" + ea(),
      kind: i.kind || "",
      language: i.language || ""
    }, a = i.label || "", s = function(l) {
      Object.defineProperty(He(n), l, {
        get: function() {
          return r[l];
        },
        set: function() {
        }
      });
    };
    for (var o in r)
      s(o);
    return Object.defineProperty(He(n), "label", {
      get: function() {
        return a;
      },
      set: function(l) {
        l !== a && (a = l, this.trigger("labelchange"));
      }
    }), n;
  }
  return t;
}(Ii), Bp = function(t) {
  var i = [
    "protocol",
    "hostname",
    "port",
    "pathname",
    "search",
    "hash",
    "host"
  ], n = Te.createElement("a");
  n.href = t;
  for (var r = {}, a = 0; a < i.length; a++)
    r[i[a]] = n[i[a]];
  return r.protocol === "http:" && (r.host = r.host.replace(/:80$/, "")), r.protocol === "https:" && (r.host = r.host.replace(/:443$/, "")), r.protocol || (r.protocol = W.location.protocol), r.host || (r.host = W.location.host), r;
}, ib = function(t) {
  if (!t.match(/^https?:\/\//)) {
    var i = Te.createElement("a");
    i.href = t, t = i.href;
  }
  return t;
}, Fp = function(t) {
  if (typeof t == "string") {
    var i = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/, n = i.exec(t);
    if (n)
      return n.pop().toLowerCase();
  }
  return "";
}, kh = function(t, i) {
  i === void 0 && (i = W.location);
  var n = Bp(t), r = n.protocol === ":" ? i.protocol : n.protocol, a = r + n.host !== i.protocol + i.host;
  return a;
}, jM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getAbsoluteURL: ib,
  getFileExtension: Fp,
  isCrossOrigin: kh,
  parseUrl: Bp
}), Vm = function(t, i) {
  var n = new W.WebVTT.Parser(
    W,
    W.vttjs,
    W.WebVTT.StringDecoder()
  ), r = [];
  n.oncue = function(a) {
    i.addCue(a);
  }, n.onparsingerror = function(a) {
    r.push(a);
  }, n.onflush = function() {
    i.trigger({
      target: i,
      type: "loadeddata"
    });
  }, n.parse(t), r.length > 0 && (W.console && W.console.groupCollapsed && W.console.groupCollapsed(
    "Text Track parsing errors for " + i.src
  ), r.forEach(function(a) {
    return mt.error(a);
  }), W.console && W.console.groupEnd && W.console.groupEnd()), n.flush();
}, Hm = function(t, i) {
  var n = {
    uri: t
  }, r = kh(t);
  r && (n.cors = r);
  var a = i.tech_.crossOrigin() === "use-credentials";
  a && (n.withCredentials = a), Iy(
    n,
    Zt(this, function(s, o, u) {
      if (s)
        return mt.error(s, o);
      i.loaded_ = !0, typeof W.WebVTT != "function" ? i.tech_ && i.tech_.any(["vttjsloaded", "vttjserror"], function(l) {
        if (l.type === "vttjserror") {
          mt.error(
            "vttjs failed to load, stopping trying to process " + i.src
          );
          return;
        }
        return Vm(u, i);
      }) : Vm(u, i);
    })
  );
}, Ll = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var r;
    if (n === void 0 && (n = {}), !n.tech)
      throw new Error("A tech was not provided.");
    var a = Kt(n, {
      kind: UM[n.kind] || "subtitles",
      language: n.language || n.srclang || ""
    }), s = Gm[a.mode] || "disabled", o = a.default;
    (a.kind === "metadata" || a.kind === "chapters") && (s = "hidden"), r = e.call(this, a) || this, r.tech_ = a.tech, r.cues_ = [], r.activeCues_ = [], r.preload_ = r.tech_.preloadTextTracks !== !1;
    var u = new jm(r.cues_), l = new jm(r.activeCues_), c = !1;
    r.timeupdateHandler = Zt(
      He(r),
      function(d) {
        if (d === void 0 && (d = {}), !this.tech_.isDisposed()) {
          if (!this.tech_.isReady_) {
            d.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(
              this.timeupdateHandler
            ));
            return;
          }
          this.activeCues = this.activeCues, c && (this.trigger("cuechange"), c = !1), d.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(
            this.timeupdateHandler
          ));
        }
      }
    );
    var h = function() {
      r.stopTracking();
    };
    return r.tech_.one("dispose", h), s !== "disabled" && r.startTracking(), Object.defineProperties(He(r), {
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} activeCues
       *         The list text track cues that are currently active for this TextTrack.
       * @instance
       */
      activeCues: {
        get: function() {
          if (!this.loaded_)
            return null;
          if (this.cues.length === 0)
            return l;
          for (var f = this.tech_.currentTime(), p = [], _ = 0, m = this.cues.length; _ < m; _++) {
            var x = this.cues[_];
            (x.startTime <= f && x.endTime >= f || x.startTime === x.endTime && x.startTime <= f && x.startTime + 0.5 >= f) && p.push(x);
          }
          if (c = !1, p.length !== this.activeCues_.length)
            c = !0;
          else
            for (var E = 0; E < p.length; E++)
              this.activeCues_.indexOf(p[E]) === -1 && (c = !0);
          return this.activeCues_ = p, l.setCues_(this.activeCues_), l;
        },
        // /!\ Keep this setter empty (see the timeupdate handler above)
        set: function() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} cues
       *         The text track cue list for this TextTrack.
       * @instance
       */
      cues: {
        get: function() {
          return this.loaded_ ? u : null;
        },
        set: function() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {boolean} default
       *         If this track was set to be on or off by default. Cannot be changed after
       *         creation.
       * @instance
       *
       * @readonly
       */
      default: {
        get: function() {
          return o;
        },
        set: function() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {string} mode
       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
       *         not be set if setting to an invalid mode.
       * @instance
       *
       * @fires TextTrack#modechange
       */
      mode: {
        get: function() {
          return s;
        },
        set: function(f) {
          Gm[f] && s !== f && (s = f, !this.preload_ && s !== "disabled" && this.cues.length === 0 && Hm(this.src, this), this.stopTracking(), s !== "disabled" && this.startTracking(), this.trigger("modechange"));
        }
      }
    }), a.src ? (r.src = a.src, r.preload_ || (r.loaded_ = !0), (r.preload_ || a.kind !== "subtitles" && a.kind !== "captions") && Hm(r.src, He(r))) : r.loaded_ = !0, r;
  }
  var i = t.prototype;
  return i.startTracking = function() {
    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler), this.tech_.on("timeupdate", this.timeupdateHandler);
  }, i.stopTracking = function() {
    this.rvf_ && (this.tech_.cancelVideoFrameCallback(this.rvf_), this.rvf_ = void 0), this.tech_.off("timeupdate", this.timeupdateHandler);
  }, i.addCue = function(r) {
    var a = r;
    if (W.vttjs && !(r instanceof W.vttjs.VTTCue)) {
      a = new W.vttjs.VTTCue(
        r.startTime,
        r.endTime,
        r.text
      );
      for (var s in r)
        s in a || (a[s] = r[s]);
      a.id = r.id, a.originalCue_ = r;
    }
    for (var o = this.tech_.textTracks(), u = 0; u < o.length; u++)
      o[u] !== this && o[u].removeCue(a);
    this.cues_.push(a), this.cues.setCues_(this.cues_);
  }, i.removeCue = function(r) {
    for (var a = this.cues_.length; a--; ) {
      var s = this.cues_[a];
      if (s === r || s.originalCue_ && s.originalCue_ === r) {
        this.cues_.splice(a, 1), this.cues.setCues_(this.cues_);
        break;
      }
    }
  }, t;
}(kp);
Ll.prototype.allowedEvents_ = {
  cuechange: "cuechange"
};
var rb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(i) {
    var n;
    i === void 0 && (i = {});
    var r = Kt(i, {
      kind: NM[i.kind] || ""
    });
    n = e.call(this, r) || this;
    var a = !1;
    return Object.defineProperty(He(n), "enabled", {
      get: function() {
        return a;
      },
      set: function(o) {
        typeof o != "boolean" || o === a || (a = o, this.trigger("enabledchange"));
      }
    }), r.enabled && (n.enabled = r.enabled), n.loaded_ = !0, n;
  }
  return t;
}(kp), nb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(i) {
    var n;
    i === void 0 && (i = {});
    var r = Kt(i, {
      kind: FM[i.kind] || ""
    });
    n = e.call(this, r) || this;
    var a = !1;
    return Object.defineProperty(He(n), "selected", {
      get: function() {
        return a;
      },
      set: function(o) {
        typeof o != "boolean" || o === a || (a = o, this.trigger("selectedchange"));
      }
    }), r.selected && (n.selected = r.selected), n;
  }
  return t;
}(kp), ab = 0, GM = 1, sb = 2, VM = 3, jo = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(i) {
    var n;
    i === void 0 && (i = {}), n = e.call(this) || this;
    var r, a = new Ll(i);
    return n.kind = a.kind, n.src = a.src, n.srclang = a.language, n.label = a.label, n.default = a.default, Object.defineProperties(He(n), {
      /**
       * @memberof HTMLTrackElement
       * @member {HTMLTrackElement~ReadyState} readyState
       *         The current ready state of the track element.
       * @instance
       */
      readyState: {
        get: function() {
          return r;
        }
      },
      /**
       * @memberof HTMLTrackElement
       * @member {TextTrack} track
       *         The underlying TextTrack object.
       * @instance
       *
       */
      track: {
        get: function() {
          return a;
        }
      }
    }), r = ab, a.addEventListener("loadeddata", function() {
      r = sb, n.trigger({
        target: He(n),
        type: "load"
      });
    }), n;
  }
  return t;
}(Ii);
jo.prototype.allowedEvents_ = {
  load: "load"
};
jo.NONE = ab;
jo.LOADING = GM;
jo.LOADED = sb;
jo.ERROR = VM;
var Or = {
  audio: {
    ListClass: OM,
    TrackClass: rb,
    capitalName: "Audio"
  },
  text: {
    ListClass: tb,
    TrackClass: Ll,
    capitalName: "Text"
  },
  video: {
    ListClass: kM,
    TrackClass: nb,
    capitalName: "Video"
  }
};
Object.keys(Or).forEach(function(e) {
  Or[e].getterName = e + "Tracks", Or[e].privateName = e + "Tracks_";
});
var Lo = {
  remoteText: {
    ListClass: tb,
    TrackClass: Ll,
    capitalName: "RemoteText",
    getterName: "remoteTextTracks",
    privateName: "remoteTextTracks_"
  },
  remoteTextEl: {
    ListClass: BM,
    TrackClass: jo,
    capitalName: "RemoteTextTrackEls",
    getterName: "remoteTextTrackEls",
    privateName: "remoteTextTrackEls_"
  }
}, Ji = kr({}, Or, Lo);
Lo.names = Object.keys(Lo);
Or.names = Object.keys(Or);
Ji.names = [].concat(Lo.names).concat(Or.names);
function HM(e, t, i, n, r) {
  r === void 0 && (r = {});
  var a = e.textTracks();
  r.kind = t, i && (r.label = i), n && (r.language = n), r.tech = e;
  var s = new Ji.text.TrackClass(r);
  return a.addTrack(s), s;
}
var Wt = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return n === void 0 && (n = {}), r === void 0 && (r = function() {
    }), n.reportTouchActivity = !1, a = e.call(this, null, n, r) || this, a.onDurationChange_ = function(s) {
      return a.onDurationChange(s);
    }, a.trackProgress_ = function(s) {
      return a.trackProgress(s);
    }, a.trackCurrentTime_ = function(s) {
      return a.trackCurrentTime(s);
    }, a.stopTrackingCurrentTime_ = function(s) {
      return a.stopTrackingCurrentTime(s);
    }, a.disposeSourceHandler_ = function(s) {
      return a.disposeSourceHandler(s);
    }, a.queuedHanders_ = /* @__PURE__ */ new Set(), a.hasStarted_ = !1, a.on("playing", function() {
      this.hasStarted_ = !0;
    }), a.on("loadstart", function() {
      this.hasStarted_ = !1;
    }), Ji.names.forEach(function(s) {
      var o = Ji[s];
      n && n[o.getterName] && (a[o.privateName] = n[o.getterName]);
    }), a.featuresProgressEvents || a.manualProgressOn(), a.featuresTimeupdateEvents || a.manualTimeUpdatesOn(), ["Text", "Audio", "Video"].forEach(function(s) {
      n["native" + s + "Tracks"] === !1 && (a["featuresNative" + s + "Tracks"] = !1);
    }), n.nativeCaptions === !1 || n.nativeTextTracks === !1 ? a.featuresNativeTextTracks = !1 : (n.nativeCaptions === !0 || n.nativeTextTracks === !0) && (a.featuresNativeTextTracks = !0), a.featuresNativeTextTracks || a.emulateTextTracks(), a.preloadTextTracks = n.preloadTextTracks !== !1, a.autoRemoteTextTracks_ = new Ji.text.ListClass(), a.initTrackListeners(), n.nativeControlsForTouch || a.emitTapEvents(), a.constructor && (a.name_ = a.constructor.name || "Unknown Tech"), a;
  }
  var i = t.prototype;
  return i.triggerSourceset = function(r) {
    var a = this;
    this.isReady_ || this.one("ready", function() {
      return a.setTimeout(function() {
        return a.triggerSourceset(r);
      }, 1);
    }), this.trigger({
      src: r,
      type: "sourceset"
    });
  }, i.manualProgressOn = function() {
    this.on("durationchange", this.onDurationChange_), this.manualProgress = !0, this.one("ready", this.trackProgress_);
  }, i.manualProgressOff = function() {
    this.manualProgress = !1, this.stopTrackingProgress(), this.off("durationchange", this.onDurationChange_);
  }, i.trackProgress = function(r) {
    this.stopTrackingProgress(), this.progressInterval = this.setInterval(
      Zt(this, function() {
        var a = this.bufferedPercent();
        this.bufferedPercent_ !== a && this.trigger("progress"), this.bufferedPercent_ = a, a === 1 && this.stopTrackingProgress();
      }),
      500
    );
  }, i.onDurationChange = function(r) {
    this.duration_ = this.duration();
  }, i.buffered = function() {
    return ja(0, 0);
  }, i.bufferedPercent = function() {
    return eb(this.buffered(), this.duration_);
  }, i.stopTrackingProgress = function() {
    this.clearInterval(this.progressInterval);
  }, i.manualTimeUpdatesOn = function() {
    this.manualTimeUpdates = !0, this.on("play", this.trackCurrentTime_), this.on("pause", this.stopTrackingCurrentTime_);
  }, i.manualTimeUpdatesOff = function() {
    this.manualTimeUpdates = !1, this.stopTrackingCurrentTime(), this.off("play", this.trackCurrentTime_), this.off("pause", this.stopTrackingCurrentTime_);
  }, i.trackCurrentTime = function() {
    this.currentTimeInterval && this.stopTrackingCurrentTime(), this.currentTimeInterval = this.setInterval(function() {
      this.trigger({
        manuallyTriggered: !0,
        target: this,
        type: "timeupdate"
      });
    }, 250);
  }, i.stopTrackingCurrentTime = function() {
    this.clearInterval(this.currentTimeInterval), this.trigger({
      manuallyTriggered: !0,
      target: this,
      type: "timeupdate"
    });
  }, i.dispose = function() {
    this.clearTracks(Or.names), this.manualProgress && this.manualProgressOff(), this.manualTimeUpdates && this.manualTimeUpdatesOff(), e.prototype.dispose.call(this);
  }, i.clearTracks = function(r) {
    var a = this;
    r = [].concat(r), r.forEach(function(s) {
      for (var o = a[s + "Tracks"]() || [], u = o.length; u--; ) {
        var l = o[u];
        s === "text" && a.removeRemoteTextTrack(l), o.removeTrack(l);
      }
    });
  }, i.cleanupAutoTextTracks = function() {
    for (var r = this.autoRemoteTextTracks_ || [], a = r.length; a--; ) {
      var s = r[a];
      this.removeRemoteTextTrack(s);
    }
  }, i.reset = function() {
  }, i.crossOrigin = function() {
  }, i.setCrossOrigin = function() {
  }, i.error = function(r) {
    return r !== void 0 && (this.error_ = new rr(r), this.trigger("error")), this.error_;
  }, i.played = function() {
    return this.hasStarted_ ? ja(0, 0) : ja();
  }, i.play = function() {
  }, i.setScrubbing = function() {
  }, i.scrubbing = function() {
  }, i.setCurrentTime = function() {
    this.manualTimeUpdates && this.trigger({
      manuallyTriggered: !0,
      target: this,
      type: "timeupdate"
    });
  }, i.initTrackListeners = function() {
    var r = this;
    Or.names.forEach(function(a) {
      var s = Or[a], o = function() {
        r.trigger(a + "trackchange");
      }, u = r[s.getterName]();
      u.addEventListener("removetrack", o), u.addEventListener("addtrack", o), r.on("dispose", function() {
        u.removeEventListener("removetrack", o), u.removeEventListener("addtrack", o);
      });
    });
  }, i.addWebVttScript_ = function() {
    var r = this;
    if (!W.WebVTT)
      if (Te.body.contains(this.el())) {
        if (!this.options_["vtt.js"] && pl(Im) && Object.keys(Im).length > 0) {
          this.trigger("vttjsloaded");
          return;
        }
        var a = Te.createElement("script");
        a.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js", a.onload = function() {
          r.trigger("vttjsloaded");
        }, a.onerror = function() {
          r.trigger("vttjserror");
        }, this.on("dispose", function() {
          a.onload = null, a.onerror = null;
        }), W.WebVTT = !0, this.el().parentNode.appendChild(a);
      } else
        this.ready(this.addWebVttScript_);
  }, i.emulateTextTracks = function() {
    var r = this, a = this.textTracks(), s = this.remoteTextTracks(), o = function(d) {
      return a.addTrack(d.track);
    }, u = function(d) {
      return a.removeTrack(d.track);
    };
    s.on("addtrack", o), s.on("removetrack", u), this.addWebVttScript_();
    var l = function() {
      return r.trigger("texttrackchange");
    }, c = function() {
      l();
      for (var d = 0; d < a.length; d++) {
        var f = a[d];
        f.removeEventListener("cuechange", l), f.mode === "showing" && f.addEventListener("cuechange", l);
      }
    };
    c(), a.addEventListener("change", c), a.addEventListener("addtrack", c), a.addEventListener("removetrack", c), this.on("dispose", function() {
      s.off("addtrack", o), s.off("removetrack", u), a.removeEventListener("change", c), a.removeEventListener("addtrack", c), a.removeEventListener("removetrack", c);
      for (var h = 0; h < a.length; h++) {
        var d = a[h];
        d.removeEventListener("cuechange", l);
      }
    });
  }, i.addTextTrack = function(r, a, s) {
    if (!r)
      throw new Error("TextTrack kind is required but was not provided");
    return HM(this, r, a, s);
  }, i.createRemoteTextTrack = function(r) {
    var a = Kt(r, {
      tech: this
    });
    return new Lo.remoteTextEl.TrackClass(a);
  }, i.addRemoteTextTrack = function(r, a) {
    var s = this;
    r === void 0 && (r = {});
    var o = this.createRemoteTextTrack(r);
    return a !== !0 && a !== !1 && (mt.warn(
      'Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js'
    ), a = !0), this.remoteTextTrackEls().addTrackElement_(o), this.remoteTextTracks().addTrack(o.track), a !== !0 && this.ready(function() {
      return s.autoRemoteTextTracks_.addTrack(o.track);
    }), o;
  }, i.removeRemoteTextTrack = function(r) {
    var a = this.remoteTextTrackEls().getTrackElementByTrack_(r);
    this.remoteTextTrackEls().removeTrackElement_(a), this.remoteTextTracks().removeTrack(r), this.autoRemoteTextTracks_.removeTrack(r);
  }, i.getVideoPlaybackQuality = function() {
    return {};
  }, i.requestPictureInPicture = function() {
    var r = this.options_.Promise || W.Promise;
    if (r)
      return r.reject();
  }, i.disablePictureInPicture = function() {
    return !0;
  }, i.setDisablePictureInPicture = function() {
  }, i.requestVideoFrameCallback = function(r) {
    var a = this, s = ea();
    return !this.isReady_ || this.paused() ? (this.queuedHanders_.add(s), this.one("playing", function() {
      a.queuedHanders_.has(s) && (a.queuedHanders_.delete(s), r());
    })) : this.requestNamedAnimationFrame(s, r), s;
  }, i.cancelVideoFrameCallback = function(r) {
    this.queuedHanders_.has(r) ? this.queuedHanders_.delete(r) : this.cancelNamedAnimationFrame(r);
  }, i.setPoster = function() {
  }, i.playsinline = function() {
  }, i.setPlaysinline = function() {
  }, i.overrideNativeAudioTracks = function() {
  }, i.overrideNativeVideoTracks = function() {
  }, i.canPlayType = function() {
    return "";
  }, t.canPlayType = function() {
    return "";
  }, t.canPlaySource = function(r, a) {
    return t.canPlayType(r.type);
  }, t.isTech = function(r) {
    return r.prototype instanceof t || r instanceof t || r === t;
  }, t.registerTech = function(r, a) {
    if (t.techs_ || (t.techs_ = {}), !t.isTech(a))
      throw new Error("Tech " + r + " must be a Tech");
    if (!t.canPlayType)
      throw new Error("Techs must have a static canPlayType method on them");
    if (!t.canPlaySource)
      throw new Error("Techs must have a static canPlaySource method on them");
    return r = vi(r), t.techs_[r] = a, t.techs_[rc(r)] = a, r !== "Tech" && t.defaultTechOrder_.push(r), a;
  }, t.getTech = function(r) {
    if (r) {
      if (t.techs_ && t.techs_[r])
        return t.techs_[r];
      if (r = vi(r), W && W.videojs && W.videojs[r])
        return mt.warn(
          "The " + r + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)"
        ), W.videojs[r];
    }
  }, t;
}(ye);
Ji.names.forEach(function(e) {
  var t = Ji[e];
  Wt.prototype[t.getterName] = function() {
    return this[t.privateName] = this[t.privateName] || new t.ListClass(), this[t.privateName];
  };
});
Wt.prototype.featuresVolumeControl = !0;
Wt.prototype.featuresMuteControl = !0;
Wt.prototype.featuresFullscreenResize = !1;
Wt.prototype.featuresPlaybackRate = !1;
Wt.prototype.featuresProgressEvents = !1;
Wt.prototype.featuresSourceset = !1;
Wt.prototype.featuresTimeupdateEvents = !1;
Wt.prototype.featuresNativeTextTracks = !1;
Wt.prototype.featuresVideoFrameCallback = !1;
Wt.withSourceHandlers = function(e) {
  e.registerSourceHandler = function(i, n) {
    var r = e.sourceHandlers;
    r || (r = e.sourceHandlers = []), n === void 0 && (n = r.length), r.splice(n, 0, i);
  }, e.canPlayType = function(i) {
    for (var n = e.sourceHandlers || [], r, a = 0; a < n.length; a++)
      if (r = n[a].canPlayType(i), r)
        return r;
    return "";
  }, e.selectSourceHandler = function(i, n) {
    for (var r = e.sourceHandlers || [], a, s = 0; s < r.length; s++)
      if (a = r[s].canHandleSource(i, n), a)
        return r[s];
    return null;
  }, e.canPlaySource = function(i, n) {
    var r = e.selectSourceHandler(i, n);
    return r ? r.canHandleSource(i, n) : "";
  };
  var t = ["seekable", "seeking", "duration"];
  t.forEach(function(i) {
    var n = this[i];
    typeof n == "function" && (this[i] = function() {
      return this.sourceHandler_ && this.sourceHandler_[i] ? this.sourceHandler_[i].apply(
        this.sourceHandler_,
        arguments
      ) : n.apply(this, arguments);
    });
  }, e.prototype), e.prototype.setSource = function(i) {
    var n = e.selectSourceHandler(i, this.options_);
    n || (e.nativeSourceHandler ? n = e.nativeSourceHandler : mt.error("No source handler found for the current source.")), this.disposeSourceHandler(), this.off("dispose", this.disposeSourceHandler_), n !== e.nativeSourceHandler && (this.currentSource_ = i), this.sourceHandler_ = n.handleSource(i, this, this.options_), this.one("dispose", this.disposeSourceHandler_);
  }, e.prototype.disposeSourceHandler = function() {
    this.currentSource_ && (this.clearTracks(["audio", "video"]), this.currentSource_ = null), this.cleanupAutoTextTracks(), this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(), this.sourceHandler_ = null);
  };
};
ye.registerComponent("Tech", Wt);
Wt.registerTech("Tech", Wt);
Wt.defaultTechOrder_ = [];
var Ga = {}, lf = {}, Vc = {};
function zM(e, t) {
  Ga[e] = Ga[e] || [], Ga[e].push(t);
}
function WM(e, t, i) {
  e.setTimeout(function() {
    return Pa(t, Ga[t.type], i, e);
  }, 1);
}
function qM(e, t) {
  e.forEach(function(i) {
    return i.setTech && i.setTech(t);
  });
}
function XM(e, t, i) {
  return e.reduceRight(Np(i), t[i]());
}
function YM(e, t, i, n) {
  return t[i](e.reduce(Np(i), n));
}
function zm(e, t, i, n) {
  n === void 0 && (n = null);
  var r = "call" + vi(i), a = e.reduce(Np(r), n), s = a === Vc, o = s ? null : t[i](a);
  return ZM(e, i, o, s), o;
}
var QM = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  ended: 1,
  muted: 1,
  paused: 1,
  played: 1,
  seekable: 1,
  volume: 1
}, KM = {
  setCurrentTime: 1,
  setMuted: 1,
  setVolume: 1
}, Wm = {
  pause: 1,
  play: 1
};
function Np(e) {
  return function(t, i) {
    return t === Vc ? Vc : i[e] ? i[e](t) : t;
  };
}
function ZM(e, t, i, n) {
  for (var r = e.length - 1; r >= 0; r--) {
    var a = e[r];
    a[t] && a[t](n, i);
  }
}
function JM(e) {
  lf[e.id()] = null;
}
function $M(e, t) {
  var i = lf[e.id()], n = null;
  if (i == null)
    return n = t(e), lf[e.id()] = [[t, n]], n;
  for (var r = 0; r < i.length; r++) {
    var a = i[r], s = a[0], o = a[1];
    s === t && (n = o);
  }
  return n === null && (n = t(e), i.push([t, n])), n;
}
function Pa(e, t, i, n, r, a) {
  e === void 0 && (e = {}), t === void 0 && (t = []), r === void 0 && (r = []), a === void 0 && (a = !1);
  var s = t, o = s[0], u = s.slice(1);
  if (typeof o == "string")
    Pa(e, Ga[o], i, n, r, a);
  else if (o) {
    var l = $M(n, o);
    if (!l.setSource)
      return r.push(l), Pa(e, u, i, n, r, a);
    l.setSource(si({}, e), function(c, h) {
      if (c)
        return Pa(e, u, i, n, r, a);
      r.push(l), Pa(
        h,
        e.type === h.type ? u : Ga[h.type],
        i,
        n,
        r,
        a
      );
    });
  } else u.length ? Pa(e, u, i, n, r, a) : a ? i(e, r) : Pa(e, Ga["*"], i, n, r, !0);
}
var e3 = {
  aac: "audio/aac",
  caf: "audio/x-caf",
  m4a: "audio/mp4",
  flac: "audio/flac",
  m4v: "video/mp4",
  m3u8: "application/x-mpegURL",
  mov: "video/mp4",
  jpg: "image/jpeg",
  ogv: "video/ogg",
  gif: "image/gif",
  opus: "video/ogg",
  jpeg: "image/jpeg",
  mp4: "video/mp4",
  mkv: "video/x-matroska",
  mp3: "audio/mpeg",
  mpd: "application/dash+xml",
  oga: "audio/ogg",
  png: "image/png",
  svg: "image/svg+xml",
  wav: "audio/wav",
  webp: "image/webp"
}, Hc = function(t) {
  t === void 0 && (t = "");
  var i = Fp(t), n = e3[i.toLowerCase()];
  return n || "";
}, t3 = function(t, i) {
  if (!i)
    return "";
  if (t.cache_.source.src === i && t.cache_.source.type)
    return t.cache_.source.type;
  var n = t.cache_.sources.filter(function(o) {
    return o.src === i;
  });
  if (n.length)
    return n[0].type;
  for (var r = t.$$("source"), a = 0; a < r.length; a++) {
    var s = r[a];
    if (s.type && s.src && s.src === i)
      return s.type;
  }
  return Hc(i);
}, i3 = function e(t) {
  if (Array.isArray(t)) {
    var i = [];
    t.forEach(function(n) {
      n = e(n), Array.isArray(n) ? i = i.concat(n) : qn(n) && i.push(n);
    }), t = i;
  } else typeof t == "string" && t.trim() ? t = [
    qm({
      src: t
    })
  ] : qn(t) && typeof t.src == "string" && t.src && t.src.trim() ? t = [qm(t)] : t = [];
  return t;
};
function qm(e) {
  if (!e.type) {
    var t = Hc(e.src);
    t && (e.type = t);
  }
  return e;
}
var r3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(i, n, r) {
    var a, s = Kt(
      {
        createEl: !1
      },
      n
    );
    if (a = e.call(this, i, s, r) || this, !n.playerOptions.sources || n.playerOptions.sources.length === 0)
      for (var o = 0, u = n.playerOptions.techOrder; o < u.length; o++) {
        var l = vi(u[o]), c = Wt.getTech(l);
        if (l || (c = ye.getComponent(l)), c && c.isSupported()) {
          i.loadTech_(l);
          break;
        }
      }
    else
      i.src(n.playerOptions.sources);
    return a;
  }
  return t;
}(ye);
ye.registerComponent("MediaLoader", r3);
var Bh = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.options_.controlText && a.controlText(a.options_.controlText), a.handleMouseOver_ = function(s) {
      return a.handleMouseOver(s);
    }, a.handleMouseOut_ = function(s) {
      return a.handleMouseOut(s);
    }, a.handleClick_ = function(s) {
      return a.handleClick(s);
    }, a.handleKeyDown_ = function(s) {
      return a.handleKeyDown(s);
    }, a.emitTapEvents(), a.enable(), a;
  }
  var i = t.prototype;
  return i.createEl = function(r, a, s) {
    r === void 0 && (r = "div"), a === void 0 && (a = {}), s === void 0 && (s = {}), a = si(
      {
        className: this.buildCSSClass(),
        tabIndex: 0
      },
      a
    ), r === "button" && mt.error(
      "Creating a ClickableComponent with an HTML element of " + r + " is not supported; use a Button instead."
    ), s = si(
      {
        role: "button"
      },
      s
    ), this.tabIndex_ = a.tabIndex;
    var o = St(r, a, s);
    return o.appendChild(
      St(
        "span",
        {
          className: "vjs-icon-placeholder"
        },
        {
          "aria-hidden": !0
        }
      )
    ), this.createControlTextEl(o), o;
  }, i.dispose = function() {
    this.controlTextEl_ = null, e.prototype.dispose.call(this);
  }, i.createControlTextEl = function(r) {
    return this.controlTextEl_ = St(
      "span",
      {
        className: "vjs-control-text"
      },
      {
        // let the screen reader user know that the text of the element may change
        "aria-live": "polite"
      }
    ), r && r.appendChild(this.controlTextEl_), this.controlText(this.controlText_, r), this.controlTextEl_;
  }, i.controlText = function(r, a) {
    if (a === void 0 && (a = this.el()), r === void 0)
      return this.controlText_ || "Need Text";
    var s = this.localize(r);
    this.controlText_ = r, _s(this.controlTextEl_, s), !this.nonIconControl && !this.player_.options_.noUITitleAttributes && a.tagName === "CX-TOOLTIP" && (a.content = s);
  }, i.buildCSSClass = function() {
    return "vjs-control vjs-button " + e.prototype.buildCSSClass.call(this);
  }, i.enable = function() {
    this.enabled_ || (this.enabled_ = !0, this.removeClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "false"), typeof this.tabIndex_ < "u" && this.el_.setAttribute("tabIndex", this.tabIndex_), this.on(["tap", "click"], this.handleClick_), this.on("keydown", this.handleKeyDown_));
  }, i.disable = function() {
    this.enabled_ = !1, this.addClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "true"), typeof this.tabIndex_ < "u" && this.el_.removeAttribute("tabIndex"), this.off("mouseover", this.handleMouseOver_), this.off("mouseout", this.handleMouseOut_), this.off(["tap", "click"], this.handleClick_), this.off("keydown", this.handleKeyDown_);
  }, i.handleLanguagechange = function() {
    this.controlText(this.controlText_);
  }, i.handleClick = function(r) {
    this.options_.clickHandler && this.options_.clickHandler.call(this, arguments);
  }, i.handleKeyDown = function(r) {
    lt.isEventKey(r, "Space") || lt.isEventKey(r, "Enter") ? (r.preventDefault(), r.stopPropagation(), this.trigger("click")) : e.prototype.handleKeyDown.call(this, r);
  }, t;
}(ye);
ye.registerComponent("ClickableComponent", Bh);
var n3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.update(), a.update_ = function(s) {
      return a.update(s);
    }, n.on("posterchange", a.update_), a;
  }
  var i = t.prototype;
  return i.dispose = function() {
    this.player().off("posterchange", this.update_), e.prototype.dispose.call(this);
  }, i.createEl = function() {
    var r = St("div", {
      className: "vjs-poster",
      // Don't want poster to be tabbable.
      tabIndex: -1
    });
    return r;
  }, i.update = function(r) {
    var a = this.player().poster();
    this.setSrc(a), a ? this.show() : this.hide();
  }, i.setSrc = function(r) {
    var a = "";
    r && (a = 'url("' + r + '")'), this.el_.style.backgroundImage = a;
  }, i.handleClick = function(r) {
    if (this.player_.controls()) {
      var a = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
      this.player_.tech(!0) && // We've observed a bug in IE and Edge when playing back DRM content where
      // calling .focus() on the video element causes the video to go black,
      // so we avoid it in that specific case
      !((Dl || Ml) && a) && this.player_.tech(!0).focus(), this.player_.paused() ? hn(this.player_.play()) : this.player_.pause();
    }
  }, t;
}(Bh);
ye.registerComponent("PosterImage", n3);
var Rr = "#222", Xm = "#ccc", a3 = {
  casual: '"Comic Sans MS", Impact, fantasy',
  monospace: "monospace",
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: "sans-serif",
  proportionalSerif: "serif",
  sansSerif: "sans-serif",
  script: '"Monotype Corsiva", cursive',
  serif: "serif",
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};
function fd(e, t) {
  var i;
  if (e.length === 4)
    i = e[1] + e[1] + e[2] + e[2] + e[3] + e[3];
  else if (e.length === 7)
    i = e.slice(1);
  else
    throw new Error(
      "Invalid color code provided, " + e + "; must be formatted as e.g. #f0e or #f604e2."
    );
  return "rgba(" + parseInt(i.slice(0, 2), 16) + "," + parseInt(i.slice(2, 4), 16) + "," + parseInt(i.slice(4, 6), 16) + "," + t + ")";
}
function pd(e, t, i) {
  try {
    e.style[t] = i;
  } catch {
    return;
  }
}
var s3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a) {
    var s;
    s = e.call(this, n, r, a) || this;
    var o = function(l) {
      return s.updateDisplay(l);
    };
    return n.on("loadstart", function(u) {
      return s.toggleDisplay(u);
    }), n.on("texttrackchange", o), n.on("loadedmetadata", function(u) {
      return s.preselectTrack(u);
    }), n.ready(
      Zt(He(s), function() {
        if (n.tech_ && n.tech_.featuresNativeTextTracks) {
          this.hide();
          return;
        }
        n.on("fullscreenchange", o), n.on("playerresize", o), W.addEventListener("orientationchange", o), n.on("dispose", function() {
          return W.removeEventListener(
            "orientationchange",
            o
          );
        });
        for (var u = this.options_.playerOptions.tracks || [], l = 0; l < u.length; l++)
          this.player_.addRemoteTextTrack(u[l], !0);
        this.preselectTrack();
      })
    ), s;
  }
  var i = t.prototype;
  return i.preselectTrack = function() {
    for (var r = {
      captions: 1,
      subtitles: 1
    }, a = this.player_.textTracks(), s = this.player_.cache_.selectedLanguage, o, u, l, c = 0; c < a.length; c++) {
      var h = a[c];
      s && s.enabled && s.language && s.language === h.language && h.kind in r ? h.kind === s.kind ? l = h : l || (l = h) : s && !s.enabled ? (l = null, o = null, u = null) : h.default && (h.kind === "descriptions" && !o ? o = h : h.kind in r && !u && (u = h));
    }
    l ? l.mode = "showing" : u ? u.mode = "showing" : o && (o.mode = "showing");
  }, i.toggleDisplay = function() {
    this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show();
  }, i.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-text-track-display"
      },
      {
        "aria-atomic": "true",
        "aria-live": "off",
        translate: "yes"
      }
    );
  }, i.clearDisplay = function() {
    typeof W.WebVTT == "function" && W.WebVTT.processCues(W, [], this.el_);
  }, i.updateDisplay = function() {
    var r = this.player_.textTracks(), a = this.options_.allowMultipleShowingTracks;
    if (this.clearDisplay(), a) {
      for (var s = [], o = 0; o < r.length; ++o) {
        var u = r[o];
        u.mode === "showing" && s.push(u);
      }
      this.updateForTrack(s);
      return;
    }
    for (var l = null, c = null, h = r.length; h--; ) {
      var d = r[h];
      d.mode === "showing" && (d.kind === "descriptions" ? l = d : c = d);
    }
    c ? (this.getAttribute("aria-live") !== "off" && this.setAttribute("aria-live", "off"), this.updateForTrack(c)) : l && (this.getAttribute("aria-live") !== "assertive" && this.setAttribute("aria-live", "assertive"), this.updateForTrack(l));
  }, i.updateDisplayState = function(r) {
    for (var a = this.player_.textTrackSettings.getValues(), s = r.activeCues, o = s.length; o--; ) {
      var u = s[o];
      if (u) {
        var l = u.displayState;
        if (a.color && (l.firstChild.style.color = a.color), a.textOpacity && pd(
          l.firstChild,
          "color",
          fd(a.color || "#fff", a.textOpacity)
        ), a.backgroundColor && (l.firstChild.style.backgroundColor = a.backgroundColor), a.backgroundOpacity && pd(
          l.firstChild,
          "backgroundColor",
          fd(
            a.backgroundColor || "#000",
            a.backgroundOpacity
          )
        ), a.windowColor && (a.windowOpacity ? pd(
          l,
          "backgroundColor",
          fd(a.windowColor, a.windowOpacity)
        ) : l.style.backgroundColor = a.windowColor), a.edgeStyle && (a.edgeStyle === "dropshadow" ? l.firstChild.style.textShadow = "2px 2px 3px " + Rr + ", 2px 2px 4px " + Rr + ", 2px 2px 5px " + Rr : a.edgeStyle === "raised" ? l.firstChild.style.textShadow = "1px 1px " + Rr + ", 2px 2px " + Rr + ", 3px 3px " + Rr : a.edgeStyle === "depressed" ? l.firstChild.style.textShadow = "1px 1px " + Xm + ", 0 1px " + Xm + ", -1px -1px " + Rr + ", 0 -1px " + Rr : a.edgeStyle === "uniform" && (l.firstChild.style.textShadow = "0 0 4px " + Rr + ", 0 0 4px " + Rr + ", 0 0 4px " + Rr + ", 0 0 4px " + Rr)), a.fontPercent && a.fontPercent !== 1) {
          var c = W.parseFloat(l.style.fontSize);
          l.style.fontSize = c * a.fontPercent + "px", l.style.height = "auto", l.style.top = "auto";
        }
        a.fontFamily && a.fontFamily !== "default" && (a.fontFamily === "small-caps" ? l.firstChild.style.fontVariant = "small-caps" : l.firstChild.style.fontFamily = a3[a.fontFamily]);
      }
    }
  }, i.updateForTrack = function(r) {
    if (Array.isArray(r) || (r = [r]), !(typeof W.WebVTT != "function" || r.every(function(f) {
      return !f.activeCues;
    }))) {
      for (var a = [], s = 0; s < r.length; ++s)
        for (var o = r[s], u = 0; u < o.activeCues.length; ++u)
          a.push(o.activeCues[u]);
      W.WebVTT.processCues(W, a, this.el_);
      for (var l = 0; l < r.length; ++l) {
        for (var c = r[l], h = 0; h < c.activeCues.length; ++h) {
          var d = c.activeCues[h].displayState;
          Un(d, "vjs-text-track-cue"), Un(
            d,
            "vjs-text-track-cue-" + (c.language ? c.language : l)
          ), c.language && Mo(d, "lang", c.language);
        }
        this.player_.textTrackSettings && this.updateDisplayState(c);
      }
    }
  }, t;
}(ye);
ye.registerComponent("TextTrackDisplay", s3);
var o3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.createEl = function() {
    var r = this.player_.isAudio(), a = this.localize(r ? "Audio Player" : "Video Player"), s = St("span", {
      className: "vjs-control-text",
      textContent: this.localize("{1} is loading.", [a])
    }), o = e.prototype.createEl.call(this, "div", {
      className: "vjs-loading-spinner",
      dir: "ltr"
    });
    return o.appendChild(s), o;
  }, t;
}(ye);
ye.registerComponent("LoadingSpinner", o3);
var Wr = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.createEl = function(r, a, s) {
    a === void 0 && (a = {}), s === void 0 && (s = {}), r = "button", a = si(
      {
        className: this.buildCSSClass()
      },
      a
    ), s = si(
      {
        // Necessary since the default button type is "submit"
        type: "button"
      },
      s
    );
    var o = St(r, a, s);
    if (o.appendChild(
      St(
        "span",
        {
          className: "vjs-icon-placeholder"
        },
        {
          "aria-hidden": !0
        }
      )
    ), this.createControlTextEl(o), o.classList.contains("vjs-button")) {
      var u = Te.createElement("cx-tooltip");
      return u.hoist = !0, u.content = this.controlText_, u.appendChild(o), o.style.cursor = "pointer", u;
    }
    return o;
  }, i.addChild = function(r, a) {
    a === void 0 && (a = {});
    var s = this.constructor.name;
    return mt.warn(
      "Adding an actionable (user controllable) child to a Button (" + s + ") is not supported; use a ClickableComponent instead."
    ), ye.prototype.addChild.call(this, r, a);
  }, i.enable = function() {
    e.prototype.enable.call(this), this.el_.removeAttribute("disabled");
  }, i.disable = function() {
    e.prototype.disable.call(this), this.el_.setAttribute("disabled", "disabled");
  }, i.handleKeyDown = function(r) {
    if (lt.isEventKey(r, "Space") || lt.isEventKey(r, "Enter")) {
      r.stopPropagation();
      return;
    }
    e.prototype.handleKeyDown.call(this, r);
  }, t;
}(Bh);
ye.registerComponent("Button", Wr);
var ob = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.mouseused_ = !1, a.on("mousedown", function(s) {
      return a.handleMouseDown(s);
    }), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-big-play-button";
  }, i.handleClick = function(r) {
    var a = this.player_.play();
    if (this.mouseused_ && r.clientX && r.clientY) {
      var s = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
      hn(a), this.player_.tech(!0) && // We've observed a bug in IE and Edge when playing back DRM content where
      // calling .focus() on the video element causes the video to go black,
      // so we avoid it in that specific case
      !((Dl || Ml) && s) && this.player_.tech(!0).focus();
      return;
    }
    var o = this.player_.getChild("controlBar"), u = o && o.getChild("playToggle");
    if (!u) {
      this.player_.tech(!0).focus();
      return;
    }
    var l = function() {
      return u.focus();
    };
    du(a) ? a.then(l, function() {
    }) : this.setTimeout(l, 1);
  }, i.handleKeyDown = function(r) {
    this.mouseused_ = !1, e.prototype.handleKeyDown.call(this, r);
  }, i.handleMouseDown = function(r) {
    this.mouseused_ = !0;
  }, t;
}(Wr);
ob.prototype.controlText_ = "Play Video";
ye.registerComponent("BigPlayButton", ob);
var u3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.controlText(
      r && r.controlText || a.localize("Close")
    ), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-close-button " + e.prototype.buildCSSClass.call(this);
  }, i.handleClick = function(r) {
    this.trigger({
      bubbles: !1,
      type: "close"
    });
  }, i.handleKeyDown = function(r) {
    lt.isEventKey(r, "Esc") ? (r.preventDefault(), r.stopPropagation(), this.trigger("click")) : e.prototype.handleKeyDown.call(this, r);
  }, t;
}(Wr);
ye.registerComponent("CloseButton", u3);
var ub = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return r === void 0 && (r = {}), a = e.call(this, n, r) || this, r.replay = r.replay === void 0 || r.replay, a.on(n, "play", function(s) {
      return a.handlePlay(s);
    }), a.on(n, "pause", function(s) {
      return a.handlePause(s);
    }), r.replay && a.on(n, "ended", function(s) {
      return a.handleEnded(s);
    }), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-play-control " + e.prototype.buildCSSClass.call(this);
  }, i.handleClick = function(r) {
    this.player_.paused() ? hn(this.player_.play()) : this.player_.pause();
  }, i.handleSeeked = function(r) {
    this.removeClass("vjs-ended"), this.player_.paused() ? this.handlePause(r) : this.handlePlay(r);
  }, i.handlePlay = function(r) {
    this.removeClass("vjs-ended"), this.removeClass("vjs-paused"), this.addClass("vjs-playing"), this.controlText("Pause");
  }, i.handlePause = function(r) {
    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.controlText("Play");
  }, i.handleEnded = function(r) {
    var a = this;
    this.removeClass("vjs-playing"), this.addClass("vjs-ended"), this.controlText("Replay"), this.one(this.player_, "seeked", function(s) {
      return a.handleSeeked(s);
    });
  }, t;
}(Wr);
ub.prototype.controlText_ = "Play";
ye.registerComponent("PlayToggle", ub);
var lb = function(t, i) {
  t = t < 0 ? 0 : t;
  var n = Math.floor(t % 60), r = Math.floor(t / 60 % 60), a = Math.floor(t / 3600), s = Math.floor(i / 60 % 60), o = Math.floor(i / 3600);
  return (isNaN(t) || t === 1 / 0) && (a = r = n = "-"), a = a > 0 || o > 0 ? a + ":" : "", r = ((a || s >= 10) && r < 10 ? "0" + r : r) + ":", n = n < 10 ? "0" + n : n, a + r + n;
}, Up = lb;
function l3(e) {
  Up = e;
}
function c3() {
  Up = lb;
}
function Ro(e, t) {
  return t === void 0 && (t = e), Up(e, t);
}
var Go = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.on(n, ["timeupdate", "ended"], function(s) {
      return a.updateContent(s);
    }), a.updateTextNode_(), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    var r = this.buildCSSClass(), a = e.prototype.createEl.call(this, "div", {
      className: r + " vjs-time-control vjs-control"
    }), s = St(
      "span",
      {
        className: "vjs-control-text",
        textContent: this.localize(this.labelText_) + ""
      },
      {
        role: "presentation"
      }
    );
    return a.appendChild(s), this.contentEl_ = St(
      "span",
      {
        className: r + "-display"
      },
      {
        // tell screen readers not to automatically read the time as it changes
        "aria-live": "off",
        // span elements have no implicit role, but some screen readers (notably VoiceOver)
        // treat them as a break between items in the DOM when using arrow keys
        // (or left-to-right swipes on iOS) to read contents of a page. Using
        // role='presentation' causes VoiceOver to NOT treat this span as a break.
        role: "presentation"
      }
    ), a.appendChild(this.contentEl_), a;
  }, i.dispose = function() {
    this.contentEl_ = null, this.textNode_ = null, e.prototype.dispose.call(this);
  }, i.updateTextNode_ = function(r) {
    var a = this;
    r === void 0 && (r = 0), r = Ro(r), this.formattedTime_ !== r && (this.formattedTime_ = r, this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", function() {
      if (a.contentEl_) {
        var s = a.textNode_;
        s && a.contentEl_.firstChild !== s && (s = null, mt.warn(
          "TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead."
        )), a.textNode_ = Te.createTextNode(a.formattedTime_), a.textNode_ && (s ? a.contentEl_.replaceChild(a.textNode_, s) : a.contentEl_.appendChild(a.textNode_));
      }
    }));
  }, i.updateContent = function(r) {
  }, t;
}(ye);
Go.prototype.labelText_ = "Time";
Go.prototype.controlText_ = "Time";
ye.registerComponent("TimeDisplay", Go);
var jp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-current-time";
  }, i.updateContent = function(r) {
    var a;
    this.player_.ended() ? a = this.player_.duration() : a = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(), this.updateTextNode_(a);
  }, t;
}(Go);
jp.prototype.labelText_ = "Current Time";
jp.prototype.controlText_ = "Current Time";
ye.registerComponent("CurrentTimeDisplay", jp);
var Gp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    a = e.call(this, n, r) || this;
    var s = function(u) {
      return a.updateContent(u);
    };
    return a.on(n, "durationchange", s), a.on(n, "loadstart", s), a.on(n, "loadedmetadata", s), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-duration";
  }, i.updateContent = function(r) {
    var a = this.player_.duration();
    this.updateTextNode_(a);
  }, t;
}(Go);
Gp.prototype.labelText_ = "Duration";
Gp.prototype.controlText_ = "Duration";
ye.registerComponent("DurationDisplay", Gp);
var h3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.createEl = function() {
    var r = e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-time-control vjs-time-divider"
      },
      {
        // this element and its contents can be hidden from assistive techs since
        // it is made extraneous by the announcement of the control text
        // for the current time and duration displays
        "aria-hidden": !0
      }
    ), a = e.prototype.createEl.call(this, "div"), s = e.prototype.createEl.call(this, "span", {
      textContent: "/"
    });
    return a.appendChild(s), r.appendChild(a), r;
  }, t;
}(ye);
ye.registerComponent("TimeDivider", h3);
var Vp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.on(n, "durationchange", function(s) {
      return a.updateContent(s);
    }), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-remaining-time";
  }, i.createEl = function() {
    var r = e.prototype.createEl.call(this);
    return this.options_.displayNegative !== !1 && r.insertBefore(
      St(
        "span",
        {},
        {
          "aria-hidden": !0
        },
        "-"
      ),
      this.contentEl_
    ), r;
  }, i.updateContent = function(r) {
    if (typeof this.player_.duration() == "number") {
      var a;
      this.player_.ended() ? a = 0 : this.player_.remainingTimeDisplay ? a = this.player_.remainingTimeDisplay() : a = this.player_.remainingTime(), this.updateTextNode_(a);
    }
  }, t;
}(Go);
Vp.prototype.labelText_ = "Remaining Time";
Vp.prototype.controlText_ = "Remaining Time";
ye.registerComponent("RemainingTimeDisplay", Vp);
var d3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.updateShowing(), a.on(a.player(), "durationchange", function(s) {
      return a.updateShowing(s);
    }), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    var r = e.prototype.createEl.call(this, "div", {
      className: "vjs-live-control vjs-control"
    });
    return this.contentEl_ = St(
      "div",
      {
        className: "vjs-live-display"
      },
      {
        "aria-live": "off"
      }
    ), this.contentEl_.appendChild(
      St("span", {
        className: "vjs-control-text",
        textContent: this.localize("Stream Type") + ""
      })
    ), this.contentEl_.appendChild(Te.createTextNode(this.localize("LIVE"))), r.appendChild(this.contentEl_), r;
  }, i.dispose = function() {
    this.contentEl_ = null, e.prototype.dispose.call(this);
  }, i.updateShowing = function(r) {
    this.player().duration() === 1 / 0 ? this.show() : this.hide();
  }, t;
}(ye);
ye.registerComponent("LiveDisplay", d3);
var cb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.updateLiveEdgeStatus(), a.player_.liveTracker && (a.updateLiveEdgeStatusHandler_ = function(s) {
      return a.updateLiveEdgeStatus(s);
    }, a.on(
      a.player_.liveTracker,
      "liveedgechange",
      a.updateLiveEdgeStatusHandler_
    )), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    var r = e.prototype.createEl.call(this, "button", {
      className: "vjs-seek-to-live-control vjs-control"
    });
    return this.textEl_ = St(
      "span",
      {
        className: "vjs-seek-to-live-text",
        textContent: this.localize("LIVE")
      },
      {
        "aria-hidden": "true"
      }
    ), r.appendChild(this.textEl_), r;
  }, i.updateLiveEdgeStatus = function() {
    !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0), this.addClass("vjs-at-live-edge"), this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1), this.removeClass("vjs-at-live-edge"), this.controlText("Seek to live, currently behind live"));
  }, i.handleClick = function() {
    this.player_.liveTracker.seekToLiveEdge();
  }, i.dispose = function() {
    this.player_.liveTracker && this.off(
      this.player_.liveTracker,
      "liveedgechange",
      this.updateLiveEdgeStatusHandler_
    ), this.textEl_ = null, e.prototype.dispose.call(this);
  }, t;
}(Wr);
cb.prototype.controlText_ = "Seek to live, currently playing live";
ye.registerComponent("SeekToLive", cb);
var Fh = function(t, i, n) {
  return t = Number(t), Math.min(n, Math.max(i, isNaN(t) ? i : t));
}, Hp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.handleMouseDown_ = function(s) {
      return a.handleMouseDown(s);
    }, a.handleMouseUp_ = function(s) {
      return a.handleMouseUp(s);
    }, a.handleKeyDown_ = function(s) {
      return a.handleKeyDown(s);
    }, a.handleClick_ = function(s) {
      return a.handleClick(s);
    }, a.handleMouseMove_ = function(s) {
      return a.handleMouseMove(s);
    }, a.update_ = function(s) {
      return a.update(s);
    }, a.bar = a.getChild(a.options_.barName), a.vertical(!!a.options_.vertical), a.enable(), a;
  }
  var i = t.prototype;
  return i.enabled = function() {
    return this.enabled_;
  }, i.enable = function() {
    this.enabled() || (this.on("mousedown", this.handleMouseDown_), this.on("touchstart", this.handleMouseDown_), this.on("keydown", this.handleKeyDown_), this.on("click", this.handleClick_), this.on(this.player_, "controlsvisible", this.update), this.playerEvent && this.on(this.player_, this.playerEvent, this.update), this.removeClass("disabled"), this.setAttribute("tabindex", 0), this.enabled_ = !0);
  }, i.disable = function() {
    if (this.enabled()) {
      var r = this.bar.el_.ownerDocument;
      this.off("mousedown", this.handleMouseDown_), this.off("touchstart", this.handleMouseDown_), this.off("keydown", this.handleKeyDown_), this.off("click", this.handleClick_), this.off(this.player_, "controlsvisible", this.update_), this.off(r, "mousemove", this.handleMouseMove_), this.off(r, "mouseup", this.handleMouseUp_), this.off(r, "touchmove", this.handleMouseMove_), this.off(r, "touchend", this.handleMouseUp_), this.removeAttribute("tabindex"), this.addClass("disabled"), this.playerEvent && this.off(this.player_, this.playerEvent, this.update), this.enabled_ = !1;
    }
  }, i.createEl = function(r, a, s) {
    return a === void 0 && (a = {}), s === void 0 && (s = {}), a.className = a.className + " vjs-slider", a = si(
      {
        tabIndex: 0
      },
      a
    ), s = si(
      {
        "aria-valuemax": 100,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        role: "slider",
        tabIndex: 0
      },
      s
    ), e.prototype.createEl.call(this, r, a, s);
  }, i.handleMouseDown = function(r) {
    var a = this.bar.el_.ownerDocument;
    r.type === "mousedown" && r.preventDefault(), r.type === "touchstart" && !$n && r.preventDefault(), U_(), this.addClass("vjs-sliding"), this.trigger("slideractive"), this.on(a, "mousemove", this.handleMouseMove_), this.on(a, "mouseup", this.handleMouseUp_), this.on(a, "touchmove", this.handleMouseMove_), this.on(a, "touchend", this.handleMouseUp_), this.handleMouseMove(r, !0);
  }, i.handleMouseMove = function(r) {
  }, i.handleMouseUp = function() {
    var r = this.bar.el_.ownerDocument;
    j_(), this.removeClass("vjs-sliding"), this.trigger("sliderinactive"), this.off(r, "mousemove", this.handleMouseMove_), this.off(r, "mouseup", this.handleMouseUp_), this.off(r, "touchmove", this.handleMouseMove_), this.off(r, "touchend", this.handleMouseUp_), this.update();
  }, i.update = function() {
    var r = this;
    if (!(!this.el_ || !this.bar)) {
      var a = this.getProgress();
      return a === this.progress_ || (this.progress_ = a, this.requestNamedAnimationFrame("Slider#update", function() {
        var s = r.vertical() ? "height" : "width";
        r.bar.el().style[s] = (a * 100).toFixed(2) + "%";
      })), a;
    }
  }, i.getProgress = function() {
    return Number(Fh(this.getPercent(), 0, 1).toFixed(4));
  }, i.calculateDistance = function(r) {
    var a = Lh(this.el_, r);
    return this.vertical() ? a.y : a.x;
  }, i.handleKeyDown = function(r) {
    lt.isEventKey(r, "Left") || lt.isEventKey(r, "Down") ? (r.preventDefault(), r.stopPropagation(), this.stepBack()) : lt.isEventKey(r, "Right") || lt.isEventKey(r, "Up") ? (r.preventDefault(), r.stopPropagation(), this.stepForward()) : e.prototype.handleKeyDown.call(this, r);
  }, i.handleClick = function(r) {
    r.stopPropagation(), r.preventDefault();
  }, i.vertical = function(r) {
    if (r === void 0)
      return this.vertical_ || !1;
    this.vertical_ = !!r, this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal");
  }, t;
}(ye);
ye.registerComponent("Slider", Hp);
var vd = function(t, i) {
  return Fh(t / i * 100, 0, 100).toFixed(2) + "%";
}, f3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.partEls_ = [], a.on(n, "progress", function(s) {
      return a.update(s);
    }), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    var r = e.prototype.createEl.call(this, "div", {
      className: "vjs-load-progress"
    }), a = St("span", {
      className: "vjs-control-text"
    }), s = St("span", {
      textContent: this.localize("Loaded")
    }), o = Te.createTextNode(": ");
    return this.percentageEl_ = St("span", {
      className: "vjs-control-text-loaded-percentage",
      textContent: "0%"
    }), r.appendChild(a), a.appendChild(s), a.appendChild(o), a.appendChild(this.percentageEl_), r;
  }, i.dispose = function() {
    this.partEls_ = null, this.percentageEl_ = null, e.prototype.dispose.call(this);
  }, i.update = function(r) {
    var a = this;
    this.requestNamedAnimationFrame("LoadProgressBar#update", function() {
      var s = a.player_.liveTracker, o = a.player_.buffered(), u = s && s.isLive() ? s.seekableEnd() : a.player_.duration(), l = a.player_.bufferedEnd(), c = a.partEls_, h = vd(l, u);
      a.percent_ !== h && (a.el_.style.width = h, _s(a.percentageEl_, h), a.percent_ = h);
      for (var d = 0; d < o.length; d++) {
        var f = o.start(d), p = o.end(d), _ = c[d];
        _ || (_ = a.el_.appendChild(St()), c[d] = _), !(_.dataset.start === f && _.dataset.end === p) && (_.dataset.start = f, _.dataset.end = p, _.style.left = vd(f, l), _.style.width = vd(p - f, l));
      }
      for (var m = c.length; m > o.length; m--)
        a.el_.removeChild(c[m - 1]);
      c.length = o.length;
    });
  }, t;
}(ye);
ye.registerComponent("LoadProgressBar", f3);
var p3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.update = Xn(
      Zt(He(a), a.update),
      $r
    ), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-time-tooltip"
      },
      {
        "aria-hidden": "true"
      }
    );
  }, i.update = function(r, a, s) {
    var o = ml(this.el_), u = Do(this.player_.el()), l = r.width * a;
    if (!(!u || !o)) {
      var c = r.left - u.left + l, h = r.width - l + (u.right - r.right), d = o.width / 2;
      c < d ? d += d - c : h < d && (d = h), d < 0 ? d = 0 : d > o.width && (d = o.width), d = Math.round(d), this.el_.style.right = "-" + d + "px", this.write(s);
    }
  }, i.write = function(r) {
    _s(this.el_, r);
  }, i.updateTime = function(r, a, s, o) {
    var u = this;
    this.requestNamedAnimationFrame("TimeTooltip#updateTime", function() {
      var l, c = u.player_.duration();
      if (u.player_.liveTracker && u.player_.liveTracker.isLive()) {
        var h = u.player_.liveTracker.liveWindow(), d = h - a * h;
        l = (d < 1 ? "" : "-") + Ro(d, h);
      } else
        l = Ro(s, c);
      u.update(r, a, l), o && o();
    });
  }, t;
}(ye);
ye.registerComponent("TimeTooltip", p3);
var zp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.update = Xn(
      Zt(He(a), a.update),
      $r
    ), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-play-progress vjs-slider-bar"
      },
      {
        "aria-hidden": "true"
      }
    );
  }, i.update = function(r, a) {
    var s = this.getChild("timeTooltip");
    if (s) {
      var o = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      s.updateTime(r, a, o);
    }
  }, t;
}(ye);
zp.prototype.options_ = {
  children: []
};
!cr && !Jn && zp.prototype.options_.children.push("timeTooltip");
ye.registerComponent("PlayProgressBar", zp);
var hb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.update = Xn(
      Zt(He(a), a.update),
      $r
    ), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  }, i.update = function(r, a) {
    var s = this, o = a * this.player_.duration();
    this.getChild("timeTooltip").updateTime(
      r,
      a,
      o,
      function() {
        s.el_.style.left = r.width * a + "px";
      }
    );
  }, t;
}(ye);
hb.prototype.options_ = {
  children: ["timeTooltip"]
};
ye.registerComponent("MouseTimeDisplay", hb);
var Yl = 5, Ym = 12, Wp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.setEventHandlers_(), a;
  }
  var i = t.prototype;
  return i.setEventHandlers_ = function() {
    var r = this;
    this.update_ = Zt(this, this.update), this.update = Xn(this.update_, $r), this.on(
      this.player_,
      ["ended", "durationchange", "timeupdate"],
      this.update
    ), this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update), this.updateInterval = null, this.enableIntervalHandler_ = function(a) {
      return r.enableInterval_(a);
    }, this.disableIntervalHandler_ = function(a) {
      return r.disableInterval_(a);
    }, this.on(this.player_, ["playing"], this.enableIntervalHandler_), this.on(
      this.player_,
      ["ended", "pause", "waiting"],
      this.disableIntervalHandler_
    ), "hidden" in Te && "visibilityState" in Te && this.on(Te, "visibilitychange", this.toggleVisibility_);
  }, i.toggleVisibility_ = function(r) {
    Te.visibilityState === "hidden" ? (this.cancelNamedAnimationFrame("SeekBar#update"), this.cancelNamedAnimationFrame("Slider#update"), this.disableInterval_(r)) : (!this.player_.ended() && !this.player_.paused() && this.enableInterval_(), this.update());
  }, i.enableInterval_ = function() {
    this.updateInterval || (this.updateInterval = this.setInterval(
      this.update,
      $r
    ));
  }, i.disableInterval_ = function(r) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && r && r.type !== "ended" || this.updateInterval && (this.clearInterval(this.updateInterval), this.updateInterval = null);
  }, i.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-progress-holder"
      },
      {
        "aria-label": this.localize("Progress Bar")
      }
    );
  }, i.update = function(r) {
    var a = this;
    if (Te.visibilityState !== "hidden") {
      var s = e.prototype.update.call(this);
      return this.requestNamedAnimationFrame("SeekBar#update", function() {
        var o = a.player_.ended() ? a.player_.duration() : a.getCurrentTime_(), u = a.player_.liveTracker, l = a.player_.duration();
        u && u.isLive() && (l = a.player_.liveTracker.liveCurrentTime()), a.percent_ !== s && (a.el_.setAttribute("aria-valuenow", (s * 100).toFixed(2)), a.percent_ = s), (a.currentTime_ !== o || a.duration_ !== l) && (a.el_.setAttribute(
          "aria-valuetext",
          a.localize(
            "progress bar timing: currentTime={1} duration={2}",
            [Ro(o, l), Ro(l, l)],
            "{1} of {2}"
          )
        ), a.currentTime_ = o, a.duration_ = l), a.bar && a.bar.update(
          Do(a.el()),
          a.getProgress()
        );
      }), s;
    }
  }, i.userSeek_ = function(r) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(r);
  }, i.getCurrentTime_ = function() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  }, i.getPercent = function() {
    var r = this.getCurrentTime_(), a, s = this.player_.liveTracker;
    return s && s.isLive() ? (a = (r - s.seekableStart()) / s.liveWindow(), s.atLiveEdge() && (a = 1)) : a = r / this.player_.duration(), a;
  }, i.handleMouseDown = function(r) {
    gl(r) && (r.stopPropagation(), this.videoWasPlaying = !this.player_.paused(), this.player_.pause(), e.prototype.handleMouseDown.call(this, r));
  }, i.handleMouseMove = function(r, a) {
    if (a === void 0 && (a = !1), !!gl(r)) {
      !a && !this.player_.scrubbing() && this.player_.scrubbing(!0);
      var s, o = this.calculateDistance(r), u = this.player_.liveTracker;
      if (!u || !u.isLive())
        s = o * this.player_.duration(), s === this.player_.duration() && (s = s - 0.1);
      else {
        if (o >= 0.99) {
          u.seekToLiveEdge();
          return;
        }
        var l = u.seekableStart(), c = u.liveCurrentTime();
        if (s = l + o * u.liveWindow(), s >= c && (s = c), s <= l && (s = l + 0.1), s === 1 / 0)
          return;
      }
      this.userSeek_(s);
    }
  }, i.enable = function() {
    e.prototype.enable.call(this);
    var r = this.getChild("mouseTimeDisplay");
    r && r.show();
  }, i.disable = function() {
    e.prototype.disable.call(this);
    var r = this.getChild("mouseTimeDisplay");
    r && r.hide();
  }, i.handleMouseUp = function(r) {
    e.prototype.handleMouseUp.call(this, r), r && r.stopPropagation(), this.player_.scrubbing(!1), this.player_.trigger({
      manuallyTriggered: !0,
      target: this,
      type: "timeupdate"
    }), this.videoWasPlaying ? hn(this.player_.play()) : this.update_();
  }, i.stepForward = function() {
    this.userSeek_(this.player_.currentTime() + Yl);
  }, i.stepBack = function() {
    this.userSeek_(this.player_.currentTime() - Yl);
  }, i.handleAction = function(r) {
    this.player_.paused() ? this.player_.play() : this.player_.pause();
  }, i.handleKeyDown = function(r) {
    var a = this.player_.liveTracker;
    if (lt.isEventKey(r, "Space") || lt.isEventKey(r, "Enter"))
      r.preventDefault(), r.stopPropagation(), this.handleAction(r);
    else if (lt.isEventKey(r, "Home"))
      r.preventDefault(), r.stopPropagation(), this.userSeek_(0);
    else if (lt.isEventKey(r, "End"))
      r.preventDefault(), r.stopPropagation(), a && a.isLive() ? this.userSeek_(a.liveCurrentTime()) : this.userSeek_(this.player_.duration());
    else if (/^[0-9]$/.test(lt(r))) {
      r.preventDefault(), r.stopPropagation();
      var s = (lt.codes[lt(r)] - lt.codes[0]) * 10 / 100;
      a && a.isLive() ? this.userSeek_(
        a.seekableStart() + a.liveWindow() * s
      ) : this.userSeek_(this.player_.duration() * s);
    } else lt.isEventKey(r, "PgDn") ? (r.preventDefault(), r.stopPropagation(), this.userSeek_(
      this.player_.currentTime() - Yl * Ym
    )) : lt.isEventKey(r, "PgUp") ? (r.preventDefault(), r.stopPropagation(), this.userSeek_(
      this.player_.currentTime() + Yl * Ym
    )) : e.prototype.handleKeyDown.call(this, r);
  }, i.dispose = function() {
    this.disableInterval_(), this.off(
      this.player_,
      ["ended", "durationchange", "timeupdate"],
      this.update
    ), this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.update), this.off(this.player_, ["playing"], this.enableIntervalHandler_), this.off(
      this.player_,
      ["ended", "pause", "waiting"],
      this.disableIntervalHandler_
    ), "hidden" in Te && "visibilityState" in Te && this.off(Te, "visibilitychange", this.toggleVisibility_), e.prototype.dispose.call(this);
  }, t;
}(Hp);
Wp.prototype.options_ = {
  barName: "playProgressBar",
  children: ["loadProgressBar", "playProgressBar"]
};
!cr && !Jn && Wp.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
ye.registerComponent("SeekBar", Wp);
var db = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.handleMouseMove = Xn(
      Zt(He(a), a.handleMouseMove),
      $r
    ), a.throttledHandleMouseSeek = Xn(
      Zt(He(a), a.handleMouseSeek),
      $r
    ), a.handleMouseUpHandler_ = function(s) {
      return a.handleMouseUp(s);
    }, a.handleMouseDownHandler_ = function(s) {
      return a.handleMouseDown(s);
    }, a.enable(), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: "vjs-progress-control vjs-control"
    });
  }, i.handleMouseMove = function(r) {
    var a = this.getChild("seekBar");
    if (a) {
      var s = a.getChild("playProgressBar"), o = a.getChild("mouseTimeDisplay");
      if (!(!s && !o)) {
        var u = a.el(), l = ml(u), c = Lh(u, r).x;
        c = Fh(c, 0, 1), o && o.update(l, c), s && s.update(l, a.getProgress());
      }
    }
  }, i.handleMouseSeek = function(r) {
    var a = this.getChild("seekBar");
    a && a.handleMouseMove(r);
  }, i.enabled = function() {
    return this.enabled_;
  }, i.disable = function() {
    if (this.children().forEach(function(a) {
      return a.disable && a.disable();
    }), !!this.enabled() && (this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.off(this.el_, "mousemove", this.handleMouseMove), this.removeListenersAddedOnMousedownAndTouchstart(), this.addClass("disabled"), this.enabled_ = !1, this.player_.scrubbing())) {
      var r = this.getChild("seekBar");
      this.player_.scrubbing(!1), r.videoWasPlaying && hn(this.player_.play());
    }
  }, i.enable = function() {
    this.children().forEach(function(r) {
      return r.enable && r.enable();
    }), !this.enabled() && (this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.on(this.el_, "mousemove", this.handleMouseMove), this.removeClass("disabled"), this.enabled_ = !0);
  }, i.removeListenersAddedOnMousedownAndTouchstart = function() {
    var r = this.el_.ownerDocument;
    this.off(r, "mousemove", this.throttledHandleMouseSeek), this.off(r, "touchmove", this.throttledHandleMouseSeek), this.off(r, "mouseup", this.handleMouseUpHandler_), this.off(r, "touchend", this.handleMouseUpHandler_);
  }, i.handleMouseDown = function(r) {
    var a = this.el_.ownerDocument, s = this.getChild("seekBar");
    s && s.handleMouseDown(r), this.on(a, "mousemove", this.throttledHandleMouseSeek), this.on(a, "touchmove", this.throttledHandleMouseSeek), this.on(a, "mouseup", this.handleMouseUpHandler_), this.on(a, "touchend", this.handleMouseUpHandler_);
  }, i.handleMouseUp = function(r) {
    var a = this.getChild("seekBar");
    a && a.handleMouseUp(r), this.removeListenersAddedOnMousedownAndTouchstart();
  }, t;
}(ye);
db.prototype.options_ = {
  children: ["seekBar"]
};
ye.registerComponent("ProgressControl", db);
var fb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.on(
      n,
      ["enterpictureinpicture", "leavepictureinpicture"],
      function(s) {
        return a.handlePictureInPictureChange(s);
      }
    ), a.on(
      n,
      ["disablepictureinpicturechanged", "loadedmetadata"],
      function(s) {
        return a.handlePictureInPictureEnabledChange(s);
      }
    ), a.on(
      n,
      ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"],
      function() {
        var s = n.currentType().substring(0, 5) === "audio";
        s || n.audioPosterMode() || n.audioOnlyMode() ? (n.isInPictureInPicture() && n.exitPictureInPicture(), a.hide()) : a.show();
      }
    ), a.disable(), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-picture-in-picture-control " + e.prototype.buildCSSClass.call(this);
  }, i.handlePictureInPictureEnabledChange = function() {
    Te.pictureInPictureEnabled && this.player_.disablePictureInPicture() === !1 ? this.enable() : this.disable();
  }, i.handlePictureInPictureChange = function(r) {
    this.player_.isInPictureInPicture() ? this.controlText("Exit Picture-in-Picture") : this.controlText("Picture-in-Picture"), this.handlePictureInPictureEnabledChange();
  }, i.handleClick = function(r) {
    this.player_.isInPictureInPicture() ? this.player_.exitPictureInPicture() : this.player_.requestPictureInPicture();
  }, t;
}(Wr);
fb.prototype.controlText_ = "Picture-in-Picture";
ye.registerComponent("PictureInPictureToggle", fb);
var pb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.on(n, "fullscreenchange", function(s) {
      return a.handleFullscreenChange(s);
    }), Te[n.fsApi_.fullscreenEnabled] === !1 && a.disable(), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-fullscreen-control " + e.prototype.buildCSSClass.call(this);
  }, i.handleFullscreenChange = function(r) {
    this.player_.isFullscreen() ? this.controlText("Non-Fullscreen") : this.controlText("Fullscreen");
  }, i.handleClick = function(r) {
    this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen();
  }, t;
}(Wr);
pb.prototype.controlText_ = "Fullscreen";
ye.registerComponent("FullscreenToggle", pb);
var v3 = function(t, i) {
  i.tech_ && !i.tech_.featuresVolumeControl && t.addClass("vjs-hidden"), t.on(i, "loadstart", function() {
    i.tech_.featuresVolumeControl ? t.removeClass("vjs-hidden") : t.addClass("vjs-hidden");
  });
}, m3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.createEl = function() {
    var r = e.prototype.createEl.call(this, "div", {
      className: "vjs-volume-level"
    });
    return r.appendChild(
      e.prototype.createEl.call(this, "span", {
        className: "vjs-control-text"
      })
    ), r;
  }, t;
}(ye);
ye.registerComponent("VolumeLevel", m3);
var g3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.update = Xn(
      Zt(He(a), a.update),
      $r
    ), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-volume-tooltip"
      },
      {
        "aria-hidden": "true"
      }
    );
  }, i.update = function(r, a, s, o) {
    if (!s) {
      var u = Do(this.el_), l = Do(this.player_.el()), c = r.width * a;
      if (!l || !u)
        return;
      var h = r.left - l.left + c, d = r.width - c + (l.right - r.right), f = u.width / 2;
      h < f ? f += f - h : d < f && (f = d), f < 0 ? f = 0 : f > u.width && (f = u.width), this.el_.style.right = "-" + f + "px";
    }
    this.write(o + "%");
  }, i.write = function(r) {
    _s(this.el_, r);
  }, i.updateVolume = function(r, a, s, o, u) {
    var l = this;
    this.requestNamedAnimationFrame(
      "VolumeLevelTooltip#updateVolume",
      function() {
        l.update(r, a, s, o.toFixed(0)), u && u();
      }
    );
  }, t;
}(ye);
ye.registerComponent("VolumeLevelTooltip", g3);
var vb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.update = Xn(
      Zt(He(a), a.update),
      $r
    ), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  }, i.update = function(r, a, s) {
    var o = this, u = 100 * a;
    this.getChild("volumeLevelTooltip").updateVolume(
      r,
      a,
      s,
      u,
      function() {
        s ? o.el_.style.bottom = r.height * a + "px" : o.el_.style.left = r.width * a + "px";
      }
    );
  }, t;
}(ye);
vb.prototype.options_ = {
  children: ["volumeLevelTooltip"]
};
ye.registerComponent(
  "MouseVolumeLevelDisplay",
  vb
);
var Nh = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.on("slideractive", function(s) {
      return a.updateLastVolume_(s);
    }), a.on(n, "volumechange", function(s) {
      return a.updateARIAAttributes(s);
    }), n.ready(function() {
      return a.updateARIAAttributes();
    }), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-volume-bar vjs-slider-bar"
      },
      {
        "aria-label": this.localize("Volume Level"),
        "aria-live": "polite"
      }
    );
  }, i.handleMouseDown = function(r) {
    gl(r) && e.prototype.handleMouseDown.call(this, r);
  }, i.handleMouseMove = function(r) {
    var a = this.getChild("mouseVolumeLevelDisplay");
    if (a) {
      var s = this.el(), o = Do(s), u = this.vertical(), l = Lh(s, r);
      l = u ? l.y : l.x, l = Fh(l, 0, 1), a.update(o, l, u);
    }
    gl(r) && (this.checkMuted(), this.player_.volume(this.calculateDistance(r)));
  }, i.checkMuted = function() {
    this.player_.muted() && this.player_.muted(!1);
  }, i.getPercent = function() {
    return this.player_.muted() ? 0 : this.player_.volume();
  }, i.stepForward = function() {
    this.checkMuted(), this.player_.volume(this.player_.volume() + 0.1);
  }, i.stepBack = function() {
    this.checkMuted(), this.player_.volume(this.player_.volume() - 0.1);
  }, i.updateARIAAttributes = function(r) {
    var a = this.player_.muted() ? 0 : this.volumeAsPercentage_();
    this.el_.setAttribute("aria-valuenow", a), this.el_.setAttribute("aria-valuetext", a + "%");
  }, i.volumeAsPercentage_ = function() {
    return Math.round(this.player_.volume() * 100);
  }, i.updateLastVolume_ = function() {
    var r = this, a = this.player_.volume();
    this.one("sliderinactive", function() {
      r.player_.volume() === 0 && r.player_.lastVolume_(a);
    });
  }, t;
}(Hp);
Nh.prototype.options_ = {
  barName: "volumeLevel",
  children: ["volumeLevel"]
};
!cr && !Jn && Nh.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
Nh.prototype.playerEvent = "volumechange";
ye.registerComponent("VolumeBar", Nh);
var mb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return r === void 0 && (r = {}), r.vertical = r.vertical || !1, (typeof r.volumeBar > "u" || pl(r.volumeBar)) && (r.volumeBar = r.volumeBar || {}, r.volumeBar.vertical = r.vertical), a = e.call(this, n, r) || this, v3(He(a), n), a.throttledHandleMouseMove = Xn(
      Zt(He(a), a.handleMouseMove),
      $r
    ), a.handleMouseUpHandler_ = function(s) {
      return a.handleMouseUp(s);
    }, a.on("mousedown", function(s) {
      return a.handleMouseDown(s);
    }), a.on("touchstart", function(s) {
      return a.handleMouseDown(s);
    }), a.on("mousemove", function(s) {
      return a.handleMouseMove(s);
    }), a.on(a.volumeBar, ["focus", "slideractive"], function() {
      a.volumeBar.addClass("vjs-slider-active"), a.addClass("vjs-slider-active"), a.trigger("slideractive");
    }), a.on(a.volumeBar, ["blur", "sliderinactive"], function() {
      a.volumeBar.removeClass("vjs-slider-active"), a.removeClass("vjs-slider-active"), a.trigger("sliderinactive");
    }), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    var r = "vjs-volume-horizontal";
    return this.options_.vertical && (r = "vjs-volume-vertical"), e.prototype.createEl.call(this, "div", {
      className: "vjs-volume-control vjs-control " + r
    });
  }, i.handleMouseDown = function(r) {
    var a = this.el_.ownerDocument;
    this.on(a, "mousemove", this.throttledHandleMouseMove), this.on(a, "touchmove", this.throttledHandleMouseMove), this.on(a, "mouseup", this.handleMouseUpHandler_), this.on(a, "touchend", this.handleMouseUpHandler_);
  }, i.handleMouseUp = function(r) {
    var a = this.el_.ownerDocument;
    this.off(a, "mousemove", this.throttledHandleMouseMove), this.off(a, "touchmove", this.throttledHandleMouseMove), this.off(a, "mouseup", this.handleMouseUpHandler_), this.off(a, "touchend", this.handleMouseUpHandler_);
  }, i.handleMouseMove = function(r) {
    this.volumeBar.handleMouseMove(r);
  }, t;
}(ye);
mb.prototype.options_ = {
  children: ["volumeBar"]
};
ye.registerComponent("VolumeControl", mb);
var y3 = function(t, i) {
  i.tech_ && !i.tech_.featuresMuteControl && t.addClass("vjs-hidden"), t.on(i, "loadstart", function() {
    i.tech_.featuresMuteControl ? t.removeClass("vjs-hidden") : t.addClass("vjs-hidden");
  });
}, gb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, y3(He(a), n), a.on(n, ["loadstart", "volumechange"], function(s) {
      return a.update(s);
    }), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-mute-control " + e.prototype.buildCSSClass.call(this);
  }, i.handleClick = function(r) {
    var a = this.player_.volume(), s = this.player_.lastVolume_();
    if (a === 0) {
      var o = s < 0.1 ? 0.1 : s;
      this.player_.volume(o), this.player_.muted(!1);
    } else
      this.player_.muted(!this.player_.muted());
  }, i.update = function(r) {
    this.updateIcon_(), this.updateControlText_();
  }, i.updateIcon_ = function() {
    var r = this.player_.volume(), a = 3;
    this.player_.tech_ && this.player_.tech_.el_ && this.player_.muted(this.player_.tech_.el_.muted), r === 0 || this.player_.muted() ? a = 0 : r < 0.33 ? a = 1 : r < 0.67 && (a = 2);
    for (var s = 0; s < 4; s++)
      Pl(this.el_, "vjs-vol-" + s);
    Un(this.el_, "vjs-vol-" + a);
  }, i.updateControlText_ = function() {
    var r = this.player_.muted() || this.player_.volume() === 0, a = r ? "Unmute" : "Mute";
    this.controlText() !== a && this.controlText(a);
  }, t;
}(Wr);
gb.prototype.controlText_ = "Mute";
ye.registerComponent("MuteToggle", gb);
var yb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return r === void 0 && (r = {}), typeof r.inline < "u" ? r.inline = r.inline : r.inline = !0, (typeof r.volumeControl > "u" || pl(r.volumeControl)) && (r.volumeControl = r.volumeControl || {}, r.volumeControl.vertical = !r.inline), a = e.call(this, n, r) || this, a.handleKeyPressHandler_ = function(s) {
      return a.handleKeyPress(s);
    }, a.on(n, ["loadstart"], function(s) {
      return a.volumePanelState_(s);
    }), a.on(a.muteToggle, "keyup", function(s) {
      return a.handleKeyPress(s);
    }), a.on(a.volumeControl, "keyup", function(s) {
      return a.handleVolumeControlKeyUp(s);
    }), a.on("keydown", function(s) {
      return a.handleKeyPress(s);
    }), a.on("mouseover", function(s) {
      return a.handleMouseOver(s);
    }), a.on("mouseout", function(s) {
      return a.handleMouseOut(s);
    }), a.on(a.volumeControl, ["slideractive"], a.sliderActive_), a.on(a.volumeControl, ["sliderinactive"], a.sliderInactive_), a;
  }
  var i = t.prototype;
  return i.sliderActive_ = function() {
    this.addClass("vjs-slider-active");
  }, i.sliderInactive_ = function() {
    this.removeClass("vjs-slider-active");
  }, i.volumePanelState_ = function() {
    this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"), this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only");
  }, i.createEl = function() {
    var r = "vjs-volume-panel-horizontal";
    return this.options_.inline || (r = "vjs-volume-panel-vertical"), e.prototype.createEl.call(this, "div", {
      className: "vjs-volume-panel vjs-control " + r
    });
  }, i.dispose = function() {
    this.handleMouseOut(), e.prototype.dispose.call(this);
  }, i.handleVolumeControlKeyUp = function(r) {
    lt.isEventKey(r, "Esc") && this.muteToggle.focus();
  }, i.handleMouseOver = function(r) {
    this.addClass("vjs-hover"), Pr(Te, "keyup", this.handleKeyPressHandler_);
  }, i.handleMouseOut = function(r) {
    this.removeClass("vjs-hover"), Hi(Te, "keyup", this.handleKeyPressHandler_);
  }, i.handleKeyPress = function(r) {
    lt.isEventKey(r, "Esc") && this.handleMouseOut();
  }, t;
}(ye);
yb.prototype.options_ = {
  children: ["muteToggle", "volumeControl"]
};
ye.registerComponent("VolumePanel", yb);
var _b = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, r && (a.menuButton_ = r.menuButton), a.focusedChild_ = -1, a.on("keydown", function(s) {
      return a.handleKeyDown(s);
    }), a.boundHandleBlur_ = function(s) {
      return a.handleBlur(s);
    }, a.boundHandleTapClick_ = function(s) {
      return a.handleTapClick(s);
    }, a;
  }
  var i = t.prototype;
  return i.addEventListenerForItem = function(r) {
    r instanceof ye && (this.on(r, "blur", this.boundHandleBlur_), this.on(r, ["tap", "click"], this.boundHandleTapClick_));
  }, i.removeEventListenerForItem = function(r) {
    r instanceof ye && (this.off(r, "blur", this.boundHandleBlur_), this.off(r, ["tap", "click"], this.boundHandleTapClick_));
  }, i.removeChild = function(r) {
    typeof r == "string" && (r = this.getChild(r)), this.removeEventListenerForItem(r), e.prototype.removeChild.call(this, r);
  }, i.addItem = function(r) {
    var a = this.addChild(r);
    a && this.addEventListenerForItem(a);
  }, i.createEl = function() {
    var r = this.options_.contentElType || "ul";
    this.contentEl_ = St(r, {
      className: "vjs-menu-content"
    }), this.contentEl_.setAttribute("role", "menu");
    var a = e.prototype.createEl.call(this, "div", {
      append: this.contentEl_,
      className: "vjs-menu"
    });
    return a.appendChild(this.contentEl_), Pr(a, "click", function(s) {
      s.preventDefault(), s.stopImmediatePropagation();
    }), a;
  }, i.dispose = function() {
    this.contentEl_ = null, this.boundHandleBlur_ = null, this.boundHandleTapClick_ = null, e.prototype.dispose.call(this);
  }, i.handleBlur = function(r) {
    var a = r.relatedTarget || Te.activeElement;
    if (!this.children().some(function(o) {
      return o.el() === a;
    })) {
      var s = this.menuButton_;
      s && s.buttonPressed_ && a !== s.el().firstChild && s.unpressButton();
    }
  }, i.handleTapClick = function(r) {
    if (this.menuButton_) {
      this.menuButton_.unpressButton();
      var a = this.children();
      if (!Array.isArray(a))
        return;
      var s = a.filter(function(o) {
        return o.el() === r.target;
      })[0];
      if (!s)
        return;
      s.name() !== "CaptionSettingsMenuItem" && this.menuButton_.focus();
    }
  }, i.handleKeyDown = function(r) {
    lt.isEventKey(r, "Left") || lt.isEventKey(r, "Down") ? (r.preventDefault(), r.stopPropagation(), this.stepForward()) : (lt.isEventKey(r, "Right") || lt.isEventKey(r, "Up")) && (r.preventDefault(), r.stopPropagation(), this.stepBack());
  }, i.stepForward = function() {
    var r = 0;
    this.focusedChild_ !== void 0 && (r = this.focusedChild_ + 1), this.focus(r);
  }, i.stepBack = function() {
    var r = 0;
    this.focusedChild_ !== void 0 && (r = this.focusedChild_ - 1), this.focus(r);
  }, i.focus = function(r) {
    r === void 0 && (r = 0);
    var a = this.children().slice(), s = a.length && a[0].hasClass("vjs-menu-title");
    s && a.shift(), a.length > 0 && (r < 0 ? r = 0 : r >= a.length && (r = a.length - 1), this.focusedChild_ = r, a[r].el_.focus());
  }, t;
}(ye);
ye.registerComponent("Menu", _b);
var qp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    r === void 0 && (r = {}), a = e.call(this, n, r) || this, a.menuButton_ = new Wr(n, r), a.menuButton_.controlText(a.controlText_), a.menuButton_.el_.setAttribute("aria-haspopup", "true");
    var s = Wr.prototype.buildCSSClass();
    a.menuButton_.el_.className = a.buildCSSClass() + " " + s, a.menuButton_.removeClass("vjs-control"), a.addChild(a.menuButton_), a.update(), a.enabled_ = !0;
    var o = function(l) {
      return a.handleClick(l);
    };
    return a.handleMenuKeyUp_ = function(u) {
      return a.handleMenuKeyUp(u);
    }, a.on(a.menuButton_, "tap", o), a.on(a.menuButton_, "click", o), a.on(a.menuButton_, "keydown", function(u) {
      return a.handleKeyDown(u);
    }), a.on(a.menuButton_, "mouseenter", function() {
      a.addClass("vjs-hover"), a.menu.show(), Pr(Te, "keyup", a.handleMenuKeyUp_);
    }), a.on("mouseleave", function(u) {
      return a.handleMouseLeave(u);
    }), a.on("keydown", function(u) {
      return a.handleSubmenuKeyDown(u);
    }), a;
  }
  var i = t.prototype;
  return i.update = function() {
    var r = this.createMenu();
    this.menu && (this.menu.dispose(), this.removeChild(this.menu)), this.menu = r, this.addChild(r), this.buttonPressed_ = !1, this.menuButton_.el_.setAttribute("aria-expanded", "false"), this.items && this.items.length <= this.hideThreshold_ ? (this.hide(), this.menu.contentEl_.removeAttribute("role")) : (this.show(), this.menu.contentEl_.setAttribute("role", "menu"));
  }, i.createMenu = function() {
    var r = new _b(this.player_, {
      menuButton: this
    });
    if (this.hideThreshold_ = 0, this.options_.title) {
      var a = St("li", {
        className: "vjs-menu-title",
        tabIndex: -1,
        textContent: vi(this.options_.title)
      }), s = new ye(this.player_, {
        el: a
      });
      r.addItem(s);
    }
    if (this.items = this.createItems(), this.items)
      for (var o = 0; o < this.items.length; o++)
        r.addItem(this.items[o]);
    return r;
  }, i.createItems = function() {
  }, i.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: this.buildWrapperCSSClass()
      },
      {}
    );
  }, i.buildWrapperCSSClass = function() {
    var r = "vjs-menu-button";
    this.options_.inline === !0 ? r += "-inline" : r += "-popup";
    var a = Wr.prototype.buildCSSClass();
    return "vjs-menu-button " + r + " " + a + " " + e.prototype.buildCSSClass.call(this);
  }, i.buildCSSClass = function() {
    var r = "vjs-menu-button";
    return this.options_.inline === !0 ? r += "-inline" : r += "-popup", "vjs-menu-button " + r + " " + e.prototype.buildCSSClass.call(this);
  }, i.controlText = function(r, a) {
    return a === void 0 && (a = this.menuButton_.el()), this.menuButton_.controlText(r, a);
  }, i.dispose = function() {
    this.handleMouseLeave(), e.prototype.dispose.call(this);
  }, i.handleClick = function(r) {
    this.buttonPressed_ ? this.unpressButton() : this.pressButton();
  }, i.handleMouseLeave = function(r) {
    this.removeClass("vjs-hover"), Hi(Te, "keyup", this.handleMenuKeyUp_);
  }, i.focus = function() {
    this.menuButton_.focus();
  }, i.blur = function() {
    this.menuButton_.blur();
  }, i.handleKeyDown = function(r) {
    lt.isEventKey(r, "Esc") || lt.isEventKey(r, "Tab") ? (this.buttonPressed_ && this.unpressButton(), lt.isEventKey(r, "Tab") || (r.preventDefault(), this.menuButton_.focus())) : (lt.isEventKey(r, "Up") || lt.isEventKey(r, "Down")) && (this.buttonPressed_ || (r.preventDefault(), this.pressButton()));
  }, i.handleMenuKeyUp = function(r) {
    (lt.isEventKey(r, "Esc") || lt.isEventKey(r, "Tab")) && this.removeClass("vjs-hover");
  }, i.handleSubmenuKeyPress = function(r) {
    this.handleSubmenuKeyDown(r);
  }, i.handleSubmenuKeyDown = function(r) {
    (lt.isEventKey(r, "Esc") || lt.isEventKey(r, "Tab")) && (this.buttonPressed_ && this.unpressButton(), lt.isEventKey(r, "Tab") || (r.preventDefault(), this.menuButton_.focus()));
  }, i.pressButton = function() {
    if (this.enabled_) {
      if (this.buttonPressed_ = !0, this.menu.show(), this.menu.lockShowing(), this.menuButton_.el_.setAttribute("aria-expanded", "true"), cr && O_())
        return;
      this.menu.focus();
    }
  }, i.unpressButton = function() {
    this.enabled_ && (this.buttonPressed_ = !1, this.menu.unlockShowing(), this.menu.hide(), this.menuButton_.el_.setAttribute("aria-expanded", "false"));
  }, i.disable = function() {
    this.unpressButton(), this.enabled_ = !1, this.addClass("vjs-disabled"), this.menuButton_.disable();
  }, i.enable = function() {
    this.enabled_ = !0, this.removeClass("vjs-disabled"), this.menuButton_.enable();
  }, t;
}(ye);
ye.registerComponent("MenuButton", qp);
var Xp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(i, n) {
    var r, a = n.tracks;
    if (r = e.call(this, i, n) || this, r.items.length <= 1 && r.hide(), !a)
      return He(r);
    var s = Zt(He(r), r.update);
    return a.addEventListener("removetrack", s), a.addEventListener("addtrack", s), a.addEventListener("labelchange", s), r.player_.on("ready", s), r.player_.on("dispose", function() {
      a.removeEventListener("removetrack", s), a.removeEventListener("addtrack", s), a.removeEventListener("labelchange", s);
    }), r;
  }
  return t;
}(qp);
ye.registerComponent("TrackButton", Xp);
var _3 = ["Tab", "Esc", "Up", "Down", "Right", "Left"], Rl = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.selectable = r.selectable, a.isSelected_ = r.selected || !1, a.multiSelectable = r.multiSelectable, a.selected(a.isSelected_), a.selectable ? a.multiSelectable ? a.el_.setAttribute("role", "menuitemcheckbox") : a.el_.setAttribute("role", "menuitemradio") : a.el_.setAttribute("role", "menuitem"), a;
  }
  var i = t.prototype;
  return i.createEl = function(r, a, s) {
    this.nonIconControl = !0;
    var o = e.prototype.createEl.call(
      this,
      "li",
      si(
        {
          className: "vjs-menu-item",
          tabIndex: -1
        },
        a
      ),
      s
    );
    return o.replaceChild(
      St("span", {
        className: "vjs-menu-item-text",
        textContent: this.localize(this.options_.label)
      }),
      o.querySelector(".vjs-icon-placeholder")
    ), o;
  }, i.handleKeyDown = function(r) {
    _3.some(function(a) {
      return lt.isEventKey(r, a);
    }) || e.prototype.handleKeyDown.call(this, r);
  }, i.handleClick = function(r) {
    this.selected(!0);
  }, i.selected = function(r) {
    this.selectable && (r ? (this.addClass("vjs-selected"), this.el_.setAttribute("aria-checked", "true"), this.controlText(", selected"), this.isSelected_ = !0) : (this.removeClass("vjs-selected"), this.el_.setAttribute("aria-checked", "false"), this.controlText(""), this.isSelected_ = !1));
  }, t;
}(Bh);
ye.registerComponent("MenuItem", Rl);
var Il = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a, s = r.track, o = n.textTracks();
    r.label = s.label || s.language || "Unknown", r.selected = s.mode === "showing", a = e.call(this, n, r) || this, a.track = s, a.kinds = (r.kinds || [r.kind || a.track.kind]).filter(
      Boolean
    );
    var u = function() {
      for (var d = arguments.length, f = new Array(d), p = 0; p < d; p++)
        f[p] = arguments[p];
      a.handleTracksChange.apply(He(a), f);
    }, l = function() {
      for (var d = arguments.length, f = new Array(d), p = 0; p < d; p++)
        f[p] = arguments[p];
      a.handleSelectedLanguageChange.apply(
        He(a),
        f
      );
    };
    if (n.on(["loadstart", "texttrackchange"], u), o.addEventListener("change", u), o.addEventListener(
      "selectedlanguagechange",
      l
    ), a.on("dispose", function() {
      n.off(["loadstart", "texttrackchange"], u), o.removeEventListener("change", u), o.removeEventListener(
        "selectedlanguagechange",
        l
      );
    }), o.onchange === void 0) {
      var c;
      a.on(["tap", "click"], function() {
        if (typeof W.Event != "object")
          try {
            c = new W.Event("change");
          } catch {
          }
        c || (c = Te.createEvent("Event"), c.initEvent("change", !0, !0)), o.dispatchEvent(c);
      });
    }
    return a.handleTracksChange(), a;
  }
  var i = t.prototype;
  return i.handleClick = function(r) {
    var a = this.track, s = this.player_.textTracks();
    if (e.prototype.handleClick.call(this, r), !!s)
      for (var o = 0; o < s.length; o++) {
        var u = s[o];
        this.kinds.indexOf(u.kind) !== -1 && (u === a ? u.mode !== "showing" && (u.mode = "showing") : u.mode !== "disabled" && (u.mode = "disabled"));
      }
  }, i.handleTracksChange = function(r) {
    var a = this.track.mode === "showing";
    a !== this.isSelected_ && this.selected(a);
  }, i.handleSelectedLanguageChange = function(r) {
    if (this.track.mode === "showing") {
      var a = this.player_.cache_.selectedLanguage;
      if (a && a.enabled && a.language === this.track.language && a.kind !== this.track.kind)
        return;
      this.player_.cache_.selectedLanguage = {
        enabled: !0,
        kind: this.track.kind,
        language: this.track.language
      };
    }
  }, i.dispose = function() {
    this.track = null, e.prototype.dispose.call(this);
  }, t;
}(Rl);
ye.registerComponent("TextTrackMenuItem", Il);
var bb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    return r.track = {
      default: !1,
      // it is no longer necessary to store `kind` or `kinds` on the track itself
      // since they are now stored in the `kinds` property of all instances of
      // TextTrackMenuItem, but this will remain for backwards compatibility
      kind: r.kind,
      kinds: r.kinds,
      mode: "disabled",
      player: n
    }, r.kinds || (r.kinds = [r.kind]), r.label ? r.track.label = r.label : r.track.label = r.kinds.join(" and ") + " off", r.selectable = !0, r.multiSelectable = !1, e.call(this, n, r) || this;
  }
  var i = t.prototype;
  return i.handleTracksChange = function(r) {
    for (var a = this.player().textTracks(), s = !0, o = 0, u = a.length; o < u; o++) {
      var l = a[o];
      if (this.options_.kinds.indexOf(l.kind) > -1 && l.mode === "showing") {
        s = !1;
        break;
      }
    }
    s !== this.isSelected_ && this.selected(s);
  }, i.handleSelectedLanguageChange = function(r) {
    for (var a = this.player().textTracks(), s = !0, o = 0, u = a.length; o < u; o++) {
      var l = a[o];
      if (["captions", "descriptions", "subtitles"].indexOf(l.kind) > -1 && l.mode === "showing") {
        s = !1;
        break;
      }
    }
    s && (this.player_.cache_.selectedLanguage = {
      enabled: !1
    });
  }, t;
}(Il);
ye.registerComponent("OffTextTrackMenuItem", bb);
var Vo = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    return r === void 0 && (r = {}), r.tracks = n.textTracks(), e.call(this, n, r) || this;
  }
  var i = t.prototype;
  return i.createItems = function(r, a) {
    r === void 0 && (r = []), a === void 0 && (a = Il);
    var s;
    this.label_ && (s = this.label_ + " off"), r.push(
      new bb(this.player_, {
        kind: this.kind_,
        kinds: this.kinds_,
        label: s
      })
    ), this.hideThreshold_ += 1;
    var o = this.player_.textTracks();
    Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]);
    for (var u = 0; u < o.length; u++) {
      var l = o[u];
      if (this.kinds_.indexOf(l.kind) > -1) {
        var c = new a(this.player_, {
          kind: this.kind_,
          kinds: this.kinds_,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: !1,
          // MenuItem is selectable
          selectable: !0,
          track: l
        });
        c.addClass("vjs-" + l.kind + "-menu-item"), c.setAttribute("title", l.label), r.push(c);
      }
    }
    return r;
  }, t;
}(Xp);
ye.registerComponent("TextTrackButton", Vo);
var xb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a, s = r.track, o = r.cue, u = n.currentTime();
    return r.selectable = !0, r.multiSelectable = !1, r.label = o.text, r.selected = o.startTime <= u && u < o.endTime, a = e.call(this, n, r) || this, a.track = s, a.cue = o, a;
  }
  var i = t.prototype;
  return i.handleClick = function(r) {
    e.prototype.handleClick.call(this), this.player_.currentTime(this.cue.startTime);
  }, t;
}(Rl);
ye.registerComponent("ChaptersTrackMenuItem", xb);
var Yp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a) {
    var s;
    return s = e.call(this, n, r, a) || this, s.selectCurrentItem_ = function() {
      s.items.forEach(function(o) {
        o.selected(s.track_.activeCues[0] === o.cue);
      });
    }, s;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-chapters-button " + e.prototype.buildCSSClass.call(this);
  }, i.buildWrapperCSSClass = function() {
    return "vjs-chapters-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, i.update = function(r) {
    if (!(r && r.track && r.track.kind !== "chapters")) {
      var a = this.findChaptersTrack();
      a !== this.track_ ? (this.setTrack(a), e.prototype.update.call(this)) : (!this.items || a && a.cues && a.cues.length !== this.items.length) && e.prototype.update.call(this);
    }
  }, i.setTrack = function(r) {
    if (this.track_ !== r) {
      if (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)), this.track_) {
        var a = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        a && a.removeEventListener("load", this.updateHandler_), this.track_.removeEventListener("cuechange", this.selectCurrentItem_), this.track_ = null;
      }
      if (this.track_ = r, this.track_) {
        this.track_.mode = "hidden";
        var s = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        s && s.addEventListener("load", this.updateHandler_), this.track_.addEventListener("cuechange", this.selectCurrentItem_);
      }
    }
  }, i.findChaptersTrack = function() {
    for (var r = this.player_.textTracks() || [], a = r.length - 1; a >= 0; a--) {
      var s = r[a];
      if (s.kind === this.kind_)
        return s;
    }
  }, i.getMenuCaption = function() {
    return this.track_ && this.track_.label ? this.track_.label : this.localize(vi(this.kind_));
  }, i.createMenu = function() {
    return this.options_.title = this.getMenuCaption(), e.prototype.createMenu.call(this);
  }, i.createItems = function() {
    var r = [];
    if (!this.track_)
      return r;
    var a = this.track_.cues;
    if (!a)
      return r;
    for (var s = 0, o = a.length; s < o; s++) {
      var u = a[s], l = new xb(this.player_, {
        cue: u,
        track: this.track_
      });
      r.push(l);
    }
    return r;
  }, t;
}(Vo);
Yp.prototype.kind_ = "chapters";
Yp.prototype.controlText_ = "Chapters";
ye.registerComponent("ChaptersButton", Yp);
var Qp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a) {
    var s;
    s = e.call(this, n, r, a) || this;
    var o = n.textTracks(), u = Zt(
      He(s),
      s.handleTracksChange
    );
    return o.addEventListener("change", u), s.on("dispose", function() {
      o.removeEventListener("change", u);
    }), s;
  }
  var i = t.prototype;
  return i.handleTracksChange = function(r) {
    for (var a = this.player().textTracks(), s = !1, o = 0, u = a.length; o < u; o++) {
      var l = a[o];
      if (l.kind !== this.kind_ && l.mode === "showing") {
        s = !0;
        break;
      }
    }
    s ? this.disable() : this.enable();
  }, i.buildCSSClass = function() {
    return "vjs-descriptions-button " + e.prototype.buildCSSClass.call(this);
  }, i.buildWrapperCSSClass = function() {
    return "vjs-descriptions-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, t;
}(Vo);
Qp.prototype.kind_ = "descriptions";
Qp.prototype.controlText_ = "Descriptions";
ye.registerComponent("DescriptionsButton", Qp);
var Kp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a) {
    return e.call(this, n, r, a) || this;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-subtitles-button " + e.prototype.buildCSSClass.call(this);
  }, i.buildWrapperCSSClass = function() {
    return "vjs-subtitles-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, t;
}(Vo);
Kp.prototype.kind_ = "subtitles";
Kp.prototype.controlText_ = "Subtitles";
ye.registerComponent("SubtitlesButton", Kp);
var Zp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return r.track = {
      default: !1,
      kind: r.kind,
      label: r.kind + " settings",
      mode: "disabled",
      player: n,
      selectable: !1
    }, r.selectable = !1, r.name = "CaptionSettingsMenuItem", a = e.call(this, n, r) || this, a.addClass("vjs-texttrack-settings"), a.controlText(", opens " + r.kind + " settings dialog"), a;
  }
  var i = t.prototype;
  return i.handleClick = function(r) {
    this.player().getChild("textTrackSettings").open();
  }, t;
}(Il);
ye.registerComponent(
  "CaptionSettingsMenuItem",
  Zp
);
var Jp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a) {
    return e.call(this, n, r, a) || this;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-captions-button " + e.prototype.buildCSSClass.call(this);
  }, i.buildWrapperCSSClass = function() {
    return "vjs-captions-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, i.createItems = function() {
    var r = [];
    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (r.push(
      new Zp(this.player_, {
        kind: this.kind_
      })
    ), this.hideThreshold_ += 1), e.prototype.createItems.call(this, r);
  }, t;
}(Vo);
Jp.prototype.kind_ = "captions";
Jp.prototype.controlText_ = "Captions";
ye.registerComponent("CaptionsButton", Jp);
var Ab = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.createEl = function(r, a, s) {
    var o = e.prototype.createEl.call(
      this,
      r,
      a,
      s
    ), u = o.querySelector(".vjs-menu-item-text");
    return this.options_.track.kind === "captions" && (u.appendChild(
      St(
        "span",
        {
          className: "vjs-icon-placeholder"
        },
        {
          "aria-hidden": !0
        }
      )
    ), u.appendChild(
      St("span", {
        className: "vjs-control-text",
        // space added as the text will visually flow with the
        // label
        textContent: " " + this.localize("Captions")
      })
    )), o;
  }, t;
}(Il);
ye.registerComponent("SubsCapsMenuItem", Ab);
var $p = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return r === void 0 && (r = {}), a = e.call(this, n, r) || this, a.label_ = "subtitles", ["en", "en-us", "en-ca", "fr-ca"].indexOf(a.player_.language_) > -1 && (a.label_ = "captions"), a.menuButton_.controlText(vi(a.label_)), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-subs-caps-button " + e.prototype.buildCSSClass.call(this);
  }, i.buildWrapperCSSClass = function() {
    return "vjs-subs-caps-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, i.createItems = function() {
    var r = [];
    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (r.push(
      new Zp(this.player_, {
        kind: this.label_
      })
    ), this.hideThreshold_ += 1), r = e.prototype.createItems.call(
      this,
      r,
      Ab
    ), r;
  }, t;
}(Vo);
$p.prototype.kinds_ = ["captions", "subtitles"];
$p.prototype.controlText_ = "Subtitles";
ye.registerComponent("SubsCapsButton", $p);
var Tb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a, s = r.track, o = n.audioTracks();
    r.label = s.label || s.language || "Unknown", r.selected = s.enabled, a = e.call(this, n, r) || this, a.track = s, a.addClass("vjs-" + s.kind + "-menu-item"), a.setAttribute("title", s.label);
    var u = function() {
      for (var c = arguments.length, h = new Array(c), d = 0; d < c; d++)
        h[d] = arguments[d];
      a.handleTracksChange.apply(He(a), h);
    };
    return o.addEventListener("change", u), a.on("dispose", function() {
      o.removeEventListener("change", u);
    }), a;
  }
  var i = t.prototype;
  return i.createEl = function(r, a, s) {
    var o = e.prototype.createEl.call(this, r, a, s), u = o.querySelector(".vjs-menu-item-text");
    return this.options_.track.kind === "main-desc" && (u.appendChild(
      St(
        "span",
        {
          className: "vjs-icon-placeholder"
        },
        {
          "aria-hidden": !0
        }
      )
    ), u.appendChild(
      St("span", {
        className: "vjs-control-text",
        textContent: " " + this.localize("Descriptions")
      })
    )), o;
  }, i.handleClick = function(r) {
    if (e.prototype.handleClick.call(this, r), this.track.enabled = !0, this.player_.tech_.featuresNativeAudioTracks)
      for (var a = this.player_.audioTracks(), s = 0; s < a.length; s++) {
        var o = a[s];
        o !== this.track && (o.enabled = o === this.track);
      }
  }, i.handleTracksChange = function(r) {
    this.selected(this.track.enabled);
  }, t;
}(Rl);
ye.registerComponent("AudioTrackMenuItem", Tb);
var Eb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    return r === void 0 && (r = {}), r.tracks = n.audioTracks(), e.call(this, n, r) || this;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-audio-button " + e.prototype.buildCSSClass.call(this);
  }, i.buildWrapperCSSClass = function() {
    return "vjs-audio-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, i.createItems = function(r) {
    r === void 0 && (r = []), this.hideThreshold_ = 1;
    for (var a = this.player_.audioTracks(), s = 0; s < a.length; s++) {
      var o = a[s];
      r.push(
        new Tb(this.player_, {
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: !1,
          // MenuItem is selectable
          selectable: !0,
          track: o
        })
      );
    }
    return r;
  }, t;
}(Xp);
Eb.prototype.controlText_ = "Audio Track";
ye.registerComponent("AudioTrackButton", Eb);
var ev = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a, s = r.rate, o = parseFloat(s, 10);
    return r.label = s, r.selected = o === n.playbackRate(), r.selectable = !0, r.multiSelectable = !1, a = e.call(this, n, r) || this, a.label = s, a.rate = o, a.on(n, "ratechange", function(u) {
      return a.update(u);
    }), a;
  }
  var i = t.prototype;
  return i.handleClick = function(r) {
    e.prototype.handleClick.call(this), this.player().playbackRate(this.rate);
  }, i.update = function(r) {
    this.selected(this.player().playbackRate() === this.rate);
  }, t;
}(Rl);
ev.prototype.contentElType = "button";
ye.registerComponent("PlaybackRateMenuItem", ev);
var wb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.menuButton_.el_.setAttribute("aria-describedby", a.labelElId_), a.updateVisibility(), a.updateLabel(), a.on(n, "loadstart", function(s) {
      return a.updateVisibility(s);
    }), a.on(n, "ratechange", function(s) {
      return a.updateLabel(s);
    }), a.on(n, "playbackrateschange", function(s) {
      return a.handlePlaybackRateschange(s);
    }), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    var r = e.prototype.createEl.call(this);
    return this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_, this.labelEl_ = St("div", {
      className: "vjs-playback-rate-value",
      id: this.labelElId_,
      textContent: "1x"
    }), r.appendChild(this.labelEl_), r;
  }, i.dispose = function() {
    this.labelEl_ = null, e.prototype.dispose.call(this);
  }, i.buildCSSClass = function() {
    return "vjs-playback-rate " + e.prototype.buildCSSClass.call(this);
  }, i.buildWrapperCSSClass = function() {
    return "vjs-playback-rate " + e.prototype.buildWrapperCSSClass.call(this);
  }, i.createItems = function() {
    for (var r = this.playbackRates(), a = [], s = r.length - 1; s >= 0; s--)
      a.push(
        new ev(this.player(), {
          rate: r[s] + "x"
        })
      );
    return a;
  }, i.updateARIAAttributes = function() {
    this.el().setAttribute("aria-valuenow", this.player().playbackRate());
  }, i.handlePlaybackRateschange = function(r) {
    this.update();
  }, i.playbackRates = function() {
    var r = this.player();
    return r.playbackRates && r.playbackRates() || [];
  }, i.playbackRateSupported = function() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  }, i.updateVisibility = function(r) {
    this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden");
  }, i.updateLabel = function(r) {
    this.playbackRateSupported() && (this.labelEl_.textContent = this.player().playbackRate() + "x");
  }, t;
}(qp);
wb.prototype.controlText_ = "Playback Rate";
ye.registerComponent("PlaybackRateMenuButton", wb);
var Sb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-spacer " + e.prototype.buildCSSClass.call(this);
  }, i.createEl = function(r, a, s) {
    return r === void 0 && (r = "div"), a === void 0 && (a = {}), s === void 0 && (s = {}), a.className || (a.className = this.buildCSSClass()), e.prototype.createEl.call(this, r, a, s);
  }, t;
}(ye);
ye.registerComponent("Spacer", Sb);
var b3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-custom-control-spacer " + e.prototype.buildCSSClass.call(this);
  }, i.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: this.buildCSSClass(),
      // No-flex/table-cell mode requires there be some content
      // in the cell to fill the remaining space of the table.
      textContent: ""
    });
  }, t;
}(Sb);
ye.registerComponent("CustomControlSpacer", b3);
var zc = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: "vjs-control-bar",
      dir: "ltr"
    });
  }, t;
}(ye);
zc.prototype.options_ = {
  children: [
    "playToggle",
    "volumePanel",
    "currentTimeDisplay",
    "timeDivider",
    "durationDisplay",
    "progressControl",
    "liveDisplay",
    "seekToLive",
    "remainingTimeDisplay",
    "customControlSpacer",
    "playbackRateMenuButton",
    "chaptersButton",
    "descriptionsButton",
    "subsCapsButton",
    "audioTrackButton",
    "fullscreenToggle"
  ]
};
"exitPictureInPicture" in Te && zc.prototype.options_.children.splice(
  zc.prototype.options_.children.length - 1,
  0,
  "pictureInPictureToggle"
);
ye.registerComponent("ControlBar", zc);
var Cb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.on(n, "error", function(s) {
      return a.open(s);
    }), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-error-display " + e.prototype.buildCSSClass.call(this);
  }, i.content = function() {
    var r = this.player().error();
    return r ? this.localize(r.message) : "";
  }, t;
}(Uo);
Cb.prototype.options_ = kr({}, Uo.prototype.options_, {
  fillAlways: !0,
  pauseOnOpen: !1,
  temporary: !1,
  uncloseable: !0
});
ye.registerComponent("ErrorDisplay", Cb);
var md = "vjs-text-track-settings", Qm = ["#000", "Black"], Km = ["#00F", "Blue"], Zm = ["#0FF", "Cyan"], Jm = ["#0F0", "Green"], $m = ["#F0F", "Magenta"], eg = ["#F00", "Red"], tg = ["#FFF", "White"], ig = ["#FF0", "Yellow"], gd = ["1", "Opaque"], yd = ["0.5", "Semi-Transparent"], rg = ["0", "Transparent"], La = {
  backgroundColor: {
    id: "captions-background-color-%s",
    label: "Color",
    options: [
      Qm,
      tg,
      eg,
      Jm,
      Km,
      ig,
      $m,
      Zm
    ],
    selector: ".vjs-bg-color > select"
  },
  backgroundOpacity: {
    id: "captions-background-opacity-%s",
    label: "Transparency",
    options: [gd, yd, rg],
    selector: ".vjs-bg-opacity > select"
  },
  color: {
    id: "captions-foreground-color-%s",
    label: "Color",
    options: [
      tg,
      Qm,
      eg,
      Jm,
      Km,
      ig,
      $m,
      Zm
    ],
    selector: ".vjs-fg-color > select"
  },
  edgeStyle: {
    id: "%s",
    label: "Text Edge Style",
    options: [
      ["none", "None"],
      ["raised", "Raised"],
      ["depressed", "Depressed"],
      ["uniform", "Uniform"],
      ["dropshadow", "Dropshadow"]
    ],
    selector: ".vjs-edge-style > select"
  },
  fontFamily: {
    id: "captions-font-family-%s",
    label: "Font Family",
    options: [
      ["proportionalSansSerif", "Proportional Sans-Serif"],
      ["monospaceSansSerif", "Monospace Sans-Serif"],
      ["proportionalSerif", "Proportional Serif"],
      ["monospaceSerif", "Monospace Serif"],
      ["casual", "Casual"],
      ["script", "Script"],
      ["small-caps", "Small Caps"]
    ],
    selector: ".vjs-font-family > select"
  },
  fontPercent: {
    default: 2,
    id: "captions-font-size-%s",
    label: "Font Size",
    options: [
      ["0.50", "50%"],
      ["0.75", "75%"],
      ["1.00", "100%"],
      ["1.25", "125%"],
      ["1.50", "150%"],
      ["1.75", "175%"],
      ["2.00", "200%"],
      ["3.00", "300%"],
      ["4.00", "400%"]
    ],
    parser: function(t) {
      return t === "1.00" ? null : Number(t);
    },
    selector: ".vjs-font-percent > select"
  },
  textOpacity: {
    id: "captions-foreground-opacity-%s",
    label: "Transparency",
    options: [gd, yd],
    selector: ".vjs-text-opacity > select"
  },
  // Options for this object are defined below.
  windowColor: {
    id: "captions-window-color-%s",
    label: "Color",
    selector: ".vjs-window-color > select"
  },
  // Options for this object are defined below.
  windowOpacity: {
    id: "captions-window-opacity-%s",
    label: "Transparency",
    options: [rg, yd, gd],
    selector: ".vjs-window-opacity > select"
  }
};
La.windowColor.options = La.backgroundColor.options;
function Mb(e, t) {
  if (t && (e = t(e)), e && e !== "none")
    return e;
}
function x3(e, t) {
  var i = e.options[e.options.selectedIndex].value;
  return Mb(i, t);
}
function A3(e, t, i) {
  if (t) {
    for (var n = 0; n < e.options.length; n++)
      if (Mb(e.options[n].value, i) === t) {
        e.selectedIndex = n;
        break;
      }
  }
}
var T3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return r.temporary = !1, a = e.call(this, n, r) || this, a.updateDisplay = a.updateDisplay.bind(
      He(a)
    ), a.fill(), a.hasBeenOpened_ = a.hasBeenFilled_ = !0, a.endDialog = St("p", {
      className: "vjs-control-text",
      textContent: a.localize("End of dialog window.")
    }), a.el().appendChild(a.endDialog), a.setDefaults(), r.persistTextTrackSettings === void 0 && (a.options_.persistTextTrackSettings = a.options_.playerOptions.persistTextTrackSettings), a.on(a.$(".vjs-done-button"), "click", function() {
      a.saveSettings(), a.close();
    }), a.on(a.$(".vjs-default-button"), "click", function() {
      a.setDefaults(), a.updateDisplay();
    }), Bs(La, function(s) {
      a.on(a.$(s.selector), "change", a.updateDisplay);
    }), a.options_.persistTextTrackSettings && a.restoreSettings(), a;
  }
  var i = t.prototype;
  return i.dispose = function() {
    this.endDialog = null, e.prototype.dispose.call(this);
  }, i.createElSelect_ = function(r, a, s) {
    var o = this;
    a === void 0 && (a = ""), s === void 0 && (s = "label");
    var u = La[r], l = u.id.replace("%s", this.id_), c = [a, l].join(" ").trim();
    return [
      "<" + s + ' id="' + l + '" class="' + (s === "label" ? "vjs-label" : "") + '">',
      this.localize(u.label),
      "</" + s + ">",
      '<select aria-labelledby="' + c + '">'
    ].concat(
      u.options.map(function(h) {
        var d = l + "-" + h[1].replace(/\W+/g, "");
        return [
          '<option id="' + d + '" value="' + h[0] + '" ',
          'aria-labelledby="' + c + " " + d + '">',
          o.localize(h[1]),
          "</option>"
        ].join("");
      })
    ).concat("</select>").join("");
  }, i.createElFgColor_ = function() {
    var r = "captions-text-legend-" + this.id_;
    return [
      '<fieldset class="vjs-fg-color vjs-track-setting">',
      '<legend id="' + r + '">',
      this.localize("Text"),
      "</legend>",
      this.createElSelect_("color", r),
      '<span class="vjs-text-opacity vjs-opacity">',
      this.createElSelect_("textOpacity", r),
      "</span>",
      "</fieldset>"
    ].join("");
  }, i.createElBgColor_ = function() {
    var r = "captions-background-" + this.id_;
    return [
      '<fieldset class="vjs-bg-color vjs-track-setting">',
      '<legend id="' + r + '">',
      this.localize("Background"),
      "</legend>",
      this.createElSelect_("backgroundColor", r),
      '<span class="vjs-bg-opacity vjs-opacity">',
      this.createElSelect_("backgroundOpacity", r),
      "</span>",
      "</fieldset>"
    ].join("");
  }, i.createElWinColor_ = function() {
    var r = "captions-window-" + this.id_;
    return [
      '<fieldset class="vjs-window-color vjs-track-setting">',
      '<legend id="' + r + '">',
      this.localize("Window"),
      "</legend>",
      this.createElSelect_("windowColor", r),
      '<span class="vjs-window-opacity vjs-opacity">',
      this.createElSelect_("windowOpacity", r),
      "</span>",
      "</fieldset>"
    ].join("");
  }, i.createElColors_ = function() {
    return St("div", {
      className: "vjs-track-settings-colors",
      innerHTML: [
        this.createElFgColor_(),
        this.createElBgColor_(),
        this.createElWinColor_()
      ].join("")
    });
  }, i.createElFont_ = function() {
    return St("div", {
      className: "vjs-track-settings-font",
      innerHTML: [
        '<fieldset class="vjs-font-percent vjs-track-setting">',
        this.createElSelect_("fontPercent", "", "legend"),
        "</fieldset>",
        '<fieldset class="vjs-edge-style vjs-track-setting">',
        this.createElSelect_("edgeStyle", "", "legend"),
        "</fieldset>",
        '<fieldset class="vjs-font-family vjs-track-setting">',
        this.createElSelect_("fontFamily", "", "legend"),
        "</fieldset>"
      ].join("")
    });
  }, i.createElControls_ = function() {
    var r = this.localize(
      "restore all settings to the default values"
    );
    return St("div", {
      className: "vjs-track-settings-controls",
      innerHTML: [
        '<button type="button" class="vjs-default-button" title="' + r + '">',
        this.localize("Reset"),
        '<span class="vjs-control-text"> ' + r + "</span>",
        "</button>",
        '<button type="button" class="vjs-done-button">' + this.localize("Done") + "</button>"
      ].join("")
    });
  }, i.content = function() {
    return [
      this.createElColors_(),
      this.createElFont_(),
      this.createElControls_()
    ];
  }, i.label = function() {
    return this.localize("Caption Settings Dialog");
  }, i.description = function() {
    return this.localize(
      "Beginning of dialog window. Escape will cancel and close the window."
    );
  }, i.buildCSSClass = function() {
    return e.prototype.buildCSSClass.call(this) + " vjs-text-track-settings";
  }, i.getValues = function() {
    var r = this;
    return hM(
      La,
      function(a, s, o) {
        var u = x3(
          r.$(s.selector),
          s.parser
        );
        return u !== void 0 && (a[o] = u), a;
      },
      {}
    );
  }, i.setValues = function(r) {
    var a = this;
    Bs(La, function(s, o) {
      A3(a.$(s.selector), r[o], s.parser);
    });
  }, i.setDefaults = function() {
    var r = this;
    Bs(La, function(a) {
      var s = a.hasOwnProperty("default") ? a.default : 0;
      r.$(a.selector).selectedIndex = s;
    });
  }, i.restoreSettings = function() {
    var r;
    try {
      r = JSON.parse(W.localStorage.getItem(md));
    } catch (a) {
      mt.warn(a);
    }
    r && this.setValues(r);
  }, i.saveSettings = function() {
    if (this.options_.persistTextTrackSettings) {
      var r = this.getValues();
      try {
        Object.keys(r).length ? W.localStorage.setItem(
          md,
          JSON.stringify(r)
        ) : W.localStorage.removeItem(md);
      } catch (a) {
        mt.warn(a);
      }
    }
  }, i.updateDisplay = function() {
    var r = this.player_.getChild("textTrackDisplay");
    r && r.updateDisplay();
  }, i.conditionalBlur_ = function() {
    this.previouslyActiveEl_ = null;
    var r = this.player_.controlBar, a = r && r.subsCapsButton, s = r && r.captionsButton;
    a ? a.focus() : s && s.focus();
  }, t;
}(Uo);
ye.registerComponent("TextTrackSettings", T3);
var E3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a, s = r.ResizeObserver || W.ResizeObserver;
    r.ResizeObserver === null && (s = !1);
    var o = Kt(
      {
        createEl: !s,
        reportTouchActivity: !1
      },
      r
    );
    return a = e.call(this, n, o) || this, a.ResizeObserver = r.ResizeObserver || W.ResizeObserver, a.loadListener_ = null, a.resizeObserver_ = null, a.debouncedHandler_ = AM(
      function() {
        a.resizeHandler();
      },
      100,
      !1,
      He(a)
    ), s ? (a.resizeObserver_ = new a.ResizeObserver(a.debouncedHandler_), a.resizeObserver_.observe(n.el())) : (a.loadListener_ = function() {
      if (!(!a.el_ || !a.el_.contentWindow)) {
        var u = a.debouncedHandler_, l = a.unloadListener_ = function() {
          Hi(this, "resize", u), Hi(this, "unload", l), l = null;
        };
        Pr(a.el_.contentWindow, "unload", l), Pr(a.el_.contentWindow, "resize", u);
      }
    }, a.one("load", a.loadListener_)), a;
  }
  var i = t.prototype;
  return i.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "iframe",
      {
        className: "vjs-resize-manager",
        tabIndex: -1,
        title: this.localize("No content")
      },
      {
        "aria-hidden": "true"
      }
    );
  }, i.resizeHandler = function() {
    !this.player_ || !this.player_.trigger || this.player_.trigger("playerresize");
  }, i.dispose = function() {
    this.debouncedHandler_ && this.debouncedHandler_.cancel(), this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()), this.resizeObserver_.disconnect()), this.loadListener_ && this.off("load", this.loadListener_), this.el_ && this.el_.contentWindow && this.unloadListener_ && this.unloadListener_.call(this.el_.contentWindow), this.ResizeObserver = null, this.resizeObserver = null, this.debouncedHandler_ = null, this.loadListener_ = null, e.prototype.dispose.call(this);
  }, t;
}(ye);
ye.registerComponent("ResizeManager", E3);
var w3 = {
  liveTolerance: 15,
  trackingThreshold: 20
}, S3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a, s = Kt(w3, r, {
      createEl: !1
    });
    return a = e.call(this, n, s) || this, a.handleVisibilityChange_ = function(o) {
      return a.handleVisibilityChange(o);
    }, a.trackLiveHandler_ = function() {
      return a.trackLive_();
    }, a.handlePlay_ = function(o) {
      return a.handlePlay(o);
    }, a.handleFirstTimeupdate_ = function(o) {
      return a.handleFirstTimeupdate(o);
    }, a.handleSeeked_ = function(o) {
      return a.handleSeeked(o);
    }, a.seekToLiveEdge_ = function(o) {
      return a.seekToLiveEdge(o);
    }, a.reset_(), a.on(a.player_, "durationchange", function(o) {
      return a.handleDurationchange(o);
    }), a.on(a.player_, "canplay", function() {
      return a.toggleTracking();
    }), Dl && "hidden" in Te && "visibilityState" in Te && a.on(Te, "visibilitychange", a.handleVisibilityChange_), a;
  }
  var i = t.prototype;
  return i.handleVisibilityChange = function() {
    this.player_.duration() === 1 / 0 && (Te.hidden ? this.stopTracking() : this.startTracking());
  }, i.trackLive_ = function() {
    var r = this.player_.seekable();
    if (!(!r || !r.length)) {
      var a = Number(W.performance.now().toFixed(4)), s = this.lastTime_ === -1 ? 0 : (a - this.lastTime_) / 1e3;
      this.lastTime_ = a, this.pastSeekEnd_ = this.pastSeekEnd() + s;
      var o = this.liveCurrentTime(), u = this.player_.currentTime(), l = this.player_.paused() || this.seekedBehindLive_ || Math.abs(o - u) > this.options_.liveTolerance;
      (!this.timeupdateSeen_ || o === 1 / 0) && (l = !1), l !== this.behindLiveEdge_ && (this.behindLiveEdge_ = l, this.trigger("liveedgechange"));
    }
  }, i.handleDurationchange = function() {
    this.toggleTracking();
  }, i.toggleTracking = function() {
    this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold ? (this.player_.options_.liveui && this.player_.addClass("vjs-liveui"), this.startTracking()) : (this.player_.removeClass("vjs-liveui"), this.stopTracking());
  }, i.startTracking = function() {
    this.isTracking() || (this.timeupdateSeen_ || (this.timeupdateSeen_ = this.player_.hasStarted()), this.trackingInterval_ = this.setInterval(
      this.trackLiveHandler_,
      $r
    ), this.trackLive_(), this.on(this.player_, ["play", "pause"], this.trackLiveHandler_), this.timeupdateSeen_ ? this.on(this.player_, "seeked", this.handleSeeked_) : (this.one(this.player_, "play", this.handlePlay_), this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_)));
  }, i.handleFirstTimeupdate = function() {
    this.timeupdateSeen_ = !0, this.on(this.player_, "seeked", this.handleSeeked_);
  }, i.handleSeeked = function() {
    var r = Math.abs(
      this.liveCurrentTime() - this.player_.currentTime()
    );
    this.seekedBehindLive_ = this.nextSeekedFromUser_ && r > 2, this.nextSeekedFromUser_ = !1, this.trackLive_();
  }, i.handlePlay = function() {
    this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
  }, i.reset_ = function() {
    this.lastTime_ = -1, this.pastSeekEnd_ = 0, this.lastSeekEnd_ = -1, this.behindLiveEdge_ = !0, this.timeupdateSeen_ = !1, this.seekedBehindLive_ = !1, this.nextSeekedFromUser_ = !1, this.clearInterval(this.trackingInterval_), this.trackingInterval_ = null, this.off(this.player_, ["play", "pause"], this.trackLiveHandler_), this.off(this.player_, "seeked", this.handleSeeked_), this.off(this.player_, "play", this.handlePlay_), this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_), this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
  }, i.nextSeekedFromUser = function() {
    this.nextSeekedFromUser_ = !0;
  }, i.stopTracking = function() {
    this.isTracking() && (this.reset_(), this.trigger("liveedgechange"));
  }, i.seekableEnd = function() {
    for (var r = this.player_.seekable(), a = [], s = r ? r.length : 0; s--; )
      a.push(r.end(s));
    return a.length ? a.sort()[a.length - 1] : 1 / 0;
  }, i.seekableStart = function() {
    for (var r = this.player_.seekable(), a = [], s = r ? r.length : 0; s--; )
      a.push(r.start(s));
    return a.length ? a.sort()[0] : 0;
  }, i.liveWindow = function() {
    var r = this.liveCurrentTime();
    return r === 1 / 0 ? 0 : r - this.seekableStart();
  }, i.isLive = function() {
    return this.isTracking();
  }, i.atLiveEdge = function() {
    return !this.behindLiveEdge();
  }, i.liveCurrentTime = function() {
    return this.pastSeekEnd() + this.seekableEnd();
  }, i.pastSeekEnd = function() {
    var r = this.seekableEnd();
    return this.lastSeekEnd_ !== -1 && r !== this.lastSeekEnd_ && (this.pastSeekEnd_ = 0), this.lastSeekEnd_ = r, this.pastSeekEnd_;
  }, i.behindLiveEdge = function() {
    return this.behindLiveEdge_;
  }, i.isTracking = function() {
    return typeof this.trackingInterval_ == "number";
  }, i.seekToLiveEdge = function() {
    this.seekedBehindLive_ = !1, !this.atLiveEdge() && (this.nextSeekedFromUser_ = !1, this.player_.currentTime(this.liveCurrentTime()));
  }, i.dispose = function() {
    this.off(Te, "visibilitychange", this.handleVisibilityChange_), this.stopTracking(), e.prototype.dispose.call(this);
  }, t;
}(ye);
ye.registerComponent("LiveTracker", S3);
var cf = function(t) {
  var i = t.el();
  if (i.hasAttribute("src"))
    return t.triggerSourceset(i.src), !0;
  var n = t.$$("source"), r = [], a = "";
  if (!n.length)
    return !1;
  for (var s = 0; s < n.length; s++) {
    var o = n[s].src;
    o && r.indexOf(o) === -1 && r.push(o);
  }
  return r.length ? (r.length === 1 && (a = r[0]), t.triggerSourceset(a), !0) : !1;
}, C3 = Object.defineProperty({}, "innerHTML", {
  get: function() {
    return this.cloneNode(!0).innerHTML;
  },
  set: function(t) {
    var i = Te.createElement(this.nodeName.toLowerCase());
    i.innerHTML = t;
    for (var n = Te.createDocumentFragment(); i.childNodes.length; )
      n.appendChild(i.childNodes[0]);
    return this.innerText = "", W.Element.prototype.appendChild.call(this, n), this.innerHTML;
  }
}), Db = function(t, i) {
  for (var n = {}, r = 0; r < t.length && (n = Object.getOwnPropertyDescriptor(t[r], i), !(n && n.set && n.get)); r++)
    ;
  return n.enumerable = !0, n.configurable = !0, n;
}, M3 = function(t) {
  return Db(
    [
      t.el(),
      W.HTMLMediaElement.prototype,
      W.Element.prototype,
      C3
    ],
    "innerHTML"
  );
}, ng = function(t) {
  var i = t.el();
  if (!i.resetSourceWatch_) {
    var n = {}, r = M3(t), a = function(o) {
      return function() {
        for (var u = arguments.length, l = new Array(u), c = 0; c < u; c++)
          l[c] = arguments[c];
        var h = o.apply(i, l);
        return cf(t), h;
      };
    };
    ["append", "appendChild", "insertAdjacentHTML"].forEach(function(s) {
      i[s] && (n[s] = i[s], i[s] = a(n[s]));
    }), Object.defineProperty(
      i,
      "innerHTML",
      Kt(r, {
        set: a(r.set)
      })
    ), i.resetSourceWatch_ = function() {
      i.resetSourceWatch_ = null, Object.keys(n).forEach(function(s) {
        i[s] = n[s];
      }), Object.defineProperty(i, "innerHTML", r);
    }, t.one("sourceset", i.resetSourceWatch_);
  }
}, D3 = Object.defineProperty({}, "src", {
  get: function() {
    return this.hasAttribute("src") ? ib(
      W.Element.prototype.getAttribute.call(this, "src")
    ) : "";
  },
  set: function(t) {
    return W.Element.prototype.setAttribute.call(this, "src", t), t;
  }
}), P3 = function(t) {
  return Db(
    [t.el(), W.HTMLMediaElement.prototype, D3],
    "src"
  );
}, L3 = function(t) {
  if (t.featuresSourceset) {
    var i = t.el();
    if (!i.resetSourceset_) {
      var n = P3(t), r = i.setAttribute, a = i.load;
      Object.defineProperty(
        i,
        "src",
        Kt(n, {
          set: function(o) {
            var u = n.set.call(i, o);
            return t.triggerSourceset(i.src), u;
          }
        })
      ), i.setAttribute = function(s, o) {
        var u = r.call(i, s, o);
        return /src/i.test(s) && t.triggerSourceset(i.src), u;
      }, i.load = function() {
        var s = a.call(i);
        return cf(t) || (t.triggerSourceset(""), ng(t)), s;
      }, i.currentSrc ? t.triggerSourceset(i.currentSrc) : cf(t) || ng(t), i.resetSourceset_ = function() {
        i.resetSourceset_ = null, i.load = a, i.setAttribute = r, Object.defineProperty(i, "src", n), i.resetSourceWatch_ && i.resetSourceWatch_();
      };
    }
  }
}, tv = function(t, i, n, r) {
  r === void 0 && (r = !0);
  var a = function(u) {
    return Object.defineProperty(t, i, {
      enumerable: !0,
      value: u,
      writable: !0
    });
  }, s = {
    configurable: !0,
    enumerable: !0,
    get: function() {
      var u = n();
      return a(u), u;
    }
  };
  return r && (s.set = a), Object.defineProperty(t, i, s);
}, Oe = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    a = e.call(this, n, r) || this;
    var s = n.source, o = !1;
    if (a.featuresVideoFrameCallback = a.featuresVideoFrameCallback && a.el_.tagName === "VIDEO", s && (a.el_.currentSrc !== s.src || n.tag && n.tag.initNetworkState_ === 3) ? a.setSource(s) : a.handleLateInit_(a.el_), n.enableSourceset && a.setupSourcesetHandling_(), a.isScrubbing_ = !1, a.el_.hasChildNodes()) {
      for (var u = a.el_.childNodes, l = u.length, c = []; l--; ) {
        var h = u[l], d = h.nodeName.toLowerCase();
        d === "track" && (a.featuresNativeTextTracks ? (a.remoteTextTrackEls().addTrackElement_(h), a.remoteTextTracks().addTrack(h.track), a.textTracks().addTrack(h.track), !o && !a.el_.hasAttribute("crossorigin") && kh(h.src) && (o = !0)) : c.push(h));
      }
      for (var f = 0; f < c.length; f++)
        a.el_.removeChild(c[f]);
    }
    return a.proxyNativeTracks_(), a.featuresNativeTextTracks && o && mt.warn(
      `Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.
This may prevent text tracks from loading.`
    ), a.restoreMetadataTracksInIOSNativePlayer_(), (Co || Pp || D_) && n.nativeControlsForTouch === !0 && a.setControls(!0), a.proxyWebkitFullscreen_(), a.triggerReady(), a;
  }
  var i = t.prototype;
  return i.dispose = function() {
    this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(), t.disposeMediaElement(this.el_), this.options_ = null, e.prototype.dispose.call(this);
  }, i.setupSourcesetHandling_ = function() {
    L3(this);
  }, i.restoreMetadataTracksInIOSNativePlayer_ = function() {
    var r = this.textTracks(), a, s = function() {
      a = [];
      for (var l = 0; l < r.length; l++) {
        var c = r[l];
        c.kind === "metadata" && a.push({
          storedMode: c.mode,
          track: c
        });
      }
    };
    s(), r.addEventListener("change", s), this.on("dispose", function() {
      return r.removeEventListener(
        "change",
        s
      );
    });
    var o = function u() {
      for (var l = 0; l < a.length; l++) {
        var c = a[l];
        c.track.mode === "disabled" && c.track.mode !== c.storedMode && (c.track.mode = c.storedMode);
      }
      r.removeEventListener("change", u);
    };
    this.on("webkitbeginfullscreen", function() {
      r.removeEventListener("change", s), r.removeEventListener("change", o), r.addEventListener("change", o);
    }), this.on("webkitendfullscreen", function() {
      r.removeEventListener("change", s), r.addEventListener("change", s), r.removeEventListener("change", o);
    });
  }, i.overrideNative_ = function(r, a) {
    var s = this;
    if (a === this["featuresNative" + r + "Tracks"]) {
      var o = r.toLowerCase();
      this[o + "TracksListeners_"] && Object.keys(this[o + "TracksListeners_"]).forEach(
        function(u) {
          var l = s.el()[o + "Tracks"];
          l.removeEventListener(
            u,
            s[o + "TracksListeners_"][u]
          );
        }
      ), this["featuresNative" + r + "Tracks"] = !a, this[o + "TracksListeners_"] = null, this.proxyNativeTracksForType_(o);
    }
  }, i.overrideNativeAudioTracks = function(r) {
    this.overrideNative_("Audio", r);
  }, i.overrideNativeVideoTracks = function(r) {
    this.overrideNative_("Video", r);
  }, i.proxyNativeTracksForType_ = function(r) {
    var a = this, s = Or[r], o = this.el()[s.getterName], u = this[s.getterName]();
    if (!(!this["featuresNative" + s.capitalName + "Tracks"] || !o || !o.addEventListener)) {
      var l = {
        addtrack: function(d) {
          u.addTrack(d.track);
        },
        change: function(d) {
          var f = {
            currentTarget: u,
            srcElement: u,
            target: u,
            type: "change"
          };
          u.trigger(f), r === "text" && a[Lo.remoteText.getterName]().trigger(f);
        },
        removetrack: function(d) {
          u.removeTrack(d.track);
        }
      }, c = function() {
        for (var d = [], f = 0; f < u.length; f++) {
          for (var p = !1, _ = 0; _ < o.length; _++)
            if (o[_] === u[f]) {
              p = !0;
              break;
            }
          p || d.push(u[f]);
        }
        for (; d.length; )
          u.removeTrack(d.shift());
      };
      this[s.getterName + "Listeners_"] = l, Object.keys(l).forEach(function(h) {
        var d = l[h];
        o.addEventListener(h, d), a.on("dispose", function(f) {
          return o.removeEventListener(h, d);
        });
      }), this.on("loadstart", c), this.on("dispose", function(h) {
        return a.off("loadstart", c);
      });
    }
  }, i.proxyNativeTracks_ = function() {
    var r = this;
    Or.names.forEach(function(a) {
      r.proxyNativeTracksForType_(a);
    });
  }, i.createEl = function() {
    var r = this.options_.tag;
    if (!r || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
      if (r) {
        var a = r.cloneNode(!0);
        r.parentNode && r.parentNode.insertBefore(a, r), t.disposeMediaElement(r), r = a;
      } else {
        r = Te.createElement("video");
        var s = this.options_.tag && Pn(this.options_.tag), o = Kt({}, s);
        (!Co || this.options_.nativeControlsForTouch !== !0) && delete o.controls, F_(
          r,
          si(o, {
            class: "vjs-tech",
            id: this.options_.techId
          })
        );
      }
      r.playerId = this.options_.playerId;
    }
    typeof this.options_.preload < "u" && Mo(r, "preload", this.options_.preload), this.options_.disablePictureInPicture !== void 0 && (r.disablePictureInPicture = this.options_.disablePictureInPicture);
    for (var u = ["loop", "muted", "playsinline", "autoplay"], l = 0; l < u.length; l++) {
      var c = u[l], h = this.options_[c];
      typeof h < "u" && (h ? Mo(r, c, c) : Ph(r, c), r[c] = h);
    }
    return r;
  }, i.handleLateInit_ = function(r) {
    if (!(r.networkState === 0 || r.networkState === 3)) {
      if (r.readyState === 0) {
        var a = !1, s = function() {
          a = !0;
        };
        this.on("loadstart", s);
        var o = function() {
          a || this.trigger("loadstart");
        };
        this.on("loadedmetadata", o), this.ready(function() {
          this.off("loadstart", s), this.off("loadedmetadata", o), a || this.trigger("loadstart");
        });
        return;
      }
      var u = ["loadstart"];
      u.push("loadedmetadata"), r.readyState >= 2 && u.push("loadeddata"), r.readyState >= 3 && u.push("canplay"), r.readyState >= 4 && u.push("canplaythrough"), this.ready(function() {
        u.forEach(function(l) {
          this.trigger(l);
        }, this);
      });
    }
  }, i.setScrubbing = function(r) {
    this.isScrubbing_ = r;
  }, i.scrubbing = function() {
    return this.isScrubbing_;
  }, i.setCurrentTime = function(r) {
    try {
      this.isScrubbing_ && this.el_.fastSeek && Dh ? this.el_.fastSeek(r) : this.el_.currentTime = r;
    } catch (a) {
      mt(a, "Video is not ready. (Video.js)");
    }
  }, i.duration = function() {
    var r = this;
    if (this.el_.duration === 1 / 0 && Jn && $n && this.el_.currentTime === 0) {
      var a = function s() {
        r.el_.currentTime > 0 && (r.el_.duration === 1 / 0 && r.trigger("durationchange"), r.off("timeupdate", s));
      };
      return this.on("timeupdate", a), NaN;
    }
    return this.el_.duration || NaN;
  }, i.width = function() {
    return this.el_.offsetWidth;
  }, i.height = function() {
    return this.el_.offsetHeight;
  }, i.proxyWebkitFullscreen_ = function() {
    var r = this;
    if ("webkitDisplayingFullscreen" in this.el_) {
      var a = function() {
        this.trigger("fullscreenchange", {
          isFullscreen: !1
        }), this.el_.controls && !this.options_.nativeControlsForTouch && this.controls() && (this.el_.controls = !1);
      }, s = function() {
        "webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture" && (this.one("webkitendfullscreen", a), this.trigger("fullscreenchange", {
          isFullscreen: !0,
          // set a flag in case another tech triggers fullscreenchange
          nativeIOSFullscreen: !0
        }));
      };
      this.on("webkitbeginfullscreen", s), this.on("dispose", function() {
        r.off("webkitbeginfullscreen", s), r.off("webkitendfullscreen", a);
      });
    }
  }, i.supportsFullScreen = function() {
    if (typeof this.el_.webkitEnterFullScreen == "function") {
      var r = W.navigator && W.navigator.userAgent || "";
      if (/Android/.test(r) || !/Chrome|Mac OS X 10.5/.test(r))
        return !0;
    }
    return !1;
  }, i.enterFullScreen = function() {
    var r = this.el_;
    if (r.paused && r.networkState <= r.HAVE_METADATA)
      hn(this.el_.play()), this.setTimeout(function() {
        r.pause();
        try {
          r.webkitEnterFullScreen();
        } catch (a) {
          this.trigger("fullscreenerror", a);
        }
      }, 0);
    else
      try {
        r.webkitEnterFullScreen();
      } catch (a) {
        this.trigger("fullscreenerror", a);
      }
  }, i.exitFullScreen = function() {
    if (!this.el_.webkitDisplayingFullscreen) {
      this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
      return;
    }
    this.el_.webkitExitFullScreen();
  }, i.requestPictureInPicture = function() {
    return this.el_.requestPictureInPicture();
  }, i.requestVideoFrameCallback = function(r) {
    return this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.requestVideoFrameCallback(r) : e.prototype.requestVideoFrameCallback.call(this, r);
  }, i.cancelVideoFrameCallback = function(r) {
    this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.cancelVideoFrameCallback(r) : e.prototype.cancelVideoFrameCallback.call(this, r);
  }, i.src = function(r) {
    if (r === void 0)
      return this.el_.src;
    this.setSrc(r);
  }, i.reset = function() {
    t.resetMediaElement(this.el_);
  }, i.currentSrc = function() {
    return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc;
  }, i.setControls = function(r) {
    this.el_.controls = !!r;
  }, i.addTextTrack = function(r, a, s) {
    return this.featuresNativeTextTracks ? this.el_.addTextTrack(r, a, s) : e.prototype.addTextTrack.call(this, r, a, s);
  }, i.createRemoteTextTrack = function(r) {
    if (!this.featuresNativeTextTracks)
      return e.prototype.createRemoteTextTrack.call(this, r);
    var a = Te.createElement("track");
    return r.kind && (a.kind = r.kind), r.label && (a.label = r.label), (r.language || r.srclang) && (a.srclang = r.language || r.srclang), r.default && (a.default = r.default), r.id && (a.id = r.id), r.src && (a.src = r.src), a;
  }, i.addRemoteTextTrack = function(r, a) {
    var s = e.prototype.addRemoteTextTrack.call(
      this,
      r,
      a
    );
    return this.featuresNativeTextTracks && this.el().appendChild(s), s;
  }, i.removeRemoteTextTrack = function(r) {
    if (e.prototype.removeRemoteTextTrack.call(this, r), this.featuresNativeTextTracks)
      for (var a = this.$$("track"), s = a.length; s--; )
        (r === a[s] || r === a[s].track) && this.el().removeChild(a[s]);
  }, i.getVideoPlaybackQuality = function() {
    if (typeof this.el().getVideoPlaybackQuality == "function")
      return this.el().getVideoPlaybackQuality();
    var r = {};
    return typeof this.el().webkitDroppedFrameCount < "u" && typeof this.el().webkitDecodedFrameCount < "u" && (r.droppedVideoFrames = this.el().webkitDroppedFrameCount, r.totalVideoFrames = this.el().webkitDecodedFrameCount), W.performance && typeof W.performance.now == "function" ? r.creationTime = W.performance.now() : W.performance && W.performance.timing && typeof W.performance.timing.navigationStart == "number" && (r.creationTime = W.Date.now() - W.performance.timing.navigationStart), r;
  }, t;
}(Wt);
tv(Oe, "TEST_VID", function() {
  if (Bo()) {
    var e = Te.createElement("video"), t = Te.createElement("track");
    return t.kind = "captions", t.srclang = "en", t.label = "English", e.appendChild(t), e;
  }
});
Oe.isSupported = function() {
  try {
    Oe.TEST_VID.volume = 0.5;
  } catch {
    return !1;
  }
  return !!(Oe.TEST_VID && Oe.TEST_VID.canPlayType);
};
Oe.canPlayType = function(e) {
  return Oe.TEST_VID.canPlayType(e);
};
Oe.canPlaySource = function(e, t) {
  return Oe.canPlayType(e.type);
};
Oe.canControlVolume = function() {
  try {
    var e = Oe.TEST_VID.volume;
    Oe.TEST_VID.volume = e / 2 + 0.1;
    var t = e !== Oe.TEST_VID.volume;
    return t && cr ? (W.setTimeout(function() {
      Oe && Oe.prototype && (Oe.prototype.featuresVolumeControl = e !== Oe.TEST_VID.volume);
    }), !1) : t;
  } catch {
    return !1;
  }
};
Oe.canMuteVolume = function() {
  try {
    var e = Oe.TEST_VID.muted;
    return Oe.TEST_VID.muted = !e, Oe.TEST_VID.muted ? Mo(Oe.TEST_VID, "muted", "muted") : Ph(Oe.TEST_VID, "muted", "muted"), e !== Oe.TEST_VID.muted;
  } catch {
    return !1;
  }
};
Oe.canControlPlaybackRate = function() {
  if (Jn && $n && L_ < 58)
    return !1;
  try {
    var e = Oe.TEST_VID.playbackRate;
    return Oe.TEST_VID.playbackRate = e / 2 + 0.1, e !== Oe.TEST_VID.playbackRate;
  } catch {
    return !1;
  }
};
Oe.canOverrideAttributes = function() {
  try {
    var e = function() {
    };
    Object.defineProperty(Te.createElement("video"), "src", {
      get: e,
      set: e
    }), Object.defineProperty(Te.createElement("audio"), "src", {
      get: e,
      set: e
    }), Object.defineProperty(Te.createElement("video"), "innerHTML", {
      get: e,
      set: e
    }), Object.defineProperty(Te.createElement("audio"), "innerHTML", {
      get: e,
      set: e
    });
  } catch {
    return !1;
  }
  return !0;
};
Oe.supportsNativeTextTracks = function() {
  return Dh || cr && $n;
};
Oe.supportsNativeVideoTracks = function() {
  return !!(Oe.TEST_VID && Oe.TEST_VID.videoTracks);
};
Oe.supportsNativeAudioTracks = function() {
  return !!(Oe.TEST_VID && Oe.TEST_VID.audioTracks);
};
Oe.Events = [
  "loadstart",
  "suspend",
  "abort",
  "error",
  "emptied",
  "stalled",
  "loadedmetadata",
  "loadeddata",
  "canplay",
  "canplaythrough",
  "playing",
  "waiting",
  "seeking",
  "seeked",
  "ended",
  "durationchange",
  "timeupdate",
  "progress",
  "play",
  "pause",
  "ratechange",
  "resize",
  "volumechange"
];
[
  ["featuresMuteControl", "canMuteVolume"],
  ["featuresPlaybackRate", "canControlPlaybackRate"],
  ["featuresSourceset", "canOverrideAttributes"],
  ["featuresNativeTextTracks", "supportsNativeTextTracks"],
  ["featuresNativeVideoTracks", "supportsNativeVideoTracks"],
  ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]
].forEach(function(e) {
  var t = e[0], i = e[1];
  tv(
    Oe.prototype,
    t,
    function() {
      return Oe[i]();
    },
    !0
  );
});
Oe.prototype.featuresVolumeControl = Oe.canControlVolume();
Oe.prototype.movingMediaElementInDOM = !cr;
Oe.prototype.featuresFullscreenResize = !0;
Oe.prototype.featuresProgressEvents = !0;
Oe.prototype.featuresTimeupdateEvents = !0;
Oe.prototype.featuresVideoFrameCallback = !!(Oe.TEST_VID && Oe.TEST_VID.requestVideoFrameCallback);
var Wc;
Oe.patchCanPlayType = function() {
  Cp >= 4 && !P_ && !$n && (Wc = Oe.TEST_VID && Oe.TEST_VID.constructor.prototype.canPlayType, Oe.TEST_VID.constructor.prototype.canPlayType = function(e) {
    var t = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
    return e && t.test(e) ? "maybe" : Wc.call(this, e);
  });
};
Oe.unpatchCanPlayType = function() {
  var e = Oe.TEST_VID.constructor.prototype.canPlayType;
  return Wc && (Oe.TEST_VID.constructor.prototype.canPlayType = Wc), e;
};
Oe.patchCanPlayType();
Oe.disposeMediaElement = function(e) {
  if (e) {
    for (e.parentNode && e.parentNode.removeChild(e); e.hasChildNodes(); )
      e.removeChild(e.firstChild);
    e.removeAttribute("src"), typeof e.load == "function" && function() {
      try {
        e.load();
      } catch {
      }
    }();
  }
};
Oe.resetMediaElement = function(e) {
  if (e) {
    for (var t = e.querySelectorAll("source"), i = t.length; i--; )
      e.removeChild(t[i]);
    e.removeAttribute("src"), typeof e.load == "function" && function() {
      try {
        e.load();
      } catch {
      }
    }();
  }
};
[
  /**
   * Get the value of `muted` from the media element. `muted` indicates
   * that the volume for the media should be set to silent. This does not actually change
   * the `volume` attribute.
   *
   * @method Html5#muted
   * @return {boolean}
   *         - True if the value of `volume` should be ignored and the audio set to silent.
   *         - False if the value of `volume` should be used.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
   * whether the media should start muted or not. Only changes the default state of the
   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
   * current state.
   *
   * @method Html5#defaultMuted
   * @return {boolean}
   *         - The value of `defaultMuted` from the media element.
   *         - True indicates that the media should start muted.
   *         - False indicates that the media should not start muted
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Get the value of `autoplay` from the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#autoplay
   * @return {boolean}
   *         - The value of `autoplay` from the media element.
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Get the value of `controls` from the media element. `controls` indicates
   * whether the native media controls should be shown or hidden.
   *
   * @method Html5#controls
   * @return {boolean}
   *         - The value of `controls` from the media element.
   *         - True indicates that native controls should be showing.
   *         - False indicates that native controls should be hidden.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
   */
  "controls",
  /**
   * Get the value of `loop` from the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#loop
   * @return {boolean}
   *         - The value of `loop` from the media element.
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(e) {
  Oe.prototype[e] = function() {
    return this.el_[e] || this.el_.hasAttribute(e);
  };
});
[
  /**
   * Set the value of `muted` on the media element. `muted` indicates that the current
   * audio level should be silent.
   *
   * @method Html5#setMuted
   * @param {boolean} muted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
   * audio level should be silent, but will only effect the muted level on initial playback..
   *
   * @method Html5.prototype.setDefaultMuted
   * @param {boolean} defaultMuted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Set the value of `autoplay` on the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#setAutoplay
   * @param {boolean} autoplay
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Set the value of `loop` on the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#setLoop
   * @param {boolean} loop
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(e) {
  Oe.prototype["set" + vi(e)] = function(t) {
    this.el_[e] = t, t ? this.el_.setAttribute(e, e) : this.el_.removeAttribute(e);
  };
});
[
  /**
   * Get the value of `paused` from the media element. `paused` indicates whether the media element
   * is currently paused or not.
   *
   * @method Html5#paused
   * @return {boolean}
   *         The value of `paused` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
   */
  "paused",
  /**
   * Get the value of `currentTime` from the media element. `currentTime` indicates
   * the current second that the media is at in playback.
   *
   * @method Html5#currentTime
   * @return {number}
   *         The value of `currentTime` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
   */
  "currentTime",
  /**
   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
   * object that represents the parts of the media that are already downloaded and
   * available for playback.
   *
   * @method Html5#buffered
   * @return {TimeRange}
   *         The value of `buffered` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
   */
  "buffered",
  /**
   * Get the value of `volume` from the media element. `volume` indicates
   * the current playback volume of audio for a media. `volume` will be a value from 0
   * (silent) to 1 (loudest and default).
   *
   * @method Html5#volume
   * @return {number}
   *         The value of `volume` from the media element. Value will be between 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Get the value of `poster` from the media element. `poster` indicates
   * that the url of an image file that can/will be shown when no media data is available.
   *
   * @method Html5#poster
   * @return {string}
   *         The value of `poster` from the media element. Value will be a url to an
   *         image.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
   */
  "poster",
  /**
   * Get the value of `preload` from the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#preload
   * @return {string}
   *         The value of `preload` from the media element. Will be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Get the value of the `error` from the media element. `error` indicates any
   * MediaError that may have occurred during playback. If error returns null there is no
   * current error.
   *
   * @method Html5#error
   * @return {MediaError|null}
   *         The value of `error` from the media element. Will be `MediaError` if there
   *         is a current error and null otherwise.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
   */
  "error",
  /**
   * Get the value of `seeking` from the media element. `seeking` indicates whether the
   * media is currently seeking to a new position or not.
   *
   * @method Html5#seeking
   * @return {boolean}
   *         - The value of `seeking` from the media element.
   *         - True indicates that the media is currently seeking to a new position.
   *         - False indicates that the media is not seeking to a new position at this time.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
   */
  "seeking",
  /**
   * Get the value of `seekable` from the media element. `seekable` returns a
   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
   *
   * @method Html5#seekable
   * @return {TimeRange}
   *         The value of `seekable` from the media element. A `TimeRange` object
   *         indicating the current ranges of time that can be seeked to.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
   */
  "seekable",
  /**
   * Get the value of `ended` from the media element. `ended` indicates whether
   * the media has reached the end or not.
   *
   * @method Html5#ended
   * @return {boolean}
   *         - The value of `ended` from the media element.
   *         - True indicates that the media has ended.
   *         - False indicates that the media has not ended.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
   */
  "ended",
  /**
   * Get the value of `playbackRate` from the media element. `playbackRate` indicates
   * the rate at which the media is currently playing back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#playbackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
   * the rate at which the media is currently playing back. This value will not indicate the current
   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
   *
   * Examples:
   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.defaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "defaultPlaybackRate",
  /**
   * Get the value of 'disablePictureInPicture' from the video element.
   *
   * @method Html5#disablePictureInPicture
   * @return {boolean} value
   *         - The value of `disablePictureInPicture` from the video element.
   *         - True indicates that the video can't be played in Picture-In-Picture mode
   *         - False indicates that the video can be played in Picture-In-Picture mode
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Get the value of `played` from the media element. `played` returns a `TimeRange`
   * object representing points in the media timeline that have been played.
   *
   * @method Html5#played
   * @return {TimeRange}
   *         The value of `played` from the media element. A `TimeRange` object indicating
   *         the ranges of time that have been played.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
   */
  "played",
  /**
   * Get the value of `networkState` from the media element. `networkState` indicates
   * the current network state. It returns an enumeration from the following list:
   * - 0: NETWORK_EMPTY
   * - 1: NETWORK_IDLE
   * - 2: NETWORK_LOADING
   * - 3: NETWORK_NO_SOURCE
   *
   * @method Html5#networkState
   * @return {number}
   *         The value of `networkState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
   */
  "networkState",
  /**
   * Get the value of `readyState` from the media element. `readyState` indicates
   * the current state of the media element. It returns an enumeration from the
   * following list:
   * - 0: HAVE_NOTHING
   * - 1: HAVE_METADATA
   * - 2: HAVE_CURRENT_DATA
   * - 3: HAVE_FUTURE_DATA
   * - 4: HAVE_ENOUGH_DATA
   *
   * @method Html5#readyState
   * @return {number}
   *         The value of `readyState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
   */
  "readyState",
  /**
   * Get the value of `videoWidth` from the video element. `videoWidth` indicates
   * the current width of the video in css pixels.
   *
   * @method Html5#videoWidth
   * @return {number}
   *         The value of `videoWidth` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoWidth",
  /**
   * Get the value of `videoHeight` from the video element. `videoHeight` indicates
   * the current height of the video in css pixels.
   *
   * @method Html5#videoHeight
   * @return {number}
   *         The value of `videoHeight` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoHeight",
  /**
   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#crossOrigin
   * @return {string}
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(e) {
  Oe.prototype[e] = function() {
    return this.el_[e];
  };
});
[
  /**
   * Set the value of `volume` on the media element. `volume` indicates the current
   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
   * so on.
   *
   * @method Html5#setVolume
   * @param {number} percentAsDecimal
   *        The volume percent as a decimal. Valid range is from 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Set the value of `src` on the media element. `src` indicates the current
   * {@link Tech~SourceObject} for the media.
   *
   * @method Html5#setSrc
   * @param {Tech~SourceObject} src
   *        The source object to set as the current source.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
   */
  "src",
  /**
   * Set the value of `poster` on the media element. `poster` is the url to
   * an image file that can/will be shown when no media data is available.
   *
   * @method Html5#setPoster
   * @param {string} poster
   *        The url to an image that should be used as the `poster` for the media
   *        element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
   */
  "poster",
  /**
   * Set the value of `preload` on the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#setPreload
   * @param {string} preload
   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Set the value of `playbackRate` on the media element. `playbackRate` indicates
   * the rate at which the media should play back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#setPlaybackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
   * the rate at which the media should play back upon initial startup. Changing this value
   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
   *
   * Example Values:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.setDefaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
   */
  "defaultPlaybackRate",
  /**
   * Prevents the browser from suggesting a Picture-in-Picture context menu
   * or to request Picture-in-Picture automatically in some cases.
   *
   * @method Html5#setDisablePictureInPicture
   * @param {boolean} value
   *         The true value will disable Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#setCrossOrigin
   * @param {string} crossOrigin
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(e) {
  Oe.prototype["set" + vi(e)] = function(t) {
    this.el_[e] = t;
  };
});
[
  /**
   * A wrapper around the media elements `pause` function. This will call the `HTML5`
   * media elements `pause` function.
   *
   * @method Html5#pause
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
   */
  "pause",
  /**
   * A wrapper around the media elements `load` function. This will call the `HTML5`s
   * media element `load` function.
   *
   * @method Html5#load
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
   */
  "load",
  /**
   * A wrapper around the media elements `play` function. This will call the `HTML5`s
   * media element `play` function.
   *
   * @method Html5#play
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
   */
  "play"
].forEach(function(e) {
  Oe.prototype[e] = function() {
    return this.el_[e]();
  };
});
Wt.withSourceHandlers(Oe);
Oe.nativeSourceHandler = {};
Oe.nativeSourceHandler.canPlayType = function(e) {
  try {
    return Oe.TEST_VID.canPlayType(e);
  } catch {
    return "";
  }
};
Oe.nativeSourceHandler.canHandleSource = function(e, t) {
  if (e.type)
    return Oe.nativeSourceHandler.canPlayType(e.type);
  if (e.src) {
    var i = Fp(e.src);
    return Oe.nativeSourceHandler.canPlayType("video/" + i);
  }
  return "";
};
Oe.nativeSourceHandler.handleSource = function(e, t, i) {
  t.setSrc(e.src);
};
Oe.nativeSourceHandler.dispose = function() {
};
Oe.registerSourceHandler(Oe.nativeSourceHandler);
Wt.registerTech("Html5", Oe);
var Pb = [
  /**
   * Fired while the user agent is downloading media data.
   *
   * @event Player#progress
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `progress` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechProgress_
   * @fires Player#progress
   * @listens Tech#progress
   */
  "progress",
  /**
   * Fires when the loading of an audio/video is aborted.
   *
   * @event Player#abort
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `abort` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechAbort_
   * @fires Player#abort
   * @listens Tech#abort
   */
  "abort",
  /**
   * Fires when the browser is intentionally not getting media data.
   *
   * @event Player#suspend
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `suspend` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechSuspend_
   * @fires Player#suspend
   * @listens Tech#suspend
   */
  "suspend",
  /**
   * Fires when the current playlist is empty.
   *
   * @event Player#emptied
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `emptied` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechEmptied_
   * @fires Player#emptied
   * @listens Tech#emptied
   */
  "emptied",
  /**
   * Fires when the browser is trying to get media data, but data is not available.
   *
   * @event Player#stalled
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `stalled` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechStalled_
   * @fires Player#stalled
   * @listens Tech#stalled
   */
  "stalled",
  /**
   * Fires when the browser has loaded meta data for the audio/video.
   *
   * @event Player#loadedmetadata
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoadedmetadata_
   * @fires Player#loadedmetadata
   * @listens Tech#loadedmetadata
   */
  "loadedmetadata",
  /**
   * Fires when the browser has loaded the current frame of the audio/video.
   *
   * @event Player#loadeddata
   * @type {event}
   */
  /**
   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoaddeddata_
   * @fires Player#loadeddata
   * @listens Tech#loadeddata
   */
  "loadeddata",
  /**
   * Fires when the current playback position has changed.
   *
   * @event Player#timeupdate
   * @type {event}
   */
  /**
   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTimeUpdate_
   * @fires Player#timeupdate
   * @listens Tech#timeupdate
   */
  "timeupdate",
  /**
   * Fires when the video's intrinsic dimensions change
   *
   * @event Player#resize
   * @type {event}
   */
  /**
   * Retrigger the `resize` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechResize_
   * @fires Player#resize
   * @listens Tech#resize
   */
  "resize",
  /**
   * Fires when the volume has been changed
   *
   * @event Player#volumechange
   * @type {event}
   */
  /**
   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechVolumechange_
   * @fires Player#volumechange
   * @listens Tech#volumechange
   */
  "volumechange",
  /**
   * Fires when the text track has been changed
   *
   * @event Player#texttrackchange
   * @type {event}
   */
  /**
   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTexttrackchange_
   * @fires Player#texttrackchange
   * @listens Tech#texttrackchange
   */
  "texttrackchange"
], _d = {
  canplay: "CanPlay",
  canplaythrough: "CanPlayThrough",
  playing: "Playing",
  seeked: "Seeked"
}, hf = [
  "tiny",
  "xsmall",
  "small",
  "medium",
  "large",
  "xlarge",
  "huge"
], nc = {};
hf.forEach(function(e) {
  var t = e.charAt(0) === "x" ? "x-" + e.substring(1) : e;
  nc[e] = "vjs-layout-" + t;
});
var R3 = {
  huge: 1 / 0,
  large: 1440,
  medium: 768,
  small: 425,
  tiny: 210,
  xlarge: 2560,
  xsmall: 320
}, bi = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a) {
    var s;
    if (n.id = n.id || r.id || "vjs_video_" + ea(), r = si(t.getTagSettings(n), r), r.initChildren = !1, r.createEl = !1, r.evented = !1, r.reportTouchActivity = !1, !r.language)
      if (typeof n.closest == "function") {
        var o = n.closest("[lang]");
        o && o.getAttribute && (r.language = o.getAttribute("lang"));
      } else
        for (var u = n; u && u.nodeType === 1; ) {
          if (Pn(u).hasOwnProperty("lang")) {
            r.language = u.getAttribute("lang");
            break;
          }
          u = u.parentNode;
        }
    if (s = e.call(this, null, r, a) || this, s.boundDocumentFullscreenChange_ = function(d) {
      return s.documentFullscreenChange_(d);
    }, s.boundFullWindowOnEscKey_ = function(d) {
      return s.fullWindowOnEscKey(d);
    }, s.boundUpdateStyleEl_ = function(d) {
      return s.updateStyleEl_(d);
    }, s.boundApplyInitTime_ = function(d) {
      return s.applyInitTime_(d);
    }, s.boundUpdateCurrentBreakpoint_ = function(d) {
      return s.updateCurrentBreakpoint_(d);
    }, s.boundHandleTechClick_ = function(d) {
      return s.handleTechClick_(d);
    }, s.boundHandleTechDoubleClick_ = function(d) {
      return s.handleTechDoubleClick_(d);
    }, s.boundHandleTechTouchStart_ = function(d) {
      return s.handleTechTouchStart_(d);
    }, s.boundHandleTechTouchMove_ = function(d) {
      return s.handleTechTouchMove_(d);
    }, s.boundHandleTechTouchEnd_ = function(d) {
      return s.handleTechTouchEnd_(d);
    }, s.boundHandleTechTap_ = function(d) {
      return s.handleTechTap_(d);
    }, s.isFullscreen_ = !1, s.log = S_(s.id_), s.fsApi_ = jc, s.isPosterFromTech_ = !1, s.queuedCallbacks_ = [], s.isReady_ = !1, s.hasStarted_ = !1, s.userActive_ = !1, s.debugEnabled_ = !1, s.audioOnlyMode_ = !1, s.audioPosterMode_ = !1, s.audioOnlyCache_ = {
      hiddenChildren: [],
      playerHeight: null
    }, !s.options_ || !s.options_.techOrder || !s.options_.techOrder.length)
      throw new Error(
        "No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?"
      );
    if (s.tag = n, s.tagAttributes = n && Pn(n), s.language(s.options_.language), r.languages) {
      var l = {};
      Object.getOwnPropertyNames(r.languages).forEach(function(d) {
        l[d.toLowerCase()] = r.languages[d];
      }), s.languages_ = l;
    } else
      s.languages_ = t.prototype.options_.languages;
    s.resetCache_(), s.poster_ = r.poster || "", s.controls_ = !!r.controls, n.controls = !1, n.removeAttribute("controls"), s.changingSrc_ = !1, s.playCallbacks_ = [], s.playTerminatedQueue_ = [], n.hasAttribute("autoplay") ? s.autoplay(!0) : s.autoplay(s.options_.autoplay), r.plugins && Object.keys(r.plugins).forEach(function(d) {
      if (typeof s[d] != "function")
        throw new Error('plugin "' + d + '" does not exist');
    }), s.scrubbing_ = !1, s.el_ = s.createEl(), Op(He(s), {
      eventBusKey: "el_"
    }), s.fsApi_.requestFullscreen && (Pr(
      Te,
      s.fsApi_.fullscreenchange,
      s.boundDocumentFullscreenChange_
    ), s.on(
      s.fsApi_.fullscreenchange,
      s.boundDocumentFullscreenChange_
    )), s.fluid_ && s.on(["playerreset", "resize"], s.boundUpdateStyleEl_);
    var c = Kt(s.options_);
    r.plugins && Object.keys(r.plugins).forEach(function(d) {
      s[d](r.plugins[d]);
    }), r.debug && s.debug(!0), s.options_.playerOptions = c, s.middleware_ = [], s.playbackRates(r.playbackRates), s.initChildren(), s.isAudio(n.nodeName.toLowerCase() === "audio"), s.controls() ? s.addClass("vjs-controls-enabled") : s.addClass("vjs-controls-disabled"), s.el_.setAttribute("role", "region"), s.isAudio() ? s.el_.setAttribute("aria-label", s.localize("Audio Player")) : s.el_.setAttribute("aria-label", s.localize("Video Player")), s.isAudio() && s.addClass("vjs-audio"), s.flexNotSupported_() && s.addClass("vjs-no-flex"), Co && s.addClass("vjs-touch-enabled"), cr || s.addClass("vjs-workinghover"), t.players[s.id_] = He(s);
    var h = T_.split(".")[0];
    return s.addClass("vjs-v" + h), s.userActive(!0), s.reportUserActivity(), s.one("play", function(d) {
      return s.listenForUserActivity_(d);
    }), s.on("stageclick", function(d) {
      return s.handleStageClick_(d);
    }), s.on("keydown", function(d) {
      return s.handleKeyDown(d);
    }), s.on("languagechange", function(d) {
      return s.handleLanguagechange(d);
    }), s.breakpoints(s.options_.breakpoints), s.responsive(s.options_.responsive), s.on("ready", function() {
      s.audioPosterMode(s.options_.audioPosterMode), s.audioOnlyMode(s.options_.audioOnlyMode);
    }), s;
  }
  var i = t.prototype;
  return i.dispose = function() {
    var r = this;
    this.trigger("dispose"), this.off("dispose"), Hi(
      Te,
      this.fsApi_.fullscreenchange,
      this.boundDocumentFullscreenChange_
    ), Hi(Te, "keydown", this.boundFullWindowOnEscKey_), this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_), this.styleEl_ = null), t.players[this.id_] = null, this.tag && this.tag.player && (this.tag.player = null), this.el_ && this.el_.player && (this.el_.player = null), this.tech_ && (this.tech_.dispose(), this.isPosterFromTech_ = !1, this.poster_ = ""), this.playerElIngest_ && (this.playerElIngest_ = null), this.tag && (this.tag = null), JM(this), Ji.names.forEach(function(a) {
      var s = Ji[a], o = r[s.getterName]();
      o && o.off && o.off();
    }), e.prototype.dispose.call(this, {
      restoreEl: this.options_.restoreEl
    });
  }, i.createEl = function() {
    var r = this.tag, a, s = this.playerElIngest_ = r.parentNode && r.parentNode.hasAttribute && r.parentNode.hasAttribute("data-vjs-player"), o = this.tag.tagName.toLowerCase() === "video-js";
    s ? a = this.el_ = r.parentNode : o || (a = this.el_ = e.prototype.createEl.call(this, "div"));
    var u = Pn(r);
    if (o) {
      for (a = this.el_ = r, r = this.tag = Te.createElement("video"); a.children.length; )
        r.appendChild(a.firstChild);
      Ua(a, "video-js") || Un(a, "video-js"), a.appendChild(r), s = this.playerElIngest_ = a, Object.keys(a).forEach(function(p) {
        try {
          r[p] = a[p];
        } catch {
        }
      });
    }
    if (r.setAttribute("tabindex", "-1"), u.tabindex = "-1", (Dl || $n && R_) && (r.setAttribute("role", "application"), u.role = "application"), r.removeAttribute("width"), r.removeAttribute("height"), "width" in u && delete u.width, "height" in u && delete u.height, Object.getOwnPropertyNames(u).forEach(function(p) {
      o && p === "class" || a.setAttribute(p, u[p]), o && r.setAttribute(p, u[p]);
    }), r.playerId = r.id, r.id += "_html5_api", r.className = "vjs-tech", r.player = a.player = this, this.addClass("vjs-paused"), W.VIDEOJS_NO_DYNAMIC_STYLE !== !0) {
      this.styleEl_ = X_("vjs-styles-dimensions");
      var l = ma(".vjs-styles-defaults"), c = ma("head");
      c.insertBefore(
        this.styleEl_,
        l ? l.nextSibling : c.firstChild
      );
    }
    this.fill_ = !1, this.fluid_ = !1, this.width(this.options_.width), this.height(this.options_.height), this.fill(this.options_.fill), this.fluid(this.options_.fluid), this.aspectRatio(this.options_.aspectRatio), this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
    for (var h = r.getElementsByTagName("a"), d = 0; d < h.length; d++) {
      var f = h.item(d);
      Un(f, "vjs-hidden"), f.setAttribute("hidden", "hidden");
    }
    return r.initNetworkState_ = r.networkState, r.parentNode && !s && r.parentNode.insertBefore(a, r), rf(r, a), this.children_.unshift(r), this.el_.setAttribute("lang", this.language_), this.el_.setAttribute("translate", "no"), this.el_ = a, a;
  }, i.crossOrigin = function(r) {
    if (!r)
      return this.techGet_("crossOrigin");
    if (r !== "anonymous" && r !== "use-credentials") {
      mt.warn(
        'crossOrigin must be "anonymous" or "use-credentials", given "' + r + '"'
      );
      return;
    }
    this.techCall_("setCrossOrigin", r);
  }, i.width = function(r) {
    return this.dimension("width", r);
  }, i.height = function(r) {
    return this.dimension("height", r);
  }, i.dimension = function(r, a) {
    var s = r + "_";
    if (a === void 0)
      return this[s] || 0;
    if (a === "" || a === "auto") {
      this[s] = void 0, this.updateStyleEl_();
      return;
    }
    var o = parseFloat(a);
    if (isNaN(o)) {
      mt.error(
        'Improper value "' + a + '" supplied for for ' + r
      );
      return;
    }
    this[s] = o, this.updateStyleEl_();
  }, i.fluid = function(r) {
    var a = this;
    if (r === void 0)
      return !!this.fluid_;
    this.fluid_ = !!r, jn(this) && this.off(["playerreset", "resize"], this.boundUpdateStyleEl_), r ? (this.addClass("vjs-fluid"), this.fill(!1), TM(this, function() {
      a.on(["playerreset", "resize"], a.boundUpdateStyleEl_);
    })) : this.removeClass("vjs-fluid"), this.updateStyleEl_();
  }, i.fill = function(r) {
    if (r === void 0)
      return !!this.fill_;
    this.fill_ = !!r, r ? (this.addClass("vjs-fill"), this.fluid(!1)) : this.removeClass("vjs-fill");
  }, i.aspectRatio = function(r) {
    if (r === void 0)
      return this.aspectRatio_;
    if (!/^\d+\:\d+$/.test(r))
      throw new Error(
        "Improper value supplied for aspect ratio. The format should be width:height, for example 16:9."
      );
    this.aspectRatio_ = r, this.fluid(!0), this.updateStyleEl_();
  }, i.updateStyleEl_ = function() {
    if (W.VIDEOJS_NO_DYNAMIC_STYLE === !0) {
      var r = typeof this.width_ == "number" ? this.width_ : this.options_.width, a = typeof this.height_ == "number" ? this.height_ : this.options_.height, s = this.tech_ && this.tech_.el();
      s && (r >= 0 && (s.width = r), a >= 0 && (s.height = a));
      return;
    }
    var o, u, l, c;
    this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto" ? l = this.aspectRatio_ : this.videoWidth() > 0 ? l = this.videoWidth() + ":" + this.videoHeight() : l = "16:9";
    var h = l.split(":"), d = h[1] / h[0];
    this.width_ !== void 0 ? o = this.width_ : this.height_ !== void 0 ? o = this.height_ / d : o = this.videoWidth() || 300, this.height_ !== void 0 ? u = this.height_ : u = o * d, /^[^a-zA-Z]/.test(this.id()) ? c = "dimensions-" + this.id() : c = this.id() + "-dimensions", this.addClass(c), Y_(
      this.styleEl_,
      `
      .` + c + ` {
        width: ` + o + `px;
        height: ` + u + `px;
      }

      .` + c + `.vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: ` + d * 100 + `%;
      }
    `
    );
  }, i.loadTech_ = function(r, a) {
    var s = this;
    this.tech_ && this.unloadTech_();
    var o = vi(r), u = r.charAt(0).toLowerCase() + r.slice(1);
    o !== "Html5" && this.tag && (Wt.getTech("Html5").disposeMediaElement(this.tag), this.tag.player = null, this.tag = null), this.techName_ = o, this.isReady_ = !1;
    var l = this.autoplay();
    (typeof this.autoplay() == "string" || this.autoplay() === !0 && this.options_.normalizeAutoplay) && (l = !1);
    var c = {
      autoplay: l,
      disablePictureInPicture: this.options_.disablePictureInPicture,
      language: this.language(),
      loop: this.options_.loop,
      muted: this.options_.muted,
      canOverridePoster: !!this.options_.techCanOverridePoster,
      nativeControlsForTouch: this.options_.nativeControlsForTouch,
      Promise: this.options_.Promise,
      playerId: this.id(),
      enableSourceset: this.options_.enableSourceset,
      source: a,
      playerElIngest: this.playerElIngest_ || !1,
      playsinline: this.options_.playsinline,
      poster: this.poster(),
      techId: this.id() + "_" + u + "_api",
      preload: this.options_.preload,
      "vtt.js": this.options_["vtt.js"]
    };
    Ji.names.forEach(function(d) {
      var f = Ji[d];
      c[f.getterName] = s[f.privateName];
    }), si(c, this.options_[o]), si(c, this.options_[u]), si(c, this.options_[r.toLowerCase()]), this.tag && (c.tag = this.tag), a && a.src === this.cache_.src && this.cache_.currentTime > 0 && (c.startTime = this.cache_.currentTime);
    var h = Wt.getTech(r);
    if (!h)
      throw new Error(
        "No Tech named '" + o + "' exists! '" + o + "' should be registered using videojs.registerTech()'"
      );
    this.tech_ = new h(c), this.tech_.ready(Zt(this, this.handleTechReady_), !0), Um.jsonToTextTracks(this.textTracksJson_ || [], this.tech_), Pb.forEach(function(d) {
      s.on(s.tech_, d, function(f) {
        return s["handleTech" + vi(d) + "_"](f);
      });
    }), Object.keys(_d).forEach(function(d) {
      s.on(s.tech_, d, function(f) {
        if (s.tech_.playbackRate() === 0 && s.tech_.seeking()) {
          s.queuedCallbacks_.push({
            callback: s["handleTech" + _d[d] + "_"].bind(
              s
            ),
            event: f
          });
          return;
        }
        s["handleTech" + _d[d] + "_"](f);
      });
    }), this.on(this.tech_, "loadstart", function(d) {
      return s.handleTechLoadStart_(d);
    }), this.on(this.tech_, "sourceset", function(d) {
      return s.handleTechSourceset_(d);
    }), this.on(this.tech_, "waiting", function(d) {
      return s.handleTechWaiting_(d);
    }), this.on(this.tech_, "ended", function(d) {
      return s.handleTechEnded_(d);
    }), this.on(this.tech_, "seeking", function(d) {
      return s.handleTechSeeking_(d);
    }), this.on(this.tech_, "play", function(d) {
      return s.handleTechPlay_(d);
    }), this.on(this.tech_, "firstplay", function(d) {
      return s.handleTechFirstPlay_(d);
    }), this.on(this.tech_, "pause", function(d) {
      return s.handleTechPause_(d);
    }), this.on(this.tech_, "durationchange", function(d) {
      return s.handleTechDurationChange_(d);
    }), this.on(this.tech_, "fullscreenchange", function(d, f) {
      return s.handleTechFullscreenChange_(d, f);
    }), this.on(this.tech_, "fullscreenerror", function(d, f) {
      return s.handleTechFullscreenError_(d, f);
    }), this.on(this.tech_, "enterpictureinpicture", function(d) {
      return s.handleTechEnterPictureInPicture_(d);
    }), this.on(this.tech_, "leavepictureinpicture", function(d) {
      return s.handleTechLeavePictureInPicture_(d);
    }), this.on(this.tech_, "error", function(d) {
      return s.handleTechError_(d);
    }), this.on(this.tech_, "posterchange", function(d) {
      return s.handleTechPosterChange_(d);
    }), this.on(this.tech_, "textdata", function(d) {
      return s.handleTechTextData_(d);
    }), this.on(this.tech_, "ratechange", function(d) {
      return s.handleTechRateChange_(d);
    }), this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_), this.usingNativeControls(this.techGet_("controls")), this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(), this.tech_.el().parentNode !== this.el() && (o !== "Html5" || !this.tag) && rf(this.tech_.el(), this.el()), this.tag && (this.tag.player = null, this.tag = null);
  }, i.unloadTech_ = function() {
    var r = this;
    Ji.names.forEach(function(a) {
      var s = Ji[a];
      r[s.privateName] = r[s.getterName]();
    }), this.textTracksJson_ = Um.textTracksToJson(this.tech_), this.isReady_ = !1, this.tech_.dispose(), this.tech_ = !1, this.isPosterFromTech_ && (this.poster_ = "", this.trigger("posterchange")), this.isPosterFromTech_ = !1;
  }, i.tech = function(r) {
    return r === void 0 && mt.warn(
      `Using the tech directly can be dangerous. I hope you know what you're doing.
See https://github.com/videojs/video.js/issues/2617 for more info.
`
    ), this.tech_;
  }, i.addTechControlsListeners_ = function() {
    this.removeTechControlsListeners_(), this.on(this.tech_, "click", this.boundHandleTechClick_), this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_), this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.on(this.tech_, "tap", this.boundHandleTechTap_);
  }, i.removeTechControlsListeners_ = function() {
    this.off(this.tech_, "tap", this.boundHandleTechTap_), this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.off(this.tech_, "click", this.boundHandleTechClick_), this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
  }, i.handleTechReady_ = function() {
    this.triggerReady(), this.cache_.volume && this.techCall_("setVolume", this.cache_.volume), this.handleTechPosterChange_(), this.handleTechDurationChange_();
  }, i.handleTechLoadStart_ = function() {
    this.removeClass("vjs-ended"), this.removeClass("vjs-seeking"), this.error(null), this.handleTechDurationChange_(), this.paused() ? (this.hasStarted(!1), this.trigger("loadstart")) : (this.trigger("loadstart"), this.trigger("firstplay")), this.manualAutoplay_(
      this.autoplay() === !0 && this.options_.normalizeAutoplay ? "play" : this.autoplay()
    );
  }, i.manualAutoplay_ = function(r) {
    var a = this;
    if (!(!this.tech_ || typeof r != "string")) {
      var s = function() {
        var l = a.muted();
        a.muted(!0);
        var c = function() {
          a.muted(l);
        };
        a.playTerminatedQueue_.push(c);
        var h = a.play();
        if (du(h))
          return h.catch(function(d) {
            throw c(), new Error(
              "Rejection at manualAutoplay. Restoring muted value. " + (d || "")
            );
          });
      }, o;
      if (r === "any" && !this.muted() ? (o = this.play(), du(o) && (o = o.catch(s))) : r === "muted" && !this.muted() ? o = s() : o = this.play(), !!du(o))
        return o.then(function() {
          a.trigger({
            autoplay: r,
            type: "autoplay-success"
          });
        }).catch(function() {
          a.trigger({
            autoplay: r,
            type: "autoplay-failure"
          });
        });
    }
  }, i.updateSourceCaches_ = function(r) {
    r === void 0 && (r = "");
    var a = r, s = "";
    typeof a != "string" && (a = r.src, s = r.type), this.cache_.source = this.cache_.source || {}, this.cache_.sources = this.cache_.sources || [], a && !s && (s = t3(this, a)), this.cache_.source = Kt({}, r, {
      src: a,
      type: s
    });
    for (var o = this.cache_.sources.filter(function(f) {
      return f.src && f.src === a;
    }), u = [], l = this.$$("source"), c = [], h = 0; h < l.length; h++) {
      var d = Pn(l[h]);
      u.push(d), d.src && d.src === a && c.push(d.src);
    }
    c.length && !o.length ? this.cache_.sources = u : o.length || (this.cache_.sources = [this.cache_.source]), this.cache_.src = a;
  }, i.handleTechSourceset_ = function(r) {
    var a = this;
    if (!this.changingSrc_) {
      var s = function(c) {
        return a.updateSourceCaches_(c);
      }, o = this.currentSource().src, u = r.src;
      o && !/^blob:/.test(o) && /^blob:/.test(u) && (!this.lastSource_ || this.lastSource_.tech !== u && this.lastSource_.player !== o) && (s = function() {
      }), s(u), r.src || this.tech_.any(["sourceset", "loadstart"], function(l) {
        if (l.type !== "sourceset") {
          var c = a.techGet("currentSrc");
          a.lastSource_.tech = c, a.updateSourceCaches_(c);
        }
      });
    }
    this.lastSource_ = {
      player: this.currentSource().src,
      tech: r.src
    }, this.trigger({
      src: r.src,
      type: "sourceset"
    });
  }, i.hasStarted = function(r) {
    if (r === void 0)
      return this.hasStarted_;
    r !== this.hasStarted_ && (this.hasStarted_ = r, this.hasStarted_ ? (this.addClass("vjs-has-started"), this.trigger("firstplay")) : this.removeClass("vjs-has-started"));
  }, i.handleTechPlay_ = function() {
    this.removeClass("vjs-ended"), this.removeClass("vjs-paused"), this.addClass("vjs-playing"), this.hasStarted(!0), this.trigger("play");
  }, i.handleTechRateChange_ = function() {
    this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0 && (this.queuedCallbacks_.forEach(function(r) {
      return r.callback(r.event);
    }), this.queuedCallbacks_ = []), this.cache_.lastPlaybackRate = this.tech_.playbackRate(), this.trigger("ratechange");
  }, i.handleTechWaiting_ = function() {
    var r = this;
    this.addClass("vjs-waiting"), this.trigger("waiting");
    var a = this.currentTime(), s = function o() {
      a !== r.currentTime() && (r.removeClass("vjs-waiting"), r.off("timeupdate", o));
    };
    this.on("timeupdate", s);
  }, i.handleTechCanPlay_ = function() {
    this.removeClass("vjs-waiting"), this.trigger("canplay");
  }, i.handleTechCanPlayThrough_ = function() {
    this.removeClass("vjs-waiting"), this.trigger("canplaythrough");
  }, i.handleTechPlaying_ = function() {
    this.removeClass("vjs-waiting"), this.trigger("playing");
  }, i.handleTechSeeking_ = function() {
    this.addClass("vjs-seeking"), this.trigger("seeking");
  }, i.handleTechSeeked_ = function() {
    this.removeClass("vjs-seeking"), this.removeClass("vjs-ended"), this.trigger("seeked");
  }, i.handleTechFirstPlay_ = function() {
    this.options_.starttime && (mt.warn(
      "Passing the `starttime` option to the player will be deprecated in 6.0"
    ), this.currentTime(this.options_.starttime)), this.addClass("vjs-has-started"), this.trigger("firstplay");
  }, i.handleTechPause_ = function() {
    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.trigger("pause");
  }, i.handleTechEnded_ = function() {
    this.addClass("vjs-ended"), this.removeClass("vjs-waiting"), this.options_.loop ? (this.currentTime(0), this.play()) : this.paused() || this.pause(), this.trigger("ended");
  }, i.handleTechDurationChange_ = function() {
    this.duration(this.techGet_("duration"));
  }, i.handleTechClick_ = function(r) {
    this.controls_ && (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click == "function" ? this.options_.userActions.click.call(this, r) : this.paused() ? hn(this.play()) : this.pause());
  }, i.handleTechDoubleClick_ = function(r) {
    if (this.controls_) {
      var a = Array.prototype.some.call(
        this.$$(".vjs-control-bar, .vjs-modal-dialog"),
        function(s) {
          return s.contains(r.target);
        }
      );
      a || (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick == "function" ? this.options_.userActions.doubleClick.call(this, r) : this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen());
    }
  }, i.handleTechTap_ = function() {
    this.userActive(!this.userActive());
  }, i.handleTechTouchStart_ = function() {
    this.userWasActive = this.userActive();
  }, i.handleTechTouchMove_ = function() {
    this.userWasActive && this.reportUserActivity();
  }, i.handleTechTouchEnd_ = function(r) {
    r.cancelable && r.preventDefault();
  }, i.handleStageClick_ = function() {
    this.reportUserActivity();
  }, i.toggleFullscreenClass_ = function() {
    this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen");
  }, i.documentFullscreenChange_ = function(r) {
    var a = r.target.player;
    if (!(a && a !== this)) {
      var s = this.el(), o = Te[this.fsApi_.fullscreenElement] === s;
      !o && s.matches ? o = s.matches(":" + this.fsApi_.fullscreen) : !o && s.msMatchesSelector && (o = s.msMatchesSelector(":" + this.fsApi_.fullscreen)), this.isFullscreen(o);
    }
  }, i.handleTechFullscreenChange_ = function(r, a) {
    var s = this;
    a && (a.nativeIOSFullscreen && (this.addClass("vjs-ios-native-fs"), this.tech_.one("webkitendfullscreen", function() {
      s.removeClass("vjs-ios-native-fs");
    })), this.isFullscreen(a.isFullscreen));
  }, i.handleTechFullscreenError_ = function(r, a) {
    this.trigger("fullscreenerror", a);
  }, i.togglePictureInPictureClass_ = function() {
    this.isInPictureInPicture() ? this.addClass("vjs-picture-in-picture") : this.removeClass("vjs-picture-in-picture");
  }, i.handleTechEnterPictureInPicture_ = function(r) {
    this.isInPictureInPicture(!0);
  }, i.handleTechLeavePictureInPicture_ = function(r) {
    this.isInPictureInPicture(!1);
  }, i.handleTechError_ = function() {
    var r = this.tech_.error();
    this.error(r);
  }, i.handleTechTextData_ = function() {
    var r = null;
    arguments.length > 1 && (r = arguments[1]), this.trigger("textdata", r);
  }, i.getCache = function() {
    return this.cache_;
  }, i.resetCache_ = function() {
    this.cache_ = {
      // Right now, the currentTime is not _really_ cached because it is always
      // retrieved from the tech (see: currentTime). However, for completeness,
      // we set it to zero here to ensure that if we do start actually caching
      // it, we reset it along with everything else.
      currentTime: 0,
      duration: NaN,
      inactivityTimeout: this.options_.inactivityTimeout,
      initTime: 0,
      lastPlaybackRate: this.defaultPlaybackRate(),
      lastVolume: 1,
      media: null,
      playbackRates: [],
      source: {},
      sources: [],
      src: "",
      volume: 1
    };
  }, i.techCall_ = function(r, a) {
    this.ready(function() {
      if (r in KM)
        return YM(this.middleware_, this.tech_, r, a);
      if (r in Wm)
        return zm(this.middleware_, this.tech_, r, a);
      try {
        this.tech_ && this.tech_[r](a);
      } catch (s) {
        throw mt(s), s;
      }
    }, !0);
  }, i.techGet_ = function(r) {
    if (!(!this.tech_ || !this.tech_.isReady_)) {
      if (r in QM)
        return XM(this.middleware_, this.tech_, r);
      if (r in Wm)
        return zm(this.middleware_, this.tech_, r);
      try {
        return this.tech_[r]();
      } catch (a) {
        throw this.tech_[r] === void 0 ? (mt(
          "Video.js: " + r + " method not defined for " + this.techName_ + " playback technology.",
          a
        ), a) : a.name === "TypeError" ? (mt(
          "Video.js: " + r + " unavailable on " + this.techName_ + " playback technology element.",
          a
        ), this.tech_.isReady_ = !1, a) : (mt(a), a);
      }
    }
  }, i.play = function() {
    var r = this, a = this.options_.Promise || W.Promise;
    return a ? new a(function(s) {
      r.play_(s);
    }) : this.play_();
  }, i.play_ = function(r) {
    var a = this;
    r === void 0 && (r = hn), this.playCallbacks_.push(r);
    var s = !!(!this.changingSrc_ && (this.src() || this.currentSrc())), o = !!(Dh || cr);
    if (this.waitToPlay_ && (this.off(["ready", "loadstart"], this.waitToPlay_), this.waitToPlay_ = null), !this.isReady_ || !s) {
      this.waitToPlay_ = function(c) {
        a.play_();
      }, this.one(["ready", "loadstart"], this.waitToPlay_), !s && o && this.load();
      return;
    }
    var u = this.techGet_("play"), l = o && this.hasClass("vjs-ended");
    l && this.resetProgressBar_(), u === null ? this.runPlayTerminatedQueue_() : this.runPlayCallbacks_(u);
  }, i.runPlayTerminatedQueue_ = function() {
    var r = this.playTerminatedQueue_.slice(0);
    this.playTerminatedQueue_ = [], r.forEach(function(a) {
      a();
    });
  }, i.runPlayCallbacks_ = function(r) {
    var a = this.playCallbacks_.slice(0);
    this.playCallbacks_ = [], this.playTerminatedQueue_ = [], a.forEach(function(s) {
      s(r);
    });
  }, i.pause = function() {
    this.techCall_("pause");
  }, i.paused = function() {
    return this.techGet_("paused") !== !1;
  }, i.played = function() {
    return this.techGet_("played") || ja(0, 0);
  }, i.scrubbing = function(r) {
    if (typeof r > "u")
      return this.scrubbing_;
    this.scrubbing_ = !!r, this.techCall_("setScrubbing", this.scrubbing_), r ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing");
  }, i.currentTime = function(r) {
    if (typeof r < "u") {
      if (r < 0 && (r = 0), !this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
        this.cache_.initTime = r, this.off("canplay", this.boundApplyInitTime_), this.one("canplay", this.boundApplyInitTime_);
        return;
      }
      this.techCall_("setCurrentTime", r), this.cache_.initTime = 0;
      return;
    }
    return this.cache_.currentTime = this.techGet_("currentTime") || 0, this.cache_.currentTime;
  }, i.applyInitTime_ = function() {
    this.currentTime(this.cache_.initTime);
  }, i.duration = function(r) {
    if (r === void 0)
      return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
    r = parseFloat(r), r < 0 && (r = 1 / 0), r !== this.cache_.duration && (this.cache_.duration = r, r === 1 / 0 ? this.addClass("vjs-live") : this.removeClass("vjs-live"), isNaN(r) || this.trigger("durationchange"));
  }, i.remainingTime = function() {
    return this.duration() - this.currentTime();
  }, i.remainingTimeDisplay = function() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  }, i.buffered = function() {
    var r = this.techGet_("buffered");
    return (!r || !r.length) && (r = ja(0, 0)), r;
  }, i.bufferedPercent = function() {
    return eb(this.buffered(), this.duration());
  }, i.bufferedEnd = function() {
    var r = this.buffered(), a = this.duration(), s = r.end(r.length - 1);
    return s > a && (s = a), s;
  }, i.volume = function(r) {
    var a;
    if (r !== void 0) {
      a = Math.max(0, Math.min(1, parseFloat(r))), this.cache_.volume = a, this.techCall_("setVolume", a), a > 0 && this.lastVolume_(a);
      return;
    }
    return a = parseFloat(this.techGet_("volume")), isNaN(a) ? 1 : a;
  }, i.muted = function(r) {
    if (r !== void 0) {
      this.techCall_("setMuted", r);
      return;
    }
    return this.techGet_("muted") || !1;
  }, i.defaultMuted = function(r) {
    return r !== void 0 ? this.techCall_("setDefaultMuted", r) : this.techGet_("defaultMuted") || !1;
  }, i.lastVolume_ = function(r) {
    if (r !== void 0 && r !== 0) {
      this.cache_.lastVolume = r;
      return;
    }
    return this.cache_.lastVolume;
  }, i.supportsFullScreen = function() {
    return this.techGet_("supportsFullScreen") || !1;
  }, i.isFullscreen = function(r) {
    if (r !== void 0) {
      var a = this.isFullscreen_;
      this.isFullscreen_ = !!r, this.isFullscreen_ !== a && this.fsApi_.prefixed && this.trigger("fullscreenchange"), this.toggleFullscreenClass_();
      return;
    }
    return this.isFullscreen_;
  }, i.requestFullscreen = function(r) {
    var a = this.options_.Promise || W.Promise;
    if (a) {
      var s = this;
      return new a(function(o, u) {
        function l() {
          s.off("fullscreenerror", h), s.off("fullscreenchange", c);
        }
        function c() {
          l(), o();
        }
        function h(f, p) {
          l(), u(p);
        }
        s.one("fullscreenchange", c), s.one("fullscreenerror", h);
        var d = s.requestFullscreenHelper_(r);
        d && (d.then(l, l), d.then(o, u));
      });
    }
    return this.requestFullscreenHelper_();
  }, i.requestFullscreenHelper_ = function(r) {
    var a = this, s;
    if (this.fsApi_.prefixed || (s = this.options_.fullscreen && this.options_.fullscreen.options || {}, r !== void 0 && (s = r)), this.fsApi_.requestFullscreen) {
      var o = this.el_[this.fsApi_.requestFullscreen](s);
      return o && o.then(
        function() {
          return a.isFullscreen(!0);
        },
        function() {
          return a.isFullscreen(!1);
        }
      ), o;
    } else this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("enterFullScreen") : this.enterFullWindow();
  }, i.exitFullscreen = function() {
    var r = this.options_.Promise || W.Promise;
    if (r) {
      var a = this;
      return new r(function(s, o) {
        function u() {
          a.off("fullscreenerror", c), a.off("fullscreenchange", l);
        }
        function l() {
          u(), s();
        }
        function c(d, f) {
          u(), o(f);
        }
        a.one("fullscreenchange", l), a.one("fullscreenerror", c);
        var h = a.exitFullscreenHelper_();
        h && (h.then(u, u), h.then(s, o));
      });
    }
    return this.exitFullscreenHelper_();
  }, i.exitFullscreenHelper_ = function() {
    var r = this;
    if (this.fsApi_.requestFullscreen) {
      var a = Te[this.fsApi_.exitFullscreen]();
      return a && hn(
        a.then(function() {
          return r.isFullscreen(!1);
        })
      ), a;
    } else this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("exitFullScreen") : this.exitFullWindow();
  }, i.enterFullWindow = function() {
    this.isFullscreen(!0), this.isFullWindow = !0, this.docOrigOverflow = Te.documentElement.style.overflow, Pr(Te, "keydown", this.boundFullWindowOnEscKey_), Te.documentElement.style.overflow = "hidden", Un(Te.body, "vjs-full-window"), this.trigger("enterFullWindow");
  }, i.fullWindowOnEscKey = function(r) {
    lt.isEventKey(r, "Esc") && this.isFullscreen() === !0 && (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen());
  }, i.exitFullWindow = function() {
    this.isFullscreen(!1), this.isFullWindow = !1, Hi(Te, "keydown", this.boundFullWindowOnEscKey_), Te.documentElement.style.overflow = this.docOrigOverflow, Pl(Te.body, "vjs-full-window"), this.trigger("exitFullWindow");
  }, i.disablePictureInPicture = function(r) {
    if (r === void 0)
      return this.techGet_("disablePictureInPicture");
    this.techCall_("setDisablePictureInPicture", r), this.options_.disablePictureInPicture = r, this.trigger("disablepictureinpicturechanged");
  }, i.isInPictureInPicture = function(r) {
    if (r !== void 0) {
      this.isInPictureInPicture_ = !!r, this.togglePictureInPictureClass_();
      return;
    }
    return !!this.isInPictureInPicture_;
  }, i.requestPictureInPicture = function() {
    if ("pictureInPictureEnabled" in Te && this.disablePictureInPicture() === !1)
      return this.techGet_("requestPictureInPicture");
  }, i.exitPictureInPicture = function() {
    if ("pictureInPictureEnabled" in Te)
      return Te.exitPictureInPicture();
  }, i.handleKeyDown = function(r) {
    var a = this.options_.userActions;
    if (!(!a || !a.hotkeys)) {
      var s = function(u) {
        var l = u.tagName.toLowerCase();
        if (u.isContentEditable)
          return !0;
        var c = [
          "button",
          "checkbox",
          "hidden",
          "radio",
          "reset",
          "submit"
        ];
        if (l === "input")
          return c.indexOf(u.type) === -1;
        var h = ["textarea"];
        return h.indexOf(l) !== -1;
      };
      s(this.el_.ownerDocument.activeElement) || (typeof a.hotkeys == "function" ? a.hotkeys.call(this, r) : this.handleHotkeys(r));
    }
  }, i.handleHotkeys = function(r) {
    var a = this.options_.userActions ? this.options_.userActions.hotkeys : {}, s = a.fullscreenKey, o = s === void 0 ? function(_) {
      return lt.isEventKey(_, "f");
    } : s, u = a.muteKey, l = u === void 0 ? function(_) {
      return lt.isEventKey(_, "m");
    } : u, c = a.playPauseKey, h = c === void 0 ? function(_) {
      return lt.isEventKey(_, "k") || lt.isEventKey(_, "Space");
    } : c;
    if (o.call(this, r)) {
      r.preventDefault(), r.stopPropagation();
      var d = ye.getComponent("FullscreenToggle");
      Te[this.fsApi_.fullscreenEnabled] !== !1 && d.prototype.handleClick.call(this, r);
    } else if (l.call(this, r)) {
      r.preventDefault(), r.stopPropagation();
      var f = ye.getComponent("MuteToggle");
      f.prototype.handleClick.call(this, r);
    } else if (h.call(this, r)) {
      r.preventDefault(), r.stopPropagation();
      var p = ye.getComponent("PlayToggle");
      p.prototype.handleClick.call(this, r);
    }
  }, i.canPlayType = function(r) {
    for (var a, s = 0, o = this.options_.techOrder; s < o.length; s++) {
      var u = o[s], l = Wt.getTech(u);
      if (l || (l = ye.getComponent(u)), !l) {
        mt.error(
          'The "' + u + '" tech is undefined. Skipped browser support check for that tech.'
        );
        continue;
      }
      if (l.isSupported() && (a = l.canPlayType(r), a))
        return a;
    }
    return "";
  }, i.selectSource = function(r) {
    var a = this, s = this.options_.techOrder.map(function(h) {
      return [h, Wt.getTech(h)];
    }).filter(function(h) {
      var d = h[0], f = h[1];
      return f ? f.isSupported() : (mt.error(
        'The "' + d + '" tech is undefined. Skipped browser support check for that tech.'
      ), !1);
    }), o = function(d, f, p) {
      var _;
      return d.some(function(m) {
        return f.some(function(x) {
          if (_ = p(m, x), _)
            return !0;
        });
      }), _;
    }, u, l = function(d) {
      return function(f, p) {
        return d(p, f);
      };
    }, c = function(d, f) {
      var p = d[0], _ = d[1];
      if (_.canPlaySource(f, a.options_[p.toLowerCase()]))
        return {
          source: f,
          tech: p
        };
    };
    return this.options_.sourceOrder ? u = o(
      r,
      s,
      l(c)
    ) : u = o(
      s,
      r,
      c
    ), u || !1;
  }, i.handleSrc_ = function(r, a) {
    var s = this;
    if (typeof r > "u")
      return this.cache_.src || "";
    this.resetRetryOnError_ && this.resetRetryOnError_();
    var o = i3(r);
    if (!o.length) {
      this.setTimeout(function() {
        this.error({
          code: 4,
          message: this.options_.notSupportedMessage
        });
      }, 0);
      return;
    }
    if (this.changingSrc_ = !0, a || (this.cache_.sources = o), this.updateSourceCaches_(o[0]), WM(this, o[0], function(c, h) {
      s.middleware_ = h, a || (s.cache_.sources = o), s.updateSourceCaches_(c);
      var d = s.src_(c);
      if (d) {
        if (o.length > 1)
          return s.handleSrc_(o.slice(1));
        s.changingSrc_ = !1, s.setTimeout(function() {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0), s.triggerReady();
        return;
      }
      qM(h, s.tech_);
    }), this.options_.retryOnError && o.length > 1) {
      var u = function() {
        s.error(null), s.handleSrc_(o.slice(1), !0);
      }, l = function() {
        s.off("error", u);
      };
      this.one("error", u), this.one("playing", l), this.resetRetryOnError_ = function() {
        s.off("error", u), s.off("playing", l);
      };
    }
  }, i.src = function(r) {
    return this.handleSrc_(r, !1);
  }, i.src_ = function(r) {
    var a = this, s = this.selectSource([r]);
    return s ? SM(s.tech, this.techName_) ? (this.ready(function() {
      this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", r) : this.techCall_("src", r.src), this.changingSrc_ = !1;
    }, !0), !1) : (this.changingSrc_ = !0, this.loadTech_(s.tech, s.source), this.tech_.ready(function() {
      a.changingSrc_ = !1;
    }), !1) : !0;
  }, i.load = function() {
    this.techCall_("load");
  }, i.reset = function() {
    var r = this, a = this.options_.Promise || W.Promise;
    if (this.paused() || !a)
      this.doReset_();
    else {
      var s = this.play();
      hn(
        s.then(function() {
          return r.doReset_();
        })
      );
    }
  }, i.doReset_ = function() {
    this.tech_ && this.tech_.clearTracks("text"), this.resetCache_(), this.poster(""), this.loadTech_(this.options_.techOrder[0], null), this.techCall_("reset"), this.resetControlBarUI_(), jn(this) && this.trigger("playerreset");
  }, i.resetControlBarUI_ = function() {
    this.resetProgressBar_(), this.resetPlaybackRate_(), this.resetVolumeBar_();
  }, i.resetProgressBar_ = function() {
    this.currentTime(0);
    var r = this.controlBar || {}, a = r.durationDisplay, s = r.remainingTimeDisplay;
    a && a.updateContent(), s && s.updateContent();
  }, i.resetPlaybackRate_ = function() {
    this.playbackRate(this.defaultPlaybackRate()), this.handleTechRateChange_();
  }, i.resetVolumeBar_ = function() {
    this.volume(1), this.trigger("volumechange");
  }, i.currentSources = function() {
    var r = this.currentSource(), a = [];
    return Object.keys(r).length !== 0 && a.push(r), this.cache_.sources || a;
  }, i.currentSource = function() {
    return this.cache_.source || {};
  }, i.currentSrc = function() {
    return this.currentSource() && this.currentSource().src || "";
  }, i.currentType = function() {
    return this.currentSource() && this.currentSource().type || "";
  }, i.preload = function(r) {
    if (r !== void 0) {
      this.techCall_("setPreload", r), this.options_.preload = r;
      return;
    }
    return this.techGet_("preload");
  }, i.autoplay = function(r) {
    if (r === void 0)
      return this.options_.autoplay || !1;
    var a;
    typeof r == "string" && /(any|play|muted)/.test(r) || r === !0 && this.options_.normalizeAutoplay ? (this.options_.autoplay = r, this.manualAutoplay_(typeof r == "string" ? r : "play"), a = !1) : r ? this.options_.autoplay = !0 : this.options_.autoplay = !1, a = typeof a > "u" ? this.options_.autoplay : a, this.tech_ && this.techCall_("setAutoplay", a);
  }, i.playsinline = function(r) {
    return r !== void 0 ? (this.techCall_("setPlaysinline", r), this.options_.playsinline = r, this) : this.techGet_("playsinline");
  }, i.loop = function(r) {
    if (r !== void 0) {
      this.techCall_("setLoop", r), this.options_.loop = r;
      return;
    }
    return this.techGet_("loop");
  }, i.poster = function(r) {
    if (r === void 0)
      return this.poster_;
    r || (r = ""), r !== this.poster_ && (this.poster_ = r, this.techCall_("setPoster", r), this.isPosterFromTech_ = !1, this.trigger("posterchange"));
  }, i.handleTechPosterChange_ = function() {
    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
      var r = this.tech_.poster() || "";
      r !== this.poster_ && (this.poster_ = r, this.isPosterFromTech_ = !0, this.trigger("posterchange"));
    }
  }, i.controls = function(r) {
    if (r === void 0)
      return !!this.controls_;
    r = !!r, this.controls_ !== r && (this.controls_ = r, this.usingNativeControls() && this.techCall_("setControls", r), this.controls_ ? (this.removeClass("vjs-controls-disabled"), this.addClass("vjs-controls-enabled"), this.trigger("controlsenabled"), this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"), this.addClass("vjs-controls-disabled"), this.trigger("controlsdisabled"), this.usingNativeControls() || this.removeTechControlsListeners_()));
  }, i.usingNativeControls = function(r) {
    if (r === void 0)
      return !!this.usingNativeControls_;
    r = !!r, this.usingNativeControls_ !== r && (this.usingNativeControls_ = r, this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"), this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"), this.trigger("usingcustomcontrols")));
  }, i.error = function(r) {
    var a = this;
    if (r === void 0)
      return this.error_ || null;
    if (va("beforeerror").forEach(function(o) {
      var u = o(a, r);
      if (!(qn(u) && !Array.isArray(u) || typeof u == "string" || typeof u == "number" || u === null)) {
        a.log.error(
          "please return a value that MediaError expects in beforeerror hooks"
        );
        return;
      }
      r = u;
    }), this.options_.suppressNotSupportedError && r && r.code === 4) {
      var s = function() {
        this.error(r);
      };
      this.options_.suppressNotSupportedError = !1, this.any(["click", "touchstart"], s), this.one("loadstart", function() {
        this.off(["click", "touchstart"], s);
      });
      return;
    }
    if (r === null) {
      this.error_ = r, this.removeClass("vjs-error"), this.errorDisplay && this.errorDisplay.close();
      return;
    }
    this.error_ = new rr(r), this.addClass("vjs-error"), mt.error(
      "(CODE:" + this.error_.code + " " + rr.errorTypes[this.error_.code] + ")",
      this.error_.message,
      this.error_
    ), this.trigger("error"), va("error").forEach(function(o) {
      return o(a, a.error_);
    });
  }, i.reportUserActivity = function(r) {
    this.userActivity_ = !0;
  }, i.userActive = function(r) {
    if (r === void 0)
      return this.userActive_;
    if (r = !!r, r !== this.userActive_) {
      if (this.userActive_ = r, this.userActive_) {
        this.userActivity_ = !0, this.removeClass("vjs-user-inactive"), this.addClass("vjs-user-active"), this.trigger("useractive");
        return;
      }
      this.tech_ && this.tech_.one("mousemove", function(a) {
        a.stopPropagation(), a.preventDefault();
      }), this.userActivity_ = !1, this.removeClass("vjs-user-active"), this.addClass("vjs-user-inactive"), this.trigger("userinactive");
    }
  }, i.listenForUserActivity_ = function() {
    var r, a, s, o = Zt(this, this.reportUserActivity), u = function(p) {
      (p.screenX !== a || p.screenY !== s) && (a = p.screenX, s = p.screenY, o());
    }, l = function() {
      o(), this.clearInterval(r), r = this.setInterval(o, 250);
    }, c = function(p) {
      o(), this.clearInterval(r);
    };
    this.on("mousedown", l), this.on("mousemove", u), this.on("mouseup", c), this.on("mouseleave", c);
    var h = this.getChild("controlBar");
    h && !cr && !Jn && (h.on("mouseenter", function(f) {
      this.player().options_.inactivityTimeout !== 0 && (this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout), this.player().options_.inactivityTimeout = 0;
    }), h.on("mouseleave", function(f) {
      this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
    })), this.on("keydown", o), this.on("keyup", o);
    var d;
    this.setInterval(function() {
      if (this.userActivity_) {
        this.userActivity_ = !1, this.userActive(!0), this.clearTimeout(d);
        var f = this.options_.inactivityTimeout;
        f <= 0 || (d = this.setTimeout(function() {
          this.userActivity_ || this.userActive(!1);
        }, f));
      }
    }, 250);
  }, i.playbackRate = function(r) {
    if (r !== void 0) {
      this.techCall_("setPlaybackRate", r);
      return;
    }
    return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1;
  }, i.defaultPlaybackRate = function(r) {
    return r !== void 0 ? this.techCall_("setDefaultPlaybackRate", r) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1;
  }, i.isAudio = function(r) {
    if (r !== void 0) {
      this.isAudio_ = !!r;
      return;
    }
    return !!this.isAudio_;
  }, i.enableAudioOnlyUI_ = function() {
    var r = this;
    this.addClass("vjs-audio-only-mode");
    var a = this.children(), s = this.getChild("ControlBar"), o = s && s.currentHeight();
    a.forEach(function(u) {
      u !== s && u.el_ && !u.hasClass("vjs-hidden") && (u.hide(), r.audioOnlyCache_.hiddenChildren.push(u));
    }), this.audioOnlyCache_.playerHeight = this.currentHeight(), this.height(o), this.trigger("audioonlymodechange");
  }, i.disableAudioOnlyUI_ = function() {
    this.removeClass("vjs-audio-only-mode"), this.audioOnlyCache_.hiddenChildren.forEach(function(r) {
      return r.show();
    }), this.height(this.audioOnlyCache_.playerHeight), this.trigger("audioonlymodechange");
  }, i.audioOnlyMode = function(r) {
    var a = this;
    if (typeof r != "boolean" || r === this.audioOnlyMode_)
      return this.audioOnlyMode_;
    this.audioOnlyMode_ = r;
    var s = this.options_.Promise || W.Promise;
    if (s) {
      if (r) {
        var o = [];
        return this.isInPictureInPicture() && o.push(this.exitPictureInPicture()), this.isFullscreen() && o.push(this.exitFullscreen()), this.audioPosterMode() && o.push(this.audioPosterMode(!1)), s.all(o).then(function() {
          return a.enableAudioOnlyUI_();
        });
      }
      return s.resolve().then(function() {
        return a.disableAudioOnlyUI_();
      });
    }
    r ? (this.isInPictureInPicture() && this.exitPictureInPicture(), this.isFullscreen() && this.exitFullscreen(), this.enableAudioOnlyUI_()) : this.disableAudioOnlyUI_();
  }, i.enablePosterModeUI_ = function() {
    var r = this.tech_ && this.tech_;
    r.hide(), this.addClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange");
  }, i.disablePosterModeUI_ = function() {
    var r = this.tech_ && this.tech_;
    r.show(), this.removeClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange");
  }, i.audioPosterMode = function(r) {
    var a = this;
    if (typeof r != "boolean" || r === this.audioPosterMode_)
      return this.audioPosterMode_;
    this.audioPosterMode_ = r;
    var s = this.options_.Promise || W.Promise;
    if (s) {
      if (r) {
        if (this.audioOnlyMode()) {
          var o = this.audioOnlyMode(!1);
          return o.then(function() {
            a.enablePosterModeUI_();
          });
        }
        return s.resolve().then(function() {
          a.enablePosterModeUI_();
        });
      }
      return s.resolve().then(function() {
        a.disablePosterModeUI_();
      });
    }
    if (r) {
      this.audioOnlyMode() && this.audioOnlyMode(!1), this.enablePosterModeUI_();
      return;
    }
    this.disablePosterModeUI_();
  }, i.addTextTrack = function(r, a, s) {
    if (this.tech_)
      return this.tech_.addTextTrack(r, a, s);
  }, i.addRemoteTextTrack = function(r, a) {
    if (this.tech_)
      return this.tech_.addRemoteTextTrack(r, a);
  }, i.removeRemoteTextTrack = function(r) {
    r === void 0 && (r = {});
    var a = r, s = a.track;
    if (s || (s = r), this.tech_)
      return this.tech_.removeRemoteTextTrack(s);
  }, i.getVideoPlaybackQuality = function() {
    return this.techGet_("getVideoPlaybackQuality");
  }, i.videoWidth = function() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  }, i.videoHeight = function() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  }, i.language = function(r) {
    if (r === void 0)
      return this.language_;
    this.language_ !== String(r).toLowerCase() && (this.language_ = String(r).toLowerCase(), jn(this) && this.trigger("languagechange"));
  }, i.languages = function() {
    return Kt(t.prototype.options_.languages, this.languages_);
  }, i.toJSON = function() {
    var r = Kt(this.options_), a = r.tracks;
    r.tracks = [];
    for (var s = 0; s < a.length; s++) {
      var o = a[s];
      o = Kt(o), o.player = void 0, r.tracks[s] = o;
    }
    return r;
  }, i.createModal = function(r, a) {
    var s = this;
    a = a || {}, a.content = r || "";
    var o = new Uo(this, a);
    return this.addChild(o), o.on("dispose", function() {
      s.removeChild(o);
    }), o.open(), o;
  }, i.updateCurrentBreakpoint_ = function() {
    if (this.responsive())
      for (var r = this.currentBreakpoint(), a = this.currentWidth(), s = 0; s < hf.length; s++) {
        var o = hf[s], u = this.breakpoints_[o];
        if (a <= u) {
          if (r === o)
            return;
          r && this.removeClass(nc[r]), this.addClass(nc[o]), this.breakpoint_ = o;
          break;
        }
      }
  }, i.removeCurrentBreakpoint_ = function() {
    var r = this.currentBreakpointClass();
    this.breakpoint_ = "", r && this.removeClass(r);
  }, i.breakpoints = function(r) {
    return r === void 0 ? si(this.breakpoints_) : (this.breakpoint_ = "", this.breakpoints_ = si({}, R3, r), this.updateCurrentBreakpoint_(), si(this.breakpoints_));
  }, i.responsive = function(r) {
    if (r === void 0)
      return this.responsive_;
    r = !!r;
    var a = this.responsive_;
    if (r !== a)
      return this.responsive_ = r, r ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_), this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_), this.removeCurrentBreakpoint_()), r;
  }, i.currentBreakpoint = function() {
    return this.breakpoint_;
  }, i.currentBreakpointClass = function() {
    return nc[this.breakpoint_] || "";
  }, i.loadMedia = function(r, a) {
    var s = this;
    if (!(!r || typeof r != "object")) {
      this.reset(), this.cache_.media = Kt(r);
      var o = this.cache_.media, u = o.artwork, l = o.poster, c = o.src, h = o.textTracks;
      !u && l && (this.cache_.media.artwork = [
        {
          src: l,
          type: Hc(l)
        }
      ]), c && this.src(c), l && this.poster(l), Array.isArray(h) && h.forEach(function(d) {
        return s.addRemoteTextTrack(d, !1);
      }), this.ready(a);
    }
  }, i.getMedia = function() {
    if (!this.cache_.media) {
      var r = this.poster(), a = this.currentSources(), s = Array.prototype.map.call(
        this.remoteTextTracks(),
        function(u) {
          return {
            kind: u.kind,
            label: u.label,
            language: u.language,
            src: u.src
          };
        }
      ), o = {
        src: a,
        textTracks: s
      };
      return r && (o.poster = r, o.artwork = [
        {
          src: o.poster,
          type: Hc(o.poster)
        }
      ]), o;
    }
    return Kt(this.cache_.media);
  }, t.getTagSettings = function(r) {
    var a = {
      sources: [],
      tracks: []
    }, s = Pn(r), o = s["data-setup"];
    if (Ua(r, "vjs-fill") && (s.fill = !0), Ua(r, "vjs-fluid") && (s.fluid = !0), o !== null) {
      var u = kC(o || "{}"), l = u[0], c = u[1];
      l && mt.error(l), si(s, c);
    }
    if (si(a, s), r.hasChildNodes())
      for (var h = r.childNodes, d = 0, f = h.length; d < f; d++) {
        var p = h[d], _ = p.nodeName.toLowerCase();
        _ === "source" ? a.sources.push(Pn(p)) : _ === "track" && a.tracks.push(Pn(p));
      }
    return a;
  }, i.flexNotSupported_ = function() {
    var r = Te.createElement("i");
    return !("flexBasis" in r.style || "webkitFlexBasis" in r.style || "mozFlexBasis" in r.style || "msFlexBasis" in r.style || // IE10-specific (2012 flex spec), available for completeness
    "msFlexOrder" in r.style);
  }, i.debug = function(r) {
    if (r === void 0)
      return this.debugEnabled_;
    r ? (this.trigger("debugon"), this.previousLogLevel_ = this.log.level, this.log.level("debug"), this.debugEnabled_ = !0) : (this.trigger("debugoff"), this.log.level(this.previousLogLevel_), this.previousLogLevel_ = void 0, this.debugEnabled_ = !1);
  }, i.playbackRates = function(r) {
    if (r === void 0)
      return this.cache_.playbackRates;
    Array.isArray(r) && r.every(function(a) {
      return typeof a == "number";
    }) && (this.cache_.playbackRates = r, this.trigger("playbackrateschange"));
  }, t;
}(ye);
Ji.names.forEach(function(e) {
  var t = Ji[e];
  bi.prototype[t.getterName] = function() {
    return this.tech_ ? this.tech_[t.getterName]() : (this[t.privateName] = this[t.privateName] || new t.ListClass(), this[t.privateName]);
  };
});
bi.prototype.crossorigin = bi.prototype.crossOrigin;
bi.players = {};
var $o = W.navigator;
bi.prototype.options_ = {
  // Included control sets
  children: [
    "mediaLoader",
    "posterImage",
    "textTrackDisplay",
    "loadingSpinner",
    "bigPlayButton",
    "liveTracker",
    "controlBar",
    "errorDisplay",
    "textTrackSettings",
    "resizeManager"
  ],
  html5: {},
  // default inactivity timeout
  inactivityTimeout: 2e3,
  language: $o && ($o.languages && $o.languages[0] || $o.userLanguage || $o.language) || "en",
  // locales and their language translations
  languages: {},
  breakpoints: {},
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],
  liveui: !1,
  audioOnlyMode: !1,
  audioPosterMode: !1,
  // Default order of fallback technology
  techOrder: Wt.defaultTechOrder_,
  fullscreen: {
    options: {
      navigationUI: "hide"
    }
  },
  normalizeAutoplay: !1,
  // Default message to show when a video cannot be played.
  notSupportedMessage: "No compatible source was found for this media.",
  // default playback rates
  playbackRates: [],
  responsive: !1
};
[
  /**
   * Returns whether or not the player is in the "ended" state.
   *
   * @return {Boolean} True if the player is in the ended state, false if not.
   * @method Player#ended
   */
  "ended",
  /**
   * Returns whether or not the player is in the "seeking" state.
   *
   * @return {Boolean} True if the player is in the seeking state, false if not.
   * @method Player#seeking
   */
  "seeking",
  /**
   * Returns the TimeRanges of the media that are currently available
   * for seeking to.
   *
   * @return {TimeRanges} the seekable intervals of the media timeline
   * @method Player#seekable
   */
  "seekable",
  /**
   * Returns the current state of network activity for the element, from
   * the codes in the list below.
   * - NETWORK_EMPTY (numeric value 0)
   *   The element has not yet been initialised. All attributes are in
   *   their initial states.
   * - NETWORK_IDLE (numeric value 1)
   *   The element's resource selection algorithm is active and has
   *   selected a resource, but it is not actually using the network at
   *   this time.
   * - NETWORK_LOADING (numeric value 2)
   *   The user agent is actively trying to download data.
   * - NETWORK_NO_SOURCE (numeric value 3)
   *   The element's resource selection algorithm is active, but it has
   *   not yet found a resource to use.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
   * @return {number} the current network activity state
   * @method Player#networkState
   */
  "networkState",
  /**
   * Returns a value that expresses the current state of the element
   * with respect to rendering the current playback position, from the
   * codes in the list below.
   * - HAVE_NOTHING (numeric value 0)
   *   No information regarding the media resource is available.
   * - HAVE_METADATA (numeric value 1)
   *   Enough of the resource has been obtained that the duration of the
   *   resource is available.
   * - HAVE_CURRENT_DATA (numeric value 2)
   *   Data for the immediate current playback position is available.
   * - HAVE_FUTURE_DATA (numeric value 3)
   *   Data for the immediate current playback position is available, as
   *   well as enough data for the user agent to advance the current
   *   playback position in the direction of playback.
   * - HAVE_ENOUGH_DATA (numeric value 4)
   *   The user agent estimates that enough data is available for
   *   playback to proceed uninterrupted.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
   * @return {number} the current playback rendering state
   * @method Player#readyState
   */
  "readyState"
].forEach(function(e) {
  bi.prototype[e] = function() {
    return this.techGet_(e);
  };
});
Pb.forEach(function(e) {
  bi.prototype["handleTech" + vi(e) + "_"] = function() {
    return this.trigger(e);
  };
});
ye.registerComponent("Player", bi);
var qc = "plugin", Fs = "activePlugins_", Rs = {}, Xc = function(t) {
  return Rs.hasOwnProperty(t);
}, ac = function(t) {
  return Xc(t) ? Rs[t] : void 0;
}, Lb = function(t, i) {
  t[Fs] = t[Fs] || {}, t[Fs][i] = !0;
}, Yc = function(t, i, n) {
  var r = (n ? "before" : "") + "pluginsetup";
  t.trigger(r, i), t.trigger(r + ":" + i.name, i);
}, I3 = function(t, i) {
  var n = function() {
    Yc(
      this,
      {
        instance: null,
        name: t,
        plugin: i
      },
      !0
    );
    var a = i.apply(this, arguments);
    return Lb(this, t), Yc(this, {
      instance: a,
      name: t,
      plugin: i
    }), a;
  };
  return Object.keys(i).forEach(function(r) {
    n[r] = i[r];
  }), n;
}, ag = function(t, i) {
  return i.prototype.name = t, function() {
    Yc(
      this,
      {
        instance: null,
        name: t,
        plugin: i
      },
      !0
    );
    for (var n = arguments.length, r = new Array(n), a = 0; a < n; a++)
      r[a] = arguments[a];
    var s = Ay(i, [this].concat(r));
    return this[t] = function() {
      return s;
    }, Yc(this, s.getEventHash()), s;
  };
}, Tn = /* @__PURE__ */ function() {
  function e(i) {
    if (this.constructor === e)
      throw new Error("Plugin must be sub-classed; not directly instantiated.");
    this.player = i, this.log || (this.log = this.player.log.createLogger(this.name)), Op(this), delete this.trigger, $_(this, this.constructor.defaultState), Lb(i, this.name), this.dispose = this.dispose.bind(this), i.on("dispose", this.dispose);
  }
  var t = e.prototype;
  return t.version = function() {
    return this.constructor.VERSION;
  }, t.getEventHash = function(n) {
    return n === void 0 && (n = {}), n.name = this.name, n.plugin = this.constructor, n.instance = this, n;
  }, t.trigger = function(n, r) {
    return r === void 0 && (r = {}), No(this.eventBusEl_, n, this.getEventHash(r));
  }, t.handleStateChanged = function(n) {
  }, t.dispose = function() {
    var n = this.name, r = this.player;
    this.trigger("dispose"), this.off(), r.off("dispose", this.dispose), r[Fs][n] = !1, this.player = this.state = null, r[n] = ag(n, Rs[n]);
  }, e.isBasic = function(n) {
    var r = typeof n == "string" ? ac(n) : n;
    return typeof r == "function" && !e.prototype.isPrototypeOf(r.prototype);
  }, e.registerPlugin = function(n, r) {
    if (typeof n != "string")
      throw new Error(
        'Illegal plugin name, "' + n + '", must be a string, was ' + typeof n + "."
      );
    if (Xc(n))
      mt.warn(
        'A plugin named "' + n + '" already exists. You may want to avoid re-registering plugins!'
      );
    else if (bi.prototype.hasOwnProperty(n))
      throw new Error(
        'Illegal plugin name, "' + n + '", cannot share a name with an existing player method!'
      );
    if (typeof r != "function")
      throw new Error(
        'Illegal plugin for "' + n + '", must be a function, was ' + typeof r + "."
      );
    return Rs[n] = r, n !== qc && (e.isBasic(r) ? bi.prototype[n] = I3(n, r) : bi.prototype[n] = ag(n, r)), r;
  }, e.deregisterPlugin = function(n) {
    if (n === qc)
      throw new Error("Cannot de-register base plugin.");
    Xc(n) && (delete Rs[n], delete bi.prototype[n]);
  }, e.getPlugins = function(n) {
    n === void 0 && (n = Object.keys(Rs));
    var r;
    return n.forEach(function(a) {
      var s = ac(a);
      s && (r = r || {}, r[a] = s);
    }), r;
  }, e.getPluginVersion = function(n) {
    var r = ac(n);
    return r && r.VERSION || "";
  }, e;
}();
Tn.getPlugin = ac;
Tn.BASE_PLUGIN_NAME = qc;
Tn.registerPlugin(qc, Tn);
bi.prototype.usingPlugin = function(e) {
  return !!this[Fs] && this[Fs][e] === !0;
};
bi.prototype.hasPlugin = function(e) {
  return !!Xc(e);
};
var sg = !1, O3 = function(t, i) {
  i === void 0 && (i = {}), sg || (mt.warn(
    "videojs.extend is deprecated as of Video.js 7.22.0 and will be removed in Video.js 8.0.0"
  ), sg = !0);
  var n = function() {
    t.apply(this, arguments);
  }, r = {};
  typeof i == "object" ? (i.constructor !== Object.prototype.constructor && (n = i.constructor), r = i) : typeof i == "function" && (n = i), uw(n, t), t && (n.super_ = t);
  for (var a in r)
    r.hasOwnProperty(a) && (n.prototype[a] = r[a]);
  return n;
}, Rb = function(t) {
  return t.indexOf("#") === 0 ? t.slice(1) : t;
};
function X(e, t, i) {
  var n = X.getPlayer(e);
  if (n)
    return t && mt.warn(
      'Player "' + e + '" is already initialised. Options will not be applied.'
    ), i && n.ready(i), n;
  var r = typeof e == "string" ? ma("#" + Rb(e)) : e;
  if (!Fo(r))
    throw new TypeError("The element or ID supplied is not valid. (videojs)");
  (!r.ownerDocument.defaultView || !r.ownerDocument.body.contains(r)) && mt.warn("The element supplied is not included in the DOM"), t = t || {}, t.restoreEl === !0 && (t.restoreEl = (r.parentNode && r.parentNode.hasAttribute("data-vjs-player") ? r.parentNode : r).cloneNode(!0)), va("beforesetup").forEach(function(s) {
    var o = s(r, Kt(t));
    if (!qn(o) || Array.isArray(o)) {
      mt.error("please return an object in beforesetup hooks");
      return;
    }
    t = Kt(t, o);
  });
  var a = ye.getComponent("Player");
  return n = new a(r, t, i), va("setup").forEach(function(s) {
    return s(n);
  }), n;
}
X.hooks_ = Ln;
X.hooks = va;
X.hook = oM;
X.hookOnce = uM;
X.removeHook = E_;
if (W.VIDEOJS_NO_DYNAMIC_STYLE !== !0 && Bo()) {
  var Ql = ma(".vjs-styles-defaults");
  if (!Ql) {
    Ql = X_("vjs-styles-defaults");
    var bd = ma("head");
    bd && bd.insertBefore(Ql, bd.firstChild), Y_(
      Ql,
      `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: 56.25%
      }
    `
    );
  }
}
af(1, X);
X.VERSION = T_;
X.options = bi.prototype.options_;
X.getPlayers = function() {
  return bi.players;
};
X.getPlayer = function(e) {
  var t = bi.players, i;
  if (typeof e == "string") {
    var n = Rb(e), r = t[n];
    if (r)
      return r;
    i = ma("#" + n);
  } else
    i = e;
  if (Fo(i)) {
    var a = i, s = a.player, o = a.playerId;
    if (s || t[o])
      return s || t[o];
  }
};
X.getAllPlayers = function() {
  return (
    // Disposed players leave a key with a `null` value, so we need to make sure
    // we filter those out.
    Object.keys(bi.players).map(function(e) {
      return bi.players[e];
    }).filter(Boolean)
  );
};
X.players = bi.players;
X.getComponent = ye.getComponent;
X.registerComponent = function(e, t) {
  Wt.isTech(t) && mt.warn(
    "The " + e + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)"
  ), ye.registerComponent.call(ye, e, t);
};
X.getTech = Wt.getTech;
X.registerTech = Wt.registerTech;
X.use = zM;
Object.defineProperty(X, "middleware", {
  enumerable: !0,
  value: {},
  writeable: !1
});
Object.defineProperty(X.middleware, "TERMINATOR", {
  enumerable: !0,
  value: Vc,
  writeable: !1
});
X.browser = pM;
X.TOUCH_ENABLED = Co;
X.extend = O3;
X.mergeOptions = Kt;
X.bind = Zt;
X.registerPlugin = Tn.registerPlugin;
X.deregisterPlugin = Tn.deregisterPlugin;
X.plugin = function(e, t) {
  return mt.warn(
    "videojs.plugin() is deprecated; use videojs.registerPlugin() instead"
  ), Tn.registerPlugin(e, t);
};
X.getPlugins = Tn.getPlugins;
X.getPlugin = Tn.getPlugin;
X.getPluginVersion = Tn.getPluginVersion;
X.addLanguage = function(e, t) {
  var i;
  return e = ("" + e).toLowerCase(), X.options.languages = Kt(
    X.options.languages,
    (i = {}, i[e] = t, i)
  ), X.options.languages[e];
};
X.log = mt;
X.createLogger = S_;
X.createTimeRange = X.createTimeRanges = ja;
X.formatTime = Ro;
X.setFormatTime = l3;
X.resetFormatTime = c3;
X.parseUrl = Bp;
X.isCrossOrigin = kh;
X.EventTarget = Ii;
X.on = Pr;
X.one = Ih;
X.off = Hi;
X.trigger = No;
X.xhr = Iy;
X.TextTrack = Ll;
X.AudioTrack = rb;
X.VideoTrack = nb;
[
  "isEl",
  "isTextNode",
  "createEl",
  "hasClass",
  "addClass",
  "removeClass",
  "toggleClass",
  "setAttributes",
  "getAttributes",
  "emptyEl",
  "appendContent",
  "insertContent"
].forEach(function(e) {
  X[e] = function() {
    return mt.warn(
      "videojs." + e + "() is deprecated; use videojs.dom." + e + "() instead"
    ), W_[e].apply(null, arguments);
  };
});
X.computedStyle = vl;
X.dom = W_;
X.url = jM;
X.defineLazyProperty = tv;
X.addLanguage("en", {
  "Non-Fullscreen": "Exit Fullscreen"
});
/* ! @name @videojs/http-streaming @version 2.16.2 @license Apache-2.0 */
var Vr = bh, Qc = function(t, i, n) {
  return t && n && n.responseURL && i !== n.responseURL ? n.responseURL : i;
}, rn = function(t) {
  return X.log.debug ? X.log.debug.bind(X, "VHS:", t + " >") : function() {
  };
}, ga = 1 / 30, dn = ga * 3, Ib = function(t, i) {
  var n = [], r;
  if (t && t.length)
    for (r = 0; r < t.length; r++)
      i(t.start(r), t.end(r)) && n.push([t.start(r), t.end(r)]);
  return X.createTimeRanges(n);
}, Is = function(t, i) {
  return Ib(t, function(n, r) {
    return n - dn <= i && r + dn >= i;
  });
}, Kl = function(t, i) {
  return Ib(t, function(n) {
    return n - ga >= i;
  });
}, k3 = function(t) {
  if (t.length < 2)
    return X.createTimeRanges();
  for (var i = [], n = 1; n < t.length; n++) {
    var r = t.end(n - 1), a = t.start(n);
    i.push([r, a]);
  }
  return X.createTimeRanges(i);
}, B3 = function(t, i) {
  var n = null, r = null, a = 0, s = [], o = [];
  if (!t || !t.length || !i || !i.length)
    return X.createTimeRange();
  for (var u = t.length; u--; )
    s.push({
      time: t.start(u),
      type: "start"
    }), s.push({
      time: t.end(u),
      type: "end"
    });
  for (u = i.length; u--; )
    s.push({
      time: i.start(u),
      type: "start"
    }), s.push({
      time: i.end(u),
      type: "end"
    });
  for (s.sort(function(l, c) {
    return l.time - c.time;
  }), u = 0; u < s.length; u++)
    s[u].type === "start" ? (a++, a === 2 && (n = s[u].time)) : s[u].type === "end" && (a--, a === 1 && (r = s[u].time)), n !== null && r !== null && (o.push([n, r]), n = null, r = null);
  return X.createTimeRanges(o);
}, Ob = function(t) {
  var i = [];
  if (!t || !t.length)
    return "";
  for (var n = 0; n < t.length; n++)
    i.push(t.start(n) + " => " + t.end(n));
  return i.join(", ");
}, F3 = function(t, i, n) {
  n === void 0 && (n = 1);
  var r = t.length ? t.end(t.length - 1) : 0;
  return (r - i) / n;
}, Oa = function(t) {
  for (var i = [], n = 0; n < t.length; n++)
    i.push({
      end: t.end(n),
      start: t.start(n)
    });
  return i;
}, N3 = function(t, i) {
  if (t === i)
    return !1;
  if (!t && i || !i && t || t.length !== i.length)
    return !0;
  for (var n = 0; n < t.length; n++)
    if (t.start(n) !== i.start(n) || t.end(n) !== i.end(n))
      return !0;
  return !1;
}, og = function(t) {
  if (!(!t || !t.length || !t.end))
    return t.end(t.length - 1);
}, iv = function(t, i) {
  var n = 0;
  if (!t || !t.length)
    return n;
  for (var r = 0; r < t.length; r++) {
    var a = t.start(r), s = t.end(r);
    if (!(i > s)) {
      if (i > a && i <= s) {
        n += s - i;
        continue;
      }
      n += s - a;
    }
  }
  return n;
}, ug = X.createTimeRange, rv = function(t, i) {
  if (!i.preload)
    return i.duration;
  var n = 0;
  return (i.parts || []).forEach(function(r) {
    n += r.duration;
  }), (i.preloadHints || []).forEach(function(r) {
    r.type === "PART" && (n += t.partTargetDuration);
  }), n;
}, df = function(t) {
  return (t.segments || []).reduce(function(i, n, r) {
    return n.parts ? n.parts.forEach(function(a, s) {
      i.push({
        duration: a.duration,
        part: a,
        partIndex: s,
        segment: n,
        segmentIndex: r
      });
    }) : i.push({
      duration: n.duration,
      part: null,
      partIndex: null,
      segment: n,
      segmentIndex: r
    }), i;
  }, []);
}, kb = function(t) {
  var i = t.segments && t.segments.length && t.segments[t.segments.length - 1];
  return i && i.parts || [];
}, Bb = function(t) {
  var i = t.preloadSegment;
  if (i) {
    var n = i.parts, r = i.preloadHints, a = (r || []).reduce(function(s, o) {
      return s + (o.type === "PART" ? 1 : 0);
    }, 0);
    return a += n && n.length ? n.length : 0, a;
  }
}, Fb = function(t, i) {
  if (i.endList)
    return 0;
  if (t && t.suggestedPresentationDelay)
    return t.suggestedPresentationDelay;
  var n = kb(i).length > 0;
  return n && i.serverControl && i.serverControl.partHoldBack ? i.serverControl.partHoldBack : n && i.partTargetDuration ? i.partTargetDuration * 3 : i.serverControl && i.serverControl.holdBack ? i.serverControl.holdBack : i.targetDuration ? i.targetDuration * 3 : 0;
}, U3 = function(t, i) {
  var n = 0, r = i - t.mediaSequence, a = t.segments[r];
  if (a) {
    if (typeof a.start < "u")
      return {
        precise: !0,
        result: a.start
      };
    if (typeof a.end < "u")
      return {
        precise: !0,
        result: a.end - a.duration
      };
  }
  for (; r--; ) {
    if (a = t.segments[r], typeof a.end < "u")
      return {
        precise: !0,
        result: n + a.end
      };
    if (n += rv(t, a), typeof a.start < "u")
      return {
        precise: !0,
        result: n + a.start
      };
  }
  return {
    precise: !1,
    result: n
  };
}, j3 = function(t, i) {
  for (var n = 0, r, a = i - t.mediaSequence; a < t.segments.length; a++) {
    if (r = t.segments[a], typeof r.start < "u")
      return {
        precise: !0,
        result: r.start - n
      };
    if (n += rv(t, r), typeof r.end < "u")
      return {
        precise: !0,
        result: r.end - n
      };
  }
  return {
    precise: !1,
    result: -1
  };
}, Nb = function(t, i, n) {
  if (typeof i > "u" && (i = t.mediaSequence + t.segments.length), i < t.mediaSequence)
    return 0;
  var r = U3(t, i);
  if (r.precise)
    return r.result;
  var a = j3(t, i);
  return a.precise ? a.result : r.result + n;
}, Ub = function(t, i, n) {
  if (!t)
    return 0;
  if (typeof n != "number" && (n = 0), typeof i > "u") {
    if (t.totalDuration)
      return t.totalDuration;
    if (!t.endList)
      return W.Infinity;
  }
  return Nb(t, i, n);
}, fu = function(t) {
  var i = t.defaultDuration, n = t.durationList, r = t.startIndex, a = t.endIndex, s = 0;
  if (r > a) {
    var o = [a, r];
    r = o[0], a = o[1];
  }
  if (r < 0) {
    for (var u = r; u < Math.min(0, a); u++)
      s += i;
    r = 0;
  }
  for (var l = r; l < a; l++)
    s += n[l].duration;
  return s;
}, jb = function(t, i, n, r) {
  if (!t || !t.segments)
    return null;
  if (t.endList)
    return Ub(t);
  if (i === null)
    return null;
  i = i || 0;
  var a = Nb(
    t,
    t.mediaSequence + t.segments.length,
    i
  );
  return n && (r = typeof r == "number" ? r : Fb(null, t), a -= r), Math.max(0, a);
}, G3 = function(t, i, n) {
  var r = !0, a = i || 0, s = jb(
    t,
    i,
    r,
    n
  );
  return s === null ? ug() : ug(a, s);
}, V3 = function(t) {
  for (var i = t.playlist, n = t.currentTime, r = t.startingSegmentIndex, a = t.startingPartIndex, s = t.startTime, o = t.experimentalExactManifestTimings, u = n - s, l = df(i), c = 0, h = 0; h < l.length; h++) {
    var d = l[h];
    if (r === d.segmentIndex && !(typeof a == "number" && typeof d.partIndex == "number" && a !== d.partIndex)) {
      c = h;
      break;
    }
  }
  if (u < 0) {
    if (c > 0)
      for (var f = c - 1; f >= 0; f--) {
        var p = l[f];
        if (u += p.duration, o) {
          if (u < 0)
            continue;
        } else if (u + ga <= 0)
          continue;
        return {
          partIndex: p.partIndex,
          segmentIndex: p.segmentIndex,
          startTime: s - fu({
            defaultDuration: i.targetDuration,
            durationList: l,
            endIndex: f,
            startIndex: c
          })
        };
      }
    return {
      partIndex: l[0] && l[0].partIndex || null,
      segmentIndex: l[0] && l[0].segmentIndex || 0,
      startTime: n
    };
  }
  if (c < 0) {
    for (var _ = c; _ < 0; _++)
      if (u -= i.targetDuration, u < 0)
        return {
          partIndex: l[0] && l[0].partIndex || null,
          segmentIndex: l[0] && l[0].segmentIndex || 0,
          startTime: n
        };
    c = 0;
  }
  for (var m = c; m < l.length; m++) {
    var x = l[m];
    if (u -= x.duration, o) {
      if (u > 0)
        continue;
    } else if (u - ga >= 0)
      continue;
    return {
      partIndex: x.partIndex,
      segmentIndex: x.segmentIndex,
      startTime: s + fu({
        defaultDuration: i.targetDuration,
        durationList: l,
        endIndex: m,
        startIndex: c
      })
    };
  }
  return {
    partIndex: l[l.length - 1].partIndex,
    segmentIndex: l[l.length - 1].segmentIndex,
    startTime: n
  };
}, Gb = function(t) {
  return t.excludeUntil && t.excludeUntil > Date.now();
}, nv = function(t) {
  return t.excludeUntil && t.excludeUntil === 1 / 0;
}, Uh = function(t) {
  var i = Gb(t);
  return !t.disabled && !i;
}, H3 = function(t) {
  return t.disabled;
}, z3 = function(t) {
  for (var i = 0; i < t.segments.length; i++)
    if (t.segments[i].key)
      return !0;
  return !1;
}, Vb = function(t, i) {
  return i.attributes && i.attributes[t];
}, W3 = function(t, i, n, r) {
  if (r === void 0 && (r = 0), !Vb("BANDWIDTH", n))
    return NaN;
  var a = t * n.attributes.BANDWIDTH;
  return (a - r * 8) / i;
}, ff = function(t, i) {
  if (t.playlists.length === 1)
    return !0;
  var n = i.attributes.BANDWIDTH || Number.MAX_VALUE;
  return t.playlists.filter(function(r) {
    return Uh(r) ? (r.attributes.BANDWIDTH || 0) < n : !1;
  }).length === 0;
}, av = function(t, i) {
  return !t && !i || !t && i || t && !i ? !1 : !!(t === i || t.id && i.id && t.id === i.id || t.resolvedUri && i.resolvedUri && t.resolvedUri === i.resolvedUri || t.uri && i.uri && t.uri === i.uri);
}, lg = function(t, i) {
  var n = t && t.mediaGroups && t.mediaGroups.AUDIO || {}, r = !1;
  for (var a in n) {
    for (var s in n[a])
      if (r = i(n[a][s]), r)
        break;
    if (r)
      break;
  }
  return !!r;
}, Ol = function(t) {
  if (!t || !t.playlists || !t.playlists.length) {
    var i = lg(t, function(s) {
      return s.playlists && s.playlists.length || s.uri;
    });
    return i;
  }
  for (var n = function(o) {
    var u = t.playlists[o], l = u.attributes && u.attributes.CODECS;
    if (l && l.split(",").every(function(h) {
      return Sy(h);
    }))
      return "continue";
    var c = lg(t, function(h) {
      return av(u, h);
    });
    return c ? "continue" : {
      v: !1
    };
  }, r = 0; r < t.playlists.length; r++) {
    var a = n(r);
    if (a !== "continue" && typeof a == "object")
      return a.v;
  }
  return !0;
}, lr = {
  duration: Ub,
  estimateSegmentRequestTime: W3,
  getMediaInfoForTime: V3,
  hasAttribute: Vb,
  isAes: z3,
  isAudioOnly: Ol,
  isBlacklisted: Gb,
  isDisabled: H3,
  isEnabled: Uh,
  isIncompatible: nv,
  liveEdgeDelay: Fb,
  isLowestEnabledRendition: ff,
  seekable: G3,
  playlistEnd: jb,
  playlistMatch: av,
  segmentDurationWithParts: rv
}, Hb = X.log, sv = function(t, i) {
  return t + "-" + i;
}, q3 = function(t, i, n) {
  return "placeholder-uri-" + t + "-" + i + "-" + n;
}, X3 = function(t) {
  var i = t.onwarn, n = t.oninfo, r = t.manifestString, a = t.customTagParsers, s = a === void 0 ? [] : a, o = t.customTagMappers, u = o === void 0 ? [] : o, l = t.experimentalLLHLS, c = new oS();
  i && c.on("warn", i), n && c.on("info", n), s.forEach(function(_) {
    return c.addParser(_);
  }), u.forEach(function(_) {
    return c.addTagMapper(_);
  }), c.push(r), c.end();
  var h = c.manifest;
  if (l || ([
    "preloadSegment",
    "skip",
    "serverControl",
    "renditionReports",
    "partInf",
    "partTargetDuration"
  ].forEach(function(_) {
    h.hasOwnProperty(_) && delete h[_];
  }), h.segments && h.segments.forEach(function(_) {
    ["parts", "preloadHints"].forEach(function(m) {
      _.hasOwnProperty(m) && delete _[m];
    });
  })), !h.targetDuration) {
    var d = 10;
    h.segments && h.segments.length && (d = h.segments.reduce(function(_, m) {
      return Math.max(_, m.duration);
    }, 0)), i && i("manifest has no targetDuration defaulting to " + d), h.targetDuration = d;
  }
  var f = kb(h);
  if (f.length && !h.partTargetDuration) {
    var p = f.reduce(function(_, m) {
      return Math.max(_, m.duration);
    }, 0);
    i && (i(
      "manifest has no partTargetDuration defaulting to " + p
    ), Hb.error(
      "LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed."
    )), h.partTargetDuration = p;
  }
  return h;
}, Ho = function(t, i) {
  t.mediaGroups && ["AUDIO", "SUBTITLES"].forEach(function(n) {
    if (t.mediaGroups[n])
      for (var r in t.mediaGroups[n])
        for (var a in t.mediaGroups[n][r]) {
          var s = t.mediaGroups[n][r][a];
          i(s, n, r, a);
        }
  });
}, zb = function(t) {
  var i = t.playlist, n = t.uri, r = t.id;
  i.id = r, i.playlistErrors_ = 0, n && (i.uri = n), i.attributes = i.attributes || {};
}, Y3 = function(t) {
  for (var i = t.playlists.length; i--; ) {
    var n = t.playlists[i];
    zb({
      id: sv(i, n.uri),
      playlist: n
    }), n.resolvedUri = Vr(t.uri, n.uri), t.playlists[n.id] = n, t.playlists[n.uri] = n, n.attributes.BANDWIDTH || Hb.warn(
      "Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute."
    );
  }
}, Q3 = function(t) {
  Ho(t, function(i) {
    i.uri && (i.resolvedUri = Vr(t.uri, i.uri));
  });
}, K3 = function(t, i) {
  var n = sv(0, i), r = {
    mediaGroups: {
      AUDIO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {},
      VIDEO: {}
    },
    playlists: [
      {
        // m3u8-parser does not attach an attributes property to media playlists so make
        // sure that the property is attached to avoid undefined reference errors
        attributes: {},
        id: n,
        resolvedUri: i,
        uri: i
      }
    ],
    resolvedUri: W.location.href,
    uri: W.location.href
  };
  return r.playlists[n] = r.playlists[0], r.playlists[i] = r.playlists[0], r;
}, Wb = function(t, i, n) {
  n === void 0 && (n = q3), t.uri = i;
  for (var r = 0; r < t.playlists.length; r++)
    if (!t.playlists[r].uri) {
      var a = "placeholder-uri-" + r;
      t.playlists[r].uri = a;
    }
  var s = Ol(t);
  Ho(
    t,
    function(o, u, l, c) {
      if (!o.playlists || !o.playlists.length) {
        if (s && u === "AUDIO" && !o.uri)
          for (var h = 0; h < t.playlists.length; h++) {
            var d = t.playlists[h];
            if (d.attributes && d.attributes.AUDIO && d.attributes.AUDIO === l)
              return;
          }
        o.playlists = [kr({}, o)];
      }
      o.playlists.forEach(function(f, p) {
        var _ = n(u, l, c, f), m = sv(p, _);
        f.uri ? f.resolvedUri = f.resolvedUri || Vr(t.uri, f.uri) : (f.uri = p === 0 ? _ : m, f.resolvedUri = f.uri), f.id = f.id || m, f.attributes = f.attributes || {}, t.playlists[f.id] = f, t.playlists[f.uri] = f;
      });
    }
  ), Y3(t), Q3(t);
}, Kc = X.mergeOptions, Z3 = X.EventTarget, J3 = function(t, i) {
  if (i.endList || !i.serverControl)
    return t;
  var n = {};
  if (i.serverControl.canBlockReload) {
    var r = i.preloadSegment, a = i.mediaSequence + i.segments.length;
    if (r) {
      var s = r.parts || [], o = Bb(i) - 1;
      o > -1 && o !== s.length - 1 && (n._HLS_part = o), (o > -1 || s.length) && a--;
    }
    n._HLS_msn = a;
  }
  if (i.serverControl && i.serverControl.canSkipUntil && (n._HLS_skip = i.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(n).length) {
    var u = new W.URL(t);
    ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(l) {
      n.hasOwnProperty(l) && u.searchParams.set(l, n[l]);
    }), t = u.toString();
  }
  return t;
}, $3 = function(t, i) {
  if (!t)
    return i;
  var n = Kc(t, i);
  if (t.preloadHints && !i.preloadHints && delete n.preloadHints, t.parts && !i.parts)
    delete n.parts;
  else if (t.parts && i.parts)
    for (var r = 0; r < i.parts.length; r++)
      t.parts && t.parts[r] && (n.parts[r] = Kc(t.parts[r], i.parts[r]));
  return !t.skipped && i.skipped && (n.skipped = !1), t.preload && !i.preload && (n.preload = !1), n;
}, eD = function(t, i, n) {
  var r = t.slice(), a = i.slice();
  n = n || 0;
  for (var s = [], o, u = 0; u < a.length; u++) {
    var l = r[u + n], c = a[u];
    l ? (o = l.map || o, s.push($3(l, c))) : (o && !c.map && (c.map = o), s.push(c));
  }
  return s;
}, qb = function(t, i) {
  !t.resolvedUri && t.uri && (t.resolvedUri = Vr(i, t.uri)), t.key && !t.key.resolvedUri && (t.key.resolvedUri = Vr(i, t.key.uri)), t.map && !t.map.resolvedUri && (t.map.resolvedUri = Vr(i, t.map.uri)), t.map && t.map.key && !t.map.key.resolvedUri && (t.map.key.resolvedUri = Vr(i, t.map.key.uri)), t.parts && t.parts.length && t.parts.forEach(function(n) {
    n.resolvedUri || (n.resolvedUri = Vr(i, n.uri));
  }), t.preloadHints && t.preloadHints.length && t.preloadHints.forEach(function(n) {
    n.resolvedUri || (n.resolvedUri = Vr(i, n.uri));
  });
}, Xb = function(t) {
  var i = t.segments || [], n = t.preloadSegment;
  if (n && n.parts && n.parts.length) {
    if (n.preloadHints) {
      for (var r = 0; r < n.preloadHints.length; r++)
        if (n.preloadHints[r].type === "MAP")
          return i;
    }
    n.duration = t.targetDuration, n.preload = !0, i.push(n);
  }
  return i;
}, Yb = function(t, i) {
  return t === i || t.segments && i.segments && t.segments.length === i.segments.length && t.endList === i.endList && t.mediaSequence === i.mediaSequence && t.preloadSegment === i.preloadSegment;
}, pf = function(t, i, n) {
  n === void 0 && (n = Yb);
  var r = Kc(t, {}), a = r.playlists[i.id];
  if (!a || n(a, i))
    return null;
  i.segments = Xb(i);
  var s = Kc(a, i);
  if (s.preloadSegment && !i.preloadSegment && delete s.preloadSegment, a.segments) {
    if (i.skip) {
      i.segments = i.segments || [];
      for (var o = 0; o < i.skip.skippedSegments; o++)
        i.segments.unshift({
          skipped: !0
        });
    }
    s.segments = eD(
      a.segments,
      i.segments,
      i.mediaSequence - a.mediaSequence
    );
  }
  s.segments.forEach(function(l) {
    qb(l, s.resolvedUri);
  });
  for (var u = 0; u < r.playlists.length; u++)
    r.playlists[u].id === i.id && (r.playlists[u] = s);
  return r.playlists[i.id] = s, r.playlists[i.uri] = s, Ho(
    t,
    function(l, c, h, d) {
      if (l.playlists)
        for (var f = 0; f < l.playlists.length; f++)
          i.id === l.playlists[f].id && (l.playlists[f] = s);
    }
  ), r;
}, vf = function(t, i) {
  var n = t.segments || [], r = n[n.length - 1], a = r && r.parts && r.parts[r.parts.length - 1], s = a && a.duration || r && r.duration;
  return i && s ? s * 1e3 : (t.partTargetDuration || t.targetDuration || 10) * 500;
}, Os = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a) {
    var s;
    if (a === void 0 && (a = {}), s = e.call(this) || this, !n)
      throw new Error("A non-empty playlist URL or object is required");
    s.logger_ = rn("PlaylistLoader");
    var o = a, u = o.withCredentials, l = u === void 0 ? !1 : u, c = o.handleManifestRedirects, h = c === void 0 ? !1 : c;
    s.src = n, s.vhs_ = r, s.withCredentials = l, s.handleManifestRedirects = h;
    var d = r.options_;
    return s.customTagParsers = d && d.customTagParsers || [], s.customTagMappers = d && d.customTagMappers || [], s.experimentalLLHLS = d && d.experimentalLLHLS || !1, X.browser.IE_VERSION && (s.experimentalLLHLS = !1), s.state = "HAVE_NOTHING", s.handleMediaupdatetimeout_ = s.handleMediaupdatetimeout_.bind(
      He(s)
    ), s.on("mediaupdatetimeout", s.handleMediaupdatetimeout_), s;
  }
  var i = t.prototype;
  return i.handleMediaupdatetimeout_ = function() {
    var r = this;
    if (this.state === "HAVE_METADATA") {
      var a = this.media(), s = Vr(this.master.uri, a.uri);
      this.experimentalLLHLS && (s = J3(s, a)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr(
        {
          uri: s,
          withCredentials: this.withCredentials
        },
        function(o, u) {
          if (r.request) {
            if (o)
              return r.playlistRequestError(
                r.request,
                r.media(),
                "HAVE_METADATA"
              );
            r.haveMetadata({
              id: r.media().id,
              playlistString: r.request.responseText,
              url: r.media().uri
            });
          }
        }
      );
    }
  }, i.playlistRequestError = function(r, a, s) {
    var o = a.uri, u = a.id;
    this.request = null, s && (this.state = s), this.error = {
      code: r.status >= 500 ? 4 : 2,
      message: "HLS playlist request error at URL: " + o + ".",
      playlist: this.master.playlists[u],
      responseText: r.responseText,
      status: r.status
    }, this.trigger("error");
  }, i.parseManifest_ = function(r) {
    var a = this, s = r.url, o = r.manifestString;
    return X3({
      customTagMappers: this.customTagMappers,
      customTagParsers: this.customTagParsers,
      experimentalLLHLS: this.experimentalLLHLS,
      manifestString: o,
      oninfo: function(l) {
        var c = l.message;
        return a.logger_("m3u8-parser info for " + s + ": " + c);
      },
      onwarn: function(l) {
        var c = l.message;
        return a.logger_("m3u8-parser warn for " + s + ": " + c);
      }
    });
  }, i.haveMetadata = function(r) {
    var a = r.playlistString, s = r.playlistObject, o = r.url, u = r.id;
    this.request = null, this.state = "HAVE_METADATA";
    var l = s || this.parseManifest_({
      manifestString: a,
      url: o
    });
    l.lastRequest = Date.now(), zb({
      id: u,
      playlist: l,
      uri: o
    });
    var c = pf(this.master, l);
    this.targetDuration = l.partTargetDuration || l.targetDuration, this.pendingMedia_ = null, c ? (this.master = c, this.media_ = this.master.playlists[u]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(vf(this.media(), !!c)), this.trigger("loadedplaylist");
  }, i.dispose = function() {
    this.trigger("dispose"), this.stopRequest(), W.clearTimeout(this.mediaUpdateTimeout), W.clearTimeout(this.finalRenditionTimeout), this.off();
  }, i.stopRequest = function() {
    if (this.request) {
      var r = this.request;
      this.request = null, r.onreadystatechange = null, r.abort();
    }
  }, i.media = function(r, a) {
    var s = this;
    if (!r)
      return this.media_;
    if (this.state === "HAVE_NOTHING")
      throw new Error("Cannot switch media playlist from " + this.state);
    if (typeof r == "string") {
      if (!this.master.playlists[r])
        throw new Error("Unknown playlist URI: " + r);
      r = this.master.playlists[r];
    }
    if (W.clearTimeout(this.finalRenditionTimeout), a) {
      var o = (r.partTargetDuration || r.targetDuration) / 2 * 1e3 || 5e3;
      this.finalRenditionTimeout = W.setTimeout(
        this.media.bind(this, r, !1),
        o
      );
      return;
    }
    var u = this.state, l = !this.media_ || r.id !== this.media_.id, c = this.master.playlists[r.id];
    if (c && c.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved
    // media playlist or, for the case of demuxed audio, a resolved audio media group)
    r.endList && r.segments.length) {
      this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = r, l && (this.trigger("mediachanging"), u === "HAVE_MASTER" ? this.trigger("loadedmetadata") : this.trigger("mediachange"));
      return;
    }
    if (this.updateMediaUpdateTimeout_(vf(r, !0)), !!l) {
      if (this.state = "SWITCHING_MEDIA", this.request) {
        if (r.resolvedUri === this.request.url)
          return;
        this.request.onreadystatechange = null, this.request.abort(), this.request = null;
      }
      this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = r, this.request = this.vhs_.xhr(
        {
          uri: r.resolvedUri,
          withCredentials: this.withCredentials
        },
        function(h, d) {
          if (s.request) {
            if (r.lastRequest = Date.now(), r.resolvedUri = Qc(
              s.handleManifestRedirects,
              r.resolvedUri,
              d
            ), h)
              return s.playlistRequestError(
                s.request,
                r,
                u
              );
            s.haveMetadata({
              id: r.id,
              playlistString: d.responseText,
              url: r.uri
            }), u === "HAVE_MASTER" ? s.trigger("loadedmetadata") : s.trigger("mediachange");
          }
        }
      );
    }
  }, i.pause = function() {
    this.mediaUpdateTimeout && (W.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), this.state === "HAVE_NOTHING" && (this.started = !1), this.state === "SWITCHING_MEDIA" ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MASTER" : this.state === "HAVE_CURRENT_METADATA" && (this.state = "HAVE_METADATA");
  }, i.load = function(r) {
    var a = this;
    this.mediaUpdateTimeout && (W.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null);
    var s = this.media();
    if (r) {
      var o = s ? (s.partTargetDuration || s.targetDuration) / 2 * 1e3 : 5e3;
      this.mediaUpdateTimeout = W.setTimeout(function() {
        a.mediaUpdateTimeout = null, a.load();
      }, o);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    s && !s.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist");
  }, i.updateMediaUpdateTimeout_ = function(r) {
    var a = this;
    this.mediaUpdateTimeout && (W.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), !(!this.media() || this.media().endList) && (this.mediaUpdateTimeout = W.setTimeout(function() {
      a.mediaUpdateTimeout = null, a.trigger("mediaupdatetimeout"), a.updateMediaUpdateTimeout_(r);
    }, r));
  }, i.start = function() {
    var r = this;
    if (this.started = !0, typeof this.src == "object") {
      this.src.uri || (this.src.uri = W.location.href), this.src.resolvedUri = this.src.uri, setTimeout(function() {
        r.setupInitialPlaylist(r.src);
      }, 0);
      return;
    }
    this.request = this.vhs_.xhr(
      {
        uri: this.src,
        withCredentials: this.withCredentials
      },
      function(a, s) {
        if (r.request) {
          if (r.request = null, a)
            return r.error = {
              // MEDIA_ERR_NETWORK
              code: 2,
              message: "HLS playlist request error at URL: " + r.src + ".",
              responseText: s.responseText,
              status: s.status
            }, r.state === "HAVE_NOTHING" && (r.started = !1), r.trigger("error");
          r.src = Qc(
            r.handleManifestRedirects,
            r.src,
            s
          );
          var o = r.parseManifest_({
            manifestString: s.responseText,
            url: r.src
          });
          r.setupInitialPlaylist(o);
        }
      }
    );
  }, i.srcUri = function() {
    return typeof this.src == "string" ? this.src : this.src.uri;
  }, i.setupInitialPlaylist = function(r) {
    if (this.state = "HAVE_MASTER", r.playlists) {
      this.master = r, Wb(this.master, this.srcUri()), r.playlists.forEach(function(s) {
        s.segments = Xb(s), s.segments.forEach(function(o) {
          qb(o, s.resolvedUri);
        });
      }), this.trigger("loadedplaylist"), this.request || this.media(this.master.playlists[0]);
      return;
    }
    var a = this.srcUri() || W.location.href;
    this.master = K3(r, a), this.haveMetadata({
      id: this.master.playlists[0].id,
      playlistObject: r,
      url: a
    }), this.trigger("loadedmetadata");
  }, t;
}(Z3), tD = X.xhr, iD = X.mergeOptions, mf = function(t, i, n, r) {
  var a = t.responseType === "arraybuffer" ? t.response : t.responseText;
  !i && a && (t.responseTime = Date.now(), t.roundTripTime = t.responseTime - t.requestTime, t.bytesReceived = a.byteLength || a.length, t.bandwidth || (t.bandwidth = Math.floor(
    t.bytesReceived / t.roundTripTime * 8 * 1e3
  ))), n.headers && (t.responseHeaders = n.headers), i && i.code === "ETIMEDOUT" && (t.timedout = !0), !i && !t.aborted && n.statusCode !== 200 && n.statusCode !== 206 && n.statusCode !== 0 && (i = new Error(
    "XHR Failed with a response of: " + (t && (a || t.responseText))
  )), r(i, t);
}, Qb = function() {
  var t = function i(n, r) {
    n = iD(
      {
        timeout: 45e3
      },
      n
    );
    var a = i.beforeRequest || X.Vhs.xhr.beforeRequest;
    if (a && typeof a == "function") {
      var s = a(n);
      s && (n = s);
    }
    var o = X.Vhs.xhr.original === !0 ? tD : X.Vhs.xhr, u = o(n, function(c, h) {
      return mf(u, c, h, r);
    }), l = u.abort;
    return u.abort = function() {
      return u.aborted = !0, l.apply(u, arguments);
    }, u.uri = n.uri, u.requestTime = Date.now(), u;
  };
  return t.original = !0, t;
}, rD = function(t) {
  var i, n = t.offset;
  return typeof t.offset == "bigint" || typeof t.length == "bigint" ? i = W.BigInt(t.offset) + W.BigInt(t.length) - W.BigInt(1) : i = t.offset + t.length - 1, "bytes=" + n + "-" + i;
}, gf = function(t) {
  var i = {};
  return t.byterange && (i.Range = rD(t.byterange)), i;
}, nD = function(t, i) {
  return t.start(i) + "-" + t.end(i);
}, aD = function(t, i) {
  var n = t.toString(16);
  return "00".substring(0, 2 - n.length) + n + (i % 2 ? " " : "");
}, sD = function(t) {
  return t >= 32 && t < 126 ? String.fromCharCode(t) : ".";
}, Kb = function(t) {
  var i = {};
  return Object.keys(t).forEach(function(n) {
    var r = t[n];
    Ty(r) ? i[n] = {
      byteLength: r.byteLength,
      byteOffset: r.byteOffset,
      bytes: r.buffer
    } : i[n] = r;
  }), i;
}, Zc = function(t) {
  var i = t.byterange || {
    length: 1 / 0,
    offset: 0
  };
  return [i.length, i.offset, t.resolvedUri].join(
    ","
  );
}, Zb = function(t) {
  return t.resolvedUri;
}, Jb = function(t) {
  for (var i = Array.prototype.slice.call(t), n = 16, r = "", a, s, o = 0; o < i.length / n; o++)
    a = i.slice(o * n, o * n + n).map(aD).join(""), s = i.slice(o * n, o * n + n).map(sD).join(""), r += a + " " + s + `
`;
  return r;
}, oD = function(t) {
  var i = t.bytes;
  return Jb(i);
}, uD = function(t) {
  var i = "", n;
  for (n = 0; n < t.length; n++)
    i += nD(t, n) + " ";
  return i;
}, lD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTransferableMessage: Kb,
  hexDump: Jb,
  initSegmentId: Zc,
  segmentKeyId: Zb,
  tagDump: oD,
  textRanges: uD
}), $b = 0.25, cD = function(t, i) {
  if (!i.dateTimeObject)
    return null;
  var n = i.videoTimingInfo.transmuxerPrependedSeconds, r = i.videoTimingInfo.transmuxedPresentationStart, a = r + n, s = t - a;
  return new Date(
    i.dateTimeObject.getTime() + s * 1e3
  );
}, hD = function(t) {
  return t.transmuxedPresentationEnd - t.transmuxedPresentationStart - t.transmuxerPrependedSeconds;
}, dD = function(t, i) {
  var n;
  try {
    n = new Date(t);
  } catch {
    return null;
  }
  if (!i || !i.segments || i.segments.length === 0)
    return null;
  var r = i.segments[0];
  if (n < r.dateTimeObject)
    return null;
  for (var a = 0; a < i.segments.length - 1; a++) {
    r = i.segments[a];
    var s = i.segments[a + 1].dateTimeObject;
    if (n < s)
      break;
  }
  var o = i.segments[i.segments.length - 1], u = o.dateTimeObject, l = o.videoTimingInfo ? hD(o.videoTimingInfo) : o.duration + o.duration * $b, c = new Date(
    u.getTime() + l * 1e3
  );
  return n > c ? null : (n > u && (r = o), {
    estimatedStart: r.videoTimingInfo ? r.videoTimingInfo.transmuxedPresentationStart : lr.duration(
      i,
      i.mediaSequence + i.segments.indexOf(r)
    ),
    segment: r,
    // Although, given that all segments have accurate date time objects, the segment
    // selected should be accurate, unless the video has been transmuxed at some point
    // (determined by the presence of the videoTimingInfo object), the segment's "player
    // time" (the start time in the player) can't be considered accurate.
    type: r.videoTimingInfo ? "accurate" : "estimate"
  });
}, fD = function(t, i) {
  if (!i || !i.segments || i.segments.length === 0)
    return null;
  for (var n = 0, r, a = 0; a < i.segments.length && (r = i.segments[a], n = r.videoTimingInfo ? r.videoTimingInfo.transmuxedPresentationEnd : n + r.duration, !(t <= n)); a++)
    ;
  var s = i.segments[i.segments.length - 1];
  if (s.videoTimingInfo && s.videoTimingInfo.transmuxedPresentationEnd < t)
    return null;
  if (t > n) {
    if (t > n + s.duration * $b)
      return null;
    r = s;
  }
  return {
    estimatedStart: r.videoTimingInfo ? r.videoTimingInfo.transmuxedPresentationStart : n - r.duration,
    segment: r,
    // Because videoTimingInfo is only set after transmux, it is the only way to get
    // accurate timing values.
    type: r.videoTimingInfo ? "accurate" : "estimate"
  };
}, pD = function(t, i) {
  var n, r;
  try {
    n = new Date(t), r = new Date(i);
  } catch {
  }
  var a = n.getTime(), s = r.getTime();
  return (s - a) / 1e3;
}, vD = function(t) {
  if (!t.segments || t.segments.length === 0)
    return !1;
  for (var i = 0; i < t.segments.length; i++) {
    var n = t.segments[i];
    if (!n.dateTimeObject)
      return !1;
  }
  return !0;
}, mD = function(t) {
  var i = t.playlist, n = t.time, r = n === void 0 ? void 0 : n, a = t.callback;
  if (!a)
    throw new Error("getProgramTime: callback must be provided");
  if (!i || r === void 0)
    return a({
      message: "getProgramTime: playlist and time must be provided"
    });
  var s = fD(r, i);
  if (!s)
    return a({
      message: "valid programTime was not found"
    });
  if (s.type === "estimate")
    return a({
      message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
      seekTime: s.estimatedStart
    });
  var o = {
    mediaSeconds: r
  }, u = cD(r, s.segment);
  return u && (o.programDateTime = u.toISOString()), a(null, o);
}, gD = function e(t) {
  var i = t.programTime, n = t.playlist, r = t.retryCount, a = r === void 0 ? 2 : r, s = t.seekTo, o = t.pauseAfterSeek, u = o === void 0 ? !0 : o, l = t.tech, c = t.callback;
  if (!c)
    throw new Error("seekToProgramTime: callback must be provided");
  if (typeof i > "u" || !n || !s)
    return c({
      message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
    });
  if (!n.endList && !l.hasStarted_)
    return c({
      message: "player must be playing a live stream to start buffering"
    });
  if (!vD(n))
    return c({
      message: "programDateTime tags must be provided in the manifest " + n.resolvedUri
    });
  var h = dD(i, n);
  if (!h)
    return c({
      message: i + " was not found in the stream"
    });
  var d = h.segment, f = pD(d.dateTimeObject, i);
  if (h.type === "estimate") {
    if (a === 0)
      return c({
        message: i + " is not buffered yet. Try again"
      });
    s(h.estimatedStart + f), l.one("seeked", function() {
      e({
        callback: c,
        pauseAfterSeek: u,
        playlist: n,
        programTime: i,
        retryCount: a - 1,
        seekTo: s,
        tech: l
      });
    });
    return;
  }
  var p = d.start + f, _ = function() {
    return c(null, l.currentTime());
  };
  l.one("seeked", _), u && l.pause(), s(p);
}, xd = function(t, i) {
  if (t.readyState === 4)
    return i();
}, yD = function(t, i, n) {
  var r = [], a, s = !1, o = function(d, f, p, _) {
    return f.abort(), s = !0, n(d, f, p, _);
  }, u = function(d, f) {
    if (!s) {
      if (d)
        return o(d, f, "", r);
      var p = f.responseText.substring(
        r && r.byteLength || 0,
        f.responseText.length
      );
      if (r = vw(r, Ey(p, !0)), a = a || nu(r), r.length < 10 || a && r.length < a + 2)
        return xd(f, function() {
          return o(d, f, "", r);
        });
      var _ = rp(r);
      return _ === "ts" && r.length < 188 ? xd(f, function() {
        return o(d, f, "", r);
      }) : !_ && r.length < 376 ? xd(f, function() {
        return o(d, f, "", r);
      }) : o(null, f, _, r);
    }
  }, l = {
    beforeSend: function(d) {
      d.overrideMimeType("text/plain; charset=x-user-defined"), d.addEventListener("progress", function(f) {
        return f.total, f.loaded, mf(
          d,
          null,
          {
            statusCode: d.status
          },
          u
        );
      });
    },
    uri: t
  }, c = i(l, function(h, d) {
    return mf(c, h, d, u);
  });
  return c;
}, _D = X.EventTarget, e1 = X.mergeOptions, cg = function(t, i) {
  if (!Yb(t, i) || t.sidx && i.sidx && (t.sidx.offset !== i.sidx.offset || t.sidx.length !== i.sidx.length))
    return !1;
  if (!t.sidx && i.sidx || t.sidx && !i.sidx || t.segments && !i.segments || !t.segments && i.segments)
    return !1;
  if (!t.segments && !i.segments)
    return !0;
  for (var n = 0; n < t.segments.length; n++) {
    var r = t.segments[n], a = i.segments[n];
    if (r.uri !== a.uri)
      return !1;
    if (!(!r.byterange && !a.byterange)) {
      var s = r.byterange, o = a.byterange;
      if (s && !o || !s && o || s.offset !== o.offset || s.length !== o.length)
        return !1;
    }
  }
  return !0;
}, bD = function(t, i, n, r) {
  var a = r.attributes.NAME || n;
  return "placeholder-uri-" + t + "-" + i + "-" + a;
}, xD = function(t) {
  var i = t.masterXml, n = t.srcUrl, r = t.clientOffset, a = t.sidxMapping, s = t.previousManifest, o = SC(i, {
    clientOffset: r,
    manifestUri: n,
    previousManifest: s,
    sidxMapping: a
  });
  return Wb(o, n, bD), o;
}, AD = function(t, i) {
  Ho(t, function(n, r, a, s) {
    s in i.mediaGroups[r][a] || delete t.mediaGroups[r][a][s];
  });
}, TD = function(t, i, n) {
  for (var r = !0, a = e1(t, {
    // These are top level properties that can be updated
    duration: i.duration,
    minimumUpdatePeriod: i.minimumUpdatePeriod,
    timelineStarts: i.timelineStarts
  }), s = 0; s < i.playlists.length; s++) {
    var o = i.playlists[s];
    if (o.sidx) {
      var u = wh(o.sidx);
      n && n[u] && n[u].sidx && gp(
        o,
        n[u].sidx,
        o.sidx.resolvedUri
      );
    }
    var l = pf(
      a,
      o,
      cg
    );
    l && (a = l, r = !1);
  }
  return Ho(i, function(c, h, d, f) {
    if (c.playlists && c.playlists.length) {
      var p = c.playlists[0].id, _ = pf(
        a,
        c.playlists[0],
        cg
      );
      _ && (a = _, f in a.mediaGroups[h][d] || (a.mediaGroups[h][d][f] = c), a.mediaGroups[h][d][f].playlists[0] = a.playlists[p], r = !1);
    }
  }), AD(a, i), i.minimumUpdatePeriod !== t.minimumUpdatePeriod && (r = !1), r ? null : a;
}, ED = function(t, i) {
  var n = !t.map && !i.map, r = n || !!(t.map && i.map && t.map.byterange.offset === i.map.byterange.offset && t.map.byterange.length === i.map.byterange.length);
  return r && t.uri === i.uri && t.byterange.offset === i.byterange.offset && t.byterange.length === i.byterange.length;
}, hg = function(t, i) {
  var n = {};
  for (var r in t) {
    var a = t[r], s = a.sidx;
    if (s) {
      var o = wh(s);
      if (!i[o])
        break;
      var u = i[o].sidxInfo;
      ED(u, s) && (n[o] = i[o]);
    }
  }
  return n;
}, wD = function(t, i) {
  var n = hg(t.playlists, i), r = n;
  return Ho(
    t,
    function(a, s, o, u) {
      if (a.playlists && a.playlists.length) {
        var l = a.playlists;
        r = e1(
          r,
          hg(l, i)
        );
      }
    }
  ), r;
}, yf = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a, s) {
    var o;
    a === void 0 && (a = {}), o = e.call(this) || this, o.masterPlaylistLoader_ = s || He(o), s || (o.isMaster_ = !0);
    var u = a, l = u.withCredentials, c = l === void 0 ? !1 : l, h = u.handleManifestRedirects, d = h === void 0 ? !1 : h;
    if (o.vhs_ = r, o.withCredentials = c, o.handleManifestRedirects = d, !n)
      throw new Error("A non-empty playlist URL or object is required");
    return o.on("minimumUpdatePeriod", function() {
      o.refreshXml_();
    }), o.on("mediaupdatetimeout", function() {
      o.refreshMedia_(o.media().id);
    }), o.state = "HAVE_NOTHING", o.loadedPlaylists_ = {}, o.logger_ = rn("DashPlaylistLoader"), o.isMaster_ ? (o.masterPlaylistLoader_.srcUrl = n, o.masterPlaylistLoader_.sidxMapping_ = {}) : o.childPlaylist_ = n, o;
  }
  var i = t.prototype;
  return i.requestErrored_ = function(r, a, s) {
    if (!this.request)
      return !0;
    if (this.request = null, r)
      return this.error = typeof r == "object" && !(r instanceof Error) ? r : {
        // MEDIA_ERR_NETWORK
        code: 2,
        message: "DASH request error at URL: " + a.uri,
        response: a.response,
        status: a.status
      }, s && (this.state = s), this.trigger("error"), !0;
  }, i.addSidxSegments_ = function(r, a, s) {
    var o = this, u = r.sidx && wh(r.sidx);
    if (!r.sidx || !u || this.masterPlaylistLoader_.sidxMapping_[u]) {
      this.mediaRequest_ = W.setTimeout(function() {
        return s(!1);
      }, 0);
      return;
    }
    var l = Qc(
      this.handleManifestRedirects,
      r.sidx.resolvedUri
    ), c = function(d, f) {
      if (!o.requestErrored_(d, f, a)) {
        var p = o.masterPlaylistLoader_.sidxMapping_, _;
        try {
          _ = RC(Ze(f.response).subarray(8));
        } catch (m) {
          o.requestErrored_(m, f, a);
          return;
        }
        return p[u] = {
          sidx: _,
          sidxInfo: r.sidx
        }, gp(r, _, r.sidx.resolvedUri), s(!0);
      }
    };
    this.request = yD(
      l,
      this.vhs_.xhr,
      function(h, d, f, p) {
        if (h)
          return c(h, d);
        if (!f || f !== "mp4")
          return c(
            {
              blacklistDuration: 1 / 0,
              // MEDIA_ERR_NETWORK
              code: 2,
              internal: !0,
              message: "Unsupported " + (f || "unknown") + " container type for sidx segment at URL: " + l,
              playlist: r,
              // response is just bytes in this case
              // but we really don't want to return that.
              response: "",
              status: d.status
            },
            d
          );
        var _ = r.sidx.byterange, m = _.offset, x = _.length;
        if (p.length >= x + m)
          return c(h, {
            response: p.subarray(m, m + x),
            status: d.status,
            uri: d.uri
          });
        o.request = o.vhs_.xhr(
          {
            headers: gf({
              byterange: r.sidx.byterange
            }),
            responseType: "arraybuffer",
            uri: l
          },
          c
        );
      }
    );
  }, i.dispose = function() {
    this.trigger("dispose"), this.stopRequest(), this.loadedPlaylists_ = {}, W.clearTimeout(this.minimumUpdatePeriodTimeout_), W.clearTimeout(this.mediaRequest_), W.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.mediaRequest_ = null, this.minimumUpdatePeriodTimeout_ = null, this.masterPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_), this.masterPlaylistLoader_.createMupOnMedia_ = null), this.off();
  }, i.hasPendingRequest = function() {
    return this.request || this.mediaRequest_;
  }, i.stopRequest = function() {
    if (this.request) {
      var r = this.request;
      this.request = null, r.onreadystatechange = null, r.abort();
    }
  }, i.media = function(r) {
    var a = this;
    if (!r)
      return this.media_;
    if (this.state === "HAVE_NOTHING")
      throw new Error("Cannot switch media playlist from " + this.state);
    var s = this.state;
    if (typeof r == "string") {
      if (!this.masterPlaylistLoader_.master.playlists[r])
        throw new Error("Unknown playlist URI: " + r);
      r = this.masterPlaylistLoader_.master.playlists[r];
    }
    var o = !this.media_ || r.id !== this.media_.id;
    if (o && this.loadedPlaylists_[r.id] && this.loadedPlaylists_[r.id].endList) {
      this.state = "HAVE_METADATA", this.media_ = r, o && (this.trigger("mediachanging"), this.trigger("mediachange"));
      return;
    }
    o && (this.media_ && this.trigger("mediachanging"), this.addSidxSegments_(r, s, function(u) {
      a.haveMetadata({
        playlist: r,
        startingState: s
      });
    }));
  }, i.haveMetadata = function(r) {
    var a = r.startingState, s = r.playlist;
    this.state = "HAVE_METADATA", this.loadedPlaylists_[s.id] = s, this.mediaRequest_ = null, this.refreshMedia_(s.id), a === "HAVE_MASTER" ? this.trigger("loadedmetadata") : this.trigger("mediachange");
  }, i.pause = function() {
    this.masterPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_), this.masterPlaylistLoader_.createMupOnMedia_ = null), this.stopRequest(), W.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.isMaster_ && (W.clearTimeout(
      this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_
    ), this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null), this.state === "HAVE_NOTHING" && (this.started = !1);
  }, i.load = function(r) {
    var a = this;
    W.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null;
    var s = this.media();
    if (r) {
      var o = s ? s.targetDuration / 2 * 1e3 : 5e3;
      this.mediaUpdateTimeout = W.setTimeout(function() {
        return a.load();
      }, o);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    s && !s.endList ? (this.isMaster_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"), this.updateMinimumUpdatePeriodTimeout_()), this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist");
  }, i.start = function() {
    var r = this;
    if (this.started = !0, !this.isMaster_) {
      this.mediaRequest_ = W.setTimeout(function() {
        return r.haveMaster_();
      }, 0);
      return;
    }
    this.requestMaster_(function(a, s) {
      r.haveMaster_(), !r.hasPendingRequest() && !r.media_ && r.media(r.masterPlaylistLoader_.master.playlists[0]);
    });
  }, i.requestMaster_ = function(r) {
    var a = this;
    this.request = this.vhs_.xhr(
      {
        uri: this.masterPlaylistLoader_.srcUrl,
        withCredentials: this.withCredentials
      },
      function(s, o) {
        if (a.requestErrored_(s, o)) {
          a.state === "HAVE_NOTHING" && (a.started = !1);
          return;
        }
        var u = o.responseText !== a.masterPlaylistLoader_.masterXml_;
        if (a.masterPlaylistLoader_.masterXml_ = o.responseText, o.responseHeaders && o.responseHeaders.date ? a.masterLoaded_ = Date.parse(o.responseHeaders.date) : a.masterLoaded_ = Date.now(), a.masterPlaylistLoader_.srcUrl = Qc(
          a.handleManifestRedirects,
          a.masterPlaylistLoader_.srcUrl,
          o
        ), u) {
          a.handleMaster_(), a.syncClientServerClock_(function() {
            return r(o, u);
          });
          return;
        }
        return r(o, u);
      }
    );
  }, i.syncClientServerClock_ = function(r) {
    var a = this, s = CC(this.masterPlaylistLoader_.masterXml_);
    if (s === null)
      return this.masterPlaylistLoader_.clientOffset_ = this.masterLoaded_ - Date.now(), r();
    if (s.method === "DIRECT")
      return this.masterPlaylistLoader_.clientOffset_ = s.value - Date.now(), r();
    this.request = this.vhs_.xhr(
      {
        method: s.method,
        uri: Vr(this.masterPlaylistLoader_.srcUrl, s.value),
        withCredentials: this.withCredentials
      },
      function(o, u) {
        if (a.request) {
          if (o)
            return a.masterPlaylistLoader_.clientOffset_ = a.masterLoaded_ - Date.now(), r();
          var l;
          s.method === "HEAD" ? !u.responseHeaders || !u.responseHeaders.date ? l = a.masterLoaded_ : l = Date.parse(u.responseHeaders.date) : l = Date.parse(u.responseText), a.masterPlaylistLoader_.clientOffset_ = l - Date.now(), r();
        }
      }
    );
  }, i.haveMaster_ = function() {
    this.state = "HAVE_MASTER", this.isMaster_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_);
  }, i.handleMaster_ = function() {
    this.mediaRequest_ = null;
    var r = this.masterPlaylistLoader_.master, a = xD({
      clientOffset: this.masterPlaylistLoader_.clientOffset_,
      masterXml: this.masterPlaylistLoader_.masterXml_,
      previousManifest: r,
      sidxMapping: this.masterPlaylistLoader_.sidxMapping_,
      srcUrl: this.masterPlaylistLoader_.srcUrl
    });
    r && (a = TD(
      r,
      a,
      this.masterPlaylistLoader_.sidxMapping_
    )), this.masterPlaylistLoader_.master = a || r;
    var s = this.masterPlaylistLoader_.master.locations && this.masterPlaylistLoader_.master.locations[0];
    return s && s !== this.masterPlaylistLoader_.srcUrl && (this.masterPlaylistLoader_.srcUrl = s), (!r || a && a.minimumUpdatePeriod !== r.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(), !!a;
  }, i.updateMinimumUpdatePeriodTimeout_ = function() {
    var r = this.masterPlaylistLoader_;
    r.createMupOnMedia_ && (r.off("loadedmetadata", r.createMupOnMedia_), r.createMupOnMedia_ = null), r.minimumUpdatePeriodTimeout_ && (W.clearTimeout(r.minimumUpdatePeriodTimeout_), r.minimumUpdatePeriodTimeout_ = null);
    var a = r.master && r.master.minimumUpdatePeriod;
    if (a === 0 && (r.media() ? a = r.media().targetDuration * 1e3 : (r.createMupOnMedia_ = r.updateMinimumUpdatePeriodTimeout_, r.one("loadedmetadata", r.createMupOnMedia_))), typeof a != "number" || a <= 0) {
      a < 0 && this.logger_(
        "found invalid minimumUpdatePeriod of " + a + ", not setting a timeout"
      );
      return;
    }
    this.createMUPTimeout_(a);
  }, i.createMUPTimeout_ = function(r) {
    var a = this.masterPlaylistLoader_;
    a.minimumUpdatePeriodTimeout_ = W.setTimeout(function() {
      a.minimumUpdatePeriodTimeout_ = null, a.trigger("minimumUpdatePeriod"), a.createMUPTimeout_(r);
    }, r);
  }, i.refreshXml_ = function() {
    var r = this;
    this.requestMaster_(function(a, s) {
      s && (r.media_ && (r.media_ = r.masterPlaylistLoader_.master.playlists[r.media_.id]), r.masterPlaylistLoader_.sidxMapping_ = wD(
        r.masterPlaylistLoader_.master,
        r.masterPlaylistLoader_.sidxMapping_
      ), r.addSidxSegments_(
        r.media(),
        r.state,
        function(o) {
          r.refreshMedia_(r.media().id);
        }
      ));
    });
  }, i.refreshMedia_ = function(r) {
    var a = this;
    if (!r)
      throw new Error("refreshMedia_ must take a media id");
    this.media_ && this.isMaster_ && this.handleMaster_();
    var s = this.masterPlaylistLoader_.master.playlists, o = !this.media_ || this.media_ !== s[r];
    if (o ? this.media_ = s[r] : this.trigger("playlistunchanged"), !this.mediaUpdateTimeout) {
      var u = function l() {
        a.media().endList || (a.mediaUpdateTimeout = W.setTimeout(
          function() {
            a.trigger("mediaupdatetimeout"), l();
          },
          vf(a.media(), !!o)
        ));
      };
      u();
    }
    this.trigger("loadedplaylist");
  }, t;
}(_D), Pi = {
  BACK_BUFFER_LENGTH: 30,
  // A fudge factor to apply to advertised playlist bitrates to account for
  // temporary flucations in client bandwidth
  BANDWIDTH_VARIANCE: 1.2,
  // If the buffer is greater than the high water line, we won't switch down
  BUFFER_HIGH_WATER_LINE: 30,
  // How much of the buffer must be filled before we consider upswitching
  BUFFER_LOW_WATER_LINE: 0,
  BUFFER_LOW_WATER_LINE_RATE: 1,
  // TODO: Remove this when experimentalBufferBasedABR is removed
  EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
  GOAL_BUFFER_LENGTH: 30,
  GOAL_BUFFER_LENGTH_RATE: 1,
  // 0.5 MB/s
  INITIAL_BANDWIDTH: 4194304,
  MAX_BUFFER_LOW_WATER_LINE: 30,
  MAX_GOAL_BUFFER_LENGTH: 60
}, SD = function(t) {
  for (var i = new Uint8Array(new ArrayBuffer(t.length)), n = 0; n < t.length; n++)
    i[n] = t.charCodeAt(n);
  return i.buffer;
}, t1 = function(t) {
  return t.on = t.addEventListener, t.off = t.removeEventListener, t;
}, CD = function(t) {
  try {
    return URL.createObjectURL(
      new Blob([t], {
        type: "application/javascript"
      })
    );
  } catch {
    var i = new BlobBuilder();
    return i.append(t), URL.createObjectURL(i.getBlob());
  }
}, i1 = function(t) {
  return function() {
    var i = CD(t), n = t1(new Worker(i));
    n.objURL = i;
    var r = n.terminate;
    return n.on = n.addEventListener, n.off = n.removeEventListener, n.terminate = function() {
      return URL.revokeObjectURL(i), r.call(this);
    }, n;
  };
}, r1 = function(t) {
  return "var browserWorkerPolyFill = " + t1.toString() + `;
browserWorkerPolyFill(self);
` + t;
}, n1 = function(t) {
  return t.toString().replace(/^function.+?{/, "").slice(0, -1);
}, MD = r1(
  n1(function() {
    var e = function() {
      this.init = function() {
        var v = {};
        this.on = function(y, g) {
          v[y] || (v[y] = []), v[y] = v[y].concat(g);
        }, this.off = function(y, g) {
          var b;
          return v[y] ? (b = v[y].indexOf(g), v[y] = v[y].slice(), v[y].splice(b, 1), b > -1) : !1;
        }, this.trigger = function(y) {
          var g, b, w, S;
          if (g = v[y], !!g)
            if (arguments.length === 2)
              for (w = g.length, b = 0; b < w; ++b)
                g[b].call(this, arguments[1]);
            else {
              for (S = [], b = arguments.length, b = 1; b < arguments.length; ++b)
                S.push(arguments[b]);
              for (w = g.length, b = 0; b < w; ++b)
                g[b].apply(this, S);
            }
        }, this.dispose = function() {
          v = {};
        };
      };
    };
    e.prototype.pipe = function(P) {
      return this.on("data", function(v) {
        P.push(v);
      }), this.on("done", function(v) {
        P.flush(v);
      }), this.on("partialdone", function(v) {
        P.partialFlush(v);
      }), this.on("endedtimeline", function(v) {
        P.endTimeline(v);
      }), this.on("reset", function(v) {
        P.reset(v);
      }), P;
    }, e.prototype.push = function(P) {
      this.trigger("data", P);
    }, e.prototype.flush = function(P) {
      this.trigger("done", P);
    }, e.prototype.partialFlush = function(P) {
      this.trigger("partialdone", P);
    }, e.prototype.endTimeline = function(P) {
      this.trigger("endedtimeline", P);
    }, e.prototype.reset = function(P) {
      this.trigger("reset", P);
    };
    var t = e, i = Math.pow(2, 32), n = function(v) {
      var y = new DataView(v.buffer, v.byteOffset, v.byteLength), g;
      return y.getBigUint64 ? (g = y.getBigUint64(0), g < Number.MAX_SAFE_INTEGER ? Number(g) : g) : y.getUint32(0) * i + y.getUint32(4);
    }, r = {
      MAX_UINT32: i,
      getUint64: n
    }, a = r.MAX_UINT32, s, o, u, l, c, h, d, f, p, _, m, x, E, M, C, R, k, F, B, I, V, Q, ee, oe, fe, he, de, G, j, se, ie, Ce, K, xe, pe, Re;
    (function() {
      var P;
      if (ee = {
        avc1: [],
        // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        // codingname
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        smhd: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        styp: [],
        tfdt: [],
        tfhd: [],
        tkhd: [],
        traf: [],
        trak: [],
        trex: [],
        trun: [],
        vmhd: []
      }, !(typeof Uint8Array > "u")) {
        for (P in ee)
          ee.hasOwnProperty(P) && (ee[P] = [
            P.charCodeAt(0),
            P.charCodeAt(1),
            P.charCodeAt(2),
            P.charCodeAt(3)
          ]);
        oe = new Uint8Array([
          105,
          115,
          111,
          109
        ]), he = new Uint8Array([
          97,
          118,
          99,
          49
        ]), fe = new Uint8Array([0, 0, 0, 1]), de = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          // pre_defined
          118,
          105,
          100,
          101,
          // handler_type: 'vide'
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          86,
          105,
          100,
          101,
          111,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
          // name: 'VideoHandler'
        ]), G = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          // pre_defined
          115,
          111,
          117,
          110,
          // handler_type: 'soun'
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          83,
          111,
          117,
          110,
          100,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
          // name: 'SoundHandler'
        ]), j = {
          audio: G,
          video: de
        }, Ce = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          1,
          // entry_count
          0,
          0,
          0,
          12,
          // entry_size
          117,
          114,
          108,
          32,
          // 'url' type
          0,
          // version 0
          0,
          0,
          1
          // entry_flags
        ]), ie = new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          0,
          0,
          // balance, 0 means centered
          0,
          0
          // reserved
        ]), K = new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0
          // entry_count
        ]), xe = K, pe = new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          // sample_size
          0,
          0,
          0,
          0
          // sample_count
        ]), Re = K, se = new Uint8Array([
          0,
          // version
          0,
          0,
          1,
          // flags
          0,
          0,
          // graphicsmode
          0,
          0,
          0,
          0,
          0,
          0
          // opcolor
        ]);
      }
    })(), s = function(v) {
      var y = [], g = 0, b, w, S;
      for (b = 1; b < arguments.length; b++)
        y.push(arguments[b]);
      for (b = y.length; b--; )
        g += y[b].byteLength;
      for (w = new Uint8Array(g + 8), S = new DataView(w.buffer, w.byteOffset, w.byteLength), S.setUint32(0, w.byteLength), w.set(v, 4), b = 0, g = 8; b < y.length; b++)
        w.set(y[b], g), g += y[b].byteLength;
      return w;
    }, o = function() {
      return s(ee.dinf, s(ee.dref, Ce));
    }, u = function(v) {
      return s(
        ee.esds,
        new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          // ES_Descriptor
          3,
          // tag, ES_DescrTag
          25,
          // length
          0,
          0,
          // ES_ID
          0,
          // streamDependenceFlag, URL_flag, reserved, streamPriority
          // DecoderConfigDescriptor
          4,
          // tag, DecoderConfigDescrTag
          17,
          // length
          64,
          // object type
          21,
          // streamType
          0,
          6,
          0,
          // bufferSizeDB
          0,
          0,
          218,
          192,
          // maxBitrate
          0,
          0,
          218,
          192,
          // avgBitrate
          // DecoderSpecificInfo
          5,
          // tag, DecoderSpecificInfoTag
          2,
          // length
          // ISO/IEC 14496-3, AudioSpecificConfig
          // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
          v.audioobjecttype << 3 | v.samplingfrequencyindex >>> 1,
          v.samplingfrequencyindex << 7 | v.channelcount << 3,
          6,
          1,
          2
          // GASpecificConfig
        ])
      );
    }, l = function() {
      return s(
        ee.ftyp,
        oe,
        fe,
        oe,
        he
      );
    }, R = function(v) {
      return s(ee.hdlr, j[v]);
    }, c = function(v) {
      return s(ee.mdat, v);
    }, C = function(v) {
      var y = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        2,
        // creation_time
        0,
        0,
        0,
        3,
        // modification_time
        0,
        1,
        95,
        144,
        // timescale, 90,000 "ticks" per second
        v.duration >>> 24 & 255,
        v.duration >>> 16 & 255,
        v.duration >>> 8 & 255,
        v.duration & 255,
        // duration
        85,
        196,
        // 'und' language (undetermined)
        0,
        0
      ]);
      return v.samplerate && (y[12] = v.samplerate >>> 24 & 255, y[13] = v.samplerate >>> 16 & 255, y[14] = v.samplerate >>> 8 & 255, y[15] = v.samplerate & 255), s(ee.mdhd, y);
    }, M = function(v) {
      return s(ee.mdia, C(v), R(v.type), d(v));
    }, h = function(v) {
      return s(
        ee.mfhd,
        new Uint8Array([
          0,
          0,
          0,
          0,
          // flags
          (v & 4278190080) >> 24,
          (v & 16711680) >> 16,
          (v & 65280) >> 8,
          v & 255
          // sequence_number
        ])
      );
    }, d = function(v) {
      return s(
        ee.minf,
        v.type === "video" ? s(ee.vmhd, se) : s(ee.smhd, ie),
        o(),
        F(v)
      );
    }, f = function(v, y) {
      for (var g = [], b = y.length; b--; )
        g[b] = I(y[b]);
      return s.apply(
        null,
        [ee.moof, h(v)].concat(g)
      );
    }, p = function(v) {
      for (var y = v.length, g = []; y--; )
        g[y] = x(v[y]);
      return s.apply(
        null,
        [ee.moov, m(4294967295)].concat(g).concat(_(v))
      );
    }, _ = function(v) {
      for (var y = v.length, g = []; y--; )
        g[y] = V(v[y]);
      return s.apply(null, [ee.mvex].concat(g));
    }, m = function(v) {
      var y = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1,
        // creation_time
        0,
        0,
        0,
        2,
        // modification_time
        0,
        1,
        95,
        144,
        // timescale, 90,000 "ticks" per second
        (v & 4278190080) >> 24,
        (v & 16711680) >> 16,
        (v & 65280) >> 8,
        v & 255,
        // duration
        0,
        1,
        0,
        0,
        // 1.0 rate
        1,
        0,
        // 1.0 volume
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        // transformation: unity matrix
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        255,
        255,
        255,
        255
        // next_track_ID
      ]);
      return s(ee.mvhd, y);
    }, k = function(v) {
      var y = v.samples || [], g = new Uint8Array(4 + y.length), b, w;
      for (w = 0; w < y.length; w++)
        b = y[w].flags, g[w + 4] = b.dependsOn << 4 | b.isDependedOn << 2 | b.hasRedundancy;
      return s(ee.sdtp, g);
    }, F = function(v) {
      return s(
        ee.stbl,
        B(v),
        s(ee.stts, Re),
        s(ee.stsc, xe),
        s(ee.stsz, pe),
        s(ee.stco, K)
      );
    }, function() {
      var P, v;
      B = function(g) {
        return s(
          ee.stsd,
          new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            1
          ]),
          g.type === "video" ? P(g) : v(g)
        );
      }, P = function(g) {
        var b = g.sps || [], w = g.pps || [], S = [], N = [], q, Z;
        for (q = 0; q < b.length; q++)
          S.push((b[q].byteLength & 65280) >>> 8), S.push(b[q].byteLength & 255), S = S.concat(
            Array.prototype.slice.call(b[q])
          );
        for (q = 0; q < w.length; q++)
          N.push((w[q].byteLength & 65280) >>> 8), N.push(w[q].byteLength & 255), N = N.concat(
            Array.prototype.slice.call(w[q])
          );
        if (Z = [
          ee.avc1,
          new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            // data_reference_index
            0,
            0,
            // pre_defined
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // pre_defined
            (g.width & 65280) >> 8,
            g.width & 255,
            // width
            (g.height & 65280) >> 8,
            g.height & 255,
            // height
            0,
            72,
            0,
            0,
            // horizresolution
            0,
            72,
            0,
            0,
            // vertresolution
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            // frame_count
            19,
            118,
            105,
            100,
            101,
            111,
            106,
            115,
            45,
            99,
            111,
            110,
            116,
            114,
            105,
            98,
            45,
            104,
            108,
            115,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // compressorname
            0,
            24,
            // depth = 24
            17,
            17
            // pre_defined = -1
          ]),
          s(
            ee.avcC,
            new Uint8Array(
              [
                1,
                // configurationVersion
                g.profileIdc,
                // AVCProfileIndication
                g.profileCompatibility,
                // profile_compatibility
                g.levelIdc,
                // AVCLevelIndication
                255
                // lengthSizeMinusOne, hard-coded to 4 bytes
              ].concat(
                [b.length],
                // numOfSequenceParameterSets
                S,
                // "SPS"
                [w.length],
                // numOfPictureParameterSets
                N
                // "PPS"
              )
            )
          ),
          s(
            ee.btrt,
            new Uint8Array([
              0,
              28,
              156,
              128,
              // bufferSizeDB
              0,
              45,
              198,
              192,
              // maxBitrate
              0,
              45,
              198,
              192
              // avgBitrate
            ])
          )
        ], g.sarRatio) {
          var Y = g.sarRatio[0], te = g.sarRatio[1];
          Z.push(
            s(
              ee.pasp,
              new Uint8Array([
                (Y & 4278190080) >> 24,
                (Y & 16711680) >> 16,
                (Y & 65280) >> 8,
                Y & 255,
                (te & 4278190080) >> 24,
                (te & 16711680) >> 16,
                (te & 65280) >> 8,
                te & 255
              ])
            )
          );
        }
        return s.apply(null, Z);
      }, v = function(g) {
        return s(
          ee.mp4a,
          new Uint8Array([
            // SampleEntry, ISO/IEC 14496-12
            0,
            0,
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            // data_reference_index
            // AudioSampleEntry, ISO/IEC 14496-12
            0,
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            // reserved
            (g.channelcount & 65280) >> 8,
            g.channelcount & 255,
            // channelcount
            (g.samplesize & 65280) >> 8,
            g.samplesize & 255,
            // samplesize
            0,
            0,
            // pre_defined
            0,
            0,
            // reserved
            (g.samplerate & 65280) >> 8,
            g.samplerate & 255,
            0,
            0
            // samplerate, 16.16
            // MP4AudioSampleEntry, ISO/IEC 14496-14
          ]),
          u(g)
        );
      };
    }(), E = function(v) {
      var y = new Uint8Array([
        0,
        // version 0
        0,
        0,
        7,
        // flags
        0,
        0,
        0,
        0,
        // creation_time
        0,
        0,
        0,
        0,
        // modification_time
        (v.id & 4278190080) >> 24,
        (v.id & 16711680) >> 16,
        (v.id & 65280) >> 8,
        v.id & 255,
        // track_ID
        0,
        0,
        0,
        0,
        // reserved
        (v.duration & 4278190080) >> 24,
        (v.duration & 16711680) >> 16,
        (v.duration & 65280) >> 8,
        v.duration & 255,
        // duration
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        // layer
        0,
        0,
        // alternate_group
        1,
        0,
        // non-audio track volume
        0,
        0,
        // reserved
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        // transformation: unity matrix
        (v.width & 65280) >> 8,
        v.width & 255,
        0,
        0,
        // width
        (v.height & 65280) >> 8,
        v.height & 255,
        0,
        0
        // height
      ]);
      return s(ee.tkhd, y);
    }, I = function(v) {
      var y, g, b, w, S, N, q;
      return y = s(
        ee.tfhd,
        new Uint8Array([
          0,
          // version 0
          0,
          0,
          58,
          // flags
          (v.id & 4278190080) >> 24,
          (v.id & 16711680) >> 16,
          (v.id & 65280) >> 8,
          v.id & 255,
          // track_ID
          0,
          0,
          0,
          1,
          // sample_description_index
          0,
          0,
          0,
          0,
          // default_sample_duration
          0,
          0,
          0,
          0,
          // default_sample_size
          0,
          0,
          0,
          0
          // default_sample_flags
        ])
      ), N = Math.floor(
        v.baseMediaDecodeTime / a
      ), q = Math.floor(
        v.baseMediaDecodeTime % a
      ), g = s(
        ee.tfdt,
        new Uint8Array([
          1,
          // version 1
          0,
          0,
          0,
          // flags
          // baseMediaDecodeTime
          N >>> 24 & 255,
          N >>> 16 & 255,
          N >>> 8 & 255,
          N & 255,
          q >>> 24 & 255,
          q >>> 16 & 255,
          q >>> 8 & 255,
          q & 255
        ])
      ), S = 92, v.type === "audio" ? (b = Q(v, S), s(
        ee.traf,
        y,
        g,
        b
      )) : (w = k(v), b = Q(
        v,
        w.length + S
      ), s(
        ee.traf,
        y,
        g,
        b,
        w
      ));
    }, x = function(v) {
      return v.duration = v.duration || 4294967295, s(ee.trak, E(v), M(v));
    }, V = function(v) {
      var y = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        (v.id & 4278190080) >> 24,
        (v.id & 16711680) >> 16,
        (v.id & 65280) >> 8,
        v.id & 255,
        // track_ID
        0,
        0,
        0,
        1,
        // default_sample_description_index
        0,
        0,
        0,
        0,
        // default_sample_duration
        0,
        0,
        0,
        0,
        // default_sample_size
        0,
        1,
        0,
        1
        // default_sample_flags
      ]);
      return v.type !== "video" && (y[y.length - 1] = 0), s(ee.trex, y);
    }, function() {
      var P, v, y;
      y = function(b, w) {
        var S = 0, N = 0, q = 0, Z = 0;
        return b.length && (b[0].duration !== void 0 && (S = 1), b[0].size !== void 0 && (N = 2), b[0].flags !== void 0 && (q = 4), b[0].compositionTimeOffset !== void 0 && (Z = 8)), [
          0,
          // version 0
          0,
          S | N | q | Z,
          1,
          // flags
          (b.length & 4278190080) >>> 24,
          (b.length & 16711680) >>> 16,
          (b.length & 65280) >>> 8,
          b.length & 255,
          // sample_count
          (w & 4278190080) >>> 24,
          (w & 16711680) >>> 16,
          (w & 65280) >>> 8,
          w & 255
          // data_offset
        ];
      }, v = function(b, w) {
        var S, N, q, Z, Y, te;
        for (Z = b.samples || [], w += 20 + 16 * Z.length, q = y(Z, w), N = new Uint8Array(q.length + Z.length * 16), N.set(q), S = q.length, te = 0; te < Z.length; te++)
          Y = Z[te], N[S++] = (Y.duration & 4278190080) >>> 24, N[S++] = (Y.duration & 16711680) >>> 16, N[S++] = (Y.duration & 65280) >>> 8, N[S++] = Y.duration & 255, N[S++] = (Y.size & 4278190080) >>> 24, N[S++] = (Y.size & 16711680) >>> 16, N[S++] = (Y.size & 65280) >>> 8, N[S++] = Y.size & 255, N[S++] = Y.flags.isLeading << 2 | Y.flags.dependsOn, N[S++] = Y.flags.isDependedOn << 6 | Y.flags.hasRedundancy << 4 | Y.flags.paddingValue << 1 | Y.flags.isNonSyncSample, N[S++] = Y.flags.degradationPriority & 61440, N[S++] = Y.flags.degradationPriority & 15, N[S++] = (Y.compositionTimeOffset & 4278190080) >>> 24, N[S++] = (Y.compositionTimeOffset & 16711680) >>> 16, N[S++] = (Y.compositionTimeOffset & 65280) >>> 8, N[S++] = Y.compositionTimeOffset & 255;
        return s(ee.trun, N);
      }, P = function(b, w) {
        var S, N, q, Z, Y, te;
        for (Z = b.samples || [], w += 20 + 8 * Z.length, q = y(Z, w), S = new Uint8Array(q.length + Z.length * 8), S.set(q), N = q.length, te = 0; te < Z.length; te++)
          Y = Z[te], S[N++] = (Y.duration & 4278190080) >>> 24, S[N++] = (Y.duration & 16711680) >>> 16, S[N++] = (Y.duration & 65280) >>> 8, S[N++] = Y.duration & 255, S[N++] = (Y.size & 4278190080) >>> 24, S[N++] = (Y.size & 16711680) >>> 16, S[N++] = (Y.size & 65280) >>> 8, S[N++] = Y.size & 255;
        return s(ee.trun, S);
      }, Q = function(b, w) {
        return b.type === "audio" ? P(b, w) : v(b, w);
      };
    }();
    var _e = {
      ftyp: l,
      initSegment: function(v) {
        var y = l(), g = p(v), b;
        return b = new Uint8Array(y.byteLength + g.byteLength), b.set(y), b.set(g, y.byteLength), b;
      },
      mdat: c,
      moof: f,
      moov: p
    }, Le = function(v) {
      var y, g, b = [], w = [];
      for (w.byteLength = 0, w.nalCount = 0, w.duration = 0, b.byteLength = 0, y = 0; y < v.length; y++)
        g = v[y], g.nalUnitType === "access_unit_delimiter_rbsp" ? (b.length && (b.duration = g.dts - b.dts, w.byteLength += b.byteLength, w.nalCount += b.length, w.duration += b.duration, w.push(b)), b = [g], b.byteLength = g.data.byteLength, b.pts = g.pts, b.dts = g.dts) : (g.nalUnitType === "slice_layer_without_partitioning_rbsp_idr" && (b.keyFrame = !0), b.duration = g.dts - b.dts, b.byteLength += g.data.byteLength, b.push(g));
      return w.length && (!b.duration || b.duration <= 0) && (b.duration = w[w.length - 1].duration), w.byteLength += b.byteLength, w.nalCount += b.length, w.duration += b.duration, w.push(b), w;
    }, Ve = function(v) {
      var y, g, b = [], w = [];
      for (b.byteLength = 0, b.nalCount = 0, b.duration = 0, b.pts = v[0].pts, b.dts = v[0].dts, w.byteLength = 0, w.nalCount = 0, w.duration = 0, w.pts = v[0].pts, w.dts = v[0].dts, y = 0; y < v.length; y++)
        g = v[y], g.keyFrame ? (b.length && (w.push(b), w.byteLength += b.byteLength, w.nalCount += b.nalCount, w.duration += b.duration), b = [g], b.nalCount = g.length, b.byteLength = g.byteLength, b.pts = g.pts, b.dts = g.dts, b.duration = g.duration) : (b.duration += g.duration, b.nalCount += g.length, b.byteLength += g.byteLength, b.push(g));
      return w.length && b.duration <= 0 && (b.duration = w[w.length - 1].duration), w.byteLength += b.byteLength, w.nalCount += b.nalCount, w.duration += b.duration, w.push(b), w;
    }, ft = function(v) {
      var y;
      return !v[0][0].keyFrame && v.length > 1 && (y = v.shift(), v.byteLength -= y.byteLength, v.nalCount -= y.nalCount, v[0][0].dts = y.dts, v[0][0].pts = y.pts, v[0][0].duration += y.duration), v;
    }, Ee = function() {
      return {
        flags: {
          degradationPriority: 0,
          dependsOn: 1,
          hasRedundancy: 0,
          isDependedOn: 0,
          isLeading: 0,
          isNonSyncSample: 1
        },
        size: 0
      };
    }, ct = function(v, y) {
      var g = Ee();
      return g.dataOffset = y, g.compositionTimeOffset = v.pts - v.dts, g.duration = v.duration, g.size = 4 * v.length, g.size += v.byteLength, v.keyFrame && (g.flags.dependsOn = 2, g.flags.isNonSyncSample = 0), g;
    }, kt = function(v, y) {
      var g, b, w, S, N, q = y || 0, Z = [];
      for (g = 0; g < v.length; g++)
        for (S = v[g], b = 0; b < S.length; b++)
          N = S[b], w = ct(N, q), q += w.size, Z.push(w);
      return Z;
    }, Mt = function(v) {
      var y, g, b, w, S, N, q = 0, Z = v.byteLength, Y = v.nalCount, te = Z + 4 * Y, ce = new Uint8Array(te), De = new DataView(ce.buffer);
      for (y = 0; y < v.length; y++)
        for (w = v[y], g = 0; g < w.length; g++)
          for (S = w[g], b = 0; b < S.length; b++)
            N = S[b], De.setUint32(q, N.data.byteLength), q += 4, ce.set(N.data, q), q += N.data.byteLength;
      return ce;
    }, Vt = function(v, y) {
      var g, b = y || 0, w = [];
      return g = ct(v, b), w.push(g), w;
    }, yt = function(v) {
      var y, g, b = 0, w = v.byteLength, S = v.length, N = w + 4 * S, q = new Uint8Array(N), Z = new DataView(q.buffer);
      for (y = 0; y < v.length; y++)
        g = v[y], Z.setUint32(b, g.data.byteLength), b += 4, q.set(g.data, b), b += g.data.byteLength;
      return q;
    }, jt = {
      concatenateNalData: Mt,
      concatenateNalDataForFrame: yt,
      extendFirstKeyFrame: ft,
      generateSampleTable: kt,
      generateSampleTableForFrame: Vt,
      groupFramesIntoGops: Ve,
      groupNalsIntoFrames: Le
    }, Et = [33, 16, 5, 32, 164, 27], gr = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252], xt = function(v) {
      for (var y = []; v--; )
        y.push(0);
      return y;
    }, ci = function(v) {
      return Object.keys(v).reduce(function(y, g) {
        return y[g] = new Uint8Array(
          v[g].reduce(function(b, w) {
            return b.concat(w);
          }, [])
        ), y;
      }, {});
    }, Gt, yr = function() {
      if (!Gt) {
        var v = {
          11025: [
            gr,
            xt(268),
            [3, 127, 248],
            xt(268),
            [6, 255, 240],
            xt(268),
            [13, 255, 224],
            xt(268),
            [27, 255, 192],
            xt(268),
            [55, 175, 128],
            xt(108),
            [112]
          ],
          12e3: [
            gr,
            xt(268),
            [3, 127, 248],
            xt(268),
            [6, 255, 240],
            xt(268),
            [13, 255, 224],
            xt(268),
            [27, 253, 128],
            xt(259),
            [56]
          ],
          16e3: [
            Et,
            [255, 192],
            xt(268),
            [55, 255, 128],
            xt(268),
            [111, 255],
            xt(269),
            [223, 108],
            xt(195),
            [1, 192]
          ],
          24e3: [
            Et,
            [255, 192],
            xt(268),
            [55, 255, 128],
            xt(268),
            [111, 112],
            xt(126),
            [224]
          ],
          32e3: [
            Et,
            [255, 192],
            xt(268),
            [55, 234],
            xt(226),
            [112]
          ],
          44100: [
            Et,
            [255, 192],
            xt(268),
            [55, 163, 128],
            xt(84),
            [112]
          ],
          48e3: [
            Et,
            [255, 192],
            xt(268),
            [55, 148, 128],
            xt(54),
            [112]
          ],
          64e3: [Et, [248, 192], xt(240), [56]],
          88200: [Et, [231], xt(170), [56]],
          8e3: [gr, xt(268), [3, 121, 16], xt(47), [7]],
          96e3: [Et, [227, 64], xt(154), [56]]
        };
        Gt = ci(v);
      }
      return Gt;
    }, gi = 9e4, ai, ae, Pe, Ie, Je, Be, st;
    ai = function(v) {
      return v * gi;
    }, ae = function(v, y) {
      return v * y;
    }, Pe = function(v) {
      return v / gi;
    }, Ie = function(v, y) {
      return v / y;
    }, Je = function(v, y) {
      return ai(Ie(v, y));
    }, Be = function(v, y) {
      return ae(Pe(v), y);
    }, st = function(v, y, g) {
      return Pe(
        g ? v : v - y
      );
    };
    var Ne = {
      ONE_SECOND_IN_TS: gi,
      audioTsToSeconds: Ie,
      audioTsToVideoTs: Je,
      metadataTsToSeconds: st,
      secondsToAudioTs: ae,
      secondsToVideoTs: ai,
      videoTsToAudioTs: Be,
      videoTsToSeconds: Pe
    }, vt = function(v) {
      var y, g, b = 0;
      for (y = 0; y < v.length; y++)
        g = v[y], b += g.data.byteLength;
      return b;
    }, Rt = function(v, y, g, b) {
      var w, S = 0, N = 0, q = 0, Z = 0, Y, te, ce;
      if (y.length && (w = Ne.audioTsToVideoTs(
        v.baseMediaDecodeTime,
        v.samplerate
      ), S = Math.ceil(
        Ne.ONE_SECOND_IN_TS / (v.samplerate / 1024)
      ), g && b && (N = w - Math.max(g, b), q = Math.floor(N / S), Z = q * S), !(q < 1 || Z > Ne.ONE_SECOND_IN_TS / 2))) {
        for (Y = yr()[v.samplerate], Y || (Y = y[0].data), te = 0; te < q; te++)
          ce = y[0], y.splice(0, 0, {
            data: Y,
            dts: ce.dts - S,
            pts: ce.pts - S
          });
        return v.baseMediaDecodeTime -= Math.floor(
          Ne.videoTsToAudioTs(Z, v.samplerate)
        ), Z;
      }
    }, ht = function(v, y, g) {
      return y.minSegmentDts >= g ? v : (y.minSegmentDts = 1 / 0, v.filter(function(b) {
        return b.dts >= g ? (y.minSegmentDts = Math.min(y.minSegmentDts, b.dts), y.minSegmentPts = y.minSegmentDts, !0) : !1;
      }));
    }, Ct = function(v) {
      var y, g, b = [];
      for (y = 0; y < v.length; y++)
        g = v[y], b.push({
          duration: 1024,
          size: g.data.byteLength
          // For AAC audio, all samples contain 1024 samples
        });
      return b;
    }, Lt = function(v) {
      var y, g, b = 0, w = new Uint8Array(vt(v));
      for (y = 0; y < v.length; y++)
        g = v[y], w.set(g.data, b), b += g.data.byteLength;
      return w;
    }, wt = {
      concatenateFrameData: Lt,
      generateSampleTable: Ct,
      prefixWithSilence: Rt,
      trimAdtsFramesByEarliestDts: ht
    }, _t = Ne.ONE_SECOND_IN_TS, Br = function(v, y) {
      typeof y.pts == "number" && (v.timelineStartInfo.pts === void 0 && (v.timelineStartInfo.pts = y.pts), v.minSegmentPts === void 0 ? v.minSegmentPts = y.pts : v.minSegmentPts = Math.min(v.minSegmentPts, y.pts), v.maxSegmentPts === void 0 ? v.maxSegmentPts = y.pts : v.maxSegmentPts = Math.max(v.maxSegmentPts, y.pts)), typeof y.dts == "number" && (v.timelineStartInfo.dts === void 0 && (v.timelineStartInfo.dts = y.dts), v.minSegmentDts === void 0 ? v.minSegmentDts = y.dts : v.minSegmentDts = Math.min(v.minSegmentDts, y.dts), v.maxSegmentDts === void 0 ? v.maxSegmentDts = y.dts : v.maxSegmentDts = Math.max(v.maxSegmentDts, y.dts));
    }, nr = function(v) {
      delete v.minSegmentDts, delete v.maxSegmentDts, delete v.minSegmentPts, delete v.maxSegmentPts;
    }, ta = function(v, y) {
      var g, b, w = v.minSegmentDts;
      return y || (w -= v.timelineStartInfo.dts), g = v.timelineStartInfo.baseMediaDecodeTime, g += w, g = Math.max(0, g), v.type === "audio" && (b = v.samplerate / _t, g *= b, g = Math.floor(g)), g;
    }, xi = {
      calculateTrackBaseMediaDecodeTime: ta,
      clearDtsInfo: nr,
      collectDtsInfo: Br
    }, Xt = 4, nn = 128, ia = function(v) {
      for (var y = 0, g = {
        payloadSize: 0,
        payloadType: -1
      }, b = 0, w = 0; y < v.byteLength && v[y] !== nn; ) {
        for (; v[y] === 255; )
          b += 255, y++;
        for (b += v[y++]; v[y] === 255; )
          w += 255, y++;
        if (w += v[y++], !g.payload && b === Xt) {
          var S = String.fromCharCode(
            v[y + 3],
            v[y + 4],
            v[y + 5],
            v[y + 6]
          );
          if (S === "GA94") {
            g.payloadType = b, g.payloadSize = w, g.payload = v.subarray(y, y + w);
            break;
          } else
            g.payload = void 0;
        }
        y += w, b = 0, w = 0;
      }
      return g;
    }, Fr = function(v) {
      return v.payload[0] !== 181 || (v.payload[1] << 8 | v.payload[2]) !== 49 || String.fromCharCode(
        v.payload[3],
        v.payload[4],
        v.payload[5],
        v.payload[6]
      ) !== "GA94" || v.payload[7] !== 3 ? null : v.payload.subarray(8, v.payload.length - 1);
    }, zo = function(v, y) {
      var g = [], b, w, S, N;
      if (!(y[0] & 64))
        return g;
      for (w = y[0] & 31, b = 0; b < w; b++)
        S = b * 3, N = {
          pts: v,
          type: y[S + 2] & 3
        }, y[S + 2] & 4 && (N.ccData = y[S + 3] << 8 | y[S + 4], g.push(N));
      return g;
    }, bs = function(v) {
      for (var y = v.byteLength, g = [], b = 1, w, S; b < y - 2; )
        v[b] === 0 && v[b + 1] === 0 && v[b + 2] === 3 ? (g.push(b + 2), b += 2) : b++;
      if (g.length === 0)
        return v;
      w = y - g.length, S = new Uint8Array(w);
      var N = 0;
      for (b = 0; b < w; N++, b++)
        N === g[0] && (N++, g.shift()), S[b] = v[N];
      return S;
    }, _r = {
      USER_DATA_REGISTERED_ITU_T_T35: Xt,
      discardEmulationPreventionBytes: bs,
      parseCaptionPackets: zo,
      parseSei: ia,
      parseUserData: Fr
    }, Oi = function P(v) {
      v = v || {}, P.prototype.init.call(this), this.parse708captions_ = typeof v.parse708captions == "boolean" ? v.parse708captions : !0, this.captionPackets_ = [], this.ccStreams_ = [
        new we(0, 0),
        new we(0, 1),
        new we(1, 0),
        new we(1, 1)
      ], this.parse708captions_ && (this.cc708Stream_ = new z({
        captionServices: v.captionServices
      })), this.reset(), this.ccStreams_.forEach(function(y) {
        y.on("data", this.trigger.bind(this, "data")), y.on("partialdone", this.trigger.bind(this, "partialdone")), y.on("done", this.trigger.bind(this, "done"));
      }, this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on(
        "partialdone",
        this.trigger.bind(this, "partialdone")
      ), this.cc708Stream_.on("done", this.trigger.bind(this, "done")));
    };
    Oi.prototype = new t(), Oi.prototype.push = function(P) {
      var v, y, g;
      if (P.nalUnitType === "sei_rbsp" && (v = _r.parseSei(P.escapedRBSP), !!v.payload && v.payloadType === _r.USER_DATA_REGISTERED_ITU_T_T35 && (y = _r.parseUserData(v), !!y))) {
        if (P.dts < this.latestDts_) {
          this.ignoreNextEqualDts_ = !0;
          return;
        } else if (P.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
          this.numSameDts_--, this.numSameDts_ || (this.ignoreNextEqualDts_ = !1);
          return;
        }
        g = _r.parseCaptionPackets(
          P.pts,
          y
        ), this.captionPackets_ = this.captionPackets_.concat(g), this.latestDts_ !== P.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = P.dts;
      }
    }, Oi.prototype.flushCCStreams = function(P) {
      this.ccStreams_.forEach(function(v) {
        return P === "flush" ? v.flush() : v.partialFlush();
      }, this);
    }, Oi.prototype.flushStream = function(P) {
      if (!this.captionPackets_.length) {
        this.flushCCStreams(P);
        return;
      }
      this.captionPackets_.forEach(function(v, y) {
        v.presortIndex = y;
      }), this.captionPackets_.sort(function(v, y) {
        return v.pts === y.pts ? v.presortIndex - y.presortIndex : v.pts - y.pts;
      }), this.captionPackets_.forEach(function(v) {
        v.type < 2 ? this.dispatchCea608Packet(v) : this.dispatchCea708Packet(v);
      }, this), this.captionPackets_.length = 0, this.flushCCStreams(P);
    }, Oi.prototype.flush = function() {
      return this.flushStream("flush");
    }, Oi.prototype.partialFlush = function() {
      return this.flushStream("partialFlush");
    }, Oi.prototype.reset = function() {
      this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach(function(P) {
        P.reset();
      });
    }, Oi.prototype.dispatchCea608Packet = function(P) {
      this.setsTextOrXDSActive(P) ? this.activeCea608Channel_[P.type] = null : this.setsChannel1Active(P) ? this.activeCea608Channel_[P.type] = 0 : this.setsChannel2Active(P) && (this.activeCea608Channel_[P.type] = 1), this.activeCea608Channel_[P.type] !== null && this.ccStreams_[(P.type << 1) + this.activeCea608Channel_[P.type]].push(P);
    }, Oi.prototype.setsChannel1Active = function(P) {
      return (P.ccData & 30720) === 4096;
    }, Oi.prototype.setsChannel2Active = function(P) {
      return (P.ccData & 30720) === 6144;
    }, Oi.prototype.setsTextOrXDSActive = function(P) {
      return (P.ccData & 28928) === 256 || (P.ccData & 30974) === 4138 || (P.ccData & 30974) === 6186;
    }, Oi.prototype.dispatchCea708Packet = function(P) {
      this.parse708captions_ && this.cc708Stream_.push(P);
    };
    var En = {
      127: 9834,
      // 
      4128: 32,
      // Transparent Space
      4129: 160,
      // Nob-breaking Transparent Space
      4133: 8230,
      // 
      4138: 352,
      // 
      4140: 338,
      // 
      4144: 9608,
      // 
      4145: 8216,
      // 
      4146: 8217,
      // 
      4147: 8220,
      // 
      4148: 8221,
      // 
      4149: 8226,
      // 
      4153: 8482,
      // 
      4154: 353,
      // 
      4156: 339,
      // 
      4157: 8480,
      // 
      4159: 376,
      // 
      4214: 8539,
      // 
      4215: 8540,
      // 
      4216: 8541,
      // 
      4217: 8542,
      // 
      4218: 9168,
      // 
      4219: 9124,
      // 
      4220: 9123,
      // 
      4221: 9135,
      // 
      4222: 9126,
      // 
      4223: 9121,
      // 
      4256: 12600
      //  (CC char)
    }, Nr = function(v) {
      var y = En[v] || v;
      return v & 4096 && v === y ? "" : String.fromCharCode(y);
    }, wn = function(v) {
      return 32 <= v && v <= 127 || 160 <= v && v <= 255;
    }, Jt = function(v) {
      this.windowNum = v, this.reset();
    };
    Jt.prototype.reset = function() {
      this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0;
    }, Jt.prototype.getText = function() {
      return this.rows.join(`
`);
    }, Jt.prototype.clearText = function() {
      this.rows = [""], this.rowIdx = 0;
    }, Jt.prototype.newLine = function(P) {
      for (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow == "function" && this.beforeRowOverflow(P), this.rows.length > 0 && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount; )
        this.rows.shift(), this.rowIdx--;
    }, Jt.prototype.isEmpty = function() {
      return this.rows.length === 0 ? !0 : this.rows.length === 1 ? this.rows[0] === "" : !1;
    }, Jt.prototype.addText = function(P) {
      this.rows[this.rowIdx] += P;
    }, Jt.prototype.backspace = function() {
      if (!this.isEmpty()) {
        var P = this.rows[this.rowIdx];
        this.rows[this.rowIdx] = P.substr(0, P.length - 1);
      }
    };
    var O = function(v, y, g) {
      this.serviceNum = v, this.text = "", this.currentWindow = new Jt(-1), this.windows = [], this.stream = g, typeof y == "string" && this.createTextDecoder(y);
    };
    O.prototype.init = function(P, v) {
      this.startPts = P;
      for (var y = 0; y < 8; y++)
        this.windows[y] = new Jt(y), typeof v == "function" && (this.windows[y].beforeRowOverflow = v);
    }, O.prototype.setCurrentWindow = function(P) {
      this.currentWindow = this.windows[P];
    }, O.prototype.createTextDecoder = function(P) {
      if (typeof TextDecoder > "u")
        this.stream.trigger("log", {
          level: "warn",
          message: "The `encoding` option is unsupported without TextDecoder support"
        });
      else
        try {
          this.textDecoder_ = new TextDecoder(P);
        } catch (v) {
          this.stream.trigger("log", {
            level: "warn",
            message: "TextDecoder could not be created with " + P + " encoding. " + v
          });
        }
    };
    var z = function P(v) {
      v = v || {}, P.prototype.init.call(this);
      var y = this, g = v.captionServices || {}, b = {}, w;
      Object.keys(g).forEach(function(S) {
        w = g[S], /^SERVICE/.test(S) && (b[S] = w.encoding);
      }), this.serviceEncodings = b, this.current708Packet = null, this.services = {}, this.push = function(S) {
        S.type === 3 ? (y.new708Packet(), y.add708Bytes(S)) : (y.current708Packet === null && y.new708Packet(), y.add708Bytes(S));
      };
    };
    z.prototype = new t(), z.prototype.new708Packet = function() {
      this.current708Packet !== null && this.push708Packet(), this.current708Packet = {
        data: [],
        ptsVals: []
      };
    }, z.prototype.add708Bytes = function(P) {
      var v = P.ccData, y = v >>> 8, g = v & 255;
      this.current708Packet.ptsVals.push(P.pts), this.current708Packet.data.push(y), this.current708Packet.data.push(g);
    }, z.prototype.push708Packet = function() {
      var P = this.current708Packet, v = P.data, y = null, g = null, b = 0, w = v[b++];
      for (P.seq = w >> 6, P.sizeCode = w & 63; b < v.length; b++)
        w = v[b++], y = w >> 5, g = w & 31, y === 7 && g > 0 && (w = v[b++], y = w), this.pushServiceBlock(y, b, g), g > 0 && (b += g - 1);
    }, z.prototype.pushServiceBlock = function(P, v, y) {
      var g, b = v, w = this.current708Packet.data, S = this.services[P];
      for (S || (S = this.initService(P, b)); b < v + y && b < w.length; b++)
        g = w[b], wn(g) ? b = this.handleText(b, S) : g === 24 ? b = this.multiByteCharacter(b, S) : g === 16 ? b = this.extendedCommands(b, S) : 128 <= g && g <= 135 ? b = this.setCurrentWindow(b, S) : 152 <= g && g <= 159 ? b = this.defineWindow(b, S) : g === 136 ? b = this.clearWindows(b, S) : g === 140 ? b = this.deleteWindows(b, S) : g === 137 ? b = this.displayWindows(b, S) : g === 138 ? b = this.hideWindows(b, S) : g === 139 ? b = this.toggleWindows(b, S) : g === 151 ? b = this.setWindowAttributes(b, S) : g === 144 ? b = this.setPenAttributes(b, S) : g === 145 ? b = this.setPenColor(b, S) : g === 146 ? b = this.setPenLocation(b, S) : g === 143 ? S = this.reset(b, S) : g === 8 ? S.currentWindow.backspace() : g === 12 ? S.currentWindow.clearText() : g === 13 ? S.currentWindow.pendingNewLine = !0 : g === 14 ? S.currentWindow.clearText() : g === 141 && b++;
    }, z.prototype.extendedCommands = function(P, v) {
      var y = this.current708Packet.data, g = y[++P];
      return wn(g) && (P = this.handleText(P, v, {
        isExtended: !0
      })), P;
    }, z.prototype.getPts = function(P) {
      return this.current708Packet.ptsVals[Math.floor(P / 2)];
    }, z.prototype.initService = function(P, v) {
      var g = "SERVICE" + P, y = this, g, b;
      return g in this.serviceEncodings && (b = this.serviceEncodings[g]), this.services[P] = new O(P, b, y), this.services[P].init(this.getPts(v), function(w) {
        y.flushDisplayed(w, y.services[P]);
      }), this.services[P];
    }, z.prototype.handleText = function(P, v, y) {
      var g = y && y.isExtended, b = y && y.isMultiByte, w = this.current708Packet.data, S = g ? 4096 : 0, N = w[P], q = w[P + 1], Z = v.currentWindow, Y, te;
      return v.textDecoder_ && !g ? (b ? (te = [N, q], P++) : te = [N], Y = v.textDecoder_.decode(new Uint8Array(te))) : Y = Nr(S | N), Z.pendingNewLine && !Z.isEmpty() && Z.newLine(this.getPts(P)), Z.pendingNewLine = !1, Z.addText(Y), P;
    }, z.prototype.multiByteCharacter = function(P, v) {
      var y = this.current708Packet.data, g = y[P + 1], b = y[P + 2];
      return wn(g) && wn(b) && (P = this.handleText(++P, v, {
        isMultiByte: !0
      })), P;
    }, z.prototype.setCurrentWindow = function(P, v) {
      var y = this.current708Packet.data, g = y[P], b = g & 7;
      return v.setCurrentWindow(b), P;
    }, z.prototype.defineWindow = function(P, v) {
      var y = this.current708Packet.data, g = y[P], b = g & 7;
      v.setCurrentWindow(b);
      var w = v.currentWindow;
      return g = y[++P], w.visible = (g & 32) >> 5, w.rowLock = (g & 16) >> 4, w.columnLock = (g & 8) >> 3, w.priority = g & 7, g = y[++P], w.relativePositioning = (g & 128) >> 7, w.anchorVertical = g & 127, g = y[++P], w.anchorHorizontal = g, g = y[++P], w.anchorPoint = (g & 240) >> 4, w.rowCount = g & 15, g = y[++P], w.columnCount = g & 63, g = y[++P], w.windowStyle = (g & 56) >> 3, w.penStyle = g & 7, w.virtualRowCount = w.rowCount + 1, P;
    }, z.prototype.setWindowAttributes = function(P, v) {
      var y = this.current708Packet.data, g = y[P], b = v.currentWindow.winAttr;
      return g = y[++P], b.fillOpacity = (g & 192) >> 6, b.fillRed = (g & 48) >> 4, b.fillGreen = (g & 12) >> 2, b.fillBlue = g & 3, g = y[++P], b.borderType = (g & 192) >> 6, b.borderRed = (g & 48) >> 4, b.borderGreen = (g & 12) >> 2, b.borderBlue = g & 3, g = y[++P], b.borderType += (g & 128) >> 5, b.wordWrap = (g & 64) >> 6, b.printDirection = (g & 48) >> 4, b.scrollDirection = (g & 12) >> 2, b.justify = g & 3, g = y[++P], b.effectSpeed = (g & 240) >> 4, b.effectDirection = (g & 12) >> 2, b.displayEffect = g & 3, P;
    }, z.prototype.flushDisplayed = function(P, v) {
      for (var y = [], g = 0; g < 8; g++)
        v.windows[g].visible && !v.windows[g].isEmpty() && y.push(v.windows[g].getText());
      v.endPts = P, v.text = y.join(`

`), this.pushCaption(v), v.startPts = P;
    }, z.prototype.pushCaption = function(P) {
      P.text !== "" && (this.trigger("data", {
        endPts: P.endPts,
        startPts: P.startPts,
        stream: "cc708_" + P.serviceNum,
        text: P.text
      }), P.text = "", P.startPts = P.endPts);
    }, z.prototype.displayWindows = function(P, v) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, v);
      for (var w = 0; w < 8; w++)
        g & 1 << w && (v.windows[w].visible = 1);
      return P;
    }, z.prototype.hideWindows = function(P, v) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, v);
      for (var w = 0; w < 8; w++)
        g & 1 << w && (v.windows[w].visible = 0);
      return P;
    }, z.prototype.toggleWindows = function(P, v) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, v);
      for (var w = 0; w < 8; w++)
        g & 1 << w && (v.windows[w].visible ^= 1);
      return P;
    }, z.prototype.clearWindows = function(P, v) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, v);
      for (var w = 0; w < 8; w++)
        g & 1 << w && v.windows[w].clearText();
      return P;
    }, z.prototype.deleteWindows = function(P, v) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, v);
      for (var w = 0; w < 8; w++)
        g & 1 << w && v.windows[w].reset();
      return P;
    }, z.prototype.setPenAttributes = function(P, v) {
      var y = this.current708Packet.data, g = y[P], b = v.currentWindow.penAttr;
      return g = y[++P], b.textTag = (g & 240) >> 4, b.offset = (g & 12) >> 2, b.penSize = g & 3, g = y[++P], b.italics = (g & 128) >> 7, b.underline = (g & 64) >> 6, b.edgeType = (g & 56) >> 3, b.fontStyle = g & 7, P;
    }, z.prototype.setPenColor = function(P, v) {
      var y = this.current708Packet.data, g = y[P], b = v.currentWindow.penColor;
      return g = y[++P], b.fgOpacity = (g & 192) >> 6, b.fgRed = (g & 48) >> 4, b.fgGreen = (g & 12) >> 2, b.fgBlue = g & 3, g = y[++P], b.bgOpacity = (g & 192) >> 6, b.bgRed = (g & 48) >> 4, b.bgGreen = (g & 12) >> 2, b.bgBlue = g & 3, g = y[++P], b.edgeRed = (g & 48) >> 4, b.edgeGreen = (g & 12) >> 2, b.edgeBlue = g & 3, P;
    }, z.prototype.setPenLocation = function(P, v) {
      var y = this.current708Packet.data, g = y[P], b = v.currentWindow.penLoc;
      return v.currentWindow.pendingNewLine = !0, g = y[++P], b.row = g & 15, g = y[++P], b.column = g & 63, P;
    }, z.prototype.reset = function(P, v) {
      var y = this.getPts(P);
      return this.flushDisplayed(y, v), this.initService(v.serviceNum, P);
    };
    var $ = {
      // 
      123: 231,
      // 
      124: 247,
      // 
      125: 209,
      42: 225,
      // 
      126: 241,
      // 
      // 
      92: 233,
      // 
      127: 9608,
      // 
      // 
      94: 237,
      // 
      304: 174,
      95: 243,
      // 
      305: 176,
      // 
      306: 189,
      96: 250,
      // 
      307: 191,
      // 
      308: 8482,
      // 
      309: 162,
      // 
      310: 163,
      // 
      311: 9834,
      // 
      312: 224,
      // 
      313: 160,
      //
      314: 232,
      // 
      315: 226,
      // 
      316: 234,
      // 
      317: 238,
      // 
      318: 244,
      // 
      319: 251,
      // 
      544: 193,
      // 
      545: 201,
      // 
      546: 211,
      // 
      547: 218,
      // 
      548: 220,
      // 
      549: 252,
      // 
      550: 8216,
      // 
      551: 161,
      // 
      552: 42,
      // *
      553: 39,
      // '
      554: 8212,
      // 
      555: 169,
      // 
      556: 8480,
      // 
      557: 8226,
      // 
      558: 8220,
      // 
      559: 8221,
      // 
      560: 192,
      // 
      561: 194,
      // 
      562: 199,
      // 
      563: 200,
      // 
      564: 202,
      // 
      565: 203,
      // 
      566: 235,
      // 
      567: 206,
      // 
      568: 207,
      // 
      569: 239,
      // 
      570: 212,
      // 
      571: 217,
      // 
      572: 249,
      // 
      573: 219,
      // 
      574: 171,
      // 
      575: 187,
      // 
      800: 195,
      // 
      801: 227,
      // 
      802: 205,
      // 
      803: 204,
      // 
      804: 236,
      // 
      805: 210,
      // 
      806: 242,
      // 
      807: 213,
      // 
      808: 245,
      // 
      809: 123,
      // {
      810: 125,
      // }
      811: 92,
      // \
      812: 94,
      // ^
      813: 95,
      // _
      814: 124,
      // |
      815: 126,
      // ~
      816: 196,
      // 
      817: 228,
      // 
      818: 214,
      // 
      819: 246,
      // 
      820: 223,
      // 
      821: 165,
      // 
      822: 164,
      // 
      823: 9474,
      // 
      824: 197,
      // 
      825: 229,
      // 
      826: 216,
      // 
      827: 248,
      // 
      828: 9484,
      // 
      829: 9488,
      // 
      830: 9492,
      // 
      831: 9496
      // 
    }, ge = function(v) {
      return v === null ? "" : (v = $[v] || v, String.fromCharCode(v));
    }, Me = 14, ze = [
      4352,
      4384,
      4608,
      4640,
      5376,
      5408,
      5632,
      5664,
      5888,
      5920,
      4096,
      4864,
      4896,
      5120,
      5152
    ], Ke = function() {
      for (var v = [], y = Me + 1; y--; )
        v.push("");
      return v;
    }, we = function P(v, y) {
      P.prototype.init.call(this), this.field_ = v || 0, this.dataChannel_ = y || 0, this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1), this.setConstants(), this.reset(), this.push = function(g) {
        var b, w, S, N, q;
        if (b = g.ccData & 32639, b === this.lastControlCode_) {
          this.lastControlCode_ = null;
          return;
        }
        if ((b & 61440) === 4096 ? this.lastControlCode_ = b : b !== this.PADDING_ && (this.lastControlCode_ = null), S = b >>> 8, N = b & 255, b !== this.PADDING_)
          if (b === this.RESUME_CAPTION_LOADING_)
            this.mode_ = "popOn";
          else if (b === this.END_OF_CAPTION_)
            this.mode_ = "popOn", this.clearFormatting(g.pts), this.flushDisplayed(g.pts), w = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = w, this.startPts_ = g.pts;
          else if (b === this.ROLL_UP_2_ROWS_)
            this.rollUpRows_ = 2, this.setRollUp(g.pts);
          else if (b === this.ROLL_UP_3_ROWS_)
            this.rollUpRows_ = 3, this.setRollUp(g.pts);
          else if (b === this.ROLL_UP_4_ROWS_)
            this.rollUpRows_ = 4, this.setRollUp(g.pts);
          else if (b === this.CARRIAGE_RETURN_)
            this.clearFormatting(g.pts), this.flushDisplayed(g.pts), this.shiftRowsUp_(), this.startPts_ = g.pts;
          else if (b === this.BACKSPACE_)
            this.mode_ === "popOn" ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(
              0,
              -1
            ) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(
              0,
              -1
            );
          else if (b === this.ERASE_DISPLAYED_MEMORY_)
            this.flushDisplayed(g.pts), this.displayed_ = Ke();
          else if (b === this.ERASE_NON_DISPLAYED_MEMORY_)
            this.nonDisplayed_ = Ke();
          else if (b === this.RESUME_DIRECT_CAPTIONING_)
            this.mode_ !== "paintOn" && (this.flushDisplayed(g.pts), this.displayed_ = Ke()), this.mode_ = "paintOn", this.startPts_ = g.pts;
          else if (this.isSpecialCharacter(S, N))
            S = (S & 3) << 8, q = ge(S | N), this[this.mode_](g.pts, q), this.column_++;
          else if (this.isExtCharacter(S, N))
            this.mode_ === "popOn" ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(
              0,
              -1
            ) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(
              0,
              -1
            ), S = (S & 3) << 8, q = ge(S | N), this[this.mode_](g.pts, q), this.column_++;
          else if (this.isMidRowCode(S, N))
            this.clearFormatting(g.pts), this[this.mode_](g.pts, " "), this.column_++, (N & 14) === 14 && this.addFormatting(g.pts, ["i"]), (N & 1) === 1 && this.addFormatting(g.pts, ["u"]);
          else if (this.isOffsetControlCode(S, N))
            this.column_ += N & 3;
          else if (this.isPAC(S, N)) {
            var Z = ze.indexOf(b & 7968);
            this.mode_ === "rollUp" && (Z - this.rollUpRows_ + 1 < 0 && (Z = this.rollUpRows_ - 1), this.setRollUp(g.pts, Z)), Z !== this.row_ && (this.clearFormatting(g.pts), this.row_ = Z), N & 1 && this.formatting_.indexOf("u") === -1 && this.addFormatting(g.pts, ["u"]), (b & 16) === 16 && (this.column_ = ((b & 14) >> 1) * 4), this.isColorPAC(N) && (N & 14) === 14 && this.addFormatting(g.pts, ["i"]);
          } else this.isNormalChar(S) && (N === 0 && (N = null), q = ge(S), q += ge(N), this[this.mode_](g.pts, q), this.column_ += q.length);
      };
    };
    we.prototype = new t(), we.prototype.flushDisplayed = function(P) {
      var v = this.displayed_.map(function(y, g) {
        try {
          return y.trim();
        } catch {
          return this.trigger("log", {
            level: "warn",
            message: "Skipping a malformed 608 caption at index " + g + "."
          }), "";
        }
      }, this).join(`
`).replace(/^\n+|\n+$/g, "");
      v.length && this.trigger("data", {
        endPts: P,
        startPts: this.startPts_,
        stream: this.name_,
        text: v
      });
    }, we.prototype.reset = function() {
      this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = Ke(), this.nonDisplayed_ = Ke(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = Me, this.rollUpRows_ = 2, this.formatting_ = [];
    }, we.prototype.setConstants = function() {
      this.dataChannel_ === 0 ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : this.dataChannel_ === 1 && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32, this.END_OF_CAPTION_ = this.CONTROL_ | 47, this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37, this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38, this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39, this.CARRIAGE_RETURN_ = this.CONTROL_ | 45, this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41, this.BACKSPACE_ = this.CONTROL_ | 33, this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44, this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
    }, we.prototype.isSpecialCharacter = function(P, v) {
      return P === this.EXT_ && v >= 48 && v <= 63;
    }, we.prototype.isExtCharacter = function(P, v) {
      return (P === this.EXT_ + 1 || P === this.EXT_ + 2) && v >= 32 && v <= 63;
    }, we.prototype.isMidRowCode = function(P, v) {
      return P === this.EXT_ && v >= 32 && v <= 47;
    }, we.prototype.isOffsetControlCode = function(P, v) {
      return P === this.OFFSET_ && v >= 33 && v <= 35;
    }, we.prototype.isPAC = function(P, v) {
      return P >= this.BASE_ && P < this.BASE_ + 8 && v >= 64 && v <= 127;
    }, we.prototype.isColorPAC = function(P) {
      return P >= 64 && P <= 79 || P >= 96 && P <= 127;
    }, we.prototype.isNormalChar = function(P) {
      return P >= 32 && P <= 127;
    }, we.prototype.setRollUp = function(P, v) {
      if (this.mode_ !== "rollUp" && (this.row_ = Me, this.mode_ = "rollUp", this.flushDisplayed(P), this.nonDisplayed_ = Ke(), this.displayed_ = Ke()), v !== void 0 && v !== this.row_)
        for (var y = 0; y < this.rollUpRows_; y++)
          this.displayed_[v - y] = this.displayed_[this.row_ - y], this.displayed_[this.row_ - y] = "";
      v === void 0 && (v = this.row_), this.topRow_ = v - this.rollUpRows_ + 1;
    }, we.prototype.addFormatting = function(P, v) {
      this.formatting_ = this.formatting_.concat(v);
      var y = v.reduce(function(g, b) {
        return g + "<" + b + ">";
      }, "");
      this[this.mode_](P, y);
    }, we.prototype.clearFormatting = function(P) {
      if (this.formatting_.length) {
        var v = this.formatting_.reverse().reduce(function(y, g) {
          return y + "</" + g + ">";
        }, "");
        this.formatting_ = [], this[this.mode_](P, v);
      }
    }, we.prototype.popOn = function(P, v) {
      var y = this.nonDisplayed_[this.row_];
      y += v, this.nonDisplayed_[this.row_] = y;
    }, we.prototype.rollUp = function(P, v) {
      var y = this.displayed_[this.row_];
      y += v, this.displayed_[this.row_] = y;
    }, we.prototype.shiftRowsUp_ = function() {
      var P;
      for (P = 0; P < this.topRow_; P++)
        this.displayed_[P] = "";
      for (P = this.row_ + 1; P < Me + 1; P++)
        this.displayed_[P] = "";
      for (P = this.topRow_; P < this.row_; P++)
        this.displayed_[P] = this.displayed_[P + 1];
      this.displayed_[this.row_] = "";
    }, we.prototype.paintOn = function(P, v) {
      var y = this.displayed_[this.row_];
      y += v, this.displayed_[this.row_] = y;
    };
    var et = {
      CaptionStream: Oi,
      Cea608Stream: we,
      Cea708Stream: z
    }, nt = {
      ADTS_STREAM_TYPE: 15,
      H264_STREAM_TYPE: 27,
      METADATA_STREAM_TYPE: 21
    }, it = 8589934592, Tt = 4294967296, Qe = "shared", Dt = function(v, y) {
      var g = 1;
      for (v > y && (g = -1); Math.abs(y - v) > Tt; )
        v += g * it;
      return v;
    }, bt = function P(v) {
      var y, g;
      P.prototype.init.call(this), this.type_ = v || Qe, this.push = function(b) {
        this.type_ !== Qe && b.type !== this.type_ || (g === void 0 && (g = b.dts), b.dts = Dt(b.dts, g), b.pts = Dt(b.pts, g), y = b.dts, this.trigger("data", b));
      }, this.flush = function() {
        g = y, this.trigger("done");
      }, this.endTimeline = function() {
        this.flush(), this.trigger("endedtimeline");
      }, this.discontinuity = function() {
        g = void 0, y = void 0;
      }, this.reset = function() {
        this.discontinuity(), this.trigger("reset");
      };
    };
    bt.prototype = new t();
    var $t = {
      TimestampRolloverStream: bt,
      handleRollover: Dt
    }, hi = function(v, y, g) {
      var b, w = "";
      for (b = y; b < g; b++)
        w += "%" + ("00" + v[b].toString(16)).slice(-2);
      return w;
    }, Ni = function(v, y, g) {
      return decodeURIComponent(hi(v, y, g));
    }, Ci = function(v, y, g) {
      return unescape(hi(v, y, g));
    }, an = function(v) {
      return v[0] << 21 | v[1] << 14 | v[2] << 7 | v[3];
    }, ra = {
      PRIV: function(v) {
        var y;
        for (y = 0; y < v.data.length; y++)
          if (v.data[y] === 0) {
            v.owner = Ci(v.data, 0, y);
            break;
          }
        v.privateData = v.data.subarray(y + 1), v.data = v.privateData;
      },
      TXXX: function(v) {
        var y;
        if (v.data[0] === 3) {
          for (y = 1; y < v.data.length; y++)
            if (v.data[y] === 0) {
              v.description = Ni(v.data, 1, y), v.value = Ni(v.data, y + 1, v.data.length).replace(
                /\0*$/,
                ""
              );
              break;
            }
          v.data = v.value;
        }
      },
      WXXX: function(v) {
        var y;
        if (v.data[0] === 3) {
          for (y = 1; y < v.data.length; y++)
            if (v.data[y] === 0) {
              v.description = Ni(v.data, 1, y), v.url = Ni(v.data, y + 1, v.data.length);
              break;
            }
        }
      }
    }, na;
    na = function(v) {
      var y = {
        // the bytes of the program-level descriptor field in MP2T
        // see ISO/IEC 13818-1:2013 (E), section 2.6 "Program and
        // program element descriptors"
        descriptor: v && v.descriptor
      }, g = 0, b = [], w = 0, S;
      if (na.prototype.init.call(this), this.dispatchType = nt.METADATA_STREAM_TYPE.toString(16), y.descriptor)
        for (S = 0; S < y.descriptor.length; S++)
          this.dispatchType += ("00" + y.descriptor[S].toString(16)).slice(-2);
      this.push = function(N) {
        var q, Z, Y, te, ce, De;
        if (N.type === "timed-metadata") {
          if (N.dataAlignmentIndicator && (w = 0, b.length = 0), b.length === 0 && (N.data.length < 10 || N.data[0] !== 73 || N.data[1] !== 68 || N.data[2] !== 51)) {
            this.trigger("log", {
              level: "warn",
              message: "Skipping unrecognized metadata packet"
            });
            return;
          }
          if (b.push(N), w += N.data.byteLength, b.length === 1 && (g = an(N.data.subarray(6, 10)), g += 10), !(w < g)) {
            for (q = {
              data: new Uint8Array(g),
              dts: b[0].dts,
              frames: [],
              pts: b[0].pts
            }, ce = 0; ce < g; )
              q.data.set(b[0].data.subarray(0, g - ce), ce), ce += b[0].data.byteLength, w -= b[0].data.byteLength, b.shift();
            Z = 10, q.data[5] & 64 && (Z += 4, Z += an(q.data.subarray(10, 14)), g -= an(q.data.subarray(16, 20)));
            do {
              if (Y = an(
                q.data.subarray(Z + 4, Z + 8)
              ), Y < 1) {
                this.trigger("log", {
                  level: "warn",
                  message: "Malformed ID3 frame encountered. Skipping metadata parsing."
                });
                return;
              }
              if (De = String.fromCharCode(
                q.data[Z],
                q.data[Z + 1],
                q.data[Z + 2],
                q.data[Z + 3]
              ), te = {
                data: q.data.subarray(
                  Z + 10,
                  Z + Y + 10
                ),
                id: De
              }, te.key = te.id, ra[te.id] && (ra[te.id](te), te.owner === "com.apple.streaming.transportStreamTimestamp")) {
                var Ue = te.data, Ae = (Ue[3] & 1) << 30 | Ue[4] << 22 | Ue[5] << 14 | Ue[6] << 6 | Ue[7] >>> 2;
                Ae *= 4, Ae += Ue[7] & 3, te.timeStamp = Ae, q.pts === void 0 && q.dts === void 0 && (q.pts = te.timeStamp, q.dts = te.timeStamp), this.trigger("timestamp", te);
              }
              q.frames.push(te), Z += 10, Z += Y;
            } while (Z < g);
            this.trigger("data", q);
          }
        }
      };
    }, na.prototype = new t();
    var aa = na, It = $t.TimestampRolloverStream, xs, sn, ei, A = 188, T = 71;
    xs = function() {
      var v = new Uint8Array(A), y = 0;
      xs.prototype.init.call(this), this.push = function(g) {
        var b = 0, w = A, S;
        for (y ? (S = new Uint8Array(g.byteLength + y), S.set(v.subarray(0, y)), S.set(g, y), y = 0) : S = g; w < S.byteLength; ) {
          if (S[b] === T && S[w] === T) {
            this.trigger("data", S.subarray(b, w)), b += A, w += A;
            continue;
          }
          b++, w++;
        }
        b < S.byteLength && (v.set(S.subarray(b), 0), y = S.byteLength - b);
      }, this.flush = function() {
        y === A && v[0] === T && (this.trigger("data", v), y = 0), this.trigger("done");
      }, this.endTimeline = function() {
        this.flush(), this.trigger("endedtimeline");
      }, this.reset = function() {
        y = 0, this.trigger("reset");
      };
    }, xs.prototype = new t(), sn = function() {
      var v, y, g, b;
      sn.prototype.init.call(this), b = this, this.packetsWaitingForPmt = [], this.programMapTable = void 0, v = function(S, N) {
        var q = 0;
        N.payloadUnitStartIndicator && (q += S[q] + 1), N.type === "pat" ? y(S.subarray(q), N) : g(S.subarray(q), N);
      }, y = function(S, N) {
        N.section_number = S[7], N.last_section_number = S[8], b.pmtPid = (S[10] & 31) << 8 | S[11], N.pmtPid = b.pmtPid;
      }, g = function(S, N) {
        var q, Z, Y, te;
        if (S[5] & 1) {
          for (b.programMapTable = {
            audio: null,
            "timed-metadata": {},
            video: null
          }, q = (S[1] & 15) << 8 | S[2], Z = 3 + q - 4, Y = (S[10] & 15) << 8 | S[11], te = 12 + Y; te < Z; ) {
            var ce = S[te], De = (S[te + 1] & 31) << 8 | S[te + 2];
            ce === nt.H264_STREAM_TYPE && b.programMapTable.video === null ? b.programMapTable.video = De : ce === nt.ADTS_STREAM_TYPE && b.programMapTable.audio === null ? b.programMapTable.audio = De : ce === nt.METADATA_STREAM_TYPE && (b.programMapTable["timed-metadata"][De] = ce), te += ((S[te + 3] & 15) << 8 | S[te + 4]) + 5;
          }
          N.programMapTable = b.programMapTable;
        }
      }, this.push = function(w) {
        var S = {}, N = 4;
        if (S.payloadUnitStartIndicator = !!(w[1] & 64), S.pid = w[1] & 31, S.pid <<= 8, S.pid |= w[2], (w[3] & 48) >>> 4 > 1 && (N += w[N] + 1), S.pid === 0)
          S.type = "pat", v(w.subarray(N), S), this.trigger("data", S);
        else if (S.pid === this.pmtPid)
          for (S.type = "pmt", v(w.subarray(N), S), this.trigger("data", S); this.packetsWaitingForPmt.length; )
            this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
        else this.programMapTable === void 0 ? this.packetsWaitingForPmt.push([w, N, S]) : this.processPes_(w, N, S);
      }, this.processPes_ = function(w, S, N) {
        N.pid === this.programMapTable.video ? N.streamType = nt.H264_STREAM_TYPE : N.pid === this.programMapTable.audio ? N.streamType = nt.ADTS_STREAM_TYPE : N.streamType = this.programMapTable["timed-metadata"][N.pid], N.type = "pes", N.data = w.subarray(S), this.trigger("data", N);
      };
    }, sn.prototype = new t(), sn.STREAM_TYPES = {
      adts: 15,
      h264: 27
    }, ei = function() {
      var v = this, y = !1, g = {
        data: [],
        size: 0
      }, b = {
        data: [],
        size: 0
      }, w = {
        data: [],
        size: 0
      }, S, N = function(Y, te) {
        var ce, De = Y[0] << 16 | Y[1] << 8 | Y[2];
        te.data = new Uint8Array(), De === 1 && (te.packetLength = 6 + (Y[4] << 8 | Y[5]), te.dataAlignmentIndicator = (Y[6] & 4) !== 0, ce = Y[7], ce & 192 && (te.pts = (Y[9] & 14) << 27 | (Y[10] & 255) << 20 | (Y[11] & 254) << 12 | (Y[12] & 255) << 5 | (Y[13] & 254) >>> 3, te.pts *= 4, te.pts += (Y[13] & 6) >>> 1, te.dts = te.pts, ce & 64 && (te.dts = (Y[14] & 14) << 27 | (Y[15] & 255) << 20 | (Y[16] & 254) << 12 | (Y[17] & 255) << 5 | (Y[18] & 254) >>> 3, te.dts *= 4, te.dts += (Y[18] & 6) >>> 1)), te.data = Y.subarray(9 + Y[8]));
      }, q = function(Y, te, ce) {
        var De = new Uint8Array(Y.size), Ue = {
          type: te
        }, Ae = 0, $e = 0, Ai = !1, Ki;
        if (!(!Y.data.length || Y.size < 9)) {
          for (Ue.trackId = Y.data[0].pid, Ae = 0; Ae < Y.data.length; Ae++)
            Ki = Y.data[Ae], De.set(Ki.data, $e), $e += Ki.data.byteLength;
          N(De, Ue), Ai = te === "video" || Ue.packetLength <= Y.size, (ce || Ai) && (Y.size = 0, Y.data.length = 0), Ai && v.trigger("data", Ue);
        }
      };
      ei.prototype.init.call(this), this.push = function(Z) {
        ({
          pat: function() {
          },
          pes: function() {
            var te, ce;
            switch (Z.streamType) {
              case nt.H264_STREAM_TYPE:
                te = g, ce = "video";
                break;
              case nt.ADTS_STREAM_TYPE:
                te = b, ce = "audio";
                break;
              case nt.METADATA_STREAM_TYPE:
                te = w, ce = "timed-metadata";
                break;
              default:
                return;
            }
            Z.payloadUnitStartIndicator && q(te, ce, !0), te.data.push(Z), te.size += Z.data.byteLength;
          },
          pmt: function() {
            var te = {
              tracks: [],
              type: "metadata"
            };
            S = Z.programMapTable, S.video !== null && te.tracks.push({
              codec: "avc",
              id: +S.video,
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              type: "video"
            }), S.audio !== null && te.tracks.push({
              codec: "adts",
              id: +S.audio,
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              type: "audio"
            }), y = !0, v.trigger("data", te);
          }
        })[Z.type]();
      }, this.reset = function() {
        g.size = 0, g.data.length = 0, b.size = 0, b.data.length = 0, this.trigger("reset");
      }, this.flushStreams_ = function() {
        q(g, "video"), q(b, "audio"), q(w, "timed-metadata");
      }, this.flush = function() {
        if (!y && S) {
          var Z = {
            tracks: [],
            type: "metadata"
          };
          S.video !== null && Z.tracks.push({
            codec: "avc",
            id: +S.video,
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            type: "video"
          }), S.audio !== null && Z.tracks.push({
            codec: "adts",
            id: +S.audio,
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            type: "audio"
          }), v.trigger("data", Z);
        }
        y = !1, this.flushStreams_(), this.trigger("done");
      };
    }, ei.prototype = new t();
    var D = {
      CaptionStream: et.CaptionStream,
      Cea608Stream: et.Cea608Stream,
      Cea708Stream: et.Cea708Stream,
      ElementaryStream: ei,
      MP2T_PACKET_LENGTH: A,
      MetadataStream: aa,
      PAT_PID: 0,
      TimestampRolloverStream: It,
      TransportPacketStream: xs,
      TransportParseStream: sn
    };
    for (var L in nt)
      nt.hasOwnProperty(L) && (D[L] = nt[L]);
    var U = D, J = Ne.ONE_SECOND_IN_TS, re, me = [
      96e3,
      88200,
      64e3,
      48e3,
      44100,
      32e3,
      24e3,
      22050,
      16e3,
      12e3,
      11025,
      8e3,
      7350
    ];
    re = function(v) {
      var y, g = 0;
      re.prototype.init.call(this), this.skipWarn_ = function(b, w) {
        this.trigger("log", {
          level: "warn",
          message: "adts skiping bytes " + b + " to " + w + " in frame " + g + " outside syncword"
        });
      }, this.push = function(b) {
        var w = 0, S, N, q, Z, Y;
        if (v || (g = 0), b.type === "audio") {
          y && y.length ? (q = y, y = new Uint8Array(
            q.byteLength + b.data.byteLength
          ), y.set(q), y.set(b.data, q.byteLength)) : y = b.data;
          for (var te; w + 7 < y.length; ) {
            if (y[w] !== 255 || (y[w + 1] & 246) !== 240) {
              typeof te != "number" && (te = w), w++;
              continue;
            }
            if (typeof te == "number" && (this.skipWarn_(te, w), te = null), N = (~y[w + 1] & 1) * 2, S = (y[w + 3] & 3) << 11 | y[w + 4] << 3 | (y[w + 5] & 224) >> 5, Z = ((y[w + 6] & 3) + 1) * 1024, Y = Z * J / me[(y[w + 2] & 60) >>> 2], y.byteLength - w < S)
              break;
            this.trigger("data", {
              audioobjecttype: (y[w + 2] >>> 6 & 3) + 1,
              channelcount: (y[w + 2] & 1) << 2 | (y[w + 3] & 192) >>> 6,
              // data is the frame without it's header
              data: y.subarray(w + 7 + N, w + S),
              dts: b.dts + g * Y,
              pts: b.pts + g * Y,
              sampleCount: Z,
              samplerate: me[(y[w + 2] & 60) >>> 2],
              // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
              samplesize: 16,
              samplingfrequencyindex: (y[w + 2] & 60) >>> 2
            }), g++, w += S;
          }
          typeof te == "number" && (this.skipWarn_(te, w), te = null), y = y.subarray(w);
        }
      }, this.flush = function() {
        g = 0, this.trigger("done");
      }, this.reset = function() {
        y = void 0, this.trigger("reset");
      }, this.endTimeline = function() {
        y = void 0, this.trigger("endedtimeline");
      };
    }, re.prototype = new t();
    var ve = re, ne;
    ne = function(v) {
      var y = v.byteLength, g = 0, b = 0;
      this.length = function() {
        return 8 * y;
      }, this.bitsAvailable = function() {
        return 8 * y + b;
      }, this.loadWord = function() {
        var w = v.byteLength - y, S = new Uint8Array(4), N = Math.min(4, y);
        if (N === 0)
          throw new Error("no bytes available");
        S.set(
          v.subarray(w, w + N)
        ), g = new DataView(S.buffer).getUint32(0), b = N * 8, y -= N;
      }, this.skipBits = function(w) {
        var S;
        b > w ? (g <<= w, b -= w) : (w -= b, S = Math.floor(w / 8), w -= S * 8, y -= S, this.loadWord(), g <<= w, b -= w);
      }, this.readBits = function(w) {
        var S = Math.min(b, w), N = g >>> 32 - S;
        return b -= S, b > 0 ? g <<= S : y > 0 && this.loadWord(), S = w - S, S > 0 ? N << S | this.readBits(S) : N;
      }, this.skipLeadingZeros = function() {
        var w;
        for (w = 0; w < b; ++w)
          if (g & 2147483648 >>> w)
            return g <<= w, b -= w, w;
        return this.loadWord(), w + this.skipLeadingZeros();
      }, this.skipUnsignedExpGolomb = function() {
        this.skipBits(1 + this.skipLeadingZeros());
      }, this.skipExpGolomb = function() {
        this.skipBits(1 + this.skipLeadingZeros());
      }, this.readUnsignedExpGolomb = function() {
        var w = this.skipLeadingZeros();
        return this.readBits(w + 1) - 1;
      }, this.readExpGolomb = function() {
        var w = this.readUnsignedExpGolomb();
        return 1 & w ? 1 + w >>> 1 : -1 * (w >>> 1);
      }, this.readBoolean = function() {
        return this.readBits(1) === 1;
      }, this.readUnsignedByte = function() {
        return this.readBits(8);
      }, this.loadWord();
    };
    var le = ne, be, Ge, qe;
    Ge = function() {
      var v = 0, y, g;
      Ge.prototype.init.call(this), this.push = function(b) {
        var w;
        g ? (w = new Uint8Array(g.byteLength + b.data.byteLength), w.set(g), w.set(b.data, g.byteLength), g = w) : g = b.data;
        for (var S = g.byteLength; v < S - 3; v++)
          if (g[v + 2] === 1) {
            y = v + 5;
            break;
          }
        for (; y < S; )
          switch (g[y]) {
            case 0:
              if (g[y - 1] !== 0) {
                y += 2;
                break;
              } else if (g[y - 2] !== 0) {
                y++;
                break;
              }
              v + 3 !== y - 2 && this.trigger("data", g.subarray(v + 3, y - 2));
              do
                y++;
              while (g[y] !== 1 && y < S);
              v = y - 2, y += 3;
              break;
            case 1:
              if (g[y - 1] !== 0 || g[y - 2] !== 0) {
                y += 3;
                break;
              }
              this.trigger("data", g.subarray(v + 3, y - 2)), v = y - 2, y += 3;
              break;
            default:
              y += 3;
              break;
          }
        g = g.subarray(v), y -= v, v = 0;
      }, this.reset = function() {
        g = null, v = 0, this.trigger("reset");
      }, this.flush = function() {
        g && g.byteLength > 3 && this.trigger("data", g.subarray(v + 3)), g = null, v = 0, this.trigger("done");
      }, this.endTimeline = function() {
        this.flush(), this.trigger("endedtimeline");
      };
    }, Ge.prototype = new t(), qe = {
      100: !0,
      110: !0,
      118: !0,
      122: !0,
      128: !0,
      134: !0,
      // TODO: the three profiles below don't
      // appear to have sps data in the specificiation anymore?
      138: !0,
      139: !0,
      244: !0,
      44: !0,
      83: !0,
      86: !0
    }, be = function() {
      var v = new Ge(), y, g, b, w, S, N, q;
      be.prototype.init.call(this), y = this, this.push = function(Z) {
        Z.type === "video" && (g = Z.trackId, b = Z.pts, w = Z.dts, v.push(Z));
      }, v.on("data", function(Z) {
        var Y = {
          data: Z,
          dts: w,
          nalUnitTypeCode: Z[0] & 31,
          pts: b,
          trackId: g
        };
        switch (Y.nalUnitTypeCode) {
          case 5:
            Y.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
            break;
          case 6:
            Y.nalUnitType = "sei_rbsp", Y.escapedRBSP = S(
              Z.subarray(1)
            );
            break;
          case 7:
            Y.nalUnitType = "seq_parameter_set_rbsp", Y.escapedRBSP = S(
              Z.subarray(1)
            ), Y.config = N(Y.escapedRBSP);
            break;
          case 8:
            Y.nalUnitType = "pic_parameter_set_rbsp";
            break;
          case 9:
            Y.nalUnitType = "access_unit_delimiter_rbsp";
            break;
        }
        y.trigger("data", Y);
      }), v.on("done", function() {
        y.trigger("done");
      }), v.on("partialdone", function() {
        y.trigger("partialdone");
      }), v.on("reset", function() {
        y.trigger("reset");
      }), v.on("endedtimeline", function() {
        y.trigger("endedtimeline");
      }), this.flush = function() {
        v.flush();
      }, this.partialFlush = function() {
        v.partialFlush();
      }, this.reset = function() {
        v.reset();
      }, this.endTimeline = function() {
        v.endTimeline();
      }, q = function(Y, te) {
        var ce = 8, De = 8, Ue, Ae;
        for (Ue = 0; Ue < Y; Ue++)
          De !== 0 && (Ae = te.readExpGolomb(), De = (ce + Ae + 256) % 256), ce = De === 0 ? ce : De;
      }, S = function(Y) {
        for (var te = Y.byteLength, ce = [], De = 1, Ue, Ae; De < te - 2; )
          Y[De] === 0 && Y[De + 1] === 0 && Y[De + 2] === 3 ? (ce.push(De + 2), De += 2) : De++;
        if (ce.length === 0)
          return Y;
        Ue = te - ce.length, Ae = new Uint8Array(Ue);
        var $e = 0;
        for (De = 0; De < Ue; $e++, De++)
          $e === ce[0] && ($e++, ce.shift()), Ae[De] = Y[$e];
        return Ae;
      }, N = function(Y) {
        var te = 0, ce = 0, De = 0, Ue = 0, Ae, $e, Ai, Ki, Ca, zh, Cv, Mv, Dv, Wh, Pv, di = [1, 1], Lv, Ma;
        if (Ae = new le(Y), $e = Ae.readUnsignedByte(), Ki = Ae.readUnsignedByte(), Ai = Ae.readUnsignedByte(), Ae.skipUnsignedExpGolomb(), qe[$e] && (Ca = Ae.readUnsignedExpGolomb(), Ca === 3 && Ae.skipBits(1), Ae.skipUnsignedExpGolomb(), Ae.skipUnsignedExpGolomb(), Ae.skipBits(1), Ae.readBoolean()))
          for (Pv = Ca !== 3 ? 8 : 12, Ma = 0; Ma < Pv; Ma++)
            Ae.readBoolean() && (Ma < 6 ? q(16, Ae) : q(64, Ae));
        if (Ae.skipUnsignedExpGolomb(), zh = Ae.readUnsignedExpGolomb(), zh === 0)
          Ae.readUnsignedExpGolomb();
        else if (zh === 1)
          for (Ae.skipBits(1), Ae.skipExpGolomb(), Ae.skipExpGolomb(), Cv = Ae.readUnsignedExpGolomb(), Ma = 0; Ma < Cv; Ma++)
            Ae.skipExpGolomb();
        if (Ae.skipUnsignedExpGolomb(), Ae.skipBits(1), Mv = Ae.readUnsignedExpGolomb(), Dv = Ae.readUnsignedExpGolomb(), Wh = Ae.readBits(1), Wh === 0 && Ae.skipBits(1), Ae.skipBits(1), Ae.readBoolean() && (te = Ae.readUnsignedExpGolomb(), ce = Ae.readUnsignedExpGolomb(), De = Ae.readUnsignedExpGolomb(), Ue = Ae.readUnsignedExpGolomb()), Ae.readBoolean() && Ae.readBoolean()) {
          switch (Lv = Ae.readUnsignedByte(), Lv) {
            case 1:
              di = [1, 1];
              break;
            case 2:
              di = [12, 11];
              break;
            case 3:
              di = [10, 11];
              break;
            case 4:
              di = [16, 11];
              break;
            case 5:
              di = [40, 33];
              break;
            case 6:
              di = [24, 11];
              break;
            case 7:
              di = [20, 11];
              break;
            case 8:
              di = [32, 11];
              break;
            case 9:
              di = [80, 33];
              break;
            case 10:
              di = [18, 11];
              break;
            case 11:
              di = [15, 11];
              break;
            case 12:
              di = [64, 33];
              break;
            case 13:
              di = [160, 99];
              break;
            case 14:
              di = [4, 3];
              break;
            case 15:
              di = [3, 2];
              break;
            case 16:
              di = [2, 1];
              break;
            case 255: {
              di = [
                Ae.readUnsignedByte() << 8 | Ae.readUnsignedByte(),
                Ae.readUnsignedByte() << 8 | Ae.readUnsignedByte()
              ];
              break;
            }
          }
          di && di[0] / di[1];
        }
        return {
          height: (2 - Wh) * (Dv + 1) * 16 - De * 2 - Ue * 2,
          levelIdc: Ai,
          profileCompatibility: Ki,
          profileIdc: $e,
          // sar is sample aspect ratio
          sarRatio: di,
          width: (Mv + 1) * 16 - te * 2 - ce * 2
        };
      };
    }, be.prototype = new t();
    var rt = {
      H264Stream: be,
      NalByteStream: Ge
    }, At = [
      96e3,
      88200,
      64e3,
      48e3,
      44100,
      32e3,
      24e3,
      22050,
      16e3,
      12e3,
      11025,
      8e3,
      7350
    ], ot = function(v, y) {
      var g = v[y + 6] << 21 | v[y + 7] << 14 | v[y + 8] << 7 | v[y + 9], b = v[y + 5], w = (b & 16) >> 4;
      return g = g >= 0 ? g : 0, w ? g + 20 : g + 10;
    }, ut = function P(v, y) {
      return v.length - y < 10 || v[y] !== 73 || v[y + 1] !== 68 || v[y + 2] !== 51 ? y : (y += ot(v, y), P(v, y));
    }, Ht = function(v) {
      var y = ut(v, 0);
      return v.length >= y + 2 && (v[y] & 255) === 255 && (v[y + 1] & 240) === 240 && // verify that the 2 layer bits are 0, aka this
      // is not mp3 data but aac data.
      (v[y + 1] & 22) === 16;
    }, ni = function(v) {
      return v[0] << 21 | v[1] << 14 | v[2] << 7 | v[3];
    }, yi = function(v, y, g) {
      var b, w = "";
      for (b = y; b < g; b++)
        w += "%" + ("00" + v[b].toString(16)).slice(-2);
      return w;
    }, ti = function(v, y, g) {
      return unescape(yi(v, y, g));
    }, Mi = function(v, y) {
      var g = (v[y + 5] & 224) >> 5, b = v[y + 4] << 3, w = v[y + 3] & 6144;
      return w | b | g;
    }, qi = function(v, y) {
      return v[y] === 73 && v[y + 1] === 68 && v[y + 2] === 51 ? "timed-metadata" : v[y] & !0 && (v[y + 1] & 240) === 240 ? "audio" : null;
    }, Xi = function(v) {
      for (var y = 0; y + 5 < v.length; ) {
        if (v[y] !== 255 || (v[y + 1] & 246) !== 240) {
          y++;
          continue;
        }
        return At[(v[y + 2] & 60) >>> 2];
      }
      return null;
    }, Yi = function(v) {
      var y, g, b, w;
      y = 10, v[5] & 64 && (y += 4, y += ni(v.subarray(10, 14)));
      do {
        if (g = ni(
          v.subarray(y + 4, y + 8)
        ), g < 1)
          return null;
        if (w = String.fromCharCode(
          v[y],
          v[y + 1],
          v[y + 2],
          v[y + 3]
        ), w === "PRIV") {
          b = v.subarray(y + 10, y + g + 10);
          for (var S = 0; S < b.byteLength; S++)
            if (b[S] === 0) {
              var N = ti(b, 0, S);
              if (N === "com.apple.streaming.transportStreamTimestamp") {
                var q = b.subarray(S + 1), Z = (q[3] & 1) << 30 | q[4] << 22 | q[5] << 14 | q[6] << 6 | q[7] >>> 2;
                return Z *= 4, Z += q[7] & 3, Z;
              }
              break;
            }
        }
        y += 10, y += g;
      } while (y < v.byteLength);
      return null;
    }, Di = {
      isLikelyAacData: Ht,
      parseAacTimestamp: Yi,
      parseAdtsSize: Mi,
      parseId3TagSize: ot,
      parseSampleRate: Xi,
      parseType: qi
    }, br;
    br = function() {
      var v = new Uint8Array(), y = 0;
      br.prototype.init.call(this), this.setTimestamp = function(g) {
        y = g;
      }, this.push = function(g) {
        var b = 0, w = 0, S, N, q, Z;
        for (v.length ? (Z = v.length, v = new Uint8Array(g.byteLength + Z), v.set(v.subarray(0, Z)), v.set(g, Z)) : v = g; v.length - w >= 3; ) {
          if (v[w] === 73 && v[w + 1] === 68 && v[w + 2] === 51) {
            if (v.length - w < 10 || (b = Di.parseId3TagSize(v, w), w + b > v.length))
              break;
            N = {
              data: v.subarray(w, w + b),
              type: "timed-metadata"
            }, this.trigger("data", N), w += b;
            continue;
          } else if ((v[w] & 255) === 255 && (v[w + 1] & 240) === 240) {
            if (v.length - w < 7 || (b = Di.parseAdtsSize(v, w), w + b > v.length))
              break;
            q = {
              data: v.subarray(w, w + b),
              dts: y,
              pts: y,
              type: "audio"
            }, this.trigger("data", q), w += b;
            continue;
          }
          w++;
        }
        S = v.length - w, S > 0 ? v = v.subarray(w) : v = new Uint8Array();
      }, this.reset = function() {
        v = new Uint8Array(), this.trigger("reset");
      }, this.endTimeline = function() {
        v = new Uint8Array(), this.trigger("endedtimeline");
      };
    }, br.prototype = new t();
    var _a = br, ba = [
      "audioobjecttype",
      "channelcount",
      "samplerate",
      "samplingfrequencyindex",
      "samplesize"
    ], Sn = ba, xa = [
      "width",
      "height",
      "profileIdc",
      "levelIdc",
      "profileCompatibility",
      "sarRatio"
    ], Cn = xa, Aa = rt.H264Stream, Ta = Di.isLikelyAacData, Ea = Ne.ONE_SECOND_IN_TS, Ur, Lr, on, zt, w1 = function(v, y) {
      y.stream = v, this.trigger("log", y);
    }, hv = function(v, y) {
      for (var g = Object.keys(y), b = 0; b < g.length; b++) {
        var w = g[b];
        w === "headOfPipeline" || !y[w].on || y[w].on("log", w1.bind(v, w));
      }
    }, dv = function(v, y) {
      var g;
      if (v.length !== y.length)
        return !1;
      for (g = 0; g < v.length; g++)
        if (v[g] !== y[g])
          return !1;
      return !0;
    }, Gh = function(v, y, g, b, w, S) {
      var N = g - y, q = b - y, Z = w - g;
      return {
        baseMediaDecodeTime: v,
        end: {
          dts: v + q,
          pts: v + Z
        },
        prependedContentDuration: S,
        start: {
          dts: v,
          pts: v + N
        }
      };
    };
    Lr = function(v, y) {
      var g = [], b, w = 0, S = 0, N = 1 / 0;
      y = y || {}, b = y.firstSequenceNumber || 0, Lr.prototype.init.call(this), this.push = function(q) {
        xi.collectDtsInfo(v, q), v && Sn.forEach(function(Z) {
          v[Z] = q[Z];
        }), g.push(q);
      }, this.setEarliestDts = function(q) {
        w = q;
      }, this.setVideoBaseMediaDecodeTime = function(q) {
        N = q;
      }, this.setAudioAppendStart = function(q) {
        S = q;
      }, this.flush = function() {
        var q, Z, Y, te, ce, De, Ue;
        if (g.length === 0) {
          this.trigger("done", "AudioSegmentStream");
          return;
        }
        q = wt.trimAdtsFramesByEarliestDts(
          g,
          v,
          w
        ), v.baseMediaDecodeTime = xi.calculateTrackBaseMediaDecodeTime(
          v,
          y.keepOriginalTimestamps
        ), Ue = wt.prefixWithSilence(
          v,
          q,
          S,
          N
        ), v.samples = wt.generateSampleTable(q), Y = _e.mdat(wt.concatenateFrameData(q)), g = [], Z = _e.moof(b, [v]), te = new Uint8Array(Z.byteLength + Y.byteLength), b++, te.set(Z), te.set(Y, Z.byteLength), xi.clearDtsInfo(v), ce = Math.ceil(
          Ea * 1024 / v.samplerate
        ), q.length && (De = q.length * ce, this.trigger(
          "segmentTimingInfo",
          Gh(
            // The audio track's baseMediaDecodeTime is in audio clock cycles, but the
            // frame info is in video clock cycles. Convert to match expectation of
            // listeners (that all timestamps will be based on video clock cycles).
            Ne.audioTsToVideoTs(
              v.baseMediaDecodeTime,
              v.samplerate
            ),
            // frame times are already in video clock, as is segment duration
            q[0].dts,
            q[0].pts,
            q[0].dts + De,
            q[0].pts + De,
            Ue || 0
          )
        ), this.trigger("timingInfo", {
          end: q[0].pts + De,
          start: q[0].pts
        })), this.trigger("data", {
          boxes: te,
          track: v
        }), this.trigger("done", "AudioSegmentStream");
      }, this.reset = function() {
        xi.clearDtsInfo(v), g = [], this.trigger("reset");
      };
    }, Lr.prototype = new t(), Ur = function(v, y) {
      var g, b = [], w = [], S, N;
      y = y || {}, g = y.firstSequenceNumber || 0, Ur.prototype.init.call(this), delete v.minPTS, this.gopCache_ = [], this.push = function(q) {
        xi.collectDtsInfo(v, q), q.nalUnitType === "seq_parameter_set_rbsp" && !S && (S = q.config, v.sps = [q.data], Cn.forEach(function(Z) {
          v[Z] = S[Z];
        }, this)), q.nalUnitType === "pic_parameter_set_rbsp" && !N && (N = q.data, v.pps = [q.data]), b.push(q);
      }, this.flush = function() {
        for (var q, Z, Y, te, ce, De, Ue = 0, Ae, $e; b.length && b[0].nalUnitType !== "access_unit_delimiter_rbsp"; )
          b.shift();
        if (b.length === 0) {
          this.resetStream_(), this.trigger("done", "VideoSegmentStream");
          return;
        }
        if (q = jt.groupNalsIntoFrames(b), Y = jt.groupFramesIntoGops(q), Y[0][0].keyFrame || (Z = this.getGopForFusion_(b[0], v), Z ? (Ue = Z.duration, Y.unshift(Z), Y.byteLength += Z.byteLength, Y.nalCount += Z.nalCount, Y.pts = Z.pts, Y.dts = Z.dts, Y.duration += Z.duration) : Y = jt.extendFirstKeyFrame(Y)), w.length) {
          var Ai;
          if (y.alignGopsAtEnd ? Ai = this.alignGopsAtEnd_(Y) : Ai = this.alignGopsAtStart_(Y), !Ai) {
            this.gopCache_.unshift({
              gop: Y.pop(),
              pps: v.pps,
              sps: v.sps
            }), this.gopCache_.length = Math.min(6, this.gopCache_.length), b = [], this.resetStream_(), this.trigger("done", "VideoSegmentStream");
            return;
          }
          xi.clearDtsInfo(v), Y = Ai;
        }
        xi.collectDtsInfo(v, Y), v.samples = jt.generateSampleTable(Y), ce = _e.mdat(jt.concatenateNalData(Y)), v.baseMediaDecodeTime = xi.calculateTrackBaseMediaDecodeTime(
          v,
          y.keepOriginalTimestamps
        ), this.trigger(
          "processedGopsInfo",
          Y.map(function(Ki) {
            return {
              byteLength: Ki.byteLength,
              dts: Ki.dts,
              pts: Ki.pts
            };
          })
        ), Ae = Y[0], $e = Y[Y.length - 1], this.trigger(
          "segmentTimingInfo",
          Gh(
            v.baseMediaDecodeTime,
            Ae.dts,
            Ae.pts,
            $e.dts + $e.duration,
            $e.pts + $e.duration,
            Ue
          )
        ), this.trigger("timingInfo", {
          end: Y[Y.length - 1].pts + Y[Y.length - 1].duration,
          start: Y[0].pts
        }), this.gopCache_.unshift({
          gop: Y.pop(),
          pps: v.pps,
          sps: v.sps
        }), this.gopCache_.length = Math.min(6, this.gopCache_.length), b = [], this.trigger("baseMediaDecodeTime", v.baseMediaDecodeTime), this.trigger("timelineStartInfo", v.timelineStartInfo), te = _e.moof(g, [v]), De = new Uint8Array(te.byteLength + ce.byteLength), g++, De.set(te), De.set(ce, te.byteLength), this.trigger("data", {
          boxes: De,
          track: v
        }), this.resetStream_(), this.trigger("done", "VideoSegmentStream");
      }, this.reset = function() {
        this.resetStream_(), b = [], this.gopCache_.length = 0, w.length = 0, this.trigger("reset");
      }, this.resetStream_ = function() {
        xi.clearDtsInfo(v), S = void 0, N = void 0;
      }, this.getGopForFusion_ = function(q) {
        var Z = 45e3, Y = 1e4, te = 1 / 0, ce, De, Ue, Ae, $e;
        for ($e = 0; $e < this.gopCache_.length; $e++)
          Ae = this.gopCache_[$e], Ue = Ae.gop, !(!(v.pps && dv(v.pps[0], Ae.pps[0])) || !(v.sps && dv(v.sps[0], Ae.sps[0]))) && (Ue.dts < v.timelineStartInfo.dts || (ce = q.dts - Ue.dts - Ue.duration, ce >= -Y && ce <= Z && (!De || te > ce) && (De = Ae, te = ce)));
        return De ? De.gop : null;
      }, this.alignGopsAtStart_ = function(q) {
        var Z, Y, te, ce, De, Ue, Ae, $e;
        for (De = q.byteLength, Ue = q.nalCount, Ae = q.duration, Z = Y = 0; Z < w.length && Y < q.length && (te = w[Z], ce = q[Y], te.pts !== ce.pts); ) {
          if (ce.pts > te.pts) {
            Z++;
            continue;
          }
          Y++, De -= ce.byteLength, Ue -= ce.nalCount, Ae -= ce.duration;
        }
        return Y === 0 ? q : Y === q.length ? null : ($e = q.slice(Y), $e.byteLength = De, $e.duration = Ae, $e.nalCount = Ue, $e.pts = $e[0].pts, $e.dts = $e[0].dts, $e);
      }, this.alignGopsAtEnd_ = function(q) {
        var Z, Y, te, ce, De, Ue;
        for (Z = w.length - 1, Y = q.length - 1, De = null, Ue = !1; Z >= 0 && Y >= 0; ) {
          if (te = w[Z], ce = q[Y], te.pts === ce.pts) {
            Ue = !0;
            break;
          }
          if (te.pts > ce.pts) {
            Z--;
            continue;
          }
          Z === w.length - 1 && (De = Y), Y--;
        }
        if (!Ue && De === null)
          return null;
        var Ae;
        if (Ue ? Ae = Y : Ae = De, Ae === 0)
          return q;
        var $e = q.slice(Ae), Ai = $e.reduce(
          function(Ki, Ca) {
            return Ki.byteLength += Ca.byteLength, Ki.duration += Ca.duration, Ki.nalCount += Ca.nalCount, Ki;
          },
          {
            byteLength: 0,
            duration: 0,
            nalCount: 0
          }
        );
        return $e.byteLength = Ai.byteLength, $e.duration = Ai.duration, $e.nalCount = Ai.nalCount, $e.pts = $e[0].pts, $e.dts = $e[0].dts, $e;
      }, this.alignGopsWith = function(q) {
        w = q;
      };
    }, Ur.prototype = new t(), zt = function(v, y) {
      this.numberOfTracks = 0, this.metadataStream = y, v = v || {}, typeof v.remux < "u" ? this.remuxTracks = !!v.remux : this.remuxTracks = !0, typeof v.keepOriginalTimestamps == "boolean" ? this.keepOriginalTimestamps = v.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, zt.prototype.init.call(this), this.push = function(g) {
        if (g.text)
          return this.pendingCaptions.push(g);
        if (g.frames)
          return this.pendingMetadata.push(g);
        this.pendingTracks.push(g.track), this.pendingBytes += g.boxes.byteLength, g.track.type === "video" && (this.videoTrack = g.track, this.pendingBoxes.push(g.boxes)), g.track.type === "audio" && (this.audioTrack = g.track, this.pendingBoxes.unshift(g.boxes));
      };
    }, zt.prototype = new t(), zt.prototype.flush = function(P) {
      var v = 0, y = {
        captionStreams: {},
        captions: [],
        info: {},
        metadata: []
      }, g, b, w, S = 0, N;
      if (this.pendingTracks.length < this.numberOfTracks) {
        if (P !== "VideoSegmentStream" && P !== "AudioSegmentStream")
          return;
        if (this.remuxTracks)
          return;
        if (this.pendingTracks.length === 0) {
          this.emittedTracks++, this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
          return;
        }
      }
      if (this.videoTrack ? (S = this.videoTrack.timelineStartInfo.pts, Cn.forEach(function(q) {
        y.info[q] = this.videoTrack[q];
      }, this)) : this.audioTrack && (S = this.audioTrack.timelineStartInfo.pts, Sn.forEach(function(q) {
        y.info[q] = this.audioTrack[q];
      }, this)), this.videoTrack || this.audioTrack) {
        for (this.pendingTracks.length === 1 ? y.type = this.pendingTracks[0].type : y.type = "combined", this.emittedTracks += this.pendingTracks.length, w = _e.initSegment(this.pendingTracks), y.initSegment = new Uint8Array(w.byteLength), y.initSegment.set(w), y.data = new Uint8Array(this.pendingBytes), N = 0; N < this.pendingBoxes.length; N++)
          y.data.set(this.pendingBoxes[N], v), v += this.pendingBoxes[N].byteLength;
        for (N = 0; N < this.pendingCaptions.length; N++)
          g = this.pendingCaptions[N], g.startTime = Ne.metadataTsToSeconds(
            g.startPts,
            S,
            this.keepOriginalTimestamps
          ), g.endTime = Ne.metadataTsToSeconds(
            g.endPts,
            S,
            this.keepOriginalTimestamps
          ), y.captionStreams[g.stream] = !0, y.captions.push(g);
        for (N = 0; N < this.pendingMetadata.length; N++)
          b = this.pendingMetadata[N], b.cueTime = Ne.metadataTsToSeconds(
            b.pts,
            S,
            this.keepOriginalTimestamps
          ), y.metadata.push(b);
        for (y.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", y), N = 0; N < y.captions.length; N++)
          g = y.captions[N], this.trigger("caption", g);
        for (N = 0; N < y.metadata.length; N++)
          b = y.metadata[N], this.trigger("id3Frame", b);
      }
      this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
    }, zt.prototype.setRemux = function(P) {
      this.remuxTracks = P;
    }, on = function(v) {
      var y = this, g = !0, b, w;
      on.prototype.init.call(this), v = v || {}, this.baseMediaDecodeTime = v.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function() {
        var S = {};
        this.transmuxPipeline_ = S, S.type = "aac", S.metadataStream = new U.MetadataStream(), S.aacStream = new _a(), S.audioTimestampRolloverStream = new U.TimestampRolloverStream("audio"), S.timedMetadataTimestampRolloverStream = new U.TimestampRolloverStream("timed-metadata"), S.adtsStream = new ve(), S.coalesceStream = new zt(
          v,
          S.metadataStream
        ), S.headOfPipeline = S.aacStream, S.aacStream.pipe(S.audioTimestampRolloverStream).pipe(S.adtsStream), S.aacStream.pipe(S.timedMetadataTimestampRolloverStream).pipe(S.metadataStream).pipe(S.coalesceStream), S.metadataStream.on("timestamp", function(N) {
          S.aacStream.setTimestamp(N.timeStamp);
        }), S.aacStream.on("data", function(N) {
          N.type !== "timed-metadata" && N.type !== "audio" || S.audioSegmentStream || (w = w || {
            codec: "adts",
            timelineStartInfo: {
              baseMediaDecodeTime: y.baseMediaDecodeTime
            },
            type: "audio"
          }, S.coalesceStream.numberOfTracks++, S.audioSegmentStream = new Lr(
            w,
            v
          ), S.audioSegmentStream.on(
            "log",
            y.getLogTrigger_("audioSegmentStream")
          ), S.audioSegmentStream.on(
            "timingInfo",
            y.trigger.bind(y, "audioTimingInfo")
          ), S.adtsStream.pipe(S.audioSegmentStream).pipe(S.coalesceStream), y.trigger("trackinfo", {
            hasAudio: !!w,
            hasVideo: !!b
          }));
        }), S.coalesceStream.on("data", this.trigger.bind(this, "data")), S.coalesceStream.on("done", this.trigger.bind(this, "done")), hv(this, S);
      }, this.setupTsPipeline = function() {
        var S = {};
        this.transmuxPipeline_ = S, S.type = "ts", S.metadataStream = new U.MetadataStream(), S.packetStream = new U.TransportPacketStream(), S.parseStream = new U.TransportParseStream(), S.elementaryStream = new U.ElementaryStream(), S.timestampRolloverStream = new U.TimestampRolloverStream(), S.adtsStream = new ve(), S.h264Stream = new Aa(), S.captionStream = new U.CaptionStream(v), S.coalesceStream = new zt(
          v,
          S.metadataStream
        ), S.headOfPipeline = S.packetStream, S.packetStream.pipe(S.parseStream).pipe(S.elementaryStream).pipe(S.timestampRolloverStream), S.timestampRolloverStream.pipe(S.h264Stream), S.timestampRolloverStream.pipe(S.adtsStream), S.timestampRolloverStream.pipe(S.metadataStream).pipe(S.coalesceStream), S.h264Stream.pipe(S.captionStream).pipe(S.coalesceStream), S.elementaryStream.on("data", function(N) {
          var q;
          if (N.type === "metadata") {
            for (q = N.tracks.length; q--; )
              !b && N.tracks[q].type === "video" ? (b = N.tracks[q], b.timelineStartInfo.baseMediaDecodeTime = y.baseMediaDecodeTime) : !w && N.tracks[q].type === "audio" && (w = N.tracks[q], w.timelineStartInfo.baseMediaDecodeTime = y.baseMediaDecodeTime);
            b && !S.videoSegmentStream && (S.coalesceStream.numberOfTracks++, S.videoSegmentStream = new Ur(
              b,
              v
            ), S.videoSegmentStream.on(
              "log",
              y.getLogTrigger_("videoSegmentStream")
            ), S.videoSegmentStream.on(
              "timelineStartInfo",
              function(Z) {
                w && !v.keepOriginalTimestamps && (w.timelineStartInfo = Z, S.audioSegmentStream.setEarliestDts(
                  Z.dts - y.baseMediaDecodeTime
                ));
              }
            ), S.videoSegmentStream.on(
              "processedGopsInfo",
              y.trigger.bind(y, "gopInfo")
            ), S.videoSegmentStream.on(
              "segmentTimingInfo",
              y.trigger.bind(y, "videoSegmentTimingInfo")
            ), S.videoSegmentStream.on(
              "baseMediaDecodeTime",
              function(Z) {
                w && S.audioSegmentStream.setVideoBaseMediaDecodeTime(
                  Z
                );
              }
            ), S.videoSegmentStream.on(
              "timingInfo",
              y.trigger.bind(y, "videoTimingInfo")
            ), S.h264Stream.pipe(S.videoSegmentStream).pipe(S.coalesceStream)), w && !S.audioSegmentStream && (S.coalesceStream.numberOfTracks++, S.audioSegmentStream = new Lr(
              w,
              v
            ), S.audioSegmentStream.on(
              "log",
              y.getLogTrigger_("audioSegmentStream")
            ), S.audioSegmentStream.on(
              "timingInfo",
              y.trigger.bind(y, "audioTimingInfo")
            ), S.audioSegmentStream.on(
              "segmentTimingInfo",
              y.trigger.bind(y, "audioSegmentTimingInfo")
            ), S.adtsStream.pipe(S.audioSegmentStream).pipe(S.coalesceStream)), y.trigger("trackinfo", {
              hasAudio: !!w,
              hasVideo: !!b
            });
          }
        }), S.coalesceStream.on("data", this.trigger.bind(this, "data")), S.coalesceStream.on("id3Frame", function(N) {
          N.dispatchType = S.metadataStream.dispatchType, y.trigger("id3Frame", N);
        }), S.coalesceStream.on(
          "caption",
          this.trigger.bind(this, "caption")
        ), S.coalesceStream.on("done", this.trigger.bind(this, "done")), hv(this, S);
      }, this.setBaseMediaDecodeTime = function(S) {
        var N = this.transmuxPipeline_;
        v.keepOriginalTimestamps || (this.baseMediaDecodeTime = S), w && (w.timelineStartInfo.dts = void 0, w.timelineStartInfo.pts = void 0, xi.clearDtsInfo(w), N.audioTimestampRolloverStream && N.audioTimestampRolloverStream.discontinuity()), b && (N.videoSegmentStream && (N.videoSegmentStream.gopCache_ = []), b.timelineStartInfo.dts = void 0, b.timelineStartInfo.pts = void 0, xi.clearDtsInfo(b), N.captionStream.reset()), N.timestampRolloverStream && N.timestampRolloverStream.discontinuity();
      }, this.setAudioAppendStart = function(S) {
        w && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(
          S
        );
      }, this.setRemux = function(S) {
        var N = this.transmuxPipeline_;
        v.remux = S, N && N.coalesceStream && N.coalesceStream.setRemux(S);
      }, this.alignGopsWith = function(S) {
        b && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(
          S
        );
      }, this.getLogTrigger_ = function(S) {
        var N = this;
        return function(q) {
          q.stream = S, N.trigger("log", q);
        };
      }, this.push = function(S) {
        if (g) {
          var N = Ta(S);
          N && this.transmuxPipeline_.type !== "aac" ? this.setupAacPipeline() : !N && this.transmuxPipeline_.type !== "ts" && this.setupTsPipeline(), g = !1;
        }
        this.transmuxPipeline_.headOfPipeline.push(S);
      }, this.flush = function() {
        g = !0, this.transmuxPipeline_.headOfPipeline.flush();
      }, this.endTimeline = function() {
        this.transmuxPipeline_.headOfPipeline.endTimeline();
      }, this.reset = function() {
        this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset();
      }, this.resetCaptions = function() {
        this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset();
      };
    }, on.prototype = new t();
    var S1 = {
      AUDIO_PROPERTIES: Sn,
      AudioSegmentStream: Lr,
      Transmuxer: on,
      VIDEO_PROPERTIES: Cn,
      VideoSegmentStream: Ur,
      // exported for testing
      generateSegmentTimingInfo: Gh
    }, C1 = function(v) {
      return v >>> 0;
    }, M1 = function(v) {
      return ("00" + v.toString(16)).slice(-2);
    }, kl = {
      toHexString: M1,
      toUnsigned: C1
    }, D1 = function(v) {
      var y = "";
      return y += String.fromCharCode(v[0]), y += String.fromCharCode(v[1]), y += String.fromCharCode(v[2]), y += String.fromCharCode(v[3]), y;
    }, wa = D1, P1 = kl.toUnsigned, L1 = function P(v, y) {
      var g = [], b, w, S, N, q;
      if (!y.length)
        return null;
      for (b = 0; b < v.byteLength; )
        w = P1(
          v[b] << 24 | v[b + 1] << 16 | v[b + 2] << 8 | v[b + 3]
        ), S = wa(v.subarray(b + 4, b + 8)), N = w > 1 ? b + w : v.byteLength, S === y[0] && (y.length === 1 ? g.push(v.subarray(b + 8, N)) : (q = P(v.subarray(b + 8, N), y.slice(1)), q.length && (g = g.concat(q)))), b = N;
      return g;
    }, Qt = L1, R1 = kl.toUnsigned, I1 = r.getUint64, O1 = function(v) {
      var y = {
        flags: new Uint8Array(v.subarray(1, 4)),
        version: v[0]
      };
      return y.version === 1 ? y.baseMediaDecodeTime = I1(v.subarray(4)) : y.baseMediaDecodeTime = R1(
        v[4] << 24 | v[5] << 16 | v[6] << 8 | v[7]
      ), y;
    }, fv = O1, k1 = function(v) {
      return {
        degradationPriority: v[2] << 8 | v[3],
        dependsOn: v[0] & 3,
        hasRedundancy: (v[1] & 48) >>> 4,
        isDependedOn: (v[1] & 192) >>> 6,
        isLeading: (v[0] & 12) >>> 2,
        isNonSyncSample: v[1] & 1,
        paddingValue: (v[1] & 14) >>> 1
      };
    }, pv = k1, B1 = function(v) {
      var y = {
        flags: new Uint8Array(v.subarray(1, 4)),
        samples: [],
        version: v[0]
      }, g = new DataView(v.buffer, v.byteOffset, v.byteLength), b = y.flags[2] & 1, w = y.flags[2] & 4, S = y.flags[1] & 1, N = y.flags[1] & 2, q = y.flags[1] & 4, Z = y.flags[1] & 8, Y = g.getUint32(4), te = 8, ce;
      for (b && (y.dataOffset = g.getInt32(te), te += 4), w && Y && (ce = {
        flags: pv(v.subarray(te, te + 4))
      }, te += 4, S && (ce.duration = g.getUint32(te), te += 4), N && (ce.size = g.getUint32(te), te += 4), Z && (y.version === 1 ? ce.compositionTimeOffset = g.getInt32(te) : ce.compositionTimeOffset = g.getUint32(te), te += 4), y.samples.push(ce), Y--); Y--; )
        ce = {}, S && (ce.duration = g.getUint32(te), te += 4), N && (ce.size = g.getUint32(te), te += 4), q && (ce.flags = pv(v.subarray(te, te + 4)), te += 4), Z && (y.version === 1 ? ce.compositionTimeOffset = g.getInt32(te) : ce.compositionTimeOffset = g.getUint32(te), te += 4), y.samples.push(ce);
      return y;
    }, vv = B1, F1 = function(v) {
      var y = new DataView(v.buffer, v.byteOffset, v.byteLength), g = {
        flags: new Uint8Array(v.subarray(1, 4)),
        trackId: y.getUint32(4),
        version: v[0]
      }, b = g.flags[2] & 1, w = g.flags[2] & 2, S = g.flags[2] & 8, N = g.flags[2] & 16, q = g.flags[2] & 32, Z = g.flags[0] & 65536, Y = g.flags[0] & 131072, te;
      return te = 8, b && (te += 4, g.baseDataOffset = y.getUint32(12), te += 4), w && (g.sampleDescriptionIndex = y.getUint32(te), te += 4), S && (g.defaultSampleDuration = y.getUint32(te), te += 4), N && (g.defaultSampleSize = y.getUint32(te), te += 4), q && (g.defaultSampleFlags = y.getUint32(te)), Z && (g.durationIsEmpty = !0), !b && Y && (g.baseDataOffsetIsMoof = !0), g;
    }, mv = F1, gv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Wo;
    typeof window < "u" ? Wo = window : typeof gv < "u" ? Wo = gv : typeof self < "u" ? Wo = self : Wo = {};
    var qo = Wo, N1 = _r.discardEmulationPreventionBytes, U1 = et.CaptionStream, j1 = function(v, y) {
      for (var g = v, b = 0; b < y.length; b++) {
        var w = y[b];
        if (g < w.size)
          return w;
        g -= w.size;
      }
      return null;
    }, G1 = function(v, y, g) {
      var b = new DataView(
        v.buffer,
        v.byteOffset,
        v.byteLength
      ), w = {
        logs: [],
        seiNals: []
      }, S, N, q, Z;
      for (N = 0; N + 4 < v.length; N += q)
        if (q = b.getUint32(N), N += 4, !(q <= 0))
          switch (v[N] & 31) {
            case 6:
              var Y = v.subarray(N + 1, N + 1 + q), te = j1(N, y);
              if (S = {
                data: Y,
                escapedRBSP: N1(Y),
                nalUnitType: "sei_rbsp",
                size: q,
                trackId: g
              }, te)
                S.pts = te.pts, S.dts = te.dts, Z = te;
              else if (Z)
                S.pts = Z.pts, S.dts = Z.dts;
              else {
                w.logs.push({
                  level: "warn",
                  message: "We've encountered a nal unit without data at " + N + " for trackId " + g + ". See mux.js#223."
                });
                break;
              }
              w.seiNals.push(S);
              break;
          }
      return w;
    }, V1 = function(v, y, g) {
      var b = y, w = g.defaultSampleDuration || 0, S = g.defaultSampleSize || 0, N = g.trackId, q = [];
      return v.forEach(function(Z) {
        var Y = vv(Z), te = Y.samples;
        te.forEach(function(ce) {
          ce.duration === void 0 && (ce.duration = w), ce.size === void 0 && (ce.size = S), ce.trackId = N, ce.dts = b, ce.compositionTimeOffset === void 0 && (ce.compositionTimeOffset = 0), typeof b == "bigint" ? (ce.pts = b + qo.BigInt(ce.compositionTimeOffset), b += qo.BigInt(ce.duration)) : (ce.pts = b + ce.compositionTimeOffset, b += ce.duration);
        }), q = q.concat(te);
      }), q;
    }, H1 = function(v, y) {
      var g = Qt(v, ["moof", "traf"]), b = Qt(v, ["mdat"]), w = {}, S = [];
      return b.forEach(function(N, q) {
        var Z = g[q];
        S.push({
          mdat: N,
          traf: Z
        });
      }), S.forEach(function(N) {
        var q = N.mdat, Z = N.traf, Y = Qt(Z, ["tfhd"]), te = mv(Y[0]), ce = te.trackId, De = Qt(Z, ["tfdt"]), Ue = De.length > 0 ? fv(De[0]).baseMediaDecodeTime : 0, Ae = Qt(Z, ["trun"]), $e, Ai;
        y === ce && Ae.length > 0 && ($e = V1(Ae, Ue, te), Ai = G1(q, $e, ce), w[ce] || (w[ce] = {
          logs: [],
          seiNals: []
        }), w[ce].seiNals = w[ce].seiNals.concat(
          Ai.seiNals
        ), w[ce].logs = w[ce].logs.concat(
          Ai.logs
        ));
      }), w;
    }, z1 = function(v, y, g) {
      var b;
      if (y === null)
        return null;
      b = H1(v, y);
      var w = b[y] || {};
      return {
        logs: w.logs,
        seiNals: w.seiNals,
        timescale: g
      };
    }, W1 = function() {
      var v = !1, y, g, b, w, S, N;
      this.isInitialized = function() {
        return v;
      }, this.init = function(q) {
        y = new U1(), v = !0, N = q ? q.isPartial : !1, y.on("data", function(Z) {
          Z.startTime = Z.startPts / w, Z.endTime = Z.endPts / w, S.captions.push(Z), S.captionStreams[Z.stream] = !0;
        }), y.on("log", function(Z) {
          S.logs.push(Z);
        });
      }, this.isNewInit = function(q, Z) {
        return q && q.length === 0 || Z && typeof Z == "object" && Object.keys(Z).length === 0 ? !1 : b !== q[0] || w !== Z[b];
      }, this.parse = function(q, Z, Y) {
        var te;
        if (this.isInitialized()) {
          if (!Z || !Y)
            return null;
          if (this.isNewInit(Z, Y))
            b = Z[0], w = Y[b];
          else if (b === null || !w)
            return g.push(q), null;
        } else return null;
        for (; g.length > 0; ) {
          var ce = g.shift();
          this.parse(ce, Z, Y);
        }
        return te = z1(q, b, w), te && te.logs && (S.logs = S.logs.concat(te.logs)), te === null || !te.seiNals ? S.logs.length ? {
          captionStreams: [],
          captions: [],
          logs: S.logs
        } : null : (this.pushNals(te.seiNals), this.flushStream(), S);
      }, this.pushNals = function(q) {
        if (!this.isInitialized() || !q || q.length === 0)
          return null;
        q.forEach(function(Z) {
          y.push(Z);
        });
      }, this.flushStream = function() {
        if (!this.isInitialized())
          return null;
        N ? y.partialFlush() : y.flush();
      }, this.clearParsedCaptions = function() {
        S.captions = [], S.captionStreams = {}, S.logs = [];
      }, this.resetCaptionStream = function() {
        if (!this.isInitialized())
          return null;
        y.reset();
      }, this.clearAllCaptions = function() {
        this.clearParsedCaptions(), this.resetCaptionStream();
      }, this.reset = function() {
        g = [], b = null, w = null, S ? this.clearParsedCaptions() : S = {
          // CC1, CC2, CC3, CC4
          captionStreams: {},
          captions: [],
          logs: []
        }, this.resetCaptionStream();
      }, this.reset();
    }, q1 = W1, Bl = kl.toUnsigned, Xo = kl.toHexString, X1 = r.getUint64, yv, _v, bv, xv, Av, Vh;
    yv = function(v) {
      var y = {}, g = Qt(v, ["moov", "trak"]);
      return g.reduce(function(b, w) {
        var S, N, q, Z, Y;
        return S = Qt(w, ["tkhd"])[0], !S || (N = S[0], q = N === 0 ? 12 : 20, Z = Bl(
          S[q] << 24 | S[q + 1] << 16 | S[q + 2] << 8 | S[q + 3]
        ), Y = Qt(w, ["mdia", "mdhd"])[0], !Y) ? null : (N = Y[0], q = N === 0 ? 12 : 20, b[Z] = Bl(
          Y[q] << 24 | Y[q + 1] << 16 | Y[q + 2] << 8 | Y[q + 3]
        ), b);
      }, y);
    }, _v = function(v, y) {
      var g;
      g = Qt(y, ["moof", "traf"]);
      var b = g.reduce(function(w, S) {
        var N = Qt(S, ["tfhd"])[0], q = Bl(
          N[4] << 24 | N[5] << 16 | N[6] << 8 | N[7]
        ), Z = v[q] || 9e4, Y = Qt(S, ["tfdt"])[0], te = new DataView(Y.buffer, Y.byteOffset, Y.byteLength), ce;
        Y[0] === 1 ? ce = X1(Y.subarray(4, 12)) : ce = te.getUint32(4);
        var De;
        return typeof ce == "bigint" ? De = ce / qo.BigInt(Z) : typeof ce == "number" && !isNaN(ce) && (De = ce / Z), De < Number.MAX_SAFE_INTEGER && (De = Number(De)), De < w && (w = De), w;
      }, 1 / 0);
      return typeof b == "bigint" || isFinite(b) ? b : 0;
    }, bv = function(v, y) {
      var g = Qt(y, ["moof", "traf"]), b = 0, w = 0, S;
      if (g && g.length) {
        var N = Qt(g[0], ["tfhd"])[0], q = Qt(g[0], ["trun"])[0], Z = Qt(g[0], ["tfdt"])[0];
        if (N) {
          var Y = mv(N);
          S = Y.trackId;
        }
        if (Z) {
          var te = fv(Z);
          b = te.baseMediaDecodeTime;
        }
        if (q) {
          var ce = vv(q);
          ce.samples && ce.samples.length && (w = ce.samples[0].compositionTimeOffset || 0);
        }
      }
      var De = v[S] || 9e4;
      typeof b == "bigint" && (w = qo.BigInt(w), De = qo.BigInt(De));
      var Ue = (b + w) / De;
      return typeof Ue == "bigint" && Ue < Number.MAX_SAFE_INTEGER && (Ue = Number(Ue)), Ue;
    }, xv = function(v) {
      var y = Qt(v, ["moov", "trak"]), g = [];
      return y.forEach(function(b) {
        var w = Qt(b, ["mdia", "hdlr"]), S = Qt(b, ["tkhd"]);
        w.forEach(function(N, q) {
          var Z = wa(N.subarray(8, 12)), Y = S[q], te, ce, De;
          Z === "vide" && (te = new DataView(Y.buffer, Y.byteOffset, Y.byteLength), ce = te.getUint8(0), De = ce === 0 ? te.getUint32(12) : te.getUint32(20), g.push(De));
        });
      }), g;
    }, Vh = function(v) {
      var y = v[0], g = y === 0 ? 12 : 20;
      return Bl(
        v[g] << 24 | v[g + 1] << 16 | v[g + 2] << 8 | v[g + 3]
      );
    }, Av = function(v) {
      var y = Qt(v, ["moov", "trak"]), g = [];
      return y.forEach(function(b) {
        var w = {}, S = Qt(b, ["tkhd"])[0], N, q;
        S && (N = new DataView(S.buffer, S.byteOffset, S.byteLength), q = N.getUint8(0), w.id = q === 0 ? N.getUint32(12) : N.getUint32(20));
        var Z = Qt(b, ["mdia", "hdlr"])[0];
        if (Z) {
          var Y = wa(Z.subarray(8, 12));
          Y === "vide" ? w.type = "video" : Y === "soun" ? w.type = "audio" : w.type = Y;
        }
        var te = Qt(b, ["mdia", "minf", "stbl", "stsd"])[0];
        if (te) {
          var ce = te.subarray(8);
          w.codec = wa(ce.subarray(4, 8));
          var De = Qt(ce, [w.codec])[0], Ue, Ae;
          De && (/^[asm]vc[1-9]$/i.test(w.codec) ? (Ue = De.subarray(78), Ae = wa(Ue.subarray(4, 8)), Ae === "avcC" && Ue.length > 11 ? (w.codec += ".", w.codec += Xo(Ue[9]), w.codec += Xo(Ue[10]), w.codec += Xo(Ue[11])) : w.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(w.codec) ? (Ue = De.subarray(28), Ae = wa(Ue.subarray(4, 8)), Ae === "esds" && Ue.length > 20 && Ue[19] !== 0 ? (w.codec += "." + Xo(Ue[19]), w.codec += "." + Xo(Ue[20] >>> 2 & 63).replace(/^0/, "")) : w.codec = "mp4a.40.2") : w.codec = w.codec.toLowerCase());
        }
        var $e = Qt(b, ["mdia", "mdhd"])[0];
        $e && (w.timescale = Vh($e)), g.push(w);
      }), g;
    };
    var Tv = {
      compositionStartTime: bv,
      // export mp4 inspector's findBox and parseType for backwards compatibility
      findBox: Qt,
      getTimescaleFromMediaHeader: Vh,
      parseType: wa,
      startTime: _v,
      timescale: yv,
      tracks: Av,
      videoTrackIds: xv
    }, Ev = function(v) {
      var y = v[1] & 31;
      return y <<= 8, y |= v[2], y;
    }, Fl = function(v) {
      return !!(v[1] & 64);
    }, Nl = function(v) {
      var y = 0;
      return (v[3] & 48) >>> 4 > 1 && (y += v[4] + 1), y;
    }, Y1 = function(v, y) {
      var g = Ev(v);
      return g === 0 ? "pat" : g === y ? "pmt" : y ? "pes" : null;
    }, Q1 = function(v) {
      var y = Fl(v), g = 4 + Nl(v);
      return y && (g += v[g] + 1), (v[g + 10] & 31) << 8 | v[g + 11];
    }, K1 = function(v) {
      var y = {}, g = Fl(v), b = 4 + Nl(v);
      if (g && (b += v[b] + 1), !!(v[b + 5] & 1)) {
        var w, S, N;
        w = (v[b + 1] & 15) << 8 | v[b + 2], S = 3 + w - 4, N = (v[b + 10] & 15) << 8 | v[b + 11];
        for (var q = 12 + N; q < S; ) {
          var Z = b + q;
          y[(v[Z + 1] & 31) << 8 | v[Z + 2]] = v[Z], q += ((v[Z + 3] & 15) << 8 | v[Z + 4]) + 5;
        }
        return y;
      }
    }, Z1 = function(v, y) {
      var g = Ev(v), b = y[g];
      switch (b) {
        case nt.H264_STREAM_TYPE:
          return "video";
        case nt.ADTS_STREAM_TYPE:
          return "audio";
        case nt.METADATA_STREAM_TYPE:
          return "timed-metadata";
        default:
          return null;
      }
    }, J1 = function(v) {
      var y = Fl(v);
      if (!y)
        return null;
      var g = 4 + Nl(v);
      if (g >= v.byteLength)
        return null;
      var b = null, w;
      return w = v[g + 7], w & 192 && (b = {}, b.pts = (v[g + 9] & 14) << 27 | (v[g + 10] & 255) << 20 | (v[g + 11] & 254) << 12 | (v[g + 12] & 255) << 5 | (v[g + 13] & 254) >>> 3, b.pts *= 4, b.pts += (v[g + 13] & 6) >>> 1, b.dts = b.pts, w & 64 && (b.dts = (v[g + 14] & 14) << 27 | (v[g + 15] & 255) << 20 | (v[g + 16] & 254) << 12 | (v[g + 17] & 255) << 5 | (v[g + 18] & 254) >>> 3, b.dts *= 4, b.dts += (v[g + 18] & 6) >>> 1)), b;
    }, Hh = function(v) {
      switch (v) {
        case 5:
          return "slice_layer_without_partitioning_rbsp_idr";
        case 6:
          return "sei_rbsp";
        case 7:
          return "seq_parameter_set_rbsp";
        case 8:
          return "pic_parameter_set_rbsp";
        case 9:
          return "access_unit_delimiter_rbsp";
        default:
          return null;
      }
    }, $1 = function(v) {
      for (var y = 4 + Nl(v), g = v.subarray(y), b = 0, w = 0, S = !1, N; w < g.byteLength - 3; w++)
        if (g[w + 2] === 1) {
          b = w + 5;
          break;
        }
      for (; b < g.byteLength; )
        switch (g[b]) {
          case 0:
            if (g[b - 1] !== 0) {
              b += 2;
              break;
            } else if (g[b - 2] !== 0) {
              b++;
              break;
            }
            w + 3 !== b - 2 && (N = Hh(
              g[w + 3] & 31
            ), N === "slice_layer_without_partitioning_rbsp_idr" && (S = !0));
            do
              b++;
            while (g[b] !== 1 && b < g.length);
            w = b - 2, b += 3;
            break;
          case 1:
            if (g[b - 1] !== 0 || g[b - 2] !== 0) {
              b += 3;
              break;
            }
            N = Hh(g[w + 3] & 31), N === "slice_layer_without_partitioning_rbsp_idr" && (S = !0), w = b - 2, b += 3;
            break;
          default:
            b += 3;
            break;
        }
      return g = g.subarray(w), b -= w, w = 0, g && g.byteLength > 3 && (N = Hh(g[w + 3] & 31), N === "slice_layer_without_partitioning_rbsp_idr" && (S = !0)), S;
    }, ex = {
      parsePat: Q1,
      parsePayloadUnitStartIndicator: Fl,
      parsePesTime: J1,
      parsePesType: Z1,
      parsePmt: K1,
      parseType: Y1,
      videoPacketContainsKeyFrame: $1
    }, As = $t.handleRollover, Bt = {};
    Bt.ts = ex, Bt.aac = Di;
    var Sa = Ne.ONE_SECOND_IN_TS, Qi = 188, un = 71, tx = function(v, y) {
      for (var g = 0, b = Qi, w, S; b < v.byteLength; ) {
        if (v[g] === un && v[b] === un) {
          switch (w = v.subarray(g, b), S = Bt.ts.parseType(w, y.pid), S) {
            case "pat":
              y.pid = Bt.ts.parsePat(w);
              break;
            case "pmt":
              var N = Bt.ts.parsePmt(w);
              y.table = y.table || {}, Object.keys(N).forEach(function(q) {
                y.table[q] = N[q];
              });
              break;
          }
          g += Qi, b += Qi;
          continue;
        }
        g++, b++;
      }
    }, wv = function(v, y, g) {
      for (var b = 0, w = Qi, S, N, q, Z, Y, te = !1; w <= v.byteLength; ) {
        if (v[b] === un && (v[w] === un || w === v.byteLength)) {
          switch (S = v.subarray(b, w), N = Bt.ts.parseType(S, y.pid), N) {
            case "pes":
              q = Bt.ts.parsePesType(S, y.table), Z = Bt.ts.parsePayloadUnitStartIndicator(S), q === "audio" && Z && (Y = Bt.ts.parsePesTime(S), Y && (Y.type = "audio", g.audio.push(Y), te = !0));
              break;
          }
          if (te)
            break;
          b += Qi, w += Qi;
          continue;
        }
        b++, w++;
      }
      for (w = v.byteLength, b = w - Qi, te = !1; b >= 0; ) {
        if (v[b] === un && (v[w] === un || w === v.byteLength)) {
          switch (S = v.subarray(b, w), N = Bt.ts.parseType(S, y.pid), N) {
            case "pes":
              q = Bt.ts.parsePesType(S, y.table), Z = Bt.ts.parsePayloadUnitStartIndicator(S), q === "audio" && Z && (Y = Bt.ts.parsePesTime(S), Y && (Y.type = "audio", g.audio.push(Y), te = !0));
              break;
          }
          if (te)
            break;
          b -= Qi, w -= Qi;
          continue;
        }
        b--, w--;
      }
    }, ix = function(v, y, g) {
      for (var b = 0, w = Qi, S, N, q, Z, Y, te, ce, De, Ue = !1, Ae = {
        data: [],
        size: 0
      }; w < v.byteLength; ) {
        if (v[b] === un && v[w] === un) {
          switch (S = v.subarray(b, w), N = Bt.ts.parseType(S, y.pid), N) {
            case "pes":
              if (q = Bt.ts.parsePesType(S, y.table), Z = Bt.ts.parsePayloadUnitStartIndicator(S), q === "video" && (Z && !Ue && (Y = Bt.ts.parsePesTime(S), Y && (Y.type = "video", g.video.push(Y), Ue = !0)), !g.firstKeyFrame)) {
                if (Z && Ae.size !== 0) {
                  for (te = new Uint8Array(Ae.size), ce = 0; Ae.data.length; )
                    De = Ae.data.shift(), te.set(De, ce), ce += De.byteLength;
                  if (Bt.ts.videoPacketContainsKeyFrame(te)) {
                    var $e = Bt.ts.parsePesTime(te);
                    $e ? (g.firstKeyFrame = $e, g.firstKeyFrame.type = "video") : console.warn(
                      "Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself."
                    );
                  }
                  Ae.size = 0;
                }
                Ae.data.push(S), Ae.size += S.byteLength;
              }
              break;
          }
          if (Ue && g.firstKeyFrame)
            break;
          b += Qi, w += Qi;
          continue;
        }
        b++, w++;
      }
      for (w = v.byteLength, b = w - Qi, Ue = !1; b >= 0; ) {
        if (v[b] === un && v[w] === un) {
          switch (S = v.subarray(b, w), N = Bt.ts.parseType(S, y.pid), N) {
            case "pes":
              q = Bt.ts.parsePesType(S, y.table), Z = Bt.ts.parsePayloadUnitStartIndicator(S), q === "video" && Z && (Y = Bt.ts.parsePesTime(S), Y && (Y.type = "video", g.video.push(Y), Ue = !0));
              break;
          }
          if (Ue)
            break;
          b -= Qi, w -= Qi;
          continue;
        }
        b--, w--;
      }
    }, rx = function(v, y) {
      if (v.audio && v.audio.length) {
        var g = y;
        (typeof g > "u" || isNaN(g)) && (g = v.audio[0].dts), v.audio.forEach(function(S) {
          S.dts = As(S.dts, g), S.pts = As(S.pts, g), S.dtsTime = S.dts / Sa, S.ptsTime = S.pts / Sa;
        });
      }
      if (v.video && v.video.length) {
        var b = y;
        if ((typeof b > "u" || isNaN(b)) && (b = v.video[0].dts), v.video.forEach(function(S) {
          S.dts = As(S.dts, b), S.pts = As(S.pts, b), S.dtsTime = S.dts / Sa, S.ptsTime = S.pts / Sa;
        }), v.firstKeyFrame) {
          var w = v.firstKeyFrame;
          w.dts = As(w.dts, b), w.pts = As(w.pts, b), w.dtsTime = w.dts / Sa, w.ptsTime = w.pts / Sa;
        }
      }
    }, nx = function(v) {
      for (var y = !1, g = 0, b = null, w = null, S = 0, N = 0, q; v.length - N >= 3; ) {
        var Z = Bt.aac.parseType(v, N);
        switch (Z) {
          case "timed-metadata":
            if (v.length - N < 10) {
              y = !0;
              break;
            }
            if (S = Bt.aac.parseId3TagSize(v, N), S > v.length) {
              y = !0;
              break;
            }
            w === null && (q = v.subarray(N, N + S), w = Bt.aac.parseAacTimestamp(q)), N += S;
            break;
          case "audio":
            if (v.length - N < 7) {
              y = !0;
              break;
            }
            if (S = Bt.aac.parseAdtsSize(v, N), S > v.length) {
              y = !0;
              break;
            }
            b === null && (q = v.subarray(N, N + S), b = Bt.aac.parseSampleRate(q)), g++, N += S;
            break;
          default:
            N++;
            break;
        }
        if (y)
          return null;
      }
      if (b === null || w === null)
        return null;
      var Y = Sa / b, te = {
        audio: [
          {
            dts: w,
            pts: w,
            type: "audio"
          },
          {
            dts: w + g * 1024 * Y,
            pts: w + g * 1024 * Y,
            type: "audio"
          }
        ]
      };
      return te;
    }, ax = function(v) {
      var y = {
        pid: null,
        table: null
      }, g = {};
      tx(v, y);
      for (var b in y.table)
        if (y.table.hasOwnProperty(b)) {
          var w = y.table[b];
          switch (w) {
            case nt.H264_STREAM_TYPE:
              g.video = [], ix(v, y, g), g.video.length === 0 && delete g.video;
              break;
            case nt.ADTS_STREAM_TYPE:
              g.audio = [], wv(v, y, g), g.audio.length === 0 && delete g.audio;
              break;
          }
        }
      return g;
    }, sx = function(v, y) {
      var g = Bt.aac.isLikelyAacData(v), b;
      return g ? b = nx(v) : b = ax(v), !b || !b.audio && !b.video ? null : (rx(b, y), b);
    }, ox = {
      inspect: sx,
      parseAudioPes_: wv
    }, ux = function(v, y) {
      y.on("data", function(g) {
        var b = g.initSegment;
        g.initSegment = {
          byteLength: b.byteLength,
          byteOffset: b.byteOffset,
          data: b.buffer
        };
        var w = g.data;
        g.data = w.buffer, v.postMessage(
          {
            action: "data",
            byteLength: w.byteLength,
            byteOffset: w.byteOffset,
            segment: g
          },
          [g.data]
        );
      }), y.on("done", function(g) {
        v.postMessage({
          action: "done"
        });
      }), y.on("gopInfo", function(g) {
        v.postMessage({
          action: "gopInfo",
          gopInfo: g
        });
      }), y.on("videoSegmentTimingInfo", function(g) {
        var b = {
          baseMediaDecodeTime: Ne.videoTsToSeconds(
            g.baseMediaDecodeTime
          ),
          end: {
            decode: Ne.videoTsToSeconds(g.end.dts),
            presentation: Ne.videoTsToSeconds(g.end.pts)
          },
          start: {
            decode: Ne.videoTsToSeconds(g.start.dts),
            presentation: Ne.videoTsToSeconds(g.start.pts)
          }
        };
        g.prependedContentDuration && (b.prependedContentDuration = Ne.videoTsToSeconds(g.prependedContentDuration)), v.postMessage({
          action: "videoSegmentTimingInfo",
          videoSegmentTimingInfo: b
        });
      }), y.on("audioSegmentTimingInfo", function(g) {
        var b = {
          baseMediaDecodeTime: Ne.videoTsToSeconds(
            g.baseMediaDecodeTime
          ),
          end: {
            decode: Ne.videoTsToSeconds(g.end.dts),
            presentation: Ne.videoTsToSeconds(g.end.pts)
          },
          start: {
            decode: Ne.videoTsToSeconds(g.start.dts),
            presentation: Ne.videoTsToSeconds(g.start.pts)
          }
        };
        g.prependedContentDuration && (b.prependedContentDuration = Ne.videoTsToSeconds(g.prependedContentDuration)), v.postMessage({
          action: "audioSegmentTimingInfo",
          audioSegmentTimingInfo: b
        });
      }), y.on("id3Frame", function(g) {
        v.postMessage({
          action: "id3Frame",
          id3Frame: g
        });
      }), y.on("caption", function(g) {
        v.postMessage({
          action: "caption",
          caption: g
        });
      }), y.on("trackinfo", function(g) {
        v.postMessage({
          action: "trackinfo",
          trackInfo: g
        });
      }), y.on("audioTimingInfo", function(g) {
        v.postMessage({
          action: "audioTimingInfo",
          audioTimingInfo: {
            end: Ne.videoTsToSeconds(g.end),
            start: Ne.videoTsToSeconds(g.start)
          }
        });
      }), y.on("videoTimingInfo", function(g) {
        v.postMessage({
          action: "videoTimingInfo",
          videoTimingInfo: {
            end: Ne.videoTsToSeconds(g.end),
            start: Ne.videoTsToSeconds(g.start)
          }
        });
      }), y.on("log", function(g) {
        v.postMessage({
          action: "log",
          log: g
        });
      });
    }, Sv = /* @__PURE__ */ function() {
      function P(y, g) {
        this.options = g || {}, this.self = y, this.init();
      }
      var v = P.prototype;
      return v.init = function() {
        this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new S1.Transmuxer(this.options), ux(this.self, this.transmuxer);
      }, v.pushMp4Captions = function(g) {
        this.captionParser || (this.captionParser = new q1(), this.captionParser.init());
        var b = new Uint8Array(
          g.data,
          g.byteOffset,
          g.byteLength
        ), w = this.captionParser.parse(
          b,
          g.trackIds,
          g.timescales
        );
        this.self.postMessage(
          {
            action: "mp4Captions",
            captions: w && w.captions || [],
            data: b.buffer,
            logs: w && w.logs || []
          },
          [b.buffer]
        );
      }, v.probeMp4StartTime = function(g) {
        var b = g.timescales, w = g.data, S = Tv.startTime(b, w);
        this.self.postMessage(
          {
            action: "probeMp4StartTime",
            data: w,
            startTime: S
          },
          [w.buffer]
        );
      }, v.probeMp4Tracks = function(g) {
        var b = g.data, w = Tv.tracks(b);
        this.self.postMessage(
          {
            action: "probeMp4Tracks",
            data: b,
            tracks: w
          },
          [b.buffer]
        );
      }, v.probeTs = function(g) {
        var b = g.data, w = g.baseStartTime, S = typeof w == "number" && !isNaN(w) ? w * Ne.ONE_SECOND_IN_TS : void 0, N = ox.inspect(b, S), q = null;
        N && (q = {
          hasAudio: N.audio && N.audio.length === 2 || !1,
          // each type's time info comes back as an array of 2 times, start and end
          hasVideo: N.video && N.video.length === 2 || !1
        }, q.hasVideo && (q.videoStart = N.video[0].ptsTime), q.hasAudio && (q.audioStart = N.audio[0].ptsTime)), this.self.postMessage(
          {
            action: "probeTs",
            data: b,
            result: q
          },
          [b.buffer]
        );
      }, v.clearAllMp4Captions = function() {
        this.captionParser && this.captionParser.clearAllCaptions();
      }, v.clearParsedMp4Captions = function() {
        this.captionParser && this.captionParser.clearParsedCaptions();
      }, v.push = function(g) {
        var b = new Uint8Array(
          g.data,
          g.byteOffset,
          g.byteLength
        );
        this.transmuxer.push(b);
      }, v.reset = function() {
        this.transmuxer.reset();
      }, v.setTimestampOffset = function(g) {
        var b = g.timestampOffset || 0;
        this.transmuxer.setBaseMediaDecodeTime(
          Math.round(Ne.secondsToVideoTs(b))
        );
      }, v.setAudioAppendStart = function(g) {
        this.transmuxer.setAudioAppendStart(
          Math.ceil(Ne.secondsToVideoTs(g.appendStart))
        );
      }, v.setRemux = function(g) {
        this.transmuxer.setRemux(g.remux);
      }, v.flush = function(g) {
        this.transmuxer.flush(), self.postMessage({
          action: "done",
          type: "transmuxed"
        });
      }, v.endTimeline = function() {
        this.transmuxer.endTimeline(), self.postMessage({
          action: "endedtimeline",
          type: "transmuxed"
        });
      }, v.alignGopsWith = function(g) {
        this.transmuxer.alignGopsWith(g.gopsToAlignWith.slice());
      }, P;
    }();
    self.onmessage = function(P) {
      if (P.data.action === "init" && P.data.options) {
        this.messageHandlers = new Sv(self, P.data.options);
        return;
      }
      this.messageHandlers || (this.messageHandlers = new Sv(self)), P.data && P.data.action && P.data.action !== "init" && this.messageHandlers[P.data.action] && this.messageHandlers[P.data.action](P.data);
    };
  })
), DD = i1(MD), PD = function(t, i, n) {
  var r = t.data.segment, a = r.type, s = r.initSegment, o = r.captions, u = r.captionStreams, l = r.metadata, c = r.videoFrameDtsTime, h = r.videoFramePtsTime;
  i.buffer.push({
    captionStreams: u,
    captions: o,
    metadata: l
  });
  var d = t.data.segment.boxes || {
    data: t.data.segment.data
  }, f = {
    // cast ArrayBuffer to TypedArray
    data: new Uint8Array(
      d.data,
      d.data.byteOffset,
      d.data.byteLength
    ),
    initSegment: new Uint8Array(
      s.data,
      s.byteOffset,
      s.byteLength
    ),
    type: a
  };
  typeof c < "u" && (f.videoFrameDtsTime = c), typeof h < "u" && (f.videoFramePtsTime = h), n(f);
}, LD = function(t) {
  var i = t.transmuxedData, n = t.callback;
  i.buffer = [], n(i);
}, RD = function(t, i) {
  i.gopInfo = t.data.gopInfo;
}, a1 = function(t) {
  var i = t.transmuxer, n = t.bytes, r = t.audioAppendStart, a = t.gopsToAlignWith, s = t.remux, o = t.onData, u = t.onTrackInfo, l = t.onAudioTimingInfo, c = t.onVideoTimingInfo, h = t.onVideoSegmentTimingInfo, d = t.onAudioSegmentTimingInfo, f = t.onId3, p = t.onCaptions, _ = t.onDone, m = t.onEndedTimeline, x = t.onTransmuxerLog, E = t.isEndOfTimeline, M = {
    buffer: []
  }, C = E, R = function(I) {
    i.currentTransmux === t && (I.data.action === "data" && PD(I, M, o), I.data.action === "trackinfo" && u(I.data.trackInfo), I.data.action === "gopInfo" && RD(I, M), I.data.action === "audioTimingInfo" && l(I.data.audioTimingInfo), I.data.action === "videoTimingInfo" && c(I.data.videoTimingInfo), I.data.action === "videoSegmentTimingInfo" && h(I.data.videoSegmentTimingInfo), I.data.action === "audioSegmentTimingInfo" && d(I.data.audioSegmentTimingInfo), I.data.action === "id3Frame" && f([I.data.id3Frame], I.data.id3Frame.dispatchType), I.data.action === "caption" && p(I.data.caption), I.data.action === "endedtimeline" && (C = !1, m()), I.data.action === "log" && x(I.data.log), I.data.type === "transmuxed" && (C || (i.onmessage = null, LD({
      callback: _,
      transmuxedData: M
    }), s1(i))));
  };
  if (i.onmessage = R, r && i.postMessage({
    action: "setAudioAppendStart",
    appendStart: r
  }), Array.isArray(a) && i.postMessage({
    action: "alignGopsWith",
    gopsToAlignWith: a
  }), typeof s < "u" && i.postMessage({
    action: "setRemux",
    remux: s
  }), n.byteLength) {
    var k = n instanceof ArrayBuffer ? n : n.buffer, F = n instanceof ArrayBuffer ? 0 : n.byteOffset;
    i.postMessage(
      {
        action: "push",
        byteLength: n.byteLength,
        // To recreate the original typed-array, we need information
        // about what portion of the ArrayBuffer it was a view into
        byteOffset: F,
        // Send the typed-array of data as an ArrayBuffer so that
        // it can be sent as a "Transferable" and avoid the costly
        // memory copy
        data: k
      },
      [k]
    );
  }
  E && i.postMessage({
    action: "endTimeline"
  }), i.postMessage({
    action: "flush"
  });
}, s1 = function(t) {
  t.currentTransmux = null, t.transmuxQueue.length && (t.currentTransmux = t.transmuxQueue.shift(), typeof t.currentTransmux == "function" ? t.currentTransmux() : a1(t.currentTransmux));
}, dg = function(t, i) {
  t.postMessage({
    action: i
  }), s1(t);
}, o1 = function(t, i) {
  if (!i.currentTransmux) {
    i.currentTransmux = t, dg(i, t);
    return;
  }
  i.transmuxQueue.push(dg.bind(null, i, t));
}, ID = function(t) {
  o1("reset", t);
}, OD = function(t) {
  o1("endTimeline", t);
}, u1 = function(t) {
  if (!t.transmuxer.currentTransmux) {
    t.transmuxer.currentTransmux = t, a1(t);
    return;
  }
  t.transmuxer.transmuxQueue.push(t);
}, kD = function(t) {
  var i = new DD();
  i.currentTransmux = null, i.transmuxQueue = [];
  var n = i.terminate;
  return i.terminate = function() {
    return i.currentTransmux = null, i.transmuxQueue.length = 0, n.call(i);
  }, i.postMessage({
    action: "init",
    options: t
  }), i;
}, Ad = {
  createTransmuxer: kD,
  endTimeline: OD,
  reset: ID,
  transmux: u1
}, Jc = function(t) {
  var i = t.transmuxer, n = t.endAction || t.action, r = t.callback, a = kr({}, t, {
    callback: null,
    endAction: null,
    transmuxer: null
  }), s = function l(c) {
    c.data.action === n && (i.removeEventListener("message", l), c.data.data && (c.data.data = new Uint8Array(
      c.data.data,
      t.byteOffset || 0,
      t.byteLength || c.data.data.byteLength
    ), t.data && (t.data = c.data.data)), r(c.data));
  };
  if (i.addEventListener("message", s), t.data) {
    var o = t.data instanceof ArrayBuffer;
    a.byteOffset = o ? 0 : t.data.byteOffset, a.byteLength = t.data.byteLength;
    var u = [o ? t.data : t.data.buffer];
    i.postMessage(a, u);
  } else
    i.postMessage(a);
}, fn = {
  ABORTED: -102,
  FAILURE: 2,
  TIMEOUT: -101
}, _f = function(t) {
  t.forEach(function(i) {
    i.abort();
  });
}, BD = function(t) {
  return {
    bandwidth: t.bandwidth,
    bytesReceived: t.bytesReceived || 0,
    roundTripTime: t.roundTripTime || 0
  };
}, FD = function(t) {
  var i = t.target, n = Date.now() - i.requestTime, r = {
    bandwidth: 1 / 0,
    bytesReceived: 0,
    roundTripTime: n || 0
  };
  return r.bytesReceived = t.loaded, r.bandwidth = Math.floor(
    r.bytesReceived / r.roundTripTime * 8 * 1e3
  ), r;
}, ov = function(t, i) {
  return i.timedout ? {
    code: fn.TIMEOUT,
    message: "HLS request timed-out at URL: " + i.uri,
    status: i.status,
    xhr: i
  } : i.aborted ? {
    code: fn.ABORTED,
    message: "HLS request aborted at URL: " + i.uri,
    status: i.status,
    xhr: i
  } : t ? {
    code: fn.FAILURE,
    message: "HLS request errored at URL: " + i.uri,
    status: i.status,
    xhr: i
  } : i.responseType === "arraybuffer" && i.response.byteLength === 0 ? {
    code: fn.FAILURE,
    message: "Empty HLS response at URL: " + i.uri,
    status: i.status,
    xhr: i
  } : null;
}, fg = function(t, i, n) {
  return function(r, a) {
    var s = a.response, o = ov(r, a);
    if (o)
      return n(o, t);
    if (s.byteLength !== 16)
      return n(
        {
          code: fn.FAILURE,
          message: "Invalid HLS key at URL: " + a.uri,
          status: a.status,
          xhr: a
        },
        t
      );
    for (var u = new DataView(s), l = new Uint32Array([
      u.getUint32(0),
      u.getUint32(4),
      u.getUint32(8),
      u.getUint32(12)
    ]), c = 0; c < i.length; c++)
      i[c].bytes = l;
    return n(null, t);
  };
}, l1 = function(t, i) {
  var n = rp(t.map.bytes);
  if (n !== "mp4") {
    var r = t.map.resolvedUri || t.map.uri;
    return i({
      code: fn.FAILURE,
      internal: !0,
      message: "Found unsupported " + (n || "unknown") + " container for initialization segment at URL: " + r
    });
  }
  Jc({
    action: "probeMp4Tracks",
    callback: function(s) {
      var o = s.tracks, u = s.data;
      return t.map.bytes = u, o.forEach(function(l) {
        t.map.tracks = t.map.tracks || {}, !t.map.tracks[l.type] && (t.map.tracks[l.type] = l, typeof l.id == "number" && l.timescale && (t.map.timescales = t.map.timescales || {}, t.map.timescales[l.id] = l.timescale));
      }), i(null);
    },
    data: t.map.bytes,
    transmuxer: t.transmuxer
  });
}, ND = function(t) {
  var i = t.segment, n = t.finishProcessingFn;
  return function(r, a) {
    var s = ov(r, a);
    if (s)
      return n(s, i);
    var o = new Uint8Array(a.response);
    if (i.map.key)
      return i.map.encryptedBytes = o, n(null, i);
    i.map.bytes = o, l1(i, function(u) {
      if (u)
        return u.xhr = a, u.status = a.status, n(u, i);
      n(null, i);
    });
  };
}, UD = function(t) {
  var i = t.segment, n = t.finishProcessingFn, r = t.responseType;
  return function(a, s) {
    var o = ov(a, s);
    if (o)
      return n(o, i);
    var u = (
      // although responseText "should" exist, this guard serves to prevent an error being
      // thrown for two primary cases:
      // 1. the mime type override stops working, or is not implemented for a specific
      //    browser
      // 2. when using mock XHR libraries like sinon that do not allow the override behavior
      r === "arraybuffer" || !s.responseText ? s.response : SD(
        s.responseText.substring(i.lastReachedChar || 0)
      )
    );
    return i.stats = BD(s), i.key ? i.encryptedBytes = new Uint8Array(u) : i.bytes = new Uint8Array(u), n(null, i);
  };
}, jD = function(t) {
  var i = t.segment, n = t.bytes, r = t.trackInfoFn, a = t.timingInfoFn, s = t.videoSegmentTimingInfoFn, o = t.audioSegmentTimingInfoFn, u = t.id3Fn, l = t.captionsFn, c = t.isEndOfTimeline, h = t.endedTimelineFn, d = t.dataFn, f = t.doneFn, p = t.onTransmuxerLog, _ = i.map && i.map.tracks || {}, m = !!(_.audio && _.video), x = a.bind(null, i, "audio", "start"), E = a.bind(null, i, "audio", "end"), M = a.bind(null, i, "video", "start"), C = a.bind(null, i, "video", "end"), R = function() {
    return u1({
      audioAppendStart: i.audioAppendStart,
      bytes: n,
      gopsToAlignWith: i.gopsToAlignWith,
      onAudioSegmentTimingInfo: function(B) {
        o(B);
      },
      onAudioTimingInfo: function(B) {
        x && typeof B.start < "u" && (x(B.start), x = null), E && typeof B.end < "u" && E(B.end);
      },
      onCaptions: function(B) {
        l(i, [B]);
      },
      isEndOfTimeline: c,
      onData: function(B) {
        B.type = B.type === "combined" ? "video" : B.type, d(i, B);
      },
      onDone: function(B) {
        f && (B.type = B.type === "combined" ? "video" : B.type, f(null, i, B));
      },
      onTrackInfo: function(B) {
        r && (m && (B.isMuxed = !0), r(i, B));
      },
      onEndedTimeline: function() {
        h();
      },
      transmuxer: i.transmuxer,
      onId3: function(B, I) {
        u(i, B, I);
      },
      onTransmuxerLog: p,
      remux: m,
      onVideoSegmentTimingInfo: function(B) {
        s(B);
      },
      onVideoTimingInfo: function(B) {
        M && typeof B.start < "u" && (M(B.start), M = null), C && typeof B.end < "u" && C(B.end);
      }
    });
  };
  Jc({
    action: "probeTs",
    baseStartTime: i.baseStartTime,
    callback: function(F) {
      i.bytes = n = F.data;
      var B = F.result;
      B && (r(i, {
        hasAudio: B.hasAudio,
        hasVideo: B.hasVideo,
        isMuxed: m
      }), r = null, B.hasAudio && !m && x(B.audioStart), B.hasVideo && M(B.videoStart), x = null, M = null), R();
    },
    data: n,
    transmuxer: i.transmuxer
  });
}, c1 = function(t) {
  var i = t.segment, n = t.bytes, r = t.trackInfoFn, a = t.timingInfoFn, s = t.videoSegmentTimingInfoFn, o = t.audioSegmentTimingInfoFn, u = t.id3Fn, l = t.captionsFn, c = t.isEndOfTimeline, h = t.endedTimelineFn, d = t.dataFn, f = t.doneFn, p = t.onTransmuxerLog, _ = new Uint8Array(n);
  if (Ow(_)) {
    i.isFmp4 = !0;
    var m = i.map.tracks, x = {
      hasAudio: !!m.audio,
      hasVideo: !!m.video,
      isFmp4: !0
    };
    m.audio && m.audio.codec && m.audio.codec !== "enca" && (x.audioCodec = m.audio.codec), m.video && m.video.codec && m.video.codec !== "encv" && (x.videoCodec = m.video.codec), m.video && m.audio && (x.isMuxed = !0), r(i, x);
    var E = function(C) {
      d(i, {
        data: _,
        type: x.hasAudio && !x.isMuxed ? "audio" : "video"
      }), C && C.length && l(i, C), f(null, i, {});
    };
    Jc({
      action: "probeMp4StartTime",
      callback: function(C) {
        var R = C.data, k = C.startTime;
        if (n = R.buffer, i.bytes = _ = R, x.hasAudio && !x.isMuxed && a(i, "audio", "start", k), x.hasVideo && a(i, "video", "start", k), !m.video || !R.byteLength || !i.transmuxer) {
          E();
          return;
        }
        Jc({
          action: "pushMp4Captions",
          callback: function(B) {
            n = B.data.buffer, i.bytes = _ = B.data, B.logs.forEach(function(I) {
              p(
                X.mergeOptions(I, {
                  stream: "mp4CaptionParser"
                })
              );
            }), E(B.captions);
          },
          data: _,
          endAction: "mp4Captions",
          timescales: i.map.timescales,
          trackIds: [m.video.id],
          transmuxer: i.transmuxer
        });
      },
      data: _,
      timescales: i.map.timescales,
      transmuxer: i.transmuxer
    });
    return;
  }
  if (!i.transmuxer) {
    f(null, i, {});
    return;
  }
  if (typeof i.container > "u" && (i.container = rp(_)), i.container !== "ts" && i.container !== "aac") {
    r(i, {
      hasAudio: !1,
      hasVideo: !1
    }), f(null, i, {});
    return;
  }
  jD({
    audioSegmentTimingInfoFn: o,
    bytes: n,
    captionsFn: l,
    dataFn: d,
    doneFn: f,
    endedTimelineFn: h,
    id3Fn: u,
    isEndOfTimeline: c,
    segment: i,
    onTransmuxerLog: p,
    timingInfoFn: a,
    trackInfoFn: r,
    videoSegmentTimingInfoFn: s
  });
}, h1 = function(t, i) {
  var n = t.id, r = t.key, a = t.encryptedBytes, s = t.decryptionWorker, o = function l(c) {
    if (c.data.source === n) {
      s.removeEventListener("message", l);
      var h = c.data.decrypted;
      i(
        new Uint8Array(
          h.bytes,
          h.byteOffset,
          h.byteLength
        )
      );
    }
  };
  s.addEventListener("message", o);
  var u;
  r.bytes.slice ? u = r.bytes.slice() : u = new Uint32Array(Array.prototype.slice.call(r.bytes)), s.postMessage(
    Kb({
      encrypted: a,
      iv: r.iv,
      key: u,
      source: n
    }),
    [a.buffer, u.buffer]
  );
}, GD = function(t) {
  var i = t.decryptionWorker, n = t.segment, r = t.trackInfoFn, a = t.timingInfoFn, s = t.videoSegmentTimingInfoFn, o = t.audioSegmentTimingInfoFn, u = t.id3Fn, l = t.captionsFn, c = t.isEndOfTimeline, h = t.endedTimelineFn, d = t.dataFn, f = t.doneFn, p = t.onTransmuxerLog;
  h1(
    {
      decryptionWorker: i,
      encryptedBytes: n.encryptedBytes,
      id: n.requestId,
      key: n.key
    },
    function(_) {
      n.bytes = _, c1({
        audioSegmentTimingInfoFn: o,
        bytes: n.bytes,
        captionsFn: l,
        dataFn: d,
        doneFn: f,
        endedTimelineFn: h,
        id3Fn: u,
        isEndOfTimeline: c,
        segment: n,
        onTransmuxerLog: p,
        timingInfoFn: a,
        trackInfoFn: r,
        videoSegmentTimingInfoFn: s
      });
    }
  );
}, VD = function(t) {
  var i = t.activeXhrs, n = t.decryptionWorker, r = t.trackInfoFn, a = t.timingInfoFn, s = t.videoSegmentTimingInfoFn, o = t.audioSegmentTimingInfoFn, u = t.id3Fn, l = t.captionsFn, c = t.isEndOfTimeline, h = t.endedTimelineFn, d = t.dataFn, f = t.doneFn, p = t.onTransmuxerLog, _ = 0, m = !1;
  return function(x, E) {
    if (!m) {
      if (x)
        return m = !0, _f(i), f(x, E);
      if (_ += 1, _ === i.length) {
        var M = function() {
          if (E.encryptedBytes)
            return GD({
              audioSegmentTimingInfoFn: o,
              captionsFn: l,
              dataFn: d,
              decryptionWorker: n,
              doneFn: f,
              endedTimelineFn: h,
              id3Fn: u,
              isEndOfTimeline: c,
              segment: E,
              onTransmuxerLog: p,
              timingInfoFn: a,
              trackInfoFn: r,
              videoSegmentTimingInfoFn: s
            });
          c1({
            audioSegmentTimingInfoFn: o,
            bytes: E.bytes,
            captionsFn: l,
            dataFn: d,
            doneFn: f,
            endedTimelineFn: h,
            id3Fn: u,
            isEndOfTimeline: c,
            segment: E,
            onTransmuxerLog: p,
            timingInfoFn: a,
            trackInfoFn: r,
            videoSegmentTimingInfoFn: s
          });
        };
        if (E.endOfAllRequests = Date.now(), E.map && E.map.encryptedBytes && !E.map.bytes)
          return h1(
            {
              decryptionWorker: n,
              encryptedBytes: E.map.encryptedBytes,
              // add -init to the "id" to differentiate between segment
              // and init segment decryption, just in case they happen
              // at the same time at some point in the future.
              id: E.requestId + "-init",
              key: E.map.key
            },
            function(C) {
              E.map.bytes = C, l1(E, function(R) {
                if (R)
                  return _f(i), f(R, E);
                M();
              });
            }
          );
        M();
      }
    }
  };
}, HD = function(t) {
  var i = t.loadendState, n = t.abortFn;
  return function(r) {
    var a = r.target;
    a.aborted && n && !i.calledAbortFn && (n(), i.calledAbortFn = !0);
  };
}, zD = function(t) {
  var i = t.segment, n = t.progressFn;
  return function(r) {
    var a = r.target;
    if (!a.aborted)
      return i.stats = X.mergeOptions(
        i.stats,
        FD(r)
      ), !i.stats.firstBytesReceivedAt && i.stats.bytesReceived && (i.stats.firstBytesReceivedAt = Date.now()), n(r, i);
  };
}, WD = function(t) {
  var i = t.xhr, n = t.xhrOptions, r = t.decryptionWorker, a = t.segment, s = t.abortFn, o = t.progressFn, u = t.trackInfoFn, l = t.timingInfoFn, c = t.videoSegmentTimingInfoFn, h = t.audioSegmentTimingInfoFn, d = t.id3Fn, f = t.captionsFn, p = t.isEndOfTimeline, _ = t.endedTimelineFn, m = t.dataFn, x = t.doneFn, E = t.onTransmuxerLog, M = [], C = VD({
    activeXhrs: M,
    audioSegmentTimingInfoFn: h,
    captionsFn: f,
    dataFn: m,
    decryptionWorker: r,
    doneFn: x,
    endedTimelineFn: _,
    id3Fn: d,
    isEndOfTimeline: p,
    onTransmuxerLog: E,
    timingInfoFn: l,
    trackInfoFn: u,
    videoSegmentTimingInfoFn: c
  });
  if (a.key && !a.key.bytes) {
    var R = [a.key];
    a.map && !a.map.bytes && a.map.key && a.map.key.resolvedUri === a.key.resolvedUri && R.push(a.map.key);
    var k = X.mergeOptions(n, {
      responseType: "arraybuffer",
      uri: a.key.resolvedUri
    }), F = fg(
      a,
      R,
      C
    ), B = i(k, F);
    M.push(B);
  }
  if (a.map && !a.map.bytes) {
    var I = a.map.key && (!a.key || a.key.resolvedUri !== a.map.key.resolvedUri);
    if (I) {
      var V = X.mergeOptions(n, {
        responseType: "arraybuffer",
        uri: a.map.key.resolvedUri
      }), Q = fg(
        a,
        [a.map.key],
        C
      ), ee = i(V, Q);
      M.push(ee);
    }
    var oe = X.mergeOptions(n, {
      headers: gf(a.map),
      responseType: "arraybuffer",
      uri: a.map.resolvedUri
    }), fe = ND({
      finishProcessingFn: C,
      segment: a
    }), he = i(oe, fe);
    M.push(he);
  }
  var de = X.mergeOptions(n, {
    headers: gf(a),
    responseType: "arraybuffer",
    uri: a.part && a.part.resolvedUri || a.resolvedUri
  }), G = UD({
    finishProcessingFn: C,
    responseType: de.responseType,
    segment: a
  }), j = i(de, G);
  j.addEventListener(
    "progress",
    zD({
      audioSegmentTimingInfoFn: h,
      captionsFn: f,
      dataFn: m,
      endedTimelineFn: _,
      id3Fn: d,
      isEndOfTimeline: p,
      progressFn: o,
      segment: a,
      timingInfoFn: l,
      trackInfoFn: u,
      videoSegmentTimingInfoFn: c
    })
  ), M.push(j);
  var se = {};
  return M.forEach(function(ie) {
    ie.addEventListener(
      "loadend",
      HD({
        abortFn: s,
        loadendState: se
      })
    );
  }), function() {
    return _f(M);
  };
}, qD = rn("CodecUtils"), XD = function(t) {
  var i = t.attributes || {};
  if (i.CODECS)
    return ln(i.CODECS);
}, d1 = function(t, i) {
  var n = i.attributes || {};
  return t && t.mediaGroups && t.mediaGroups.AUDIO && n.AUDIO && t.mediaGroups.AUDIO[n.AUDIO];
}, YD = function(t, i) {
  if (!d1(t, i))
    return !0;
  var n = i.attributes || {}, r = t.mediaGroups.AUDIO[n.AUDIO];
  for (var a in r)
    if (!r[a].uri && !r[a].playlists)
      return !0;
  return !1;
}, $c = function(t) {
  var i = {};
  return t.forEach(function(n) {
    var r = n.mediaType, a = n.type, s = n.details;
    i[r] = i[r] || [], i[r].push(wy("" + a + s));
  }), Object.keys(i).forEach(function(n) {
    if (i[n].length > 1) {
      qD(
        "multiple " + n + " codecs found as attributes: " + i[n].join(", ") + ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs."
      ), i[n] = null;
      return;
    }
    i[n] = i[n][0];
  }), i;
}, pg = function(t) {
  var i = 0;
  return t.audio && i++, t.video && i++, i;
}, pu = function(t, i) {
  var n = i.attributes || {}, r = $c(XD(i) || []);
  if (d1(t, i) && !r.audio && !YD(t, i)) {
    var a = $c(
      gw(t, n.AUDIO) || []
    );
    a.audio && (r.audio = a.audio);
  }
  return r;
}, Zl = rn("PlaylistSelector"), vg = function(t) {
  if (!(!t || !t.playlist)) {
    var i = t.playlist;
    return JSON.stringify({
      bandwidth: t.bandwidth,
      codecs: i.attributes && i.attributes.CODECS || "",
      height: t.height,
      id: i.id,
      width: t.width
    });
  }
}, eh = function(t, i) {
  if (!t)
    return "";
  var n = W.getComputedStyle(t);
  return n ? n[i] : "";
}, Ns = function(t, i) {
  var n = t.slice();
  t.sort(function(r, a) {
    var s = i(r, a);
    return s === 0 ? n.indexOf(r) - n.indexOf(a) : s;
  });
}, uv = function(t, i) {
  var n, r;
  return t.attributes.BANDWIDTH && (n = t.attributes.BANDWIDTH), n = n || W.Number.MAX_VALUE, i.attributes.BANDWIDTH && (r = i.attributes.BANDWIDTH), r = r || W.Number.MAX_VALUE, n - r;
}, QD = function(t, i) {
  var n, r;
  return t.attributes.RESOLUTION && t.attributes.RESOLUTION.width && (n = t.attributes.RESOLUTION.width), n = n || W.Number.MAX_VALUE, i.attributes.RESOLUTION && i.attributes.RESOLUTION.width && (r = i.attributes.RESOLUTION.width), r = r || W.Number.MAX_VALUE, n === r && t.attributes.BANDWIDTH && i.attributes.BANDWIDTH ? t.attributes.BANDWIDTH - i.attributes.BANDWIDTH : n - r;
}, f1 = function(t, i, n, r, a, s) {
  if (t) {
    var o = {
      bandwidth: i,
      height: r,
      limitRenditionByPlayerDimensions: a,
      width: n
    }, u = t.playlists;
    lr.isAudioOnly(t) && (u = s.getAudioTrackPlaylists_(), o.audioOnly = !0);
    var l = u.map(function(V) {
      var Q, ee = V.attributes && V.attributes.RESOLUTION && V.attributes.RESOLUTION.width, oe = V.attributes && V.attributes.RESOLUTION && V.attributes.RESOLUTION.height;
      return Q = V.attributes && V.attributes.BANDWIDTH, Q = Q || W.Number.MAX_VALUE, {
        bandwidth: Q,
        height: oe,
        playlist: V,
        width: ee
      };
    });
    Ns(l, function(V, Q) {
      return V.bandwidth - Q.bandwidth;
    }), l = l.filter(function(V) {
      return !lr.isIncompatible(V.playlist);
    });
    var c = l.filter(function(V) {
      return lr.isEnabled(V.playlist);
    });
    c.length || (c = l.filter(function(V) {
      return !lr.isDisabled(V.playlist);
    }));
    var h = c.filter(function(V) {
      return V.bandwidth * Pi.BANDWIDTH_VARIANCE < i;
    }), d = h[h.length - 1], f = h.filter(function(V) {
      return V.bandwidth === d.bandwidth;
    })[0];
    if (a === !1) {
      var p = f || c[0] || l[0];
      if (p && p.playlist) {
        var _ = "sortedPlaylistReps";
        return f && (_ = "bandwidthBestRep"), c[0] && (_ = "enabledPlaylistReps"), Zl(
          "choosing " + vg(p) + " using " + _ + " with options",
          o
        ), p.playlist;
      }
      return Zl("could not choose a playlist with options", o), null;
    }
    var m = h.filter(function(V) {
      return V.width && V.height;
    });
    Ns(m, function(V, Q) {
      return V.width - Q.width;
    });
    var x = m.filter(function(V) {
      return V.width === n && V.height === r;
    });
    d = x[x.length - 1];
    var E = x.filter(function(V) {
      return V.bandwidth === d.bandwidth;
    })[0], M, C, R;
    E || (M = m.filter(function(V) {
      return V.width > n || V.height > r;
    }), C = M.filter(function(V) {
      return V.width === M[0].width && V.height === M[0].height;
    }), d = C[C.length - 1], R = C.filter(function(V) {
      return V.bandwidth === d.bandwidth;
    })[0]);
    var k;
    if (s.experimentalLeastPixelDiffSelector) {
      var F = m.map(function(V) {
        return V.pixelDiff = Math.abs(V.width - n) + Math.abs(V.height - r), V;
      });
      Ns(F, function(V, Q) {
        return V.pixelDiff === Q.pixelDiff ? Q.bandwidth - V.bandwidth : V.pixelDiff - Q.pixelDiff;
      }), k = F[0];
    }
    var B = k || R || E || f || c[0] || l[0];
    if (B && B.playlist) {
      var I = "sortedPlaylistReps";
      return k ? I = "leastPixelDiffRep" : R ? I = "resolutionPlusOneRep" : E ? I = "resolutionBestRep" : f ? I = "bandwidthBestRep" : c[0] && (I = "enabledPlaylistReps"), Zl(
        "choosing " + vg(B) + " using " + I + " with options",
        o
      ), B.playlist;
    }
    return Zl("could not choose a playlist with options", o), null;
  }
}, mg = function() {
  var t = this.useDevicePixelRatio && W.devicePixelRatio || 1;
  return f1(
    this.playlists.master,
    this.systemBandwidth,
    parseInt(eh(this.tech_.el(), "width"), 10) * t,
    parseInt(eh(this.tech_.el(), "height"), 10) * t,
    this.limitRenditionByPlayerDimensions,
    this.masterPlaylistController_
  );
}, KD = function(t) {
  var i = -1, n = -1;
  if (t < 0 || t > 1)
    throw new Error("Moving average bandwidth decay must be between 0 and 1.");
  return function() {
    var r = this.useDevicePixelRatio && W.devicePixelRatio || 1;
    return i < 0 && (i = this.systemBandwidth, n = this.systemBandwidth), this.systemBandwidth > 0 && this.systemBandwidth !== n && (i = t * this.systemBandwidth + (1 - t) * i, n = this.systemBandwidth), f1(
      this.playlists.master,
      i,
      parseInt(eh(this.tech_.el(), "width"), 10) * r,
      parseInt(eh(this.tech_.el(), "height"), 10) * r,
      this.limitRenditionByPlayerDimensions,
      this.masterPlaylistController_
    );
  };
}, ZD = function(t) {
  var i = t.master, n = t.currentTime, r = t.bandwidth, a = t.duration, s = t.segmentDuration, o = t.timeUntilRebuffer, u = t.currentTimeline, l = t.syncController, c = i.playlists.filter(function(_) {
    return !lr.isIncompatible(_);
  }), h = c.filter(lr.isEnabled);
  h.length || (h = c.filter(function(_) {
    return !lr.isDisabled(_);
  }));
  var d = h.filter(
    lr.hasAttribute.bind(null, "BANDWIDTH")
  ), f = d.map(function(_) {
    var m = l.getSyncPoint(
      _,
      a,
      u,
      n
    ), x = m ? 1 : 2, E = lr.estimateSegmentRequestTime(
      s,
      r,
      _
    ), M = E * x - o;
    return {
      playlist: _,
      rebufferingImpact: M
    };
  }), p = f.filter(function(_) {
    return _.rebufferingImpact <= 0;
  });
  return Ns(p, function(_, m) {
    return uv(m.playlist, _.playlist);
  }), p.length ? p[0] : (Ns(f, function(_, m) {
    return _.rebufferingImpact - m.rebufferingImpact;
  }), f[0] || null);
}, JD = function() {
  var t = this, i = this.playlists.master.playlists.filter(lr.isEnabled);
  Ns(i, function(r, a) {
    return uv(r, a);
  });
  var n = i.filter(function(r) {
    return !!pu(t.playlists.master, r).video;
  });
  return n[0] || null;
}, $D = function(t) {
  var i = 0, n;
  return t.bytes && (n = new Uint8Array(t.bytes), t.segments.forEach(function(r) {
    n.set(r, i), i += r.byteLength;
  })), n;
}, eP = function(t, i, n) {
  if (!t[n]) {
    i.trigger({
      name: "vhs-608",
      type: "usage"
    }), i.trigger({
      name: "hls-608",
      type: "usage"
    });
    var r = n;
    /^cc708_/.test(n) && (r = "SERVICE" + n.split("_")[1]);
    var a = i.textTracks().getTrackById(r);
    if (a)
      t[n] = a;
    else {
      var s = i.options_.vhs && i.options_.vhs.captionServices || {}, o = n, u = n, l = !1, c = s[r];
      c && (o = c.label, u = c.language, l = c.default), t[n] = i.addRemoteTextTrack(
        {
          // TODO: investigate why this doesn't seem to turn the caption on by default
          default: l,
          id: r,
          kind: "captions",
          label: o,
          language: u
        },
        !1
      ).track;
    }
  }
}, tP = function(t) {
  var i = t.inbandTextTracks, n = t.captionArray, r = t.timestampOffset;
  if (n) {
    var a = W.WebKitDataCue || W.VTTCue;
    n.forEach(function(s) {
      var o = s.stream;
      i[o].addCue(
        new a(
          s.startTime + r,
          s.endTime + r,
          s.text
        )
      );
    });
  }
}, iP = function(t) {
  Object.defineProperties(t.frame, {
    id: {
      get: function() {
        return X.log.warn(
          "cue.frame.id is deprecated. Use cue.value.key instead."
        ), t.value.key;
      }
    },
    privateData: {
      get: function() {
        return X.log.warn(
          "cue.frame.privateData is deprecated. Use cue.value.data instead."
        ), t.value.data;
      }
    },
    value: {
      get: function() {
        return X.log.warn(
          "cue.frame.value is deprecated. Use cue.value.data instead."
        ), t.value.data;
      }
    }
  });
}, rP = function(t) {
  var i = t.inbandTextTracks, n = t.metadataArray, r = t.timestampOffset, a = t.videoDuration;
  if (n) {
    var s = W.WebKitDataCue || W.VTTCue, o = i.metadataTrack_;
    if (o && (n.forEach(function(f) {
      var p = f.cueTime + r;
      typeof p != "number" || W.isNaN(p) || p < 0 || !(p < 1 / 0) || f.frames.forEach(function(_) {
        var m = new s(
          p,
          p,
          _.value || _.url || _.data || ""
        );
        m.frame = _, m.value = _, iP(m), o.addCue(m);
      });
    }), !(!o.cues || !o.cues.length))) {
      for (var u = o.cues, l = [], c = 0; c < u.length; c++)
        u[c] && l.push(u[c]);
      var h = l.reduce(function(f, p) {
        var _ = f[p.startTime] || [];
        return _.push(p), f[p.startTime] = _, f;
      }, {}), d = Object.keys(h).sort(
        function(f, p) {
          return Number(f) - Number(p);
        }
      );
      d.forEach(function(f, p) {
        var _ = h[f], m = Number(d[p + 1]) || a;
        _.forEach(function(x) {
          x.endTime = m;
        });
      });
    }
  }
}, nP = function(t, i, n) {
  t.metadataTrack_ || (t.metadataTrack_ = n.addRemoteTextTrack(
    {
      kind: "metadata",
      label: "Timed Metadata"
    },
    !1
  ).track, t.metadataTrack_.inBandMetadataTrackDispatchType = i);
}, ou = function(t, i, n) {
  var r, a;
  if (n && n.cues)
    for (r = n.cues.length; r--; )
      a = n.cues[r], a.startTime >= t && a.endTime <= i && n.removeCue(a);
}, aP = function(t) {
  var i = t.cues;
  if (i)
    for (var n = 0; n < i.length; n++) {
      for (var r = [], a = 0, s = 0; s < i.length; s++)
        i[n].startTime === i[s].startTime && i[n].endTime === i[s].endTime && i[n].text === i[s].text && (a++, a > 1 && r.push(i[s]));
      r.length && r.forEach(function(o) {
        return t.removeCue(o);
      });
    }
}, sP = function(t, i, n) {
  if (typeof i > "u" || i === null || !t.length)
    return [];
  var r = Math.ceil(
    (i - n + 3) * Nc.ONE_SECOND_IN_TS
  ), a;
  for (a = 0; a < t.length && !(t[a].pts > r); a++)
    ;
  return t.slice(a);
}, oP = function(t, i, n) {
  if (!i.length)
    return t;
  if (n)
    return i.slice();
  var r = i[0].pts, a = 0;
  for (a; a < t.length && !(t[a].pts >= r); a++)
    ;
  return t.slice(0, a).concat(i);
}, uP = function(t, i, n, r) {
  for (var a = Math.ceil((i - r) * Nc.ONE_SECOND_IN_TS), s = Math.ceil((n - r) * Nc.ONE_SECOND_IN_TS), o = t.slice(), u = t.length; u-- && !(t[u].pts <= s); )
    ;
  if (u === -1)
    return o;
  for (var l = u + 1; l-- && !(t[l].pts <= a); )
    ;
  return l = Math.max(l, 0), o.splice(l, u - l + 1), o;
}, lP = function(t, i) {
  if (!t && !i || !t && i || t && !i)
    return !1;
  if (t === i)
    return !0;
  var n = Object.keys(t).sort(), r = Object.keys(i).sort();
  if (n.length !== r.length)
    return !1;
  for (var a = 0; a < n.length; a++) {
    var s = n[a];
    if (s !== r[a] || t[s] !== i[s])
      return !1;
  }
  return !0;
}, p1 = 22, cP = function(t, i, n) {
  i = i || [];
  for (var r = [], a = 0, s = 0; s < i.length; s++) {
    var o = i[s];
    if (t === o.timeline && (r.push(s), a += o.duration, a > n))
      return s;
  }
  return r.length === 0 ? 0 : r[r.length - 1];
}, eu = 1, hP = 500, gg = function(t) {
  return typeof t == "number" && isFinite(t);
}, Jl = 1 / 60, dP = function(t, i, n) {
  return t !== "main" || !i || !n ? null : !n.hasAudio && !n.hasVideo ? "Neither audio nor video found in segment." : i.hasVideo && !n.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !i.hasVideo && n.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null;
}, fP = function(t, i, n) {
  var r = i - Pi.BACK_BUFFER_LENGTH;
  t.length && (r = Math.max(r, t.start(0)));
  var a = i - n;
  return Math.min(a, r);
}, Ps = function(t) {
  var i = t.startOfSegment, n = t.duration, r = t.segment, a = t.part, s = t.playlist, o = s.mediaSequence, u = s.id, l = s.segments, c = l === void 0 ? [] : l, h = t.mediaIndex, d = t.partIndex, f = t.timeline, p = c.length - 1, _ = "mediaIndex/partIndex increment";
  t.getMediaInfoForTime ? _ = "getMediaInfoForTime (" + t.getMediaInfoForTime + ")" : t.isSyncRequest && (_ = "getSyncSegmentCandidate (isSyncRequest)"), t.independent && (_ += " with independent " + t.independent);
  var m = typeof d == "number", x = t.segment.uri ? "segment" : "pre-segment", E = m ? Bb({
    preloadSegment: r
  }) - 1 : 0;
  return x + " [" + (o + h) + "/" + (o + p) + "]" + (m ? " part [" + d + "/" + E + "]" : "") + (" segment start/end [" + r.start + " => " + r.end + "]") + (m ? " part start/end [" + a.start + " => " + a.end + "]" : "") + (" startOfSegment [" + i + "]") + (" duration [" + n + "]") + (" timeline [" + f + "]") + (" selected by [" + _ + "]") + (" playlist [" + u + "]");
}, yg = function(t) {
  return t + "TimingInfo";
}, pP = function(t) {
  var i = t.segmentTimeline, n = t.currentTimeline, r = t.startOfSegment, a = t.buffered, s = t.overrideCheck;
  return !s && i === n ? null : i < n ? r : a.length ? a.end(a.length - 1) : r;
}, _g = function(t) {
  var i = t.timelineChangeController, n = t.currentTimeline, r = t.segmentTimeline, a = t.loaderType, s = t.audioDisabled;
  if (n === r)
    return !1;
  if (a === "audio") {
    var o = i.lastTimelineChange({
      type: "main"
    });
    return !o || o.to !== r;
  }
  if (a === "main" && s) {
    var u = i.pendingTimelineChange({
      type: "audio"
    });
    return !(u && u.to === r);
  }
  return !1;
}, vP = function(t) {
  var i = 0;
  return ["video", "audio"].forEach(function(n) {
    var r = t[n + "TimingInfo"];
    if (r) {
      var a = r.start, s = r.end, o;
      typeof a == "bigint" || typeof s == "bigint" ? o = W.BigInt(s) - W.BigInt(a) : typeof a == "number" && typeof s == "number" && (o = s - a), typeof o < "u" && o > i && (i = o);
    }
  }), typeof i == "bigint" && i < Number.MAX_SAFE_INTEGER && (i = Number(i)), i;
}, bg = function(t) {
  var i = t.segmentDuration, n = t.maxDuration;
  return i ? Math.round(i) > n + ga : !1;
}, mP = function(t, i) {
  if (i !== "hls")
    return null;
  var n = vP({
    audioTimingInfo: t.audioTimingInfo,
    videoTimingInfo: t.videoTimingInfo
  });
  if (!n)
    return null;
  var r = t.playlist.targetDuration, a = bg({
    maxDuration: r * 2,
    segmentDuration: n
  }), s = bg({
    maxDuration: r,
    segmentDuration: n
  }), o = "Segment with index " + t.mediaIndex + " " + ("from playlist " + t.playlist.id + " ") + ("has a duration of " + n + " ") + ("when the reported duration is " + t.duration + " ") + ("and the target duration is " + r + ". ") + "For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
  return a || s ? {
    message: o,
    severity: a ? "warn" : "info"
  } : null;
}, bf = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    if (a = e.call(this) || this, !n)
      throw new TypeError("Initialization settings are required");
    if (typeof n.currentTime != "function")
      throw new TypeError("No currentTime getter specified");
    if (!n.mediaSource)
      throw new TypeError("No MediaSource specified");
    return a.bandwidth = n.bandwidth, a.throughput = {
      count: 0,
      rate: 0
    }, a.roundTrip = NaN, a.resetStats_(), a.mediaIndex = null, a.partIndex = null, a.hasPlayed_ = n.hasPlayed, a.currentTime_ = n.currentTime, a.seekable_ = n.seekable, a.seeking_ = n.seeking, a.duration_ = n.duration, a.mediaSource_ = n.mediaSource, a.vhs_ = n.vhs, a.loaderType_ = n.loaderType, a.currentMediaInfo_ = void 0, a.startingMediaInfo_ = void 0, a.segmentMetadataTrack_ = n.segmentMetadataTrack, a.goalBufferLength_ = n.goalBufferLength, a.sourceType_ = n.sourceType, a.sourceUpdater_ = n.sourceUpdater, a.inbandTextTracks_ = n.inbandTextTracks, a.state_ = "INIT", a.timelineChangeController_ = n.timelineChangeController, a.shouldSaveSegmentTimingInfo_ = !0, a.parse708captions_ = n.parse708captions, a.useDtsForTimestampOffset_ = n.useDtsForTimestampOffset, a.captionServices_ = n.captionServices, a.experimentalExactManifestTimings = n.experimentalExactManifestTimings, a.checkBufferTimeout_ = null, a.error_ = void 0, a.currentTimeline_ = -1, a.pendingSegment_ = null, a.xhrOptions_ = null, a.pendingSegments_ = [], a.audioDisabled_ = !1, a.isPendingTimestampOffset_ = !1, a.gopBuffer_ = [], a.timeMapping_ = 0, a.safeAppend_ = X.browser.IE_VERSION >= 11, a.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, a.playlistOfLastInitSegment_ = {
      audio: null,
      video: null
    }, a.callQueue_ = [], a.loadQueue_ = [], a.metadataQueue_ = {
      caption: [],
      id3: []
    }, a.waitingOnRemove_ = !1, a.quotaExceededErrorRetryTimeout_ = null, a.activeInitSegmentId_ = null, a.initSegments_ = {}, a.cacheEncryptionKeys_ = n.cacheEncryptionKeys, a.keyCache_ = {}, a.decrypter_ = n.decrypter, a.syncController_ = n.syncController, a.syncPoint_ = {
      segmentIndex: 0,
      time: 0
    }, a.transmuxer_ = a.createTransmuxer_(), a.triggerSyncInfoUpdate_ = function() {
      return a.trigger("syncinfoupdate");
    }, a.syncController_.on("syncinfoupdate", a.triggerSyncInfoUpdate_), a.mediaSource_.addEventListener("sourceopen", function() {
      a.isEndOfStream_() || (a.ended_ = !1);
    }), a.fetchAtBuffer_ = !1, a.logger_ = rn("SegmentLoader[" + a.loaderType_ + "]"), Object.defineProperty(He(a), "state", {
      get: function() {
        return this.state_;
      },
      set: function(o) {
        o !== this.state_ && (this.logger_(this.state_ + " -> " + o), this.state_ = o, this.trigger("statechange"));
      }
    }), a.sourceUpdater_.on("ready", function() {
      a.hasEnoughInfoToAppend_() && a.processCallQueue_();
    }), a.loaderType_ === "main" && a.timelineChangeController_.on("pendingtimelinechange", function() {
      a.hasEnoughInfoToAppend_() && a.processCallQueue_();
    }), a.loaderType_ === "audio" && a.timelineChangeController_.on("timelinechange", function() {
      a.hasEnoughInfoToLoad_() && a.processLoadQueue_(), a.hasEnoughInfoToAppend_() && a.processCallQueue_();
    }), a;
  }
  var i = t.prototype;
  return i.createTransmuxer_ = function() {
    return Ad.createTransmuxer({
      alignGopsAtEnd: this.safeAppend_,
      captionServices: this.captionServices_,
      keepOriginalTimestamps: !0,
      parse708captions: this.parse708captions_,
      remux: !1
    });
  }, i.resetStats_ = function() {
    this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0;
  }, i.dispose = function() {
    this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && W.clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off();
  }, i.setAudio = function(r) {
    this.audioDisabled_ = !r, r ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_());
  }, i.abort = function() {
    if (this.state !== "WAITING") {
      this.pendingSegment_ && (this.pendingSegment_ = null);
      return;
    }
    this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_();
  }, i.abort_ = function() {
    this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, W.clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null;
  }, i.checkForAbort_ = function(r) {
    return this.state === "APPENDING" && !this.pendingSegment_ ? (this.state = "READY", !0) : !this.pendingSegment_ || this.pendingSegment_.requestId !== r;
  }, i.error = function(r) {
    return typeof r < "u" && (this.logger_("error occurred:", r), this.error_ = r), this.pendingSegment_ = null, this.error_;
  }, i.endOfStream = function() {
    this.ended_ = !0, this.transmuxer_ && Ad.reset(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended");
  }, i.buffered_ = function() {
    var r = this.getMediaInfo_();
    if (!this.sourceUpdater_ || !r)
      return X.createTimeRanges();
    if (this.loaderType_ === "main") {
      var a = r.hasAudio, s = r.hasVideo, o = r.isMuxed;
      if (s && a && !this.audioDisabled_ && !o)
        return this.sourceUpdater_.buffered();
      if (s)
        return this.sourceUpdater_.videoBuffered();
    }
    return this.sourceUpdater_.audioBuffered();
  }, i.initSegmentForMap = function(r, a) {
    if (a === void 0 && (a = !1), !r)
      return null;
    var s = Zc(r), o = this.initSegments_[s];
    return a && !o && r.bytes && (this.initSegments_[s] = o = {
      byterange: r.byterange,
      bytes: r.bytes,
      resolvedUri: r.resolvedUri,
      timescales: r.timescales,
      tracks: r.tracks
    }), o || r;
  }, i.segmentKey = function(r, a) {
    if (a === void 0 && (a = !1), !r)
      return null;
    var s = Zb(r), o = this.keyCache_[s];
    this.cacheEncryptionKeys_ && a && !o && r.bytes && (this.keyCache_[s] = o = {
      bytes: r.bytes,
      resolvedUri: r.resolvedUri
    });
    var u = {
      resolvedUri: (o || r).resolvedUri
    };
    return o && (u.bytes = o.bytes), u;
  }, i.couldBeginLoading_ = function() {
    return this.playlist_ && !this.paused();
  }, i.load = function() {
    if (this.monitorBuffer_(), !!this.playlist_) {
      if (this.state === "INIT" && this.couldBeginLoading_())
        return this.init_();
      !this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT" || (this.state = "READY");
    }
  }, i.init_ = function() {
    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
  }, i.playlist = function(r, a) {
    if (a === void 0 && (a = {}), !!r) {
      var s = this.playlist_, o = this.pendingSegment_;
      this.playlist_ = r, this.xhrOptions_ = a, this.state === "INIT" && (r.syncInfo = {
        mediaSequence: r.mediaSequence,
        time: 0
      }, this.loaderType_ === "main" && this.syncController_.setDateTimeMappingForStart(r));
      var u = null;
      if (s && (s.id ? u = s.id : s.uri && (u = s.uri)), this.logger_(
        "playlist update [" + u + " => " + (r.id || r.uri) + "]"
      ), this.trigger("syncinfoupdate"), this.state === "INIT" && this.couldBeginLoading_())
        return this.init_();
      if (!s || s.uri !== r.uri) {
        this.mediaIndex !== null && (r.endList ? this.resyncLoader() : this.resetLoader()), this.currentMediaInfo_ = void 0, this.trigger("playlistupdate");
        return;
      }
      var l = r.mediaSequence - s.mediaSequence;
      if (this.logger_("live window shift [" + l + "]"), this.mediaIndex !== null)
        if (this.mediaIndex -= l, this.mediaIndex < 0)
          this.mediaIndex = null, this.partIndex = null;
        else {
          var c = this.playlist_.segments[this.mediaIndex];
          if (this.partIndex && (!c.parts || !c.parts.length || !c.parts[this.partIndex])) {
            var h = this.mediaIndex;
            this.logger_(
              "currently processing part (index " + this.partIndex + ") no longer exists."
            ), this.resetLoader(), this.mediaIndex = h;
          }
        }
      o && (o.mediaIndex -= l, o.mediaIndex < 0 ? (o.mediaIndex = null, o.partIndex = null) : (o.mediaIndex >= 0 && (o.segment = r.segments[o.mediaIndex]), o.partIndex >= 0 && o.segment.parts && (o.part = o.segment.parts[o.partIndex]))), this.syncController_.saveExpiredSegmentInfo(s, r);
    }
  }, i.pause = function() {
    this.checkBufferTimeout_ && (W.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null);
  }, i.paused = function() {
    return this.checkBufferTimeout_ === null;
  }, i.resetEverything = function(r) {
    this.ended_ = !1, this.activeInitSegmentId_ = null, this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.resetLoader(), this.remove(0, 1 / 0, r), this.transmuxer_ && (this.transmuxer_.postMessage({
      action: "clearAllMp4Captions"
    }), this.transmuxer_.postMessage({
      action: "reset"
    }));
  }, i.resetLoader = function() {
    this.fetchAtBuffer_ = !1, this.resyncLoader();
  }, i.resyncLoader = function() {
    this.transmuxer_ && Ad.reset(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.abort(), this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearParsedMp4Captions"
    });
  }, i.remove = function(r, a, s, o) {
    if (s === void 0 && (s = function() {
    }), o === void 0 && (o = !1), a === 1 / 0 && (a = this.duration_()), a <= r) {
      this.logger_("skipping remove because end ${end} is <= start ${start}");
      return;
    }
    if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
      this.logger_(
        "skipping remove because no source updater or starting media info"
      );
      return;
    }
    var u = 1, l = function() {
      u--, u === 0 && s();
    };
    (o || !this.audioDisabled_) && (u++, this.sourceUpdater_.removeAudio(r, a, l)), (o || this.loaderType_ === "main") && (this.gopBuffer_ = uP(
      this.gopBuffer_,
      r,
      a,
      this.timeMapping_
    ), u++, this.sourceUpdater_.removeVideo(r, a, l));
    for (var c in this.inbandTextTracks_)
      ou(r, a, this.inbandTextTracks_[c]);
    ou(r, a, this.segmentMetadataTrack_), l();
  }, i.monitorBuffer_ = function() {
    this.checkBufferTimeout_ && W.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = W.setTimeout(
      this.monitorBufferTick_.bind(this),
      1
    );
  }, i.monitorBufferTick_ = function() {
    this.state === "READY" && this.fillBuffer_(), this.checkBufferTimeout_ && W.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = W.setTimeout(
      this.monitorBufferTick_.bind(this),
      hP
    );
  }, i.fillBuffer_ = function() {
    if (!this.sourceUpdater_.updating()) {
      var r = this.chooseNextRequest_();
      r && (typeof r.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({
        from: this.currentTimeline_,
        to: r.timeline,
        type: this.loaderType_
      })), this.loadSegment_(r));
    }
  }, i.isEndOfStream_ = function(r, a, s) {
    if (r === void 0 && (r = this.mediaIndex), a === void 0 && (a = this.playlist_), s === void 0 && (s = this.partIndex), !a || !this.mediaSource_)
      return !1;
    var o = typeof r == "number" && a.segments[r], u = r + 1 === a.segments.length, l = !o || !o.parts || s + 1 === o.parts.length;
    return a.endList && this.mediaSource_.readyState === "open" && u && l;
  }, i.chooseNextRequest_ = function() {
    var r = this.buffered_(), a = og(r) || 0, s = iv(r, this.currentTime_()), o = !this.hasPlayed_() && s >= 1, u = s >= this.goalBufferLength_(), l = this.playlist_.segments;
    if (!l.length || o || u)
      return null;
    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(
      this.playlist_,
      this.duration_(),
      this.currentTimeline_,
      this.currentTime_()
    );
    var c = {
      isSyncRequest: !this.syncPoint_,
      mediaIndex: null,
      partIndex: null,
      playlist: this.playlist_,
      startOfSegment: null
    };
    if (c.isSyncRequest)
      c.mediaIndex = cP(
        this.currentTimeline_,
        l,
        a
      );
    else if (this.mediaIndex !== null) {
      var h = l[this.mediaIndex], d = typeof this.partIndex == "number" ? this.partIndex : -1;
      c.startOfSegment = h.end ? h.end : a, h.parts && h.parts[d + 1] ? (c.mediaIndex = this.mediaIndex, c.partIndex = d + 1) : c.mediaIndex = this.mediaIndex + 1;
    } else {
      var f = lr.getMediaInfoForTime({
        currentTime: this.fetchAtBuffer_ ? a : this.currentTime_(),
        experimentalExactManifestTimings: this.experimentalExactManifestTimings,
        playlist: this.playlist_,
        startTime: this.syncPoint_.time,
        startingPartIndex: this.syncPoint_.partIndex,
        startingSegmentIndex: this.syncPoint_.segmentIndex
      }), p = f.segmentIndex, _ = f.startTime, m = f.partIndex;
      c.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + a : "currentTime " + this.currentTime_(), c.mediaIndex = p, c.startOfSegment = _, c.partIndex = m;
    }
    var x = l[c.mediaIndex], E = x && typeof c.partIndex == "number" && x.parts && x.parts[c.partIndex];
    if (!x || typeof c.partIndex == "number" && !E)
      return null;
    if (typeof c.partIndex != "number" && x.parts && (c.partIndex = 0, E = x.parts[0]), !s && E && !E.independent)
      if (c.partIndex === 0) {
        var M = l[c.mediaIndex - 1], C = M.parts && M.parts.length && M.parts[M.parts.length - 1];
        C && C.independent && (c.mediaIndex -= 1, c.partIndex = M.parts.length - 1, c.independent = "previous segment");
      } else x.parts[c.partIndex - 1].independent && (c.partIndex -= 1, c.independent = "previous part");
    var R = this.mediaSource_ && this.mediaSource_.readyState === "ended";
    return c.mediaIndex >= l.length - 1 && R && !this.seeking_() ? null : this.generateSegmentInfo_(c);
  }, i.generateSegmentInfo_ = function(r) {
    var a = r.independent, s = r.playlist, o = r.mediaIndex, u = r.startOfSegment, l = r.isSyncRequest, c = r.partIndex, h = r.forceTimestampOffset, d = r.getMediaInfoForTime, f = s.segments[o], p = typeof c == "number" && f.parts[c], _ = {
      // unencrypted bytes of the segment
      bytes: null,
      // when a key is defined for this segment, the encrypted bytes
      encryptedBytes: null,
      // whether or not to update the SegmentLoader's state with this
      // segment's mediaIndex
      isSyncRequest: l,
      // The expected duration of the segment in seconds
      duration: p && p.duration || f.duration,
      // the segment's mediaIndex at the time it was requested
      mediaIndex: o,
      part: p,
      partIndex: p ? c : null,
      // the segment's playlist
      playlist: s,
      byteLength: 0,
      requestId: "segment-loader-" + Math.random(),
      // type of getMediaInfoForTime that was used to get this segment
      getMediaInfoForTime: d,
      // resolve the segment URL relative to the playlist
      uri: p && p.resolvedUri || f.resolvedUri,
      independent: a,
      startOfSegment: u,
      // retain the segment in case the playlist updates while doing an async process
      segment: f,
      // The timeline that the segment is in
      timeline: f.timeline,
      // The target timestampOffset for this segment when we append it
      // to the source buffer
      timestampOffset: null,
      transmuxer: this.transmuxer_
    }, m = typeof h < "u" ? h : this.isPendingTimestampOffset_;
    _.timestampOffset = this.timestampOffsetForSegment_({
      buffered: this.buffered_(),
      currentTimeline: this.currentTimeline_,
      overrideCheck: m,
      segmentTimeline: f.timeline,
      startOfSegment: u
    });
    var x = og(this.sourceUpdater_.audioBuffered());
    return typeof x == "number" && (_.audioAppendStart = x - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (_.gopsToAlignWith = sP(
      this.gopBuffer_,
      // since the transmuxer is using the actual timing values, but the time is
      // adjusted by the timestmap offset, we must adjust the value here
      this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(),
      this.timeMapping_
    )), _;
  }, i.timestampOffsetForSegment_ = function(r) {
    return pP(r);
  }, i.earlyAbortWhenNeeded_ = function(r) {
    if (!(this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition
    // TODO: Replace using timeout with a boolean indicating whether this playlist is
    //       the lowestEnabledRendition.
    !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes
    !this.playlist_.attributes.BANDWIDTH) && !(Date.now() - (r.firstBytesReceivedAt || Date.now()) < 1e3)) {
      var a = this.currentTime_(), s = r.bandwidth, o = this.pendingSegment_.duration, u = lr.estimateSegmentRequestTime(
        o,
        s,
        this.playlist_,
        r.bytesReceived
      ), l = F3(
        this.buffered_(),
        a,
        this.vhs_.tech_.playbackRate()
      ) - 1;
      if (!(u <= l)) {
        var c = ZD({
          bandwidth: s,
          currentTime: a,
          currentTimeline: this.currentTimeline_,
          duration: this.duration_(),
          master: this.vhs_.playlists.master,
          segmentDuration: o,
          syncController: this.syncController_,
          timeUntilRebuffer: l
        });
        if (c) {
          var h = u - l, d = h - c.rebufferingImpact, f = 0.5;
          l <= ga && (f = 1), !(!c.playlist || c.playlist.uri === this.playlist_.uri || d < f) && (this.bandwidth = c.playlist.attributes.BANDWIDTH * Pi.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort"));
        }
      }
    }
  }, i.handleAbort_ = function(r) {
    this.logger_("Aborting " + Ps(r)), this.mediaRequestsAborted += 1;
  }, i.handleProgress_ = function(r, a) {
    this.earlyAbortWhenNeeded_(a.stats), !this.checkForAbort_(a.requestId) && this.trigger("progress");
  }, i.handleTrackInfo_ = function(r, a) {
    this.earlyAbortWhenNeeded_(r.stats), !this.checkForAbort_(r.requestId) && (this.checkForIllegalMediaSwitch(a) || (a = a || {}, lP(this.currentMediaInfo_, a) || (this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.startingMediaInfo_ = a, this.currentMediaInfo_ = a, this.logger_("trackinfo update", a), this.trigger("trackinfo")), !this.checkForAbort_(r.requestId) && (this.pendingSegment_.trackInfo = a, this.hasEnoughInfoToAppend_() && this.processCallQueue_())));
  }, i.handleTimingInfo_ = function(r, a, s, o) {
    if (this.earlyAbortWhenNeeded_(r.stats), !this.checkForAbort_(r.requestId)) {
      var u = this.pendingSegment_, l = yg(a);
      u[l] = u[l] || {}, u[l][s] = o, this.logger_("timinginfo: " + a + " - " + s + " - " + o), this.hasEnoughInfoToAppend_() && this.processCallQueue_();
    }
  }, i.handleCaptions_ = function(r, a) {
    var s = this;
    if (this.earlyAbortWhenNeeded_(r.stats), !this.checkForAbort_(r.requestId)) {
      if (a.length === 0) {
        this.logger_("SegmentLoader received no captions from a caption event");
        return;
      }
      var o = this.pendingSegment_;
      if (!o.hasAppendedData_) {
        this.metadataQueue_.caption.push(
          this.handleCaptions_.bind(this, r, a)
        );
        return;
      }
      var u = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(), l = {};
      a.forEach(function(c) {
        l[c.stream] = l[c.stream] || {
          captions: [],
          // 0 as an other value will be more than this
          endTime: 0,
          // Infinity, as any other value will be less than this
          startTime: 1 / 0
        };
        var h = l[c.stream];
        h.startTime = Math.min(
          h.startTime,
          c.startTime + u
        ), h.endTime = Math.max(
          h.endTime,
          c.endTime + u
        ), h.captions.push(c);
      }), Object.keys(l).forEach(function(c) {
        var h = l[c], d = h.startTime, f = h.endTime, p = h.captions, _ = s.inbandTextTracks_;
        s.logger_(
          "adding cues from " + d + " -> " + f + " for " + c
        ), eP(
          _,
          s.vhs_.tech_,
          c
        ), ou(d, f, _[c]), tP({
          captionArray: p,
          inbandTextTracks: _,
          timestampOffset: u
        });
      }), this.transmuxer_ && this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  }, i.handleId3_ = function(r, a, s) {
    if (this.earlyAbortWhenNeeded_(r.stats), !this.checkForAbort_(r.requestId)) {
      var o = this.pendingSegment_;
      if (!o.hasAppendedData_) {
        this.metadataQueue_.id3.push(
          this.handleId3_.bind(this, r, a, s)
        );
        return;
      }
      var u = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
      nP(
        this.inbandTextTracks_,
        s,
        this.vhs_.tech_
      ), rP({
        inbandTextTracks: this.inbandTextTracks_,
        metadataArray: a,
        timestampOffset: u,
        videoDuration: this.duration_()
      });
    }
  }, i.processMetadataQueue_ = function() {
    this.metadataQueue_.id3.forEach(function(r) {
      return r();
    }), this.metadataQueue_.caption.forEach(function(r) {
      return r();
    }), this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [];
  }, i.processCallQueue_ = function() {
    var r = this.callQueue_;
    this.callQueue_ = [], r.forEach(function(a) {
      return a();
    });
  }, i.processLoadQueue_ = function() {
    var r = this.loadQueue_;
    this.loadQueue_ = [], r.forEach(function(a) {
      return a();
    });
  }, i.hasEnoughInfoToLoad_ = function() {
    if (this.loaderType_ !== "audio")
      return !0;
    var r = this.pendingSegment_;
    return r ? this.getCurrentMediaInfo_() ? (
      // Technically, instead of waiting to load a segment on timeline changes, a segment
      // can be requested and downloaded and only wait before it is transmuxed or parsed.
      // But in practice, there are a few reasons why it is better to wait until a loader
      // is ready to append that segment before requesting and downloading:
      //
      // 1. Because audio and main loaders cross discontinuities together, if this loader
      //    is waiting for the other to catch up, then instead of requesting another
      //    segment and using up more bandwidth, by not yet loading, more bandwidth is
      //    allotted to the loader currently behind.
      // 2. media-segment-request doesn't have to have logic to consider whether a segment
      // is ready to be processed or not, isolating the queueing behavior to the loader.
      // 3. The audio loader bases some of its segment properties on timing information
      //    provided by the main loader, meaning that, if the logic for waiting on
      //    processing was in media-segment-request, then it would also need to know how
      //    to re-generate the segment information after the main loader caught up.
      !_g({
        audioDisabled: this.audioDisabled_,
        currentTimeline: this.currentTimeline_,
        loaderType: this.loaderType_,
        segmentTimeline: r.timeline,
        timelineChangeController: this.timelineChangeController_
      })
    ) : !0 : !1;
  }, i.getCurrentMediaInfo_ = function(r) {
    return r === void 0 && (r = this.pendingSegment_), r && r.trackInfo || this.currentMediaInfo_;
  }, i.getMediaInfo_ = function(r) {
    return r === void 0 && (r = this.pendingSegment_), this.getCurrentMediaInfo_(r) || this.startingMediaInfo_;
  }, i.getPendingSegmentPlaylist = function() {
    return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
  }, i.hasEnoughInfoToAppend_ = function() {
    if (!this.sourceUpdater_.ready() || this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_)
      return !1;
    var r = this.pendingSegment_, a = this.getCurrentMediaInfo_();
    if (!r || !a)
      return !1;
    var s = a.hasAudio, o = a.hasVideo, u = a.isMuxed;
    return !(o && !r.videoTimingInfo || s && !this.audioDisabled_ && !u && !r.audioTimingInfo || _g({
      audioDisabled: this.audioDisabled_,
      currentTimeline: this.currentTimeline_,
      loaderType: this.loaderType_,
      segmentTimeline: r.timeline,
      timelineChangeController: this.timelineChangeController_
    }));
  }, i.handleData_ = function(r, a) {
    if (this.earlyAbortWhenNeeded_(r.stats), !this.checkForAbort_(r.requestId)) {
      if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
        this.callQueue_.push(this.handleData_.bind(this, r, a));
        return;
      }
      var s = this.pendingSegment_;
      if (this.setTimeMapping_(s.timeline), this.updateMediaSecondsLoaded_(s.part || s.segment), this.mediaSource_.readyState !== "closed") {
        if (r.map && (r.map = this.initSegmentForMap(r.map, !0), s.segment.map = r.map), r.key && this.segmentKey(r.key, !0), s.isFmp4 = r.isFmp4, s.timingInfo = s.timingInfo || {}, s.isFmp4)
          this.trigger("fmp4"), s.timingInfo.start = s[yg(a.type)].start;
        else {
          var o = this.getCurrentMediaInfo_(), u = this.loaderType_ === "main" && o && o.hasVideo, l;
          u && (l = s.videoTimingInfo.start), s.timingInfo.start = this.trueSegmentStart_({
            audioTimingInfo: s.audioTimingInfo,
            currentStart: s.timingInfo.start,
            currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
            firstVideoFrameTimeForData: l,
            mediaIndex: s.mediaIndex,
            playlist: s.playlist,
            useVideoTimingInfo: u,
            videoTimingInfo: s.videoTimingInfo
          });
        }
        if (this.updateAppendInitSegmentStatus(s, a.type), this.updateSourceBufferTimestampOffset_(s), s.isSyncRequest) {
          this.updateTimingInfoEnd_(s), this.syncController_.saveSegmentTimingInfo({
            segmentInfo: s,
            shouldSaveTimelineMapping: this.loaderType_ === "main"
          });
          var c = this.chooseNextRequest_();
          if (c.mediaIndex !== s.mediaIndex || c.partIndex !== s.partIndex) {
            this.logger_("sync segment was incorrect, not appending");
            return;
          }
          this.logger_("sync segment was correct, appending");
        }
        s.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(s, a), a.type === "video" && this.vhs_.tech_.trigger({
          name: "vhs-segment",
          payload: {
            result: a,
            segmentInfo: s,
            simpleSegment: r
          },
          type: "vhs"
        });
      }
    }
  }, i.updateAppendInitSegmentStatus = function(r, a) {
    this.loaderType_ === "main" && typeof r.timestampOffset == "number" && // in the case that we're handling partial data, we don't want to append an init
    // segment for each chunk
    !r.changedTimestampOffset && (this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }), this.playlistOfLastInitSegment_[a] !== r.playlist && (this.appendInitSegment_[a] = !0);
  }, i.getInitSegmentAndUpdateState_ = function(r) {
    var a = r.type, s = r.initSegment, o = r.map, u = r.playlist;
    if (o) {
      var l = Zc(o);
      if (this.activeInitSegmentId_ === l)
        return null;
      s = this.initSegmentForMap(o, !0).bytes, this.activeInitSegmentId_ = l;
    }
    return s && this.appendInitSegment_[a] ? (this.playlistOfLastInitSegment_[a] = u, this.appendInitSegment_[a] = !1, this.activeInitSegmentId_ = null, s) : null;
  }, i.handleQuotaExceededError_ = function(r, a) {
    var s = this, o = r.segmentInfo, u = r.type, l = r.bytes, c = this.sourceUpdater_.audioBuffered(), h = this.sourceUpdater_.videoBuffered();
    c.length > 1 && this.logger_(
      "On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + Oa(c).join(", ")
    ), h.length > 1 && this.logger_(
      "On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + Oa(h).join(", ")
    );
    var d = c.length ? c.start(0) : 0, f = c.length ? c.end(c.length - 1) : 0, p = h.length ? h.start(0) : 0, _ = h.length ? h.end(h.length - 1) : 0;
    if (f - d <= eu && _ - p <= eu) {
      this.logger_(
        "On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. " + ("Appended byte length: " + l.byteLength + ", ") + ("audio buffer: " + Oa(c).join(", ") + ", ") + ("video buffer: " + Oa(h).join(", ") + ", ")
      ), this.error({
        excludeUntil: 1 / 0,
        message: "Quota exceeded error with append of a single segment of content"
      }), this.trigger("error");
      return;
    }
    this.waitingOnRemove_ = !0, this.callQueue_.push(
      this.appendToSourceBuffer_.bind(this, {
        bytes: l,
        segmentInfo: o,
        type: u
      })
    );
    var m = this.currentTime_(), x = m - eu;
    this.logger_(
      "On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + x
    ), this.remove(
      0,
      x,
      function() {
        s.logger_(
          "On QUOTA_EXCEEDED_ERR, retrying append in " + eu + "s"
        ), s.waitingOnRemove_ = !1, s.quotaExceededErrorRetryTimeout_ = W.setTimeout(
          function() {
            s.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), s.quotaExceededErrorRetryTimeout_ = null, s.processCallQueue_();
          },
          eu * 1e3
        );
      },
      !0
    );
  }, i.handleAppendError_ = function(r, a) {
    var s = r.segmentInfo, o = r.type, u = r.bytes;
    if (a) {
      if (a.code === p1) {
        this.handleQuotaExceededError_({
          bytes: u,
          segmentInfo: s,
          type: o
        });
        return;
      }
      this.logger_("Received non QUOTA_EXCEEDED_ERR on append", a), this.error(
        o + " append of " + u.length + "b failed for segment " + ("#" + s.mediaIndex + " in playlist " + s.playlist.id)
      ), this.trigger("appenderror");
    }
  }, i.appendToSourceBuffer_ = function(r) {
    var a = r.segmentInfo, s = r.type, o = r.initSegment, u = r.data, l = r.bytes;
    if (!l) {
      var c = [u], h = u.byteLength;
      o && (c.unshift(o), h += o.byteLength), l = $D({
        bytes: h,
        segments: c
      });
    }
    this.sourceUpdater_.appendBuffer(
      {
        bytes: l,
        segmentInfo: a,
        type: s
      },
      this.handleAppendError_.bind(this, {
        bytes: l,
        segmentInfo: a,
        type: s
      })
    );
  }, i.handleSegmentTimingInfo_ = function(r, a, s) {
    if (!(!this.pendingSegment_ || a !== this.pendingSegment_.requestId)) {
      var o = this.pendingSegment_.segment, u = r + "TimingInfo";
      o[u] || (o[u] = {}), o[u].transmuxerPrependedSeconds = s.prependedContentDuration || 0, o[u].transmuxedPresentationStart = s.start.presentation, o[u].transmuxedDecodeStart = s.start.decode, o[u].transmuxedPresentationEnd = s.end.presentation, o[u].transmuxedDecodeEnd = s.end.decode, o[u].baseMediaDecodeTime = s.baseMediaDecodeTime;
    }
  }, i.appendData_ = function(r, a) {
    var s = a.type, o = a.data;
    if (!(!o || !o.byteLength) && !(s === "audio" && this.audioDisabled_)) {
      var u = this.getInitSegmentAndUpdateState_({
        initSegment: a.initSegment,
        map: r.isFmp4 ? r.segment.map : null,
        playlist: r.playlist,
        type: s
      });
      this.appendToSourceBuffer_({
        data: o,
        initSegment: u,
        segmentInfo: r,
        type: s
      });
    }
  }, i.loadSegment_ = function(r) {
    var a = this;
    if (this.state = "WAITING", this.pendingSegment_ = r, this.trimBackBuffer_(r), typeof r.timestampOffset == "number" && this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearAllMp4Captions"
    }), !this.hasEnoughInfoToLoad_()) {
      this.loadQueue_.push(function() {
        var s = kr({}, r, {
          forceTimestampOffset: !0
        });
        kr(r, a.generateSegmentInfo_(s)), a.isPendingTimestampOffset_ = !1, a.updateTransmuxerAndRequestSegment_(r);
      });
      return;
    }
    this.updateTransmuxerAndRequestSegment_(r);
  }, i.updateTransmuxerAndRequestSegment_ = function(r) {
    var a = this;
    this.shouldUpdateTransmuxerTimestampOffset_(r.timestampOffset) && (this.gopBuffer_.length = 0, r.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({
      action: "reset"
    }), this.transmuxer_.postMessage({
      action: "setTimestampOffset",
      timestampOffset: r.timestampOffset
    }));
    var s = this.createSimplifiedSegmentObj_(r), o = this.isEndOfStream_(
      r.mediaIndex,
      r.playlist,
      r.partIndex
    ), u = this.mediaIndex !== null, l = r.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,
    // the first timeline
    r.timeline > 0, c = o || u && l;
    this.logger_("Requesting " + Ps(r)), s.map && !s.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }), r.abortRequests = WD({
      abortFn: this.handleAbort_.bind(this, r),
      audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(
        this,
        "audio",
        r.requestId
      ),
      captionsFn: this.handleCaptions_.bind(this),
      decryptionWorker: this.decrypter_,
      endedTimelineFn: function() {
        a.logger_("received endedtimeline callback");
      },
      progressFn: this.handleProgress_.bind(this),
      dataFn: this.handleData_.bind(this),
      segment: s,
      doneFn: this.segmentRequestFinished_.bind(this),
      xhr: this.vhs_.xhr,
      id3Fn: this.handleId3_.bind(this),
      xhrOptions: this.xhrOptions_,
      isEndOfTimeline: c,
      onTransmuxerLog: function(d) {
        var f = d.message, p = d.level, _ = d.stream;
        a.logger_(
          Ps(r) + " logged from transmuxer stream " + _ + " as a " + p + ": " + f
        );
      },
      timingInfoFn: this.handleTimingInfo_.bind(this),
      trackInfoFn: this.handleTrackInfo_.bind(this),
      videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(
        this,
        "video",
        r.requestId
      )
    });
  }, i.trimBackBuffer_ = function(r) {
    var a = fP(
      this.seekable_(),
      this.currentTime_(),
      this.playlist_.targetDuration || 10
    );
    a > 0 && this.remove(0, a);
  }, i.createSimplifiedSegmentObj_ = function(r) {
    var a = r.segment, s = r.part, o = {
      audioAppendStart: r.audioAppendStart,
      byterange: s ? s.byterange : a.byterange,
      gopsToAlignWith: r.gopsToAlignWith,
      part: r.part,
      requestId: r.requestId,
      resolvedUri: s ? s.resolvedUri : a.resolvedUri,
      transmuxer: r.transmuxer
    }, u = r.playlist.segments[r.mediaIndex - 1];
    if (u && u.timeline === a.timeline && (u.videoTimingInfo ? o.baseStartTime = u.videoTimingInfo.transmuxedDecodeEnd : u.audioTimingInfo && (o.baseStartTime = u.audioTimingInfo.transmuxedDecodeEnd)), a.key) {
      var l = a.key.iv || new Uint32Array([
        0,
        0,
        0,
        r.mediaIndex + r.playlist.mediaSequence
      ]);
      o.key = this.segmentKey(a.key), o.key.iv = l;
    }
    return a.map && (o.map = this.initSegmentForMap(a.map)), o;
  }, i.saveTransferStats_ = function(r) {
    this.mediaRequests += 1, r && (this.mediaBytesTransferred += r.bytesReceived, this.mediaTransferDuration += r.roundTripTime);
  }, i.saveBandwidthRelatedStats_ = function(r, a) {
    if (this.pendingSegment_.byteLength = a.bytesReceived, r < Jl) {
      this.logger_(
        "Ignoring segment's bandwidth because its duration of " + r + (" is less than the min to record " + Jl)
      );
      return;
    }
    this.bandwidth = a.bandwidth, this.roundTrip = a.roundTripTime;
  }, i.handleTimeout_ = function() {
    this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate"), this.trigger("timeout");
  }, i.segmentRequestFinished_ = function(r, a, s) {
    if (this.callQueue_.length) {
      this.callQueue_.push(
        this.segmentRequestFinished_.bind(this, r, a, s)
      );
      return;
    }
    if (this.saveTransferStats_(a.stats), !!this.pendingSegment_ && a.requestId === this.pendingSegment_.requestId) {
      if (r) {
        if (this.pendingSegment_ = null, this.state = "READY", r.code === fn.ABORTED)
          return;
        if (this.pause(), r.code === fn.TIMEOUT) {
          this.handleTimeout_();
          return;
        }
        this.mediaRequestsErrored += 1, this.error(r), this.trigger("error");
        return;
      }
      var o = this.pendingSegment_;
      this.saveBandwidthRelatedStats_(o.duration, a.stats), o.endOfAllRequests = a.endOfAllRequests, s.gopInfo && (this.gopBuffer_ = oP(
        this.gopBuffer_,
        s.gopInfo,
        this.safeAppend_
      )), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(o);
    }
  }, i.setTimeMapping_ = function(r) {
    var a = this.syncController_.mappingForTimeline(r);
    a !== null && (this.timeMapping_ = a);
  }, i.updateMediaSecondsLoaded_ = function(r) {
    typeof r.start == "number" && typeof r.end == "number" ? this.mediaSecondsLoaded += r.end - r.start : this.mediaSecondsLoaded += r.duration;
  }, i.shouldUpdateTransmuxerTimestampOffset_ = function(r) {
    return r === null ? !1 : this.loaderType_ === "main" && r !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && r !== this.sourceUpdater_.audioTimestampOffset();
  }, i.trueSegmentStart_ = function(r) {
    var a = r.currentStart, s = r.playlist, o = r.mediaIndex, u = r.firstVideoFrameTimeForData, l = r.currentVideoTimestampOffset, c = r.useVideoTimingInfo, h = r.videoTimingInfo, d = r.audioTimingInfo;
    if (typeof a < "u")
      return a;
    if (!c)
      return d.start;
    var f = s.segments[o - 1];
    return o === 0 || !f || typeof f.start > "u" || f.end !== u + l ? u : h.start;
  }, i.waitForAppendsToComplete_ = function(r) {
    var a = this.getCurrentMediaInfo_(r);
    if (!a) {
      this.error({
        blacklistDuration: 1 / 0,
        message: "No starting media returned, likely due to an unsupported media format."
      }), this.trigger("error");
      return;
    }
    var s = a.hasAudio, o = a.hasVideo, u = a.isMuxed, l = this.loaderType_ === "main" && o, c = !this.audioDisabled_ && s && !u;
    if (r.waitingOnAppends = 0, !r.hasAppendedData_) {
      !r.timingInfo && typeof r.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !0), r.timingInfo = {
        start: 0
      }, r.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(r), this.processMetadataQueue_()), this.checkAppendsDone_(r);
      return;
    }
    l && r.waitingOnAppends++, c && r.waitingOnAppends++, l && this.sourceUpdater_.videoQueueCallback(
      this.checkAppendsDone_.bind(this, r)
    ), c && this.sourceUpdater_.audioQueueCallback(
      this.checkAppendsDone_.bind(this, r)
    );
  }, i.checkAppendsDone_ = function(r) {
    this.checkForAbort_(r.requestId) || (r.waitingOnAppends--, r.waitingOnAppends === 0 && this.handleAppendsDone_());
  }, i.checkForIllegalMediaSwitch = function(r) {
    var a = dP(
      this.loaderType_,
      this.getCurrentMediaInfo_(),
      r
    );
    return a ? (this.error({
      blacklistDuration: 1 / 0,
      message: a
    }), this.trigger("error"), !0) : !1;
  }, i.updateSourceBufferTimestampOffset_ = function(r) {
    if (!(r.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has
    // priority, timing-wise, so we must wait
    typeof r.timingInfo.start != "number" || // already updated the timestamp offset for this segment
    r.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset
    this.loaderType_ !== "main")) {
      var a = !1;
      r.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
        audioTimingInfo: r.segment.audioTimingInfo,
        timingInfo: r.timingInfo,
        videoTimingInfo: r.segment.videoTimingInfo
      }), r.changedTimestampOffset = !0, r.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(r.timestampOffset), a = !0), r.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(r.timestampOffset), a = !0), a && this.trigger("timestampoffset");
    }
  }, i.getSegmentStartTimeForTimestampOffsetCalculation_ = function(r) {
    var a = r.videoTimingInfo, s = r.audioTimingInfo, o = r.timingInfo;
    return this.useDtsForTimestampOffset_ ? a && typeof a.transmuxedDecodeStart == "number" ? a.transmuxedDecodeStart : s && typeof s.transmuxedDecodeStart == "number" ? s.transmuxedDecodeStart : o.start : o.start;
  }, i.updateTimingInfoEnd_ = function(r) {
    r.timingInfo = r.timingInfo || {};
    var a = this.getMediaInfo_(), s = this.loaderType_ === "main" && a && a.hasVideo, o = s && r.videoTimingInfo ? r.videoTimingInfo : r.audioTimingInfo;
    o && (r.timingInfo.end = typeof o.end == "number" ? (
      // current example is the case of fmp4), so use the rough duration to calculate an
      // end time.
      o.end
    ) : o.start + r.duration);
  }, i.handleAppendsDone_ = function() {
    if (this.pendingSegment_ && this.trigger("appendsdone"), !this.pendingSegment_) {
      this.state = "READY", this.paused() || this.monitorBuffer_();
      return;
    }
    var r = this.pendingSegment_;
    this.updateTimingInfoEnd_(r), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({
      segmentInfo: r,
      shouldSaveTimelineMapping: this.loaderType_ === "main"
    });
    var a = mP(
      r,
      this.sourceType_
    );
    if (a && (a.severity === "warn" ? X.log.warn(a.message) : this.logger_(a.message)), this.recordThroughput_(r), this.pendingSegment_ = null, this.state = "READY", r.isSyncRequest && (this.trigger("syncinfoupdate"), !r.hasAppendedData_)) {
      this.logger_(
        "Throwing away un-appended sync request " + Ps(r)
      );
      return;
    }
    this.logger_("Appended " + Ps(r)), this.addSegmentMetadataCue_(r), this.fetchAtBuffer_ = !0, this.currentTimeline_ !== r.timeline && (this.timelineChangeController_.lastTimelineChange({
      from: this.currentTimeline_,
      to: r.timeline,
      type: this.loaderType_
    }), this.loaderType_ === "main" && !this.audioDisabled_ && this.timelineChangeController_.lastTimelineChange({
      from: this.currentTimeline_,
      to: r.timeline,
      type: "audio"
    })), this.currentTimeline_ = r.timeline, this.trigger("syncinfoupdate");
    var s = r.segment, o = r.part, u = s.end && this.currentTime_() - s.end > r.playlist.targetDuration * 3, l = o && o.end && this.currentTime_() - o.end > r.playlist.partTargetDuration * 3;
    if (u || l) {
      this.logger_(
        "bad " + (u ? "segment" : "part") + " " + Ps(r)
      ), this.resetEverything();
      return;
    }
    var c = this.mediaIndex !== null;
    c && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = r.mediaIndex, this.partIndex = r.partIndex, this.isEndOfStream_(
      r.mediaIndex,
      r.playlist,
      r.partIndex
    ) && this.endOfStream(), this.trigger("appended"), r.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_();
  }, i.recordThroughput_ = function(r) {
    if (r.duration < Jl) {
      this.logger_(
        "Ignoring segment's throughput because its duration of " + r.duration + (" is less than the min to record " + Jl)
      );
      return;
    }
    var a = this.throughput.rate, s = Date.now() - r.endOfAllRequests + 1, o = Math.floor(
      r.byteLength / s * 8 * 1e3
    );
    this.throughput.rate += (o - a) / ++this.throughput.count;
  }, i.addSegmentMetadataCue_ = function(r) {
    if (this.segmentMetadataTrack_) {
      var a = r.segment, s = a.start, o = a.end;
      if (!(!gg(s) || !gg(o))) {
        ou(s, o, this.segmentMetadataTrack_);
        var u = W.WebKitDataCue || W.VTTCue, l = {
          bandwidth: r.playlist.attributes.BANDWIDTH,
          byteLength: r.byteLength,
          codecs: r.playlist.attributes.CODECS,
          custom: a.custom,
          dateTimeObject: a.dateTimeObject,
          dateTimeString: a.dateTimeString,
          end: o,
          playlist: r.playlist.id,
          resolution: r.playlist.attributes.RESOLUTION,
          start: s,
          timeline: r.timeline,
          uri: r.uri
        }, c = JSON.stringify(l), h = new u(s, o, c);
        h.value = l, this.segmentMetadataTrack_.addCue(h);
      }
    }
  }, t;
}(X.EventTarget);
function Rn() {
}
var v1 = function(t) {
  return typeof t != "string" ? t : t.replace(/./, function(i) {
    return i.toUpperCase();
  });
}, gP = ["video", "audio"], xf = function(t, i) {
  var n = i[t + "Buffer"];
  return n && n.updating || i.queuePending[t];
}, yP = function(t, i) {
  for (var n = 0; n < i.length; n++) {
    var r = i[n];
    if (r.type === "mediaSource")
      return null;
    if (r.type === t)
      return n;
  }
  return null;
}, lv = function e(t, i) {
  if (i.queue.length !== 0) {
    var n = 0, r = i.queue[n];
    if (r.type === "mediaSource") {
      !i.updating() && i.mediaSource.readyState !== "closed" && (i.queue.shift(), r.action(i), r.doneFn && r.doneFn(), e("audio", i), e("video", i));
      return;
    }
    if (t !== "mediaSource" && !(!i.ready() || i.mediaSource.readyState === "closed" || xf(t, i))) {
      if (r.type !== t) {
        if (n = yP(t, i.queue), n === null)
          return;
        r = i.queue[n];
      }
      if (i.queue.splice(n, 1), i.queuePending[t] = r, r.action(t, i), !r.doneFn) {
        i.queuePending[t] = null, e(t, i);
        return;
      }
    }
  }
}, m1 = function(t, i) {
  var n = i[t + "Buffer"], r = v1(t);
  n && (n.removeEventListener(
    "updateend",
    i["on" + r + "UpdateEnd_"]
  ), n.removeEventListener(
    "error",
    i["on" + r + "Error_"]
  ), i.codecs[t] = null, i[t + "Buffer"] = null);
}, cn = function(t, i) {
  return t && i && Array.prototype.indexOf.call(t.sourceBuffers, i) !== -1;
}, xr = {
  abort: function() {
    return function(t, i) {
      if (i.mediaSource.readyState === "open") {
        var n = i[t + "Buffer"];
        if (cn(i.mediaSource, n)) {
          i.logger_("calling abort on " + t + "Buffer");
          try {
            n.abort();
          } catch (r) {
            X.log.warn("Failed to abort on " + t + "Buffer", r);
          }
        }
      }
    };
  },
  addSourceBuffer: function(t, i) {
    return function(n) {
      var r = v1(t), a = ll(i);
      n.logger_(
        "Adding " + t + "Buffer with codec " + i + " to mediaSource"
      );
      var s = n.mediaSource.addSourceBuffer(a);
      s.addEventListener(
        "updateend",
        n["on" + r + "UpdateEnd_"]
      ), s.addEventListener(
        "error",
        n["on" + r + "Error_"]
      ), n.codecs[t] = i, n[t + "Buffer"] = s;
    };
  },
  appendBuffer: function(t, i, n) {
    return function(r, a) {
      var s = a[r + "Buffer"];
      if (cn(a.mediaSource, s)) {
        a.logger_(
          "Appending segment " + i.mediaIndex + "'s " + t.length + " bytes to " + r + "Buffer"
        );
        try {
          s.appendBuffer(t);
        } catch (o) {
          a.logger_(
            "Error with code " + o.code + " " + (o.code === p1 ? "(QUOTA_EXCEEDED_ERR) " : "") + ("when appending segment " + i.mediaIndex + " to " + r + "Buffer")
          ), a.queuePending[r] = null, n(o);
        }
      }
    };
  },
  callback: function(t) {
    return function(i, n) {
      t();
    };
  },
  changeType: function(t) {
    return function(i, n) {
      var r = n[i + "Buffer"], a = ll(t);
      cn(n.mediaSource, r) && n.codecs[i] !== t && (n.logger_(
        "changing " + i + "Buffer codec from " + n.codecs[i] + " to " + t
      ), r.changeType(a), n.codecs[i] = t);
    };
  },
  duration: function(t) {
    return function(i) {
      i.logger_("Setting mediaSource duration to " + t);
      try {
        i.mediaSource.duration = t;
      } catch (n) {
        X.log.warn("Failed to set media source duration", n);
      }
    };
  },
  endOfStream: function(t) {
    return function(i) {
      if (i.mediaSource.readyState === "open") {
        i.logger_(
          "Calling mediaSource endOfStream(" + (t || "") + ")"
        );
        try {
          i.mediaSource.endOfStream(t);
        } catch (n) {
          X.log.warn("Failed to call media source endOfStream", n);
        }
      }
    };
  },
  remove: function(t, i) {
    return function(n, r) {
      var a = r[n + "Buffer"];
      if (cn(r.mediaSource, a)) {
        r.logger_(
          "Removing " + t + " to " + i + " from " + n + "Buffer"
        );
        try {
          a.remove(t, i);
        } catch {
          r.logger_(
            "Remove " + t + " to " + i + " from " + n + "Buffer failed"
          );
        }
      }
    };
  },
  removeSourceBuffer: function(t) {
    return function(i) {
      var n = i[t + "Buffer"];
      if (m1(t, i), !!cn(i.mediaSource, n)) {
        i.logger_(
          "Removing " + t + "Buffer with codec " + i.codecs[t] + " from mediaSource"
        );
        try {
          i.mediaSource.removeSourceBuffer(n);
        } catch (r) {
          X.log.warn("Failed to removeSourceBuffer " + t + "Buffer", r);
        }
      }
    };
  },
  timestampOffset: function(t) {
    return function(i, n) {
      var r = n[i + "Buffer"];
      cn(n.mediaSource, r) && (n.logger_("Setting " + i + "timestampOffset to " + t), r.timestampOffset = t);
    };
  }
}, Ar = function(t) {
  var i = t.type, n = t.sourceUpdater, r = t.action, a = t.doneFn, s = t.name;
  n.queue.push({
    action: r,
    doneFn: a,
    name: s,
    type: i
  }), lv(i, n);
}, xg = function(t, i) {
  return function(n) {
    if (i.queuePending[t]) {
      var r = i.queuePending[t].doneFn;
      i.queuePending[t] = null, r && r(i[t + "Error_"]);
    }
    lv(t, i);
  };
}, g1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var r;
    return r = e.call(this) || this, r.mediaSource = n, r.sourceopenListener_ = function() {
      return lv("mediaSource", He(r));
    }, r.mediaSource.addEventListener("sourceopen", r.sourceopenListener_), r.logger_ = rn("SourceUpdater"), r.audioTimestampOffset_ = 0, r.videoTimestampOffset_ = 0, r.queue = [], r.queuePending = {
      audio: null,
      video: null
    }, r.delayedAudioAppendQueue_ = [], r.videoAppendQueued_ = !1, r.codecs = {}, r.onVideoUpdateEnd_ = xg(
      "video",
      He(r)
    ), r.onAudioUpdateEnd_ = xg(
      "audio",
      He(r)
    ), r.onVideoError_ = function(a) {
      r.videoError_ = a;
    }, r.onAudioError_ = function(a) {
      r.audioError_ = a;
    }, r.createdSourceBuffers_ = !1, r.initializedEme_ = !1, r.triggeredReady_ = !1, r;
  }
  var i = t.prototype;
  return i.initializedEme = function() {
    this.initializedEme_ = !0, this.triggerReady();
  }, i.hasCreatedSourceBuffers = function() {
    return this.createdSourceBuffers_;
  }, i.hasInitializedAnyEme = function() {
    return this.initializedEme_;
  }, i.ready = function() {
    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
  }, i.createSourceBuffers = function(r) {
    this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(r), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady());
  }, i.triggerReady = function() {
    this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready"));
  }, i.addSourceBuffer = function(r, a) {
    Ar({
      action: xr.addSourceBuffer(r, a),
      name: "addSourceBuffer",
      sourceUpdater: this,
      type: "mediaSource"
    });
  }, i.abort = function(r) {
    Ar({
      action: xr.abort(r),
      name: "abort",
      sourceUpdater: this,
      type: r
    });
  }, i.removeSourceBuffer = function(r) {
    if (!this.canRemoveSourceBuffer()) {
      X.log.error("removeSourceBuffer is not supported!");
      return;
    }
    Ar({
      action: xr.removeSourceBuffer(r),
      name: "removeSourceBuffer",
      sourceUpdater: this,
      type: "mediaSource"
    });
  }, i.canRemoveSourceBuffer = function() {
    return !X.browser.IE_VERSION && !X.browser.IS_FIREFOX && W.MediaSource && W.MediaSource.prototype && typeof W.MediaSource.prototype.removeSourceBuffer == "function";
  }, t.canChangeType = function() {
    return W.SourceBuffer && W.SourceBuffer.prototype && typeof W.SourceBuffer.prototype.changeType == "function";
  }, i.canChangeType = function() {
    return this.constructor.canChangeType();
  }, i.changeType = function(r, a) {
    if (!this.canChangeType()) {
      X.log.error("changeType is not supported!");
      return;
    }
    Ar({
      action: xr.changeType(a),
      name: "changeType",
      sourceUpdater: this,
      type: r
    });
  }, i.addOrChangeSourceBuffers = function(r) {
    var a = this;
    if (!r || typeof r != "object" || Object.keys(r).length === 0)
      throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
    Object.keys(r).forEach(function(s) {
      var o = r[s];
      if (!a.hasCreatedSourceBuffers())
        return a.addSourceBuffer(s, o);
      a.canChangeType() && a.changeType(s, o);
    });
  }, i.appendBuffer = function(r, a) {
    var s = this, o = r.segmentInfo, u = r.type, l = r.bytes;
    if (this.processedAppend_ = !0, u === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
      this.delayedAudioAppendQueue_.push([r, a]), this.logger_(
        "delayed audio append of " + l.length + " until video append"
      );
      return;
    }
    var c = a;
    if (Ar({
      action: xr.appendBuffer(
        l,
        o || {
          mediaIndex: -1
        },
        c
      ),
      doneFn: a,
      name: "appendBuffer",
      sourceUpdater: this,
      type: u
    }), u === "video") {
      if (this.videoAppendQueued_ = !0, !this.delayedAudioAppendQueue_.length)
        return;
      var h = this.delayedAudioAppendQueue_.slice();
      this.logger_("queuing delayed audio " + h.length + " appendBuffers"), this.delayedAudioAppendQueue_.length = 0, h.forEach(function(d) {
        s.appendBuffer.apply(s, d);
      });
    }
  }, i.audioBuffered = function() {
    return cn(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : X.createTimeRange();
  }, i.videoBuffered = function() {
    return cn(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : X.createTimeRange();
  }, i.buffered = function() {
    var r = cn(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null, a = cn(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
    return a && !r ? this.audioBuffered() : r && !a ? this.videoBuffered() : B3(this.audioBuffered(), this.videoBuffered());
  }, i.setDuration = function(r, a) {
    a === void 0 && (a = Rn), Ar({
      action: xr.duration(r),
      doneFn: a,
      name: "duration",
      sourceUpdater: this,
      type: "mediaSource"
    });
  }, i.endOfStream = function(r, a) {
    r === void 0 && (r = null), a === void 0 && (a = Rn), typeof r != "string" && (r = void 0), Ar({
      action: xr.endOfStream(r),
      doneFn: a,
      name: "endOfStream",
      sourceUpdater: this,
      type: "mediaSource"
    });
  }, i.removeAudio = function(r, a, s) {
    if (s === void 0 && (s = Rn), !this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
      s();
      return;
    }
    Ar({
      action: xr.remove(r, a),
      doneFn: s,
      name: "remove",
      sourceUpdater: this,
      type: "audio"
    });
  }, i.removeVideo = function(r, a, s) {
    if (s === void 0 && (s = Rn), !this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
      s();
      return;
    }
    Ar({
      action: xr.remove(r, a),
      doneFn: s,
      name: "remove",
      sourceUpdater: this,
      type: "video"
    });
  }, i.updating = function() {
    return !!(xf("audio", this) || xf("video", this));
  }, i.audioTimestampOffset = function(r) {
    return typeof r < "u" && this.audioBuffer && // no point in updating if it's the same
    this.audioTimestampOffset_ !== r && (Ar({
      action: xr.timestampOffset(r),
      name: "timestampOffset",
      sourceUpdater: this,
      type: "audio"
    }), this.audioTimestampOffset_ = r), this.audioTimestampOffset_;
  }, i.videoTimestampOffset = function(r) {
    return typeof r < "u" && this.videoBuffer && // no point in updating if it's the same
    this.videoTimestampOffset !== r && (Ar({
      action: xr.timestampOffset(r),
      name: "timestampOffset",
      sourceUpdater: this,
      type: "video"
    }), this.videoTimestampOffset_ = r), this.videoTimestampOffset_;
  }, i.audioQueueCallback = function(r) {
    this.audioBuffer && Ar({
      action: xr.callback(r),
      name: "callback",
      sourceUpdater: this,
      type: "audio"
    });
  }, i.videoQueueCallback = function(r) {
    this.videoBuffer && Ar({
      action: xr.callback(r),
      name: "callback",
      sourceUpdater: this,
      type: "video"
    });
  }, i.dispose = function() {
    var r = this;
    this.trigger("dispose"), gP.forEach(function(a) {
      r.abort(a), r.canRemoveSourceBuffer() ? r.removeSourceBuffer(a) : r[a + "QueueCallback"](function() {
        return m1(a, r);
      });
    }), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener(
      "sourceopen",
      this.sourceopenListener_
    ), this.off();
  }, t;
}(X.EventTarget), Ag = function(t) {
  return decodeURIComponent(escape(String.fromCharCode.apply(null, t)));
}, Tg = new Uint8Array(
  `

`.split("").map(function(e) {
    return e.charCodeAt(0);
  })
), _P = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.call(
      this,
      "Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded."
    ) || this;
  }
  return t;
}(/* @__PURE__ */ Xd(Error)), bP = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return r === void 0 && (r = {}), a = e.call(this, n, r) || this, a.mediaSource_ = null, a.subtitlesTrack_ = null, a.loaderType_ = "subtitle", a.featuresNativeTextTracks_ = n.featuresNativeTextTracks, a.loadVttJs = n.loadVttJs, a.shouldSaveSegmentTimingInfo_ = !1, a;
  }
  var i = t.prototype;
  return i.createTransmuxer_ = function() {
    return null;
  }, i.buffered_ = function() {
    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length)
      return X.createTimeRanges();
    var r = this.subtitlesTrack_.cues, a = r[0].startTime, s = r[r.length - 1].startTime;
    return X.createTimeRanges([[a, s]]);
  }, i.initSegmentForMap = function(r, a) {
    if (a === void 0 && (a = !1), !r)
      return null;
    var s = Zc(r), o = this.initSegments_[s];
    if (a && !o && r.bytes) {
      var u = Tg.byteLength + r.bytes.byteLength, l = new Uint8Array(u);
      l.set(r.bytes), l.set(Tg, r.bytes.byteLength), this.initSegments_[s] = o = {
        byterange: r.byterange,
        bytes: l,
        resolvedUri: r.resolvedUri
      };
    }
    return o || r;
  }, i.couldBeginLoading_ = function() {
    return this.playlist_ && this.subtitlesTrack_ && !this.paused();
  }, i.init_ = function() {
    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
  }, i.track = function(r) {
    return typeof r > "u" ? this.subtitlesTrack_ : (this.subtitlesTrack_ = r, this.state === "INIT" && this.couldBeginLoading_() && this.init_(), this.subtitlesTrack_);
  }, i.remove = function(r, a) {
    ou(r, a, this.subtitlesTrack_);
  }, i.fillBuffer_ = function() {
    var r = this, a = this.chooseNextRequest_();
    if (a) {
      if (this.syncController_.timestampOffsetForTimeline(a.timeline) === null) {
        var s = function() {
          r.state = "READY", r.paused() || r.monitorBuffer_();
        };
        this.syncController_.one("timestampoffset", s), this.state = "WAITING_ON_TIMELINE";
        return;
      }
      this.loadSegment_(a);
    }
  }, i.timestampOffsetForSegment_ = function() {
    return null;
  }, i.chooseNextRequest_ = function() {
    return this.skipEmptySegments_(
      e.prototype.chooseNextRequest_.call(this)
    );
  }, i.skipEmptySegments_ = function(r) {
    for (; r && r.segment.empty; ) {
      if (r.mediaIndex + 1 >= r.playlist.segments.length) {
        r = null;
        break;
      }
      r = this.generateSegmentInfo_({
        isSyncRequest: r.isSyncRequest,
        mediaIndex: r.mediaIndex + 1,
        playlist: r.playlist,
        startOfSegment: r.startOfSegment + r.duration
      });
    }
    return r;
  }, i.stopForError = function(r) {
    this.error(r), this.state = "READY", this.pause(), this.trigger("error");
  }, i.segmentRequestFinished_ = function(r, a, s) {
    var o = this;
    if (!this.subtitlesTrack_) {
      this.state = "READY";
      return;
    }
    if (this.saveTransferStats_(a.stats), !this.pendingSegment_) {
      this.state = "READY", this.mediaRequestsAborted += 1;
      return;
    }
    if (r) {
      r.code === fn.TIMEOUT && this.handleTimeout_(), r.code === fn.ABORTED ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1, this.stopForError(r);
      return;
    }
    var u = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(u.duration, a.stats), a.key && this.segmentKey(a.key, !0), this.state = "APPENDING", this.trigger("appending");
    var l = u.segment;
    if (l.map && (l.map.bytes = a.map.bytes), u.bytes = a.bytes, typeof W.WebVTT != "function" && typeof this.loadVttJs == "function") {
      this.state = "WAITING_ON_VTTJS", this.loadVttJs().then(
        function() {
          return o.segmentRequestFinished_(r, a, s);
        },
        function() {
          return o.stopForError({
            message: "Error loading vtt.js"
          });
        }
      );
      return;
    }
    l.requested = !0;
    try {
      this.parseVTTCues_(u);
    } catch (c) {
      this.stopForError({
        message: c.message
      });
      return;
    }
    if (this.updateTimeMapping_(
      u,
      this.syncController_.timelines[u.timeline],
      this.playlist_
    ), u.cues.length ? u.timingInfo = {
      end: u.cues[u.cues.length - 1].endTime,
      start: u.cues[0].startTime
    } : u.timingInfo = {
      end: u.startOfSegment + u.duration,
      start: u.startOfSegment
    }, u.isSyncRequest) {
      this.trigger("syncinfoupdate"), this.pendingSegment_ = null, this.state = "READY";
      return;
    }
    u.byteLength = u.bytes.byteLength, this.mediaSecondsLoaded += l.duration, u.cues.forEach(function(c) {
      o.subtitlesTrack_.addCue(
        o.featuresNativeTextTracks_ ? new W.VTTCue(c.startTime, c.endTime, c.text) : c
      );
    }), aP(this.subtitlesTrack_), this.handleAppendsDone_();
  }, i.handleData_ = function() {
  }, i.updateTimingInfoEnd_ = function() {
  }, i.parseVTTCues_ = function(r) {
    var a, s = !1;
    if (typeof W.WebVTT != "function")
      throw new _P();
    typeof W.TextDecoder == "function" ? a = new W.TextDecoder("utf8") : (a = W.WebVTT.StringDecoder(), s = !0);
    var o = new W.WebVTT.Parser(W, W.vttjs, a);
    if (r.cues = [], r.timestampmap = {
      LOCAL: 0,
      MPEGTS: 0
    }, o.oncue = r.cues.push.bind(r.cues), o.ontimestampmap = function(c) {
      r.timestampmap = c;
    }, o.onparsingerror = function(c) {
      X.log.warn("Error encountered when parsing cues: " + c.message);
    }, r.segment.map) {
      var u = r.segment.map.bytes;
      s && (u = Ag(u)), o.parse(u);
    }
    var l = r.bytes;
    s && (l = Ag(l)), o.parse(l), o.flush();
  }, i.updateTimeMapping_ = function(r, a, s) {
    var o = r.segment;
    if (a) {
      if (!r.cues.length) {
        o.empty = !0;
        return;
      }
      var u = r.timestampmap, l = u.MPEGTS / Nc.ONE_SECOND_IN_TS - u.LOCAL + a.mapping;
      if (r.cues.forEach(function(d) {
        d.startTime += l, d.endTime += l;
      }), !s.syncInfo) {
        var c = r.cues[0].startTime, h = r.cues[r.cues.length - 1].startTime;
        s.syncInfo = {
          mediaSequence: s.mediaSequence + r.mediaIndex,
          time: Math.min(c, h - o.duration)
        };
      }
    }
  }, t;
}(bf), xP = function(t, i) {
  for (var n = t.cues, r = 0; r < n.length; r++) {
    var a = n[r];
    if (i >= a.adStartTime && i <= a.adEndTime)
      return a;
  }
  return null;
}, AP = function(t, i, n) {
  if (n === void 0 && (n = 0), !!t.segments)
    for (var r = n, a, s = 0; s < t.segments.length; s++) {
      var o = t.segments[s];
      if (a || (a = xP(i, r + o.duration / 2)), a) {
        if ("cueIn" in o) {
          a.endTime = r, a.adEndTime = r, r += o.duration, a = null;
          continue;
        }
        if (r < a.endTime) {
          r += o.duration;
          continue;
        }
        a.endTime += o.duration;
      } else if ("cueOut" in o && (a = new W.VTTCue(
        r,
        r + o.duration,
        o.cueOut
      ), a.adStartTime = r, a.adEndTime = r + parseFloat(o.cueOut), i.addCue(a)), "cueOutCont" in o) {
        var u = o.cueOutCont.split("/").map(parseFloat), l = u[0], c = u[1];
        a = new W.VTTCue(r, r + o.duration, ""), a.adStartTime = r - l, a.adEndTime = a.adStartTime + c, i.addCue(a);
      }
      r += o.duration;
    }
}, TP = 86400, Eg = [
  // Stategy "VOD": Handle the VOD-case where the sync-point is *always*
  //                the equivalence display-time 0 === segment-index 0
  {
    name: "VOD",
    run: function(t, i, n, r, a) {
      if (n !== 1 / 0) {
        var s = {
          partIndex: null,
          segmentIndex: 0,
          time: 0
        };
        return s;
      }
      return null;
    }
  },
  // Stategy "ProgramDateTime": We have a program-date-time tag in this playlist
  {
    name: "ProgramDateTime",
    run: function(t, i, n, r, a) {
      if (!Object.keys(t.timelineToDatetimeMappings).length)
        return null;
      var s = null, o = null, u = df(i);
      a = a || 0;
      for (var l = 0; l < u.length; l++) {
        var c = i.endList || a === 0 ? l : u.length - (l + 1), h = u[c], d = h.segment, f = t.timelineToDatetimeMappings[d.timeline];
        if (!(!f || !d.dateTimeObject)) {
          var p = d.dateTimeObject.getTime() / 1e3, _ = p + f;
          if (d.parts && typeof h.partIndex == "number")
            for (var m = 0; m < h.partIndex; m++)
              _ += d.parts[m].duration;
          var x = Math.abs(a - _);
          if (o !== null && (x === 0 || o < x))
            break;
          o = x, s = {
            partIndex: h.partIndex,
            segmentIndex: h.segmentIndex,
            time: _
          };
        }
      }
      return s;
    }
  },
  // Stategy "Segment": We have a known time mapping for a timeline and a
  //                    segment in the current timeline with timing data
  {
    name: "Segment",
    run: function(t, i, n, r, a) {
      var s = null, o = null;
      a = a || 0;
      for (var u = df(i), l = 0; l < u.length; l++) {
        var c = i.endList || a === 0 ? l : u.length - (l + 1), h = u[c], d = h.segment, f = h.part && h.part.start || d && d.start;
        if (d.timeline === r && typeof f < "u") {
          var p = Math.abs(a - f);
          if (o !== null && o < p)
            break;
          (!s || o === null || o >= p) && (o = p, s = {
            partIndex: h.partIndex,
            segmentIndex: h.segmentIndex,
            time: f
          });
        }
      }
      return s;
    }
  },
  // Stategy "Discontinuity": We have a discontinuity with a known
  //                          display-time
  {
    name: "Discontinuity",
    run: function(t, i, n, r, a) {
      var s = null;
      if (a = a || 0, i.discontinuityStarts && i.discontinuityStarts.length)
        for (var o = null, u = 0; u < i.discontinuityStarts.length; u++) {
          var l = i.discontinuityStarts[u], c = i.discontinuitySequence + u + 1, h = t.discontinuities[c];
          if (h) {
            var d = Math.abs(a - h.time);
            if (o !== null && o < d)
              break;
            (!s || o === null || o >= d) && (o = d, s = {
              partIndex: null,
              segmentIndex: l,
              time: h.time
            });
          }
        }
      return s;
    }
  },
  // Stategy "Playlist": We have a playlist with a known mapping of
  //                     segment index to display time
  {
    name: "Playlist",
    run: function(t, i, n, r, a) {
      if (i.syncInfo) {
        var s = {
          partIndex: null,
          segmentIndex: i.syncInfo.mediaSequence - i.mediaSequence,
          time: i.syncInfo.time
        };
        return s;
      }
      return null;
    }
  }
], EP = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var r;
    return r = e.call(this) || this, r.timelines = [], r.discontinuities = [], r.timelineToDatetimeMappings = {}, r.logger_ = rn("SyncController"), r;
  }
  var i = t.prototype;
  return i.getSyncPoint = function(r, a, s, o) {
    var u = this.runStrategies_(
      r,
      a,
      s,
      o
    );
    return u.length ? this.selectSyncPoint_(u, {
      key: "time",
      value: o
    }) : null;
  }, i.getExpiredTime = function(r, a) {
    if (!r || !r.segments)
      return null;
    var s = this.runStrategies_(
      r,
      a,
      r.discontinuitySequence,
      0
    );
    if (!s.length)
      return null;
    var o = this.selectSyncPoint_(s, {
      key: "segmentIndex",
      value: 0
    });
    return o.segmentIndex > 0 && (o.time *= -1), Math.abs(
      o.time + fu({
        defaultDuration: r.targetDuration,
        durationList: r.segments,
        endIndex: 0,
        startIndex: o.segmentIndex
      })
    );
  }, i.runStrategies_ = function(r, a, s, o) {
    for (var u = [], l = 0; l < Eg.length; l++) {
      var c = Eg[l], h = c.run(
        this,
        r,
        a,
        s,
        o
      );
      h && (h.strategy = c.name, u.push({
        strategy: c.name,
        syncPoint: h
      }));
    }
    return u;
  }, i.selectSyncPoint_ = function(r, a) {
    for (var s = r[0].syncPoint, o = Math.abs(
      r[0].syncPoint[a.key] - a.value
    ), u = r[0].strategy, l = 1; l < r.length; l++) {
      var c = Math.abs(
        r[l].syncPoint[a.key] - a.value
      );
      c < o && (o = c, s = r[l].syncPoint, u = r[l].strategy);
    }
    return this.logger_(
      "syncPoint for [" + a.key + ": " + a.value + "] chosen with strategy" + (" [" + u + "]: [time:" + s.time + ",") + (" segmentIndex:" + s.segmentIndex) + (typeof s.partIndex == "number" ? ",partIndex:" + s.partIndex : "") + "]"
    ), s;
  }, i.saveExpiredSegmentInfo = function(r, a) {
    var s = a.mediaSequence - r.mediaSequence;
    if (s > TP) {
      X.log.warn(
        "Not saving expired segment info. Media sequence gap " + s + " is too large."
      );
      return;
    }
    for (var o = s - 1; o >= 0; o--) {
      var u = r.segments[o];
      if (u && typeof u.start < "u") {
        a.syncInfo = {
          mediaSequence: r.mediaSequence + o,
          time: u.start
        }, this.logger_(
          "playlist refresh sync: [time:" + a.syncInfo.time + "," + (" mediaSequence: " + a.syncInfo.mediaSequence + "]")
        ), this.trigger("syncinfoupdate");
        break;
      }
    }
  }, i.setDateTimeMappingForStart = function(r) {
    if (this.timelineToDatetimeMappings = {}, r.segments && r.segments.length && r.segments[0].dateTimeObject) {
      var a = r.segments[0], s = a.dateTimeObject.getTime() / 1e3;
      this.timelineToDatetimeMappings[a.timeline] = -s;
    }
  }, i.saveSegmentTimingInfo = function(r) {
    var a = r.segmentInfo, s = r.shouldSaveTimelineMapping, o = this.calculateSegmentTimeMapping_(
      a,
      a.timingInfo,
      s
    ), u = a.segment;
    o && (this.saveDiscontinuitySyncInfo_(a), a.playlist.syncInfo || (a.playlist.syncInfo = {
      mediaSequence: a.playlist.mediaSequence + a.mediaIndex,
      time: u.start
    }));
    var l = u.dateTimeObject;
    u.discontinuity && s && l && (this.timelineToDatetimeMappings[u.timeline] = -(l.getTime() / 1e3));
  }, i.timestampOffsetForTimeline = function(r) {
    return typeof this.timelines[r] > "u" ? null : this.timelines[r].time;
  }, i.mappingForTimeline = function(r) {
    return typeof this.timelines[r] > "u" ? null : this.timelines[r].mapping;
  }, i.calculateSegmentTimeMapping_ = function(r, a, s) {
    var o = r.segment, u = r.part, l = this.timelines[r.timeline], c, h;
    if (typeof r.timestampOffset == "number")
      l = {
        mapping: r.startOfSegment - a.start,
        time: r.startOfSegment
      }, s && (this.timelines[r.timeline] = l, this.trigger("timestampoffset"), this.logger_(
        "time mapping for timeline " + r.timeline + ": " + ("[time: " + l.time + "] [mapping: " + l.mapping + "]")
      )), c = r.startOfSegment, h = a.end + l.mapping;
    else if (l)
      c = a.start + l.mapping, h = a.end + l.mapping;
    else
      return !1;
    return u && (u.start = c, u.end = h), (!o.start || c < o.start) && (o.start = c), o.end = h, !0;
  }, i.saveDiscontinuitySyncInfo_ = function(r) {
    var a = r.playlist, s = r.segment;
    if (s.discontinuity)
      this.discontinuities[s.timeline] = {
        accuracy: 0,
        time: s.start
      };
    else if (a.discontinuityStarts && a.discontinuityStarts.length)
      for (var o = 0; o < a.discontinuityStarts.length; o++) {
        var u = a.discontinuityStarts[o], l = a.discontinuitySequence + o + 1, c = u - r.mediaIndex, h = Math.abs(c);
        if (!this.discontinuities[l] || this.discontinuities[l].accuracy > h) {
          var d = void 0;
          c < 0 ? d = s.start - fu({
            defaultDuration: a.targetDuration,
            durationList: a.segments,
            endIndex: u,
            startIndex: r.mediaIndex
          }) : d = s.end + fu({
            defaultDuration: a.targetDuration,
            durationList: a.segments,
            endIndex: u,
            startIndex: r.mediaIndex + 1
          }), this.discontinuities[l] = {
            accuracy: h,
            time: d
          };
        }
      }
  }, i.dispose = function() {
    this.trigger("dispose"), this.off();
  }, t;
}(X.EventTarget), wP = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    var n;
    return n = e.call(this) || this, n.pendingTimelineChanges_ = {}, n.lastTimelineChanges_ = {}, n;
  }
  var i = t.prototype;
  return i.clearPendingTimelineChange = function(r) {
    this.pendingTimelineChanges_[r] = null, this.trigger("pendingtimelinechange");
  }, i.pendingTimelineChange = function(r) {
    var a = r.type, s = r.from, o = r.to;
    return typeof s == "number" && typeof o == "number" && (this.pendingTimelineChanges_[a] = {
      from: s,
      to: o,
      type: a
    }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[a];
  }, i.lastTimelineChange = function(r) {
    var a = r.type, s = r.from, o = r.to;
    return typeof s == "number" && typeof o == "number" && (this.lastTimelineChanges_[a] = {
      from: s,
      to: o,
      type: a
    }, delete this.pendingTimelineChanges_[a], this.trigger("timelinechange")), this.lastTimelineChanges_[a];
  }, i.dispose = function() {
    this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off();
  }, t;
}(X.EventTarget), SP = r1(
  n1(function() {
    var e = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function t(C, R, k) {
      return k = {
        exports: {},
        path: R,
        require: function(B, I) {
          return i(
            B,
            I ?? k.path
          );
        }
      }, C(k, k.exports), k.exports;
    }
    function i() {
      throw new Error(
        "Dynamic requires are not currently supported by @rollup/plugin-commonjs"
      );
    }
    var n = t(function(C) {
      function R(F, B) {
        for (var I = 0; I < B.length; I++) {
          var V = B[I];
          V.enumerable = V.enumerable || !1, V.configurable = !0, "value" in V && (V.writable = !0), Object.defineProperty(F, V.key, V);
        }
      }
      function k(F, B, I) {
        return B && R(F.prototype, B), I && R(F, I), F;
      }
      C.exports = k, C.exports.default = C.exports, C.exports.__esModule = !0;
    }), r = t(function(C) {
      function R(k, F) {
        return C.exports = R = Object.setPrototypeOf || function(I, V) {
          return I.__proto__ = V, I;
        }, C.exports.default = C.exports, C.exports.__esModule = !0, R(k, F);
      }
      C.exports = R, C.exports.default = C.exports, C.exports.__esModule = !0;
    }), a = t(function(C) {
      function R(k, F) {
        k.prototype = Object.create(F.prototype), k.prototype.constructor = k, r(k, F);
      }
      C.exports = R, C.exports.default = C.exports, C.exports.__esModule = !0;
    }), s = /* @__PURE__ */ function() {
      function C() {
        this.listeners = {};
      }
      var R = C.prototype;
      return R.on = function(F, B) {
        this.listeners[F] || (this.listeners[F] = []), this.listeners[F].push(B);
      }, R.off = function(F, B) {
        if (!this.listeners[F])
          return !1;
        var I = this.listeners[F].indexOf(B);
        return this.listeners[F] = this.listeners[F].slice(0), this.listeners[F].splice(I, 1), I > -1;
      }, R.trigger = function(F) {
        var B = this.listeners[F];
        if (B)
          if (arguments.length === 2)
            for (var I = B.length, V = 0; V < I; ++V)
              B[V].call(this, arguments[1]);
          else
            for (var Q = Array.prototype.slice.call(arguments, 1), ee = B.length, oe = 0; oe < ee; ++oe)
              B[oe].apply(this, Q);
      }, R.dispose = function() {
        this.listeners = {};
      }, R.pipe = function(F) {
        this.on("data", function(B) {
          F.push(B);
        });
      }, C;
    }();
    /* ! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
    function o(C) {
      return C.subarray(
        0,
        C.byteLength - C[C.byteLength - 1]
      );
    }
    /* ! @name aes-decrypter @version 3.1.3 @license Apache-2.0 */
    var u = function() {
      var R = [
        [[], [], [], [], []],
        [[], [], [], [], []]
      ], k = R[0], F = R[1], B = k[4], I = F[4], V, Q, ee, oe = [], fe = [], he, de, G, j, se, ie;
      for (V = 0; V < 256; V++)
        fe[(oe[V] = V << 1 ^ (V >> 7) * 283) ^ V] = V;
      for (Q = ee = 0; !B[Q]; Q ^= he || 1, ee = fe[ee] || 1)
        for (j = ee ^ ee << 1 ^ ee << 2 ^ ee << 3 ^ ee << 4, j = j >> 8 ^ j & 255 ^ 99, B[Q] = j, I[j] = Q, G = oe[de = oe[he = oe[Q]]], ie = G * 16843009 ^ de * 65537 ^ he * 257 ^ Q * 16843008, se = oe[j] * 257 ^ j * 16843008, V = 0; V < 4; V++)
          k[V][Q] = se = se << 24 ^ se >>> 8, F[V][j] = ie = ie << 24 ^ ie >>> 8;
      for (V = 0; V < 5; V++)
        k[V] = k[V].slice(0), F[V] = F[V].slice(0);
      return R;
    }, l = null, c = /* @__PURE__ */ function() {
      function C(k) {
        l || (l = u()), this._tables = [
          [
            l[0][0].slice(),
            l[0][1].slice(),
            l[0][2].slice(),
            l[0][3].slice(),
            l[0][4].slice()
          ],
          [
            l[1][0].slice(),
            l[1][1].slice(),
            l[1][2].slice(),
            l[1][3].slice(),
            l[1][4].slice()
          ]
        ];
        var F, B, I, V = this._tables[0][4], Q = this._tables[1], ee = k.length, oe = 1;
        if (ee !== 4 && ee !== 6 && ee !== 8)
          throw new Error("Invalid aes key size");
        var fe = k.slice(0), he = [];
        for (this._key = [fe, he], F = ee; F < 4 * ee + 28; F++)
          I = fe[F - 1], (F % ee === 0 || ee === 8 && F % ee === 4) && (I = V[I >>> 24] << 24 ^ V[I >> 16 & 255] << 16 ^ V[I >> 8 & 255] << 8 ^ V[I & 255], F % ee === 0 && (I = I << 8 ^ I >>> 24 ^ oe << 24, oe = oe << 1 ^ (oe >> 7) * 283)), fe[F] = fe[F - ee] ^ I;
        for (B = 0; F; B++, F--)
          I = fe[B & 3 ? F : F - 4], F <= 4 || B < 4 ? he[B] = I : he[B] = Q[0][V[I >>> 24]] ^ Q[1][V[I >> 16 & 255]] ^ Q[2][V[I >> 8 & 255]] ^ Q[3][V[I & 255]];
      }
      var R = C.prototype;
      return R.decrypt = function(F, B, I, V, Q, ee) {
        var oe = this._key[1], fe = F ^ oe[0], he = V ^ oe[1], de = I ^ oe[2], G = B ^ oe[3], j, se, ie, Ce = oe.length / 4 - 2, K, xe = 4, pe = this._tables[1], Re = pe[0], _e = pe[1], Le = pe[2], Ve = pe[3], ft = pe[4];
        for (K = 0; K < Ce; K++)
          j = Re[fe >>> 24] ^ _e[he >> 16 & 255] ^ Le[de >> 8 & 255] ^ Ve[G & 255] ^ oe[xe], se = Re[he >>> 24] ^ _e[de >> 16 & 255] ^ Le[G >> 8 & 255] ^ Ve[fe & 255] ^ oe[xe + 1], ie = Re[de >>> 24] ^ _e[G >> 16 & 255] ^ Le[fe >> 8 & 255] ^ Ve[he & 255] ^ oe[xe + 2], G = Re[G >>> 24] ^ _e[fe >> 16 & 255] ^ Le[he >> 8 & 255] ^ Ve[de & 255] ^ oe[xe + 3], xe += 4, fe = j, he = se, de = ie;
        for (K = 0; K < 4; K++)
          Q[(3 & -K) + ee] = ft[fe >>> 24] << 24 ^ ft[he >> 16 & 255] << 16 ^ ft[de >> 8 & 255] << 8 ^ ft[G & 255] ^ oe[xe++], j = fe, fe = he, he = de, de = G, G = j;
      }, C;
    }(), h = /* @__PURE__ */ function(C) {
      a(R, C);
      function R() {
        var F;
        return F = C.call(this, s) || this, F.jobs = [], F.delay = 1, F.timeout_ = null, F;
      }
      var k = R.prototype;
      return k.processJob_ = function() {
        this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null;
      }, k.push = function(B) {
        this.jobs.push(B), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay));
      }, R;
    }(s), d = function(R) {
      return R << 24 | (R & 65280) << 8 | (R & 16711680) >> 8 | R >>> 24;
    }, f = function(R, k, F) {
      var B = new Int32Array(
        R.buffer,
        R.byteOffset,
        R.byteLength >> 2
      ), I = new c(Array.prototype.slice.call(k)), V = new Uint8Array(R.byteLength), Q = new Int32Array(V.buffer), ee, oe, fe, he, de, G, j, se, ie;
      for (ee = F[0], oe = F[1], fe = F[2], he = F[3], ie = 0; ie < B.length; ie += 4)
        de = d(B[ie]), G = d(B[ie + 1]), j = d(B[ie + 2]), se = d(B[ie + 3]), I.decrypt(
          de,
          G,
          j,
          se,
          Q,
          ie
        ), Q[ie] = d(Q[ie] ^ ee), Q[ie + 1] = d(Q[ie + 1] ^ oe), Q[ie + 2] = d(Q[ie + 2] ^ fe), Q[ie + 3] = d(Q[ie + 3] ^ he), ee = de, oe = G, fe = j, he = se;
      return V;
    }, p = /* @__PURE__ */ function() {
      function C(k, F, B, I) {
        var V = C.STEP, Q = new Int32Array(k.buffer), ee = new Uint8Array(k.byteLength), oe = 0;
        for (this.asyncStream_ = new h(), this.asyncStream_.push(
          this.decryptChunk_(
            Q.subarray(oe, oe + V),
            F,
            B,
            ee
          )
        ), oe = V; oe < Q.length; oe += V)
          B = new Uint32Array([
            d(Q[oe - 4]),
            d(Q[oe - 3]),
            d(Q[oe - 2]),
            d(Q[oe - 1])
          ]), this.asyncStream_.push(
            this.decryptChunk_(
              Q.subarray(oe, oe + V),
              F,
              B,
              ee
            )
          );
        this.asyncStream_.push(function() {
          I(null, o(ee));
        });
      }
      var R = C.prototype;
      return R.decryptChunk_ = function(F, B, I, V) {
        return function() {
          var Q = f(F, B, I);
          V.set(Q, F.byteOffset);
        };
      }, n(C, null, [
        {
          get: function() {
            return 32e3;
          },
          key: "STEP"
        }
      ]), C;
    }(), _;
    typeof window < "u" ? _ = window : typeof e < "u" ? _ = e : typeof self < "u" ? _ = self : _ = {};
    var m = _, x = function(R) {
      return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(R) : R && R.buffer instanceof ArrayBuffer;
    }, E = m.BigInt || Number;
    E("0x1"), E("0x100"), E("0x10000"), E("0x1000000"), E("0x100000000"), E("0x10000000000"), E("0x1000000000000"), E("0x100000000000000"), E("0x10000000000000000");
    var M = function(R) {
      var k = {};
      return Object.keys(R).forEach(function(F) {
        var B = R[F];
        x(B) ? k[F] = {
          byteLength: B.byteLength,
          byteOffset: B.byteOffset,
          bytes: B.buffer
        } : k[F] = B;
      }), k;
    };
    self.onmessage = function(C) {
      var R = C.data, k = new Uint8Array(
        R.encrypted.bytes,
        R.encrypted.byteOffset,
        R.encrypted.byteLength
      ), F = new Uint32Array(
        R.key.bytes,
        R.key.byteOffset,
        R.key.byteLength / 4
      ), B = new Uint32Array(
        R.iv.bytes,
        R.iv.byteOffset,
        R.iv.byteLength / 4
      );
      new p(k, F, B, function(I, V) {
        self.postMessage(
          M({
            decrypted: V,
            source: R.source
          }),
          [V.buffer]
        );
      });
    };
  })
), CP = i1(SP), MP = function(t) {
  var i = t.default ? "main" : "alternative";
  return t.characteristics && t.characteristics.indexOf(
    "public.accessibility.describes-video"
  ) >= 0 && (i = "main-desc"), i;
}, th = function(t, i) {
  t.abort(), t.pause(), i && i.activePlaylistLoader && (i.activePlaylistLoader.pause(), i.activePlaylistLoader = null);
}, Af = function(t, i) {
  i.activePlaylistLoader = t, t.load();
}, DP = function(t, i) {
  return function() {
    var n = i.segmentLoaders, r = n[t], a = n.main, s = i.mediaTypes[t], o = s.activeTrack(), u = s.getActiveGroup(), l = s.activePlaylistLoader, c = s.lastGroup_;
    if (!(u && c && u.id === c.id) && (s.lastGroup_ = u, s.lastTrack_ = o, th(r, s), !(!u || u.isMasterPlaylist))) {
      if (!u.playlistLoader) {
        l && a.resetEverything();
        return;
      }
      r.resyncLoader(), Af(u.playlistLoader, s);
    }
  };
}, PP = function(t, i) {
  return function() {
    var n = i.segmentLoaders[t], r = i.mediaTypes[t];
    r.lastGroup_ = null, n.abort(), n.pause();
  };
}, LP = function(t, i) {
  return function() {
    var n = i.masterPlaylistLoader, r = i.segmentLoaders, a = r[t], s = r.main, o = i.mediaTypes[t], u = o.activeTrack(), l = o.getActiveGroup(), c = o.activePlaylistLoader, h = o.lastTrack_;
    if (!(h && u && h.id === u.id) && (o.lastGroup_ = l, o.lastTrack_ = u, th(a, o), !!l)) {
      if (l.isMasterPlaylist) {
        if (!u || !h || u.id === h.id)
          return;
        var d = i.vhs.masterPlaylistController_, f = d.selectPlaylist();
        if (d.media() === f)
          return;
        o.logger_(
          "track change. Switching master audio from " + h.id + " to " + u.id
        ), n.pause(), s.resetEverything(), d.fastQualityChange_(f);
        return;
      }
      if (t === "AUDIO") {
        if (!l.playlistLoader) {
          s.setAudio(!0), s.resetEverything();
          return;
        }
        a.setAudio(!0), s.setAudio(!1);
      }
      if (c === l.playlistLoader) {
        Af(l.playlistLoader, o);
        return;
      }
      a.track && a.track(u), a.resetEverything(), Af(l.playlistLoader, o);
    }
  };
}, ih = {
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning (or error if the playlist is blacklisted) to
   *         console and switches back to default audio track.
   * @function onError.AUDIO
   */
  AUDIO: function(t, i) {
    return function() {
      var n = i.segmentLoaders[t], r = i.mediaTypes[t], a = i.blacklistCurrentPlaylist;
      th(n, r);
      var s = r.activeTrack(), o = r.activeGroup(), u = (o.filter(function(h) {
        return h.default;
      })[0] || o[0]).id, l = r.tracks[u];
      if (s === l) {
        a({
          message: "Problem encountered loading the default audio track."
        });
        return;
      }
      X.log.warn(
        "Problem encountered loading the alternate audio track.Switching back to default."
      );
      for (var c in r.tracks)
        r.tracks[c].enabled = r.tracks[c] === l;
      r.onTrackChanged();
    };
  },
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning to console and disables the active subtitle track
   * @function onError.SUBTITLES
   */
  SUBTITLES: function(t, i) {
    return function() {
      var n = i.segmentLoaders[t], r = i.mediaTypes[t];
      X.log.warn(
        "Problem encountered loading the subtitle track.Disabling subtitle track."
      ), th(n, r);
      var a = r.activeTrack();
      a && (a.mode = "disabled"), r.onTrackChanged();
    };
  }
}, wg = {
  /**
   * Setup event listeners for audio playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.AUDIO
   */
  AUDIO: function(t, i, n) {
    if (i) {
      var r = n.tech, a = n.requestOptions, s = n.segmentLoaders[t];
      i.on("loadedmetadata", function() {
        var o = i.media();
        s.playlist(o, a), (!r.paused() || o.endList && r.preload() !== "none") && s.load();
      }), i.on("loadedplaylist", function() {
        s.playlist(i.media(), a), r.paused() || s.load();
      }), i.on("error", ih[t](t, n));
    }
  },
  /**
   * Setup event listeners for subtitle playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.SUBTITLES
   */
  SUBTITLES: function(t, i, n) {
    var r = n.tech, a = n.requestOptions, s = n.segmentLoaders[t], o = n.mediaTypes[t];
    i.on("loadedmetadata", function() {
      var u = i.media();
      s.playlist(u, a), s.track(o.activeTrack()), (!r.paused() || u.endList && r.preload() !== "none") && s.load();
    }), i.on("loadedplaylist", function() {
      s.playlist(i.media(), a), r.paused() || s.load();
    }), i.on("error", ih[t](t, n));
  }
}, RP = {
  /**
   * Setup PlaylistLoaders and AudioTracks for the audio groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.AUDIO
   */
  AUDIO: function(t, i) {
    var n = i.vhs, r = i.sourceType, a = i.segmentLoaders[t], s = i.requestOptions, o = i.master.mediaGroups, u = i.mediaTypes[t], l = u.groups, c = u.tracks, h = u.logger_, d = i.masterPlaylistLoader, f = Ol(d.master);
    (!o[t] || Object.keys(o[t]).length === 0) && (o[t] = {
      main: {
        default: {
          default: !0
        }
      }
    }, f && (o[t].main.default.playlists = d.master.playlists));
    for (var p in o[t]) {
      l[p] || (l[p] = []);
      for (var _ in o[t][p]) {
        var m = o[t][p][_], x = void 0;
        if (f ? (h(
          "AUDIO group '" + p + "' label '" + _ + "' is a master playlist"
        ), m.isMasterPlaylist = !0, x = null) : r === "vhs-json" && m.playlists ? x = new Os(
          m.playlists[0],
          n,
          s
        ) : m.resolvedUri ? x = new Os(
          m.resolvedUri,
          n,
          s
        ) : m.playlists && r === "dash" ? x = new yf(
          m.playlists[0],
          n,
          s,
          d
        ) : x = null, m = X.mergeOptions(
          {
            id: _,
            playlistLoader: x
          },
          m
        ), wg[t](t, m.playlistLoader, i), l[p].push(m), typeof c[_] > "u") {
          var E = new X.AudioTrack({
            default: m.default,
            enabled: !1,
            id: _,
            kind: MP(m),
            label: _,
            language: m.language
          });
          c[_] = E;
        }
      }
    }
    a.on("error", ih[t](t, i));
  },
  /**
   * Setup TextTracks for the closed-caption groups
   *
   * @param {String} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize['CLOSED-CAPTIONS']
   */
  "CLOSED-CAPTIONS": function(t, i) {
    var n = i.tech, r = i.master.mediaGroups, a = i.mediaTypes[t], s = a.groups, o = a.tracks;
    for (var u in r[t]) {
      s[u] || (s[u] = []);
      for (var l in r[t][u]) {
        var c = r[t][u][l];
        if (/^(?:CC|SERVICE)/.test(c.instreamId)) {
          var h = n.options_.vhs && n.options_.vhs.captionServices || {}, d = {
            default: c.default && c.autoselect,
            instreamId: c.instreamId,
            label: l,
            language: c.language
          };
          if (h[d.instreamId] && (d = X.mergeOptions(
            d,
            h[d.instreamId]
          )), d.default === void 0 && delete d.default, s[u].push(
            X.mergeOptions(
              {
                id: l
              },
              c
            )
          ), typeof o[l] > "u") {
            var f = n.addRemoteTextTrack(
              {
                default: d.default,
                id: d.instreamId,
                kind: "captions",
                label: d.label,
                language: d.language
              },
              !1
            ).track;
            o[l] = f;
          }
        }
      }
    }
  },
  /**
   * Setup PlaylistLoaders and TextTracks for the subtitle groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.SUBTITLES
   */
  SUBTITLES: function(t, i) {
    var n = i.tech, r = i.vhs, a = i.sourceType, s = i.segmentLoaders[t], o = i.requestOptions, u = i.master.mediaGroups, l = i.mediaTypes[t], c = l.groups, h = l.tracks, d = i.masterPlaylistLoader;
    for (var f in u[t]) {
      c[f] || (c[f] = []);
      for (var p in u[t][f])
        if (!u[t][f][p].forced) {
          var _ = u[t][f][p], m = void 0;
          if (a === "hls")
            m = new Os(
              _.resolvedUri,
              r,
              o
            );
          else if (a === "dash") {
            var x = _.playlists.filter(function(M) {
              return M.excludeUntil !== 1 / 0;
            });
            if (!x.length)
              return;
            m = new yf(
              _.playlists[0],
              r,
              o,
              d
            );
          } else a === "vhs-json" && (m = new Os(
            // if the vhs-json object included the media playlist, use the media playlist
            // as provided, otherwise use the resolved URI to load the playlist
            _.playlists ? _.playlists[0] : _.resolvedUri,
            r,
            o
          ));
          if (_ = X.mergeOptions(
            {
              id: p,
              playlistLoader: m
            },
            _
          ), wg[t](t, _.playlistLoader, i), c[f].push(_), typeof h[p] > "u") {
            var E = n.addRemoteTextTrack(
              {
                default: _.default && _.autoselect,
                id: p,
                kind: "subtitles",
                label: p,
                language: _.language
              },
              !1
            ).track;
            h[p] = E;
          }
        }
    }
    s.on("error", ih[t](t, i));
  }
}, IP = function e(t, i) {
  for (var n = 0; n < t.length; n++)
    if (av(i, t[n]) || t[n].playlists && e(t[n].playlists, i))
      return !0;
  return !1;
}, OP = function(t, i) {
  return function(n) {
    var r = i.masterPlaylistLoader, a = i.mediaTypes[t].groups, s = r.media();
    if (!s)
      return null;
    var o = null;
    s.attributes[t] && (o = a[s.attributes[t]]);
    var u = Object.keys(a);
    if (!o)
      if (t === "AUDIO" && u.length > 1 && Ol(i.master))
        for (var l = 0; l < u.length; l++) {
          var c = a[u[l]];
          if (IP(c, s)) {
            o = c;
            break;
          }
        }
      else a.main ? o = a.main : u.length === 1 && (o = a[u[0]]);
    return typeof n > "u" ? o : n === null || !o ? null : o.filter(function(h) {
      return h.id === n.id;
    })[0] || null;
  };
}, kP = {
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.AUDIO
   */
  AUDIO: function(t, i) {
    return function() {
      var n = i.mediaTypes[t].tracks;
      for (var r in n)
        if (n[r].enabled)
          return n[r];
      return null;
    };
  },
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.SUBTITLES
   */
  SUBTITLES: function(t, i) {
    return function() {
      var n = i.mediaTypes[t].tracks;
      for (var r in n)
        if (n[r].mode === "showing" || n[r].mode === "hidden")
          return n[r];
      return null;
    };
  }
}, BP = function(t, i) {
  var n = i.mediaTypes;
  return function() {
    var r = n[t].activeTrack();
    return r ? n[t].activeGroup(r) : null;
  };
}, FP = function(t) {
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(p) {
    RP[p](p, t);
  });
  var i = t.mediaTypes, n = t.masterPlaylistLoader, r = t.tech, a = t.vhs, s = t.segmentLoaders, o = s.AUDIO, u = s.main;
  ["AUDIO", "SUBTITLES"].forEach(function(p) {
    i[p].activeGroup = OP(p, t), i[p].activeTrack = kP[p](p, t), i[p].onGroupChanged = DP(p, t), i[p].onGroupChanging = PP(p, t), i[p].onTrackChanged = LP(p, t), i[p].getActiveGroup = BP(p, t);
  });
  var l = i.AUDIO.activeGroup();
  if (l) {
    var c = (l.filter(function(p) {
      return p.default;
    })[0] || l[0]).id;
    i.AUDIO.tracks[c].enabled = !0, i.AUDIO.onGroupChanged(), i.AUDIO.onTrackChanged();
    var h = i.AUDIO.getActiveGroup();
    h.playlistLoader ? (u.setAudio(!1), o.setAudio(!0)) : u.setAudio(!0);
  }
  n.on("mediachange", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(p) {
      return i[p].onGroupChanged();
    });
  }), n.on("mediachanging", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(p) {
      return i[p].onGroupChanging();
    });
  });
  var d = function() {
    i.AUDIO.onTrackChanged(), r.trigger({
      name: "vhs-audio-change",
      type: "usage"
    }), r.trigger({
      name: "hls-audio-change",
      type: "usage"
    });
  };
  r.audioTracks().addEventListener("change", d), r.remoteTextTracks().addEventListener("change", i.SUBTITLES.onTrackChanged), a.on("dispose", function() {
    r.audioTracks().removeEventListener("change", d), r.remoteTextTracks().removeEventListener("change", i.SUBTITLES.onTrackChanged);
  }), r.clearTracks("audio");
  for (var f in i.AUDIO.tracks)
    r.audioTracks().addTrack(i.AUDIO.tracks[f]);
}, NP = function() {
  var t = {};
  return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(i) {
    t[i] = {
      activeGroup: Rn,
      activePlaylistLoader: null,
      activeTrack: Rn,
      getActiveGroup: Rn,
      groups: {},
      lastTrack_: null,
      logger_: rn("MediaGroups[" + i + "]"),
      onGroupChanged: Rn,
      onTrackChanged: Rn,
      tracks: {}
    };
  }), t;
}, UP = 60 * 2, Dn, jP = [
  "mediaRequests",
  "mediaRequestsAborted",
  "mediaRequestsTimedout",
  "mediaRequestsErrored",
  "mediaTransferDuration",
  "mediaBytesTransferred",
  "mediaAppends"
], GP = function(t) {
  return this.audioSegmentLoader_[t] + this.mainSegmentLoader_[t];
}, VP = function(t) {
  var i = t.currentPlaylist, n = t.buffered, r = t.currentTime, a = t.nextPlaylist, s = t.bufferLowWaterLine, o = t.bufferHighWaterLine, u = t.duration, l = t.experimentalBufferBasedABR, c = t.log;
  if (!a)
    return X.log.warn(
      "We received no playlist to switch to. Please check your stream."
    ), !1;
  var h = "allowing switch " + (i && i.id || "null") + " -> " + a.id;
  if (!i)
    return c(h + " as current playlist is not set"), !0;
  if (a.id === i.id)
    return !1;
  var d = !!Is(n, r).length;
  if (!i.endList)
    return !d && typeof i.partTargetDuration == "number" ? (c(
      "not " + h + " as current playlist is live llhls, but currentTime isn't in buffered."
    ), !1) : (c(h + " as current playlist is live"), !0);
  var f = iv(n, r), p = l ? Pi.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Pi.MAX_BUFFER_LOW_WATER_LINE;
  if (u < p)
    return c(
      h + " as duration < max low water line (" + u + " < " + p + ")"
    ), !0;
  var _ = a.attributes.BANDWIDTH, m = i.attributes.BANDWIDTH;
  if (_ < m && (!l || f < o)) {
    var x = h + " as next bandwidth < current bandwidth (" + _ + " < " + m + ")";
    return l && (x += " and forwardBuffer < bufferHighWaterLine (" + f + " < " + o + ")"), c(x), !0;
  }
  if ((!l || _ > m) && f >= s) {
    var E = h + " as forwardBuffer >= bufferLowWaterLine (" + f + " >= " + s + ")";
    return l && (E += " and next bandwidth > current bandwidth (" + _ + " > " + m + ")"), c(E), !0;
  }
  return c("not " + h + " as no switching criteria met"), !1;
}, HP = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var r;
    r = e.call(this) || this;
    var a = n.src, s = n.handleManifestRedirects, o = n.withCredentials, u = n.tech, l = n.bandwidth, c = n.externVhs, h = n.useCueTags, d = n.blacklistDuration, f = n.enableLowInitialPlaylist, p = n.sourceType, _ = n.cacheEncryptionKeys, m = n.experimentalBufferBasedABR, x = n.experimentalLeastPixelDiffSelector, E = n.captionServices;
    if (!a)
      throw new Error(
        "A non-empty playlist URL or JSON manifest string is required"
      );
    var M = n.maxPlaylistRetries;
    (M === null || typeof M > "u") && (M = 1 / 0), Dn = c, r.experimentalBufferBasedABR = !!m, r.experimentalLeastPixelDiffSelector = !!x, r.withCredentials = o, r.tech_ = u, r.vhs_ = u.vhs, r.sourceType_ = p, r.useCueTags_ = h, r.blacklistDuration = d, r.maxPlaylistRetries = M, r.enableLowInitialPlaylist = f, r.useCueTags_ && (r.cueTagsTrack_ = r.tech_.addTextTrack("metadata", "ad-cues"), r.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), r.requestOptions_ = {
      handleManifestRedirects: s,
      maxPlaylistRetries: M,
      timeout: null,
      withCredentials: o
    }, r.on("error", r.pauseLoading), r.mediaTypes_ = NP(), r.mediaSource = new W.MediaSource(), r.handleDurationChange_ = r.handleDurationChange_.bind(
      He(r)
    ), r.handleSourceOpen_ = r.handleSourceOpen_.bind(
      He(r)
    ), r.handleSourceEnded_ = r.handleSourceEnded_.bind(
      He(r)
    ), r.mediaSource.addEventListener(
      "durationchange",
      r.handleDurationChange_
    ), r.mediaSource.addEventListener("sourceopen", r.handleSourceOpen_), r.mediaSource.addEventListener("sourceended", r.handleSourceEnded_), r.seekable_ = X.createTimeRanges(), r.hasPlayed_ = !1, r.syncController_ = new EP(n), r.segmentMetadataTrack_ = u.addRemoteTextTrack(
      {
        kind: "metadata",
        label: "segment-metadata"
      },
      !1
    ).track, r.decrypter_ = new CP(), r.sourceUpdater_ = new g1(r.mediaSource), r.inbandTextTracks_ = {}, r.timelineChangeController_ = new wP();
    var C = {
      captionServices: E,
      currentTime: r.tech_.currentTime.bind(r.tech_),
      duration: function() {
        return r.duration();
      },
      bandwidth: l,
      goalBufferLength: function() {
        return r.goalBufferLength();
      },
      decrypter: r.decrypter_,
      mediaSource: r.mediaSource,
      hasPlayed: function() {
        return r.hasPlayed_;
      },
      parse708captions: n.parse708captions,
      cacheEncryptionKeys: _,
      vhs: r.vhs_,
      experimentalExactManifestTimings: n.experimentalExactManifestTimings,
      useDtsForTimestampOffset: n.useDtsForTimestampOffset,
      inbandTextTracks: r.inbandTextTracks_,
      seekable: function() {
        return r.seekable();
      },
      seeking: function() {
        return r.tech_.seeking();
      },
      sourceType: r.sourceType_,
      sourceUpdater: r.sourceUpdater_,
      syncController: r.syncController_,
      timelineChangeController: r.timelineChangeController_
    };
    r.masterPlaylistLoader_ = r.sourceType_ === "dash" ? new yf(a, r.vhs_, r.requestOptions_) : new Os(a, r.vhs_, r.requestOptions_), r.setupMasterPlaylistLoaderListeners_(), r.mainSegmentLoader_ = new bf(
      X.mergeOptions(C, {
        loaderType: "main",
        segmentMetadataTrack: r.segmentMetadataTrack_
      }),
      n
    ), r.audioSegmentLoader_ = new bf(
      X.mergeOptions(C, {
        loaderType: "audio"
      }),
      n
    ), r.subtitleSegmentLoader_ = new bP(
      X.mergeOptions(C, {
        featuresNativeTextTracks: r.tech_.featuresNativeTextTracks,
        loadVttJs: function() {
          return new Promise(function(F, B) {
            function I() {
              u.off("vttjserror", V), F();
            }
            function V() {
              u.off("vttjsloaded", I), B();
            }
            u.one("vttjsloaded", I), u.one("vttjserror", V), u.addWebVttScript_();
          });
        },
        loaderType: "vtt"
      }),
      n
    ), r.setupSegmentLoaderListeners_(), r.experimentalBufferBasedABR && (r.masterPlaylistLoader_.one("loadedplaylist", function() {
      return r.startABRTimer_();
    }), r.tech_.on("pause", function() {
      return r.stopABRTimer_();
    }), r.tech_.on("play", function() {
      return r.startABRTimer_();
    })), jP.forEach(function(k) {
      r[k + "_"] = GP.bind(
        He(r),
        k
      );
    }), r.logger_ = rn("MPC"), r.triggeredFmp4Usage = !1, r.tech_.preload() === "none" ? (r.loadOnPlay_ = function() {
      r.loadOnPlay_ = null, r.masterPlaylistLoader_.load();
    }, r.tech_.one("play", r.loadOnPlay_)) : r.masterPlaylistLoader_.load(), r.timeToLoadedData__ = -1, r.mainAppendsToLoadedData__ = -1, r.audioAppendsToLoadedData__ = -1;
    var R = r.tech_.preload() === "none" ? "play" : "loadstart";
    return r.tech_.one(R, function() {
      var k = Date.now();
      r.tech_.one("loadeddata", function() {
        r.timeToLoadedData__ = Date.now() - k, r.mainAppendsToLoadedData__ = r.mainSegmentLoader_.mediaAppends, r.audioAppendsToLoadedData__ = r.audioSegmentLoader_.mediaAppends;
      });
    }), r;
  }
  var i = t.prototype;
  return i.mainAppendsToLoadedData_ = function() {
    return this.mainAppendsToLoadedData__;
  }, i.audioAppendsToLoadedData_ = function() {
    return this.audioAppendsToLoadedData__;
  }, i.appendsToLoadedData_ = function() {
    var r = this.mainAppendsToLoadedData_(), a = this.audioAppendsToLoadedData_();
    return r === -1 || a === -1 ? -1 : r + a;
  }, i.timeToLoadedData_ = function() {
    return this.timeToLoadedData__;
  }, i.checkABR_ = function(r) {
    r === void 0 && (r = "abr");
    var a = this.selectPlaylist();
    a && this.shouldSwitchToMedia_(a) && this.switchMedia_(a, r);
  }, i.switchMedia_ = function(r, a, s) {
    var o = this.media(), u = o && (o.id || o.uri), l = r.id || r.uri;
    u && u !== l && (this.logger_("switch media " + u + " -> " + l + " from " + a), this.tech_.trigger({
      name: "vhs-rendition-change-" + a,
      type: "usage"
    })), this.masterPlaylistLoader_.media(r, s);
  }, i.startABRTimer_ = function() {
    var r = this;
    this.stopABRTimer_(), this.abrTimer_ = W.setInterval(function() {
      return r.checkABR_();
    }, 250);
  }, i.stopABRTimer_ = function() {
    this.tech_.scrubbing && this.tech_.scrubbing() || (W.clearInterval(this.abrTimer_), this.abrTimer_ = null);
  }, i.getAudioTrackPlaylists_ = function() {
    var r = this.master(), a = r && r.playlists || [];
    if (!r || !r.mediaGroups || !r.mediaGroups.AUDIO)
      return a;
    var s = r.mediaGroups.AUDIO, o = Object.keys(s), u;
    if (Object.keys(this.mediaTypes_.AUDIO.groups).length)
      u = this.mediaTypes_.AUDIO.activeTrack();
    else {
      var l = s.main || o.length && s[o[0]];
      for (var c in l)
        if (l[c].default) {
          u = {
            label: c
          };
          break;
        }
    }
    if (!u)
      return a;
    var h = [];
    for (var d in s)
      if (s[d][u.label]) {
        var f = s[d][u.label];
        if (f.playlists && f.playlists.length)
          h.push.apply(h, f.playlists);
        else if (f.uri)
          h.push(f);
        else if (r.playlists.length)
          for (var p = 0; p < r.playlists.length; p++) {
            var _ = r.playlists[p];
            _.attributes && _.attributes.AUDIO && _.attributes.AUDIO === d && h.push(_);
          }
      }
    return h.length ? h : a;
  }, i.setupMasterPlaylistLoaderListeners_ = function() {
    var r = this;
    this.masterPlaylistLoader_.on("loadedmetadata", function() {
      var a = r.masterPlaylistLoader_.media(), s = a.targetDuration * 1.5 * 1e3;
      ff(
        r.masterPlaylistLoader_.master,
        r.masterPlaylistLoader_.media()
      ) ? r.requestOptions_.timeout = 0 : r.requestOptions_.timeout = s, a.endList && r.tech_.preload() !== "none" && (r.mainSegmentLoader_.playlist(a, r.requestOptions_), r.mainSegmentLoader_.load()), FP({
        blacklistCurrentPlaylist: r.blacklistCurrentPlaylist.bind(r),
        master: r.master(),
        masterPlaylistLoader: r.masterPlaylistLoader_,
        mediaTypes: r.mediaTypes_,
        requestOptions: r.requestOptions_,
        segmentLoaders: {
          AUDIO: r.audioSegmentLoader_,
          SUBTITLES: r.subtitleSegmentLoader_,
          main: r.mainSegmentLoader_
        },
        sourceType: r.sourceType_,
        tech: r.tech_,
        vhs: r.vhs_
      }), r.triggerPresenceUsage_(r.master(), a), r.setupFirstPlay(), !r.mediaTypes_.AUDIO.activePlaylistLoader || r.mediaTypes_.AUDIO.activePlaylistLoader.media() ? r.trigger("selectedinitialmedia") : r.mediaTypes_.AUDIO.activePlaylistLoader.one(
        "loadedmetadata",
        function() {
          r.trigger("selectedinitialmedia");
        }
      );
    }), this.masterPlaylistLoader_.on("loadedplaylist", function() {
      r.loadOnPlay_ && r.tech_.off("play", r.loadOnPlay_);
      var a = r.masterPlaylistLoader_.media();
      if (!a) {
        r.excludeUnsupportedVariants_();
        var s;
        if (r.enableLowInitialPlaylist && (s = r.selectInitialPlaylist()), s || (s = r.selectPlaylist()), !s || !r.shouldSwitchToMedia_(s))
          return;
        r.initialMedia_ = s, r.switchMedia_(r.initialMedia_, "initial");
        var o = r.sourceType_ === "vhs-json" && r.initialMedia_.segments;
        if (!o)
          return;
        a = r.initialMedia_;
      }
      r.handleUpdatedMediaPlaylist(a);
    }), this.masterPlaylistLoader_.on("error", function() {
      r.blacklistCurrentPlaylist(r.masterPlaylistLoader_.error);
    }), this.masterPlaylistLoader_.on("mediachanging", function() {
      r.mainSegmentLoader_.abort(), r.mainSegmentLoader_.pause();
    }), this.masterPlaylistLoader_.on("mediachange", function() {
      var a = r.masterPlaylistLoader_.media(), s = a.targetDuration * 1.5 * 1e3;
      ff(
        r.masterPlaylistLoader_.master,
        r.masterPlaylistLoader_.media()
      ) ? r.requestOptions_.timeout = 0 : r.requestOptions_.timeout = s, r.masterPlaylistLoader_.load(), r.mainSegmentLoader_.playlist(a, r.requestOptions_), r.mainSegmentLoader_.load(), r.tech_.trigger({
        bubbles: !0,
        type: "mediachange"
      });
    }), this.masterPlaylistLoader_.on("playlistunchanged", function() {
      var a = r.masterPlaylistLoader_.media();
      if (a.lastExcludeReason_ !== "playlist-unchanged") {
        var s = r.stuckAtPlaylistEnd_(a);
        s && (r.blacklistCurrentPlaylist({
          message: "Playlist no longer updating.",
          reason: "playlist-unchanged"
        }), r.tech_.trigger("playliststuck"));
      }
    }), this.masterPlaylistLoader_.on("renditiondisabled", function() {
      r.tech_.trigger({
        name: "vhs-rendition-disabled",
        type: "usage"
      }), r.tech_.trigger({
        name: "hls-rendition-disabled",
        type: "usage"
      });
    }), this.masterPlaylistLoader_.on("renditionenabled", function() {
      r.tech_.trigger({
        name: "vhs-rendition-enabled",
        type: "usage"
      }), r.tech_.trigger({
        name: "hls-rendition-enabled",
        type: "usage"
      });
    });
  }, i.handleUpdatedMediaPlaylist = function(r) {
    this.useCueTags_ && this.updateAdCues_(r), this.mainSegmentLoader_.playlist(r, this.requestOptions_), this.updateDuration(!r.endList), this.tech_.paused() || (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load());
  }, i.triggerPresenceUsage_ = function(r, a) {
    var s = r.mediaGroups || {}, o = !0, u = Object.keys(s.AUDIO);
    for (var l in s.AUDIO)
      for (var c in s.AUDIO[l]) {
        var h = s.AUDIO[l][c];
        h.uri || (o = !1);
      }
    o && (this.tech_.trigger({
      name: "vhs-demuxed",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-demuxed",
      type: "usage"
    })), Object.keys(s.SUBTITLES).length && (this.tech_.trigger({
      name: "vhs-webvtt",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-webvtt",
      type: "usage"
    })), Dn.Playlist.isAes(a) && (this.tech_.trigger({
      name: "vhs-aes",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-aes",
      type: "usage"
    })), u.length && Object.keys(s.AUDIO[u[0]]).length > 1 && (this.tech_.trigger({
      name: "vhs-alternate-audio",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-alternate-audio",
      type: "usage"
    })), this.useCueTags_ && (this.tech_.trigger({
      name: "vhs-playlist-cue-tags",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-playlist-cue-tags",
      type: "usage"
    }));
  }, i.shouldSwitchToMedia_ = function(r) {
    var a = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_, s = this.tech_.currentTime(), o = this.bufferLowWaterLine(), u = this.bufferHighWaterLine(), l = this.tech_.buffered();
    return VP({
      bufferHighWaterLine: u,
      bufferLowWaterLine: o,
      buffered: l,
      currentPlaylist: a,
      currentTime: s,
      duration: this.duration(),
      experimentalBufferBasedABR: this.experimentalBufferBasedABR,
      log: this.logger_,
      nextPlaylist: r
    });
  }, i.setupSegmentLoaderListeners_ = function() {
    var r = this;
    this.mainSegmentLoader_.on("bandwidthupdate", function() {
      r.checkABR_("bandwidthupdate"), r.tech_.trigger("bandwidthupdate");
    }), this.mainSegmentLoader_.on("timeout", function() {
      r.experimentalBufferBasedABR && r.mainSegmentLoader_.load();
    }), this.experimentalBufferBasedABR || this.mainSegmentLoader_.on("progress", function() {
      r.trigger("progress");
    }), this.mainSegmentLoader_.on("error", function() {
      r.blacklistCurrentPlaylist(r.mainSegmentLoader_.error());
    }), this.mainSegmentLoader_.on("appenderror", function() {
      r.error = r.mainSegmentLoader_.error_, r.trigger("error");
    }), this.mainSegmentLoader_.on("syncinfoupdate", function() {
      r.onSyncInfoUpdate_();
    }), this.mainSegmentLoader_.on("timestampoffset", function() {
      r.tech_.trigger({
        name: "vhs-timestamp-offset",
        type: "usage"
      }), r.tech_.trigger({
        name: "hls-timestamp-offset",
        type: "usage"
      });
    }), this.audioSegmentLoader_.on("syncinfoupdate", function() {
      r.onSyncInfoUpdate_();
    }), this.audioSegmentLoader_.on("appenderror", function() {
      r.error = r.audioSegmentLoader_.error_, r.trigger("error");
    }), this.mainSegmentLoader_.on("ended", function() {
      r.logger_("main segment loader ended"), r.onEndOfStream();
    }), this.mainSegmentLoader_.on("earlyabort", function(s) {
      r.experimentalBufferBasedABR || (r.delegateLoaders_("all", ["abort"]), r.blacklistCurrentPlaylist(
        {
          message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
        },
        UP
      ));
    });
    var a = function() {
      if (!r.sourceUpdater_.hasCreatedSourceBuffers())
        return r.tryToCreateSourceBuffers_();
      var o = r.getCodecsOrExclude_();
      o && r.sourceUpdater_.addOrChangeSourceBuffers(o);
    };
    this.mainSegmentLoader_.on("trackinfo", a), this.audioSegmentLoader_.on("trackinfo", a), this.mainSegmentLoader_.on("fmp4", function() {
      r.triggeredFmp4Usage || (r.tech_.trigger({
        name: "vhs-fmp4",
        type: "usage"
      }), r.tech_.trigger({
        name: "hls-fmp4",
        type: "usage"
      }), r.triggeredFmp4Usage = !0);
    }), this.audioSegmentLoader_.on("fmp4", function() {
      r.triggeredFmp4Usage || (r.tech_.trigger({
        name: "vhs-fmp4",
        type: "usage"
      }), r.tech_.trigger({
        name: "hls-fmp4",
        type: "usage"
      }), r.triggeredFmp4Usage = !0);
    }), this.audioSegmentLoader_.on("ended", function() {
      r.logger_("audioSegmentLoader ended"), r.onEndOfStream();
    });
  }, i.mediaSecondsLoaded_ = function() {
    return Math.max(
      this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded
    );
  }, i.load = function() {
    this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load();
  }, i.smoothQualityChange_ = function(r) {
    r === void 0 && (r = this.selectPlaylist()), this.fastQualityChange_(r);
  }, i.fastQualityChange_ = function(r) {
    var a = this;
    if (r === void 0 && (r = this.selectPlaylist()), r === this.masterPlaylistLoader_.media()) {
      this.logger_(
        "skipping fastQualityChange because new media is same as old"
      );
      return;
    }
    this.switchMedia_(r, "fast-quality"), this.mainSegmentLoader_.resetEverything(function() {
      X.browser.IE_VERSION || X.browser.IS_EDGE ? a.tech_.setCurrentTime(a.tech_.currentTime() + 0.04) : a.tech_.setCurrentTime(a.tech_.currentTime());
    });
  }, i.play = function() {
    if (!this.setupFirstPlay()) {
      this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load();
      var r = this.tech_.seekable();
      if (this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < r.start(0))
        return this.tech_.setCurrentTime(r.end(r.length - 1));
    }
  }, i.setupFirstPlay = function() {
    var r = this, a = this.masterPlaylistLoader_.media();
    if (!a || this.tech_.paused() || this.hasPlayed_)
      return !1;
    if (!a.endList) {
      var s = this.seekable();
      if (!s.length)
        return !1;
      if (X.browser.IE_VERSION && this.tech_.readyState() === 0)
        return this.tech_.one("loadedmetadata", function() {
          r.trigger("firstplay"), r.tech_.setCurrentTime(s.end(0)), r.hasPlayed_ = !0;
        }), !1;
      this.trigger("firstplay"), this.tech_.setCurrentTime(s.end(0));
    }
    return this.hasPlayed_ = !0, this.load(), !0;
  }, i.handleSourceOpen_ = function() {
    if (this.tryToCreateSourceBuffers_(), this.tech_.autoplay()) {
      var r = this.tech_.play();
      typeof r < "u" && typeof r.then == "function" && r.then(null, function(a) {
      });
    }
    this.trigger("sourceopen");
  }, i.handleSourceEnded_ = function() {
    if (this.inbandTextTracks_.metadataTrack_) {
      var r = this.inbandTextTracks_.metadataTrack_.cues;
      if (!(!r || !r.length)) {
        var a = this.duration();
        r[r.length - 1].endTime = isNaN(a) || Math.abs(a) === 1 / 0 ? Number.MAX_VALUE : a;
      }
    }
  }, i.handleDurationChange_ = function() {
    this.tech_.trigger("durationchange");
  }, i.onEndOfStream = function() {
    var r = this.mainSegmentLoader_.ended_;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      var a = this.mainSegmentLoader_.getCurrentMediaInfo_();
      !a || a.hasVideo ? r = r && this.audioSegmentLoader_.ended_ : r = this.audioSegmentLoader_.ended_;
    }
    r && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream());
  }, i.stuckAtPlaylistEnd_ = function(r) {
    var a = this.seekable();
    if (!a.length)
      return !1;
    var s = this.syncController_.getExpiredTime(
      r,
      this.duration()
    );
    if (s === null)
      return !1;
    var o = Dn.Playlist.playlistEnd(r, s), u = this.tech_.currentTime(), l = this.tech_.buffered();
    if (!l.length)
      return o - u <= dn;
    var c = l.end(l.length - 1);
    return c - u <= dn && o - c <= dn;
  }, i.blacklistCurrentPlaylist = function(r, a) {
    r === void 0 && (r = {});
    var s = r.playlist || this.masterPlaylistLoader_.media();
    if (a = a || r.blacklistDuration || this.blacklistDuration, !s) {
      this.error = r, this.mediaSource.readyState !== "open" ? this.trigger("error") : this.sourceUpdater_.endOfStream("network");
      return;
    }
    s.playlistErrors_++;
    var o = this.masterPlaylistLoader_.master.playlists, u = o.filter(Uh), l = u.length === 1 && u[0] === s;
    if (o.length === 1 && a !== 1 / 0)
      return X.log.warn(
        "Problem encountered with playlist " + s.id + ". Trying again since it is the only playlist."
      ), this.tech_.trigger("retryplaylist"), this.masterPlaylistLoader_.load(l);
    if (l) {
      var c = !1;
      o.forEach(function(x) {
        if (x !== s) {
          var E = x.excludeUntil;
          typeof E < "u" && E !== 1 / 0 && (c = !0, delete x.excludeUntil);
        }
      }), c && (X.log.warn(
        "Removing other playlists from the exclusion list because the last rendition is about to be excluded."
      ), this.tech_.trigger("retryplaylist"));
    }
    var h;
    s.playlistErrors_ > this.maxPlaylistRetries ? h = 1 / 0 : h = Date.now() + a * 1e3, s.excludeUntil = h, r.reason && (s.lastExcludeReason_ = r.reason), this.tech_.trigger("blacklistplaylist"), this.tech_.trigger({
      name: "vhs-rendition-blacklisted",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-rendition-blacklisted",
      type: "usage"
    });
    var d = this.selectPlaylist();
    if (!d) {
      this.error = "Playback cannot continue. No available working or supported playlists.", this.trigger("error");
      return;
    }
    var f = r.internal ? this.logger_ : X.log.warn, p = r.message ? " " + r.message : "";
    f(
      (r.internal ? "Internal problem" : "Problem") + " encountered with playlist " + s.id + "." + (p + " Switching to playlist " + d.id + ".")
    ), d.attributes.AUDIO !== s.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]), d.attributes.SUBTITLES !== s.attributes.SUBTITLES && this.delegateLoaders_("subtitle", ["abort", "pause"]), this.delegateLoaders_("main", ["abort", "pause"]);
    var _ = d.targetDuration / 2 * 1e3 || 5 * 1e3, m = typeof d.lastRequest == "number" && Date.now() - d.lastRequest <= _;
    return this.switchMedia_(
      d,
      "exclude",
      l || m
    );
  }, i.pauseLoading = function() {
    this.delegateLoaders_("all", ["abort", "pause"]), this.stopABRTimer_();
  }, i.delegateLoaders_ = function(r, a) {
    var s = this, o = [], u = r === "all";
    (u || r === "main") && o.push(this.masterPlaylistLoader_);
    var l = [];
    (u || r === "audio") && l.push("AUDIO"), (u || r === "subtitle") && (l.push("CLOSED-CAPTIONS"), l.push("SUBTITLES")), l.forEach(function(c) {
      var h = s.mediaTypes_[c] && s.mediaTypes_[c].activePlaylistLoader;
      h && o.push(h);
    }), ["main", "audio", "subtitle"].forEach(function(c) {
      var h = s[c + "SegmentLoader_"];
      h && (r === c || r === "all") && o.push(h);
    }), o.forEach(function(c) {
      return a.forEach(function(h) {
        typeof c[h] == "function" && c[h]();
      });
    });
  }, i.setCurrentTime = function(r) {
    var a = Is(this.tech_.buffered(), r);
    if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media()) || !this.masterPlaylistLoader_.media().segments)
      return 0;
    if (a && a.length)
      return r;
    this.mainSegmentLoader_.resetEverything(), this.mainSegmentLoader_.abort(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.resetEverything(), this.audioSegmentLoader_.abort()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.resetEverything(), this.subtitleSegmentLoader_.abort()), this.load();
  }, i.duration = function() {
    if (!this.masterPlaylistLoader_)
      return 0;
    var r = this.masterPlaylistLoader_.media();
    return r ? r.endList ? this.mediaSource ? this.mediaSource.duration : Dn.Playlist.duration(r) : 1 / 0 : 0;
  }, i.seekable = function() {
    return this.seekable_;
  }, i.onSyncInfoUpdate_ = function() {
    var r;
    if (this.masterPlaylistLoader_) {
      var a = this.masterPlaylistLoader_.media();
      if (a) {
        var s = this.syncController_.getExpiredTime(a, this.duration());
        if (s !== null) {
          var o = this.masterPlaylistLoader_.master, u = Dn.Playlist.seekable(
            a,
            s,
            Dn.Playlist.liveEdgeDelay(o, a)
          );
          if (u.length !== 0 && !(this.mediaTypes_.AUDIO.activePlaylistLoader && (a = this.mediaTypes_.AUDIO.activePlaylistLoader.media(), s = this.syncController_.getExpiredTime(a, this.duration()), s === null || (r = Dn.Playlist.seekable(
            a,
            s,
            Dn.Playlist.liveEdgeDelay(o, a)
          ), r.length === 0)))) {
            var l, c;
            this.seekable_ && this.seekable_.length && (l = this.seekable_.end(0), c = this.seekable_.start(0)), r ? r.start(0) > u.end(0) || u.start(0) > r.end(0) ? this.seekable_ = u : this.seekable_ = X.createTimeRanges([
              [
                r.start(0) > u.start(0) ? r.start(0) : u.start(0),
                r.end(0) < u.end(0) ? r.end(0) : u.end(0)
              ]
            ]) : this.seekable_ = u, !(this.seekable_ && this.seekable_.length && this.seekable_.end(0) === l && this.seekable_.start(0) === c) && (this.logger_("seekable updated [" + Ob(this.seekable_) + "]"), this.tech_.trigger("seekablechanged"));
          }
        }
      }
    }
  }, i.updateDuration = function(r) {
    if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), this.mediaSource.readyState !== "open") {
      this.updateDuration_ = this.updateDuration.bind(this, r), this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
      return;
    }
    if (r) {
      var a = this.seekable();
      if (!a.length)
        return;
      (isNaN(this.mediaSource.duration) || this.mediaSource.duration < a.end(a.length - 1)) && this.sourceUpdater_.setDuration(a.end(a.length - 1));
      return;
    }
    var s = this.tech_.buffered(), o = Dn.Playlist.duration(this.masterPlaylistLoader_.media());
    s.length > 0 && (o = Math.max(o, s.end(s.length - 1))), this.mediaSource.duration !== o && this.sourceUpdater_.setDuration(o);
  }, i.dispose = function() {
    var r = this;
    this.trigger("dispose"), this.decrypter_.terminate(), this.masterPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), ["AUDIO", "SUBTITLES"].forEach(function(a) {
      var s = r.mediaTypes_[a].groups;
      for (var o in s)
        s[o].forEach(function(u) {
          u.playlistLoader && u.playlistLoader.dispose();
        });
    }), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener(
      "durationchange",
      this.handleDurationChange_
    ), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener(
      "sourceended",
      this.handleSourceEnded_
    ), this.off();
  }, i.master = function() {
    return this.masterPlaylistLoader_.master;
  }, i.media = function() {
    return this.masterPlaylistLoader_.media() || this.initialMedia_;
  }, i.areMediaTypesKnown_ = function() {
    var r = !!this.mediaTypes_.AUDIO.activePlaylistLoader, a = !!this.mainSegmentLoader_.getCurrentMediaInfo_(), s = r ? !!this.audioSegmentLoader_.getCurrentMediaInfo_() : !0;
    return !(!a || !s);
  }, i.getCodecsOrExclude_ = function() {
    var r = this, a = {
      audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {},
      main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {}
    }, s = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
    a.video = a.main;
    var o = pu(this.master(), s), u = {}, l = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    if (a.main.hasVideo && (u.video = o.video || a.main.videoCodec || _w), a.main.isMuxed && (u.video += "," + (o.audio || a.main.audioCodec || tm)), (a.main.hasAudio && !a.main.isMuxed || a.audio.hasAudio || l) && (u.audio = o.audio || a.main.audioCodec || a.audio.audioCodec || tm, a.audio.isFmp4 = a.main.hasAudio && !a.main.isMuxed ? a.main.isFmp4 : a.audio.isFmp4), !u.audio && !u.video) {
      this.blacklistCurrentPlaylist({
        blacklistDuration: 1 / 0,
        message: "Could not determine codecs for playlist.",
        playlist: s
      });
      return;
    }
    var c = function(x, E) {
      return x ? tc(E) : ed(E);
    }, h = {}, d;
    if (["video", "audio"].forEach(function(m) {
      if (u.hasOwnProperty(m) && !c(a[m].isFmp4, u[m])) {
        var x = a[m].isFmp4 ? "browser" : "muxer";
        h[x] = h[x] || [], h[x].push(u[m]), m === "audio" && (d = x);
      }
    }), l && d && s.attributes.AUDIO) {
      var f = s.attributes.AUDIO;
      this.master().playlists.forEach(function(m) {
        var x = m.attributes && m.attributes.AUDIO;
        x === f && m !== s && (m.excludeUntil = 1 / 0);
      }), this.logger_(
        "excluding audio group " + f + " as " + d + ' does not support codec(s): "' + u.audio + '"'
      );
    }
    if (Object.keys(h).length) {
      var p = Object.keys(h).reduce(function(m, x) {
        return m && (m += ", "), m += x + ' does not support codec(s): "' + h[x].join(",") + '"', m;
      }, "") + ".";
      this.blacklistCurrentPlaylist({
        blacklistDuration: 1 / 0,
        internal: !0,
        message: p,
        playlist: s
      });
      return;
    }
    if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
      var _ = [];
      if (["video", "audio"].forEach(function(m) {
        var x = (ln(r.sourceUpdater_.codecs[m] || "")[0] || {}).type, E = (ln(u[m] || "")[0] || {}).type;
        x && E && x.toLowerCase() !== E.toLowerCase() && _.push(
          '"' + r.sourceUpdater_.codecs[m] + '" -> "' + u[m] + '"'
        );
      }), _.length) {
        this.blacklistCurrentPlaylist({
          blacklistDuration: 1 / 0,
          internal: !0,
          message: "Codec switching not supported: " + _.join(", ") + ".",
          playlist: s
        });
        return;
      }
    }
    return u;
  }, i.tryToCreateSourceBuffers_ = function() {
    if (!(this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) && this.areMediaTypesKnown_()) {
      var r = this.getCodecsOrExclude_();
      if (r) {
        this.sourceUpdater_.createSourceBuffers(r);
        var a = [r.video, r.audio].filter(Boolean).join(",");
        this.excludeIncompatibleVariants_(a);
      }
    }
  }, i.excludeUnsupportedVariants_ = function() {
    var r = this, a = this.master().playlists, s = [];
    Object.keys(a).forEach(function(o) {
      var u = a[o];
      if (s.indexOf(u.id) === -1) {
        s.push(u.id);
        var l = pu(r.master, u), c = [];
        l.audio && !ed(l.audio) && !tc(l.audio) && c.push("audio codec " + l.audio), l.video && !ed(l.video) && !tc(l.video) && c.push("video codec " + l.video), l.text && l.text === "stpp.ttml.im1t" && c.push("text codec " + l.text), c.length && (u.excludeUntil = 1 / 0, r.logger_(
          "excluding " + u.id + " for unsupported: " + c.join(", ")
        ));
      }
    });
  }, i.excludeIncompatibleVariants_ = function(r) {
    var a = this, s = [], o = this.master().playlists, u = $c(ln(r)), l = pg(u), c = u.video && ln(u.video)[0] || null, h = u.audio && ln(u.audio)[0] || null;
    Object.keys(o).forEach(function(d) {
      var f = o[d];
      if (!(s.indexOf(f.id) !== -1 || f.excludeUntil === 1 / 0)) {
        s.push(f.id);
        var p = [], _ = pu(
          a.masterPlaylistLoader_.master,
          f
        ), m = pg(_);
        if (!(!_.audio && !_.video)) {
          if (m !== l && p.push(
            'codec count "' + m + '" !== "' + l + '"'
          ), !a.sourceUpdater_.canChangeType()) {
            var x = _.video && ln(_.video)[0] || null, E = _.audio && ln(_.audio)[0] || null;
            x && c && x.type.toLowerCase() !== c.type.toLowerCase() && p.push(
              'video codec "' + x.type + '" !== "' + c.type + '"'
            ), E && h && E.type.toLowerCase() !== h.type.toLowerCase() && p.push(
              'audio codec "' + E.type + '" !== "' + h.type + '"'
            );
          }
          p.length && (f.excludeUntil = 1 / 0, a.logger_(
            "blacklisting " + f.id + ": " + p.join(" && ")
          ));
        }
      }
    });
  }, i.updateAdCues_ = function(r) {
    var a = 0, s = this.seekable();
    s.length && (a = s.start(0)), AP(r, this.cueTagsTrack_, a);
  }, i.goalBufferLength = function() {
    var r = this.tech_.currentTime(), a = Pi.GOAL_BUFFER_LENGTH, s = Pi.GOAL_BUFFER_LENGTH_RATE, o = Math.max(a, Pi.MAX_GOAL_BUFFER_LENGTH);
    return Math.min(a + r * s, o);
  }, i.bufferLowWaterLine = function() {
    var r = this.tech_.currentTime(), a = Pi.BUFFER_LOW_WATER_LINE, s = Pi.BUFFER_LOW_WATER_LINE_RATE, o = Math.max(a, Pi.MAX_BUFFER_LOW_WATER_LINE), u = Math.max(
      a,
      Pi.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE
    );
    return Math.min(
      a + r * s,
      this.experimentalBufferBasedABR ? u : o
    );
  }, i.bufferHighWaterLine = function() {
    return Pi.BUFFER_HIGH_WATER_LINE;
  }, t;
}(X.EventTarget), zP = function(t, i, n) {
  return function(r) {
    var a = t.master.playlists[i], s = nv(a), o = Uh(a);
    return typeof r > "u" ? o : (r ? delete a.disabled : a.disabled = !0, r !== o && !s && (n(), r ? t.trigger("renditionenabled") : t.trigger("renditiondisabled")), r);
  };
}, WP = function(t, i, n) {
  var r = t.masterPlaylistController_, a = t.options_.smoothQualityChange, s = a ? "smooth" : "fast", o = r[s + "QualityChange_"].bind(r);
  if (i.attributes) {
    var u = i.attributes.RESOLUTION;
    this.width = u && u.width, this.height = u && u.height, this.bandwidth = i.attributes.BANDWIDTH, this.frameRate = i.attributes["FRAME-RATE"];
  }
  this.codecs = pu(r.master(), i), this.playlist = i, this.id = n, this.enabled = zP(
    t.playlists,
    i.id,
    o
  );
}, qP = function(t) {
  t.representations = function() {
    var i = t.masterPlaylistController_.master(), n = Ol(i) ? t.masterPlaylistController_.getAudioTrackPlaylists_() : i.playlists;
    return n ? n.filter(function(r) {
      return !nv(r);
    }).map(function(r, a) {
      return new WP(t, r, r.id);
    }) : [];
  };
}, Sg = ["seeking", "seeked", "pause", "playing", "error"], XP = /* @__PURE__ */ function() {
  function e(i) {
    var n = this;
    this.masterPlaylistController_ = i.masterPlaylistController, this.tech_ = i.tech, this.seekable = i.seekable, this.allowSeeksWithinUnsafeLiveWindow = i.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = i.liveRangeSafeTimeDelta, this.media = i.media, this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.timer_ = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = rn("PlaybackWatcher"), this.logger_("initialize");
    var r = function() {
      return n.monitorCurrentTime_();
    }, a = function() {
      return n.monitorCurrentTime_();
    }, s = function() {
      return n.techWaiting_();
    }, o = function() {
      return n.cancelTimer_();
    }, u = this.masterPlaylistController_, l = ["main", "subtitle", "audio"], c = {};
    l.forEach(function(d) {
      c[d] = {
        reset: function() {
          return n.resetSegmentDownloads_(d);
        },
        updateend: function() {
          return n.checkSegmentDownloads_(d);
        }
      }, u[d + "SegmentLoader_"].on(
        "appendsdone",
        c[d].updateend
      ), u[d + "SegmentLoader_"].on(
        "playlistupdate",
        c[d].reset
      ), n.tech_.on(["seeked", "seeking"], c[d].reset);
    });
    var h = function(f) {
      ["main", "audio"].forEach(function(p) {
        u[p + "SegmentLoader_"][f]("appended", n.seekingAppendCheck_);
      });
    };
    this.seekingAppendCheck_ = function() {
      n.fixesBadSeeks_() && (n.consecutiveUpdates = 0, n.lastRecordedTime = n.tech_.currentTime(), h("off"));
    }, this.clearSeekingAppendCheck_ = function() {
      return h("off");
    }, this.watchForBadSeeking_ = function() {
      n.clearSeekingAppendCheck_(), h("on");
    }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", s), this.tech_.on(Sg, o), this.tech_.on("canplay", a), this.tech_.one("play", r), this.dispose = function() {
      n.clearSeekingAppendCheck_(), n.logger_("dispose"), n.tech_.off("waiting", s), n.tech_.off(Sg, o), n.tech_.off("canplay", a), n.tech_.off("play", r), n.tech_.off("seeking", n.watchForBadSeeking_), n.tech_.off("seeked", n.clearSeekingAppendCheck_), l.forEach(function(d) {
        u[d + "SegmentLoader_"].off(
          "appendsdone",
          c[d].updateend
        ), u[d + "SegmentLoader_"].off(
          "playlistupdate",
          c[d].reset
        ), n.tech_.off(["seeked", "seeking"], c[d].reset);
      }), n.checkCurrentTimeTimeout_ && W.clearTimeout(n.checkCurrentTimeTimeout_), n.cancelTimer_();
    };
  }
  var t = e.prototype;
  return t.monitorCurrentTime_ = function() {
    this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && W.clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = W.setTimeout(
      this.monitorCurrentTime_.bind(this),
      250
    );
  }, t.resetSegmentDownloads_ = function(n) {
    var r = this.masterPlaylistController_[n + "SegmentLoader_"];
    this[n + "StalledDownloads_"] > 0 && this.logger_(
      "resetting possible stalled download count for " + n + " loader"
    ), this[n + "StalledDownloads_"] = 0, this[n + "Buffered_"] = r.buffered_();
  }, t.checkSegmentDownloads_ = function(n) {
    var r = this.masterPlaylistController_, a = r[n + "SegmentLoader_"], s = a.buffered_(), o = N3(
      this[n + "Buffered_"],
      s
    );
    if (this[n + "Buffered_"] = s, o) {
      this.resetSegmentDownloads_(n);
      return;
    }
    this[n + "StalledDownloads_"]++, this.logger_(
      "found #" + this[n + "StalledDownloads_"] + " " + n + " appends that did not increase buffer (possible stalled download)",
      {
        buffered: Oa(s),
        playlistId: a.playlist_ && a.playlist_.id
      }
    ), !(this[n + "StalledDownloads_"] < 10) && (this.logger_(n + " loader stalled download exclusion"), this.resetSegmentDownloads_(n), this.tech_.trigger({
      name: "vhs-" + n + "-download-exclusion",
      type: "usage"
    }), n !== "subtitle" && r.blacklistCurrentPlaylist(
      {
        message: "Excessive " + n + " segment downloading detected."
      },
      1 / 0
    ));
  }, t.checkCurrentTime_ = function() {
    if (!(this.tech_.paused() || this.tech_.seeking())) {
      var n = this.tech_.currentTime(), r = this.tech_.buffered();
      if (this.lastRecordedTime === n && (!r.length || n + dn >= r.end(r.length - 1)))
        return this.techWaiting_();
      this.consecutiveUpdates >= 5 && n === this.lastRecordedTime ? (this.consecutiveUpdates++, this.waiting_()) : n === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0, this.lastRecordedTime = n);
    }
  }, t.cancelTimer_ = function() {
    this.consecutiveUpdates = 0, this.timer_ && (this.logger_("cancelTimer_"), clearTimeout(this.timer_)), this.timer_ = null;
  }, t.fixesBadSeeks_ = function() {
    var n = this.tech_.seeking();
    if (!n)
      return !1;
    var r = this.seekable(), a = this.tech_.currentTime(), s = this.afterSeekableWindow_(
      r,
      a,
      this.media(),
      this.allowSeeksWithinUnsafeLiveWindow
    ), o;
    if (s) {
      var u = r.end(r.length - 1);
      o = u;
    }
    if (this.beforeSeekableWindow_(r, a)) {
      var l = r.start(0);
      o = l + // if the playlist is too short and the seekable range is an exact time (can
      // happen in live with a 3 segment playlist), then don't use a time delta
      (l === r.end(0) ? 0 : dn);
    }
    if (typeof o < "u")
      return this.logger_(
        "Trying to seek outside of seekable at time " + a + " with " + ("seekable range " + Ob(r) + ". Seeking to ") + (o + ".")
      ), this.tech_.setCurrentTime(o), !0;
    for (var c = this.masterPlaylistController_.sourceUpdater_, h = this.tech_.buffered(), d = c.audioBuffer ? c.audioBuffered() : null, f = c.videoBuffer ? c.videoBuffered() : null, p = this.media(), _ = p.partTargetDuration ? p.partTargetDuration : (p.targetDuration - ga) * 2, m = [d, f], x = 0; x < m.length; x++)
      if (m[x]) {
        var E = iv(m[x], a);
        if (E < _)
          return !1;
      }
    var M = Kl(h, a);
    return M.length === 0 ? !1 : (o = M.start(0) + dn, this.logger_(
      "Buffered region starts (" + M.start(0) + ") " + (" just beyond seek point (" + a + "). Seeking to " + o + ".")
    ), this.tech_.setCurrentTime(o), !0);
  }, t.waiting_ = function() {
    if (!this.techWaiting_()) {
      var n = this.tech_.currentTime(), r = this.tech_.buffered(), a = Is(r, n);
      if (a.length && n + 3 <= a.end(0)) {
        this.cancelTimer_(), this.tech_.setCurrentTime(n), this.logger_(
          "Stopped at " + n + " while inside a buffered region " + ("[" + a.start(0) + " -> " + a.end(0) + "]. Attempting to resume ") + "playback by seeking to the current time."
        ), this.tech_.trigger({
          name: "vhs-unknown-waiting",
          type: "usage"
        }), this.tech_.trigger({
          name: "hls-unknown-waiting",
          type: "usage"
        });
        return;
      }
    }
  }, t.techWaiting_ = function() {
    var n = this.seekable(), r = this.tech_.currentTime();
    if (this.tech_.seeking() || this.timer_ !== null)
      return !0;
    if (this.beforeSeekableWindow_(n, r)) {
      var a = n.end(n.length - 1);
      return this.logger_(
        "Fell out of live window at time " + r + ". Seeking to " + ("live point (seekable end) " + a)
      ), this.cancelTimer_(), this.tech_.setCurrentTime(a), this.tech_.trigger({
        name: "vhs-live-resync",
        type: "usage"
      }), this.tech_.trigger({
        name: "hls-live-resync",
        type: "usage"
      }), !0;
    }
    var s = this.tech_.vhs.masterPlaylistController_.sourceUpdater_, o = this.tech_.buffered(), u = this.videoUnderflow_({
      audioBuffered: s.audioBuffered(),
      currentTime: r,
      videoBuffered: s.videoBuffered()
    });
    if (u)
      return this.cancelTimer_(), this.tech_.setCurrentTime(r), this.tech_.trigger({
        name: "vhs-video-underflow",
        type: "usage"
      }), this.tech_.trigger({
        name: "hls-video-underflow",
        type: "usage"
      }), !0;
    var l = Kl(o, r);
    if (l.length > 0) {
      var c = l.start(0) - r;
      return this.logger_(
        "Stopped at " + r + ", setting timer for " + c + ", seeking " + ("to " + l.start(0))
      ), this.cancelTimer_(), this.timer_ = setTimeout(
        this.skipTheGap_.bind(this),
        c * 1e3,
        r
      ), !0;
    }
    return !1;
  }, t.afterSeekableWindow_ = function(n, r, a, s) {
    if (s === void 0 && (s = !1), !n.length)
      return !1;
    var o = n.end(n.length - 1) + dn, u = !a.endList;
    return u && s && (o = n.end(n.length - 1) + a.targetDuration * 3), r > o;
  }, t.beforeSeekableWindow_ = function(n, r) {
    return !!(n.length && // can't fall before 0 and 0 seekable start identifies VOD stream
    n.start(0) > 0 && r < n.start(0) - this.liveRangeSafeTimeDelta);
  }, t.videoUnderflow_ = function(n) {
    var r = n.videoBuffered, a = n.audioBuffered, s = n.currentTime;
    if (r) {
      var o;
      if (r.length && a.length) {
        var u = Is(r, s - 3), l = Is(r, s), c = Is(a, s);
        c.length && !l.length && u.length && (o = {
          end: c.end(0),
          start: u.end(0)
        });
      } else {
        var h = Kl(r, s);
        h.length || (o = this.gapFromVideoUnderflow_(r, s));
      }
      return o ? (this.logger_(
        "Encountered a gap in video from " + o.start + " to " + o.end + ". " + ("Seeking to current time " + s)
      ), !0) : !1;
    }
  }, t.skipTheGap_ = function(n) {
    var r = this.tech_.buffered(), a = this.tech_.currentTime(), s = Kl(r, a);
    this.cancelTimer_(), !(s.length === 0 || a !== n) && (this.logger_(
      "skipTheGap_:",
      "currentTime:",
      a,
      "scheduled currentTime:",
      n,
      "nextRange start:",
      s.start(0)
    ), this.tech_.setCurrentTime(s.start(0) + ga), this.tech_.trigger({
      name: "vhs-gap-skip",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-gap-skip",
      type: "usage"
    }));
  }, t.gapFromVideoUnderflow_ = function(n, r) {
    for (var a = k3(n), s = 0; s < a.length; s++) {
      var o = a.start(s), u = a.end(s);
      if (r - o < 4 && r - o > 2)
        return {
          end: u,
          start: o
        };
    }
    return null;
  }, e;
}(), YP = {
  errorInterval: 30,
  getSource: function(t) {
    var i = this.tech({
      IWillNotUseThisInPlugins: !0
    }), n = i.currentSource_ || this.currentSource();
    return t(n);
  }
}, QP = function e(t, i) {
  var n = 0, r = 0, a = X.mergeOptions(YP, i);
  t.ready(function() {
    t.trigger({
      name: "vhs-error-reload-initialized",
      type: "usage"
    }), t.trigger({
      name: "hls-error-reload-initialized",
      type: "usage"
    });
  });
  var s = function() {
    r && t.currentTime(r);
  }, o = function(d) {
    d != null && (r = t.duration() !== 1 / 0 && t.currentTime() || 0, t.one("loadedmetadata", s), t.src(d), t.trigger({
      name: "vhs-error-reload",
      type: "usage"
    }), t.trigger({
      name: "hls-error-reload",
      type: "usage"
    }), t.play());
  }, u = function() {
    if (Date.now() - n < a.errorInterval * 1e3) {
      t.trigger({
        name: "vhs-error-reload-canceled",
        type: "usage"
      }), t.trigger({
        name: "hls-error-reload-canceled",
        type: "usage"
      });
      return;
    }
    if (!a.getSource || typeof a.getSource != "function") {
      X.log.error(
        "ERROR: reloadSourceOnError - The option getSource must be a function!"
      );
      return;
    }
    return n = Date.now(), a.getSource.call(t, o);
  }, l = function h() {
    t.off("loadedmetadata", s), t.off("error", u), t.off("dispose", h);
  }, c = function(d) {
    l(), e(t, d);
  };
  t.on("error", u), t.on("dispose", l), t.reloadSourceOnError = c;
}, KP = function(t) {
  QP(this, t);
}, y1 = "2.16.2", ZP = "6.0.1", JP = "0.22.1", $P = "4.8.0", eL = "3.1.3", Bi = {
  INITIAL_PLAYLIST_SELECTOR: JD,
  Playlist: lr,
  PlaylistLoader: Os,
  STANDARD_PLAYLIST_SELECTOR: mg,
  comparePlaylistBandwidth: uv,
  comparePlaylistResolution: QD,
  lastBandwidthSelector: mg,
  movingAverageBandwidthSelector: KD,
  utils: lD,
  xhr: Qb()
};
Object.keys(Pi).forEach(function(e) {
  Object.defineProperty(Bi, e, {
    get: function() {
      return X.log.warn(
        "using Vhs." + e + " is UNSAFE be sure you know what you are doing"
      ), Pi[e];
    },
    set: function(i) {
      if (X.log.warn(
        "using Vhs." + e + " is UNSAFE be sure you know what you are doing"
      ), typeof i != "number" || i < 0) {
        X.log.warn(
          "value of Vhs." + e + " must be greater than or equal to 0"
        );
        return;
      }
      Pi[e] = i;
    }
  });
});
var _1 = "videojs-vhs", b1 = function(t, i) {
  for (var n = i.media(), r = -1, a = 0; a < t.length; a++)
    if (t[a].id === n.id) {
      r = a;
      break;
    }
  t.selectedIndex_ = r, t.trigger({
    selectedIndex: r,
    type: "change"
  });
}, tL = function(t, i) {
  i.representations().forEach(function(n) {
    t.addQualityLevel(n);
  }), b1(t, i.playlists);
};
Bi.canPlaySource = function() {
  return X.log.warn(
    "HLS is no longer a tech. Please remove it from your player's techOrder."
  );
};
var iL = function(t, i, n) {
  if (!t)
    return t;
  var r = {};
  i && i.attributes && i.attributes.CODECS && (r = $c(ln(i.attributes.CODECS))), n && n.attributes && n.attributes.CODECS && (r.audio = n.attributes.CODECS);
  var a = ll(r.video), s = ll(r.audio), o = {};
  for (var u in t)
    o[u] = {}, s && (o[u].audioContentType = s), a && (o[u].videoContentType = a), i.contentProtection && i.contentProtection[u] && i.contentProtection[u].pssh && (o[u].pssh = i.contentProtection[u].pssh), typeof t[u] == "string" && (o[u].url = t[u]);
  return X.mergeOptions(t, o);
}, rL = function(t, i) {
  return t.reduce(function(n, r) {
    if (!r.contentProtection)
      return n;
    var a = i.reduce(function(s, o) {
      var u = r.contentProtection[o];
      return u && u.pssh && (s[o] = {
        pssh: u.pssh
      }), s;
    }, {});
    return Object.keys(a).length && n.push(a), n;
  }, []);
}, nL = function(t) {
  var i = t.player, n = t.sourceKeySystems, r = t.audioMedia, a = t.mainPlaylists;
  if (!i.eme.initializeMediaKeys)
    return Promise.resolve();
  var s = r ? a.concat([r]) : a, o = rL(
    s,
    Object.keys(n)
  ), u = [], l = [];
  return o.forEach(function(c) {
    l.push(
      new Promise(function(h, d) {
        i.tech_.one("keysessioncreated", h);
      })
    ), u.push(
      new Promise(function(h, d) {
        i.eme.initializeMediaKeys(
          {
            keySystems: c
          },
          function(f) {
            if (f) {
              d(f);
              return;
            }
            h();
          }
        );
      })
    );
  }), Promise.race([
    // If a session was previously created, these will all finish resolving without
    // creating a new session, otherwise it will take until the end of all license
    // requests, which is why the key session check is used (to make setup much faster).
    Promise.all(u),
    // Once a single session is created, the browser knows DRM will be used.
    Promise.race(l)
  ]);
}, aL = function(t) {
  var i = t.player, n = t.sourceKeySystems, r = t.media, a = t.audioMedia, s = iL(n, r, a);
  return s ? (i.currentSource().keySystems = s, s && !i.eme ? (X.log.warn(
    "DRM encrypted source cannot be decrypted without a DRM plugin"
  ), !1) : !0) : !1;
}, x1 = function() {
  if (!W.localStorage)
    return null;
  var t = W.localStorage.getItem(_1);
  if (!t)
    return null;
  try {
    return JSON.parse(t);
  } catch {
    return null;
  }
}, sL = function(t) {
  if (!W.localStorage)
    return !1;
  var i = x1();
  i = i ? X.mergeOptions(i, t) : t;
  try {
    W.localStorage.setItem(
      _1,
      JSON.stringify(i)
    );
  } catch {
    return !1;
  }
  return i;
}, oL = function(t) {
  return t.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0 ? JSON.parse(t.substring(t.indexOf(",") + 1)) : t;
};
Bi.supportsNativeHls = function() {
  if (!Te || !Te.createElement)
    return !1;
  var e = Te.createElement("video");
  if (!X.getTech("Html5").isSupported())
    return !1;
  var t = [
    // Apple santioned
    "application/vnd.apple.mpegurl",
    // Apple sanctioned for backwards compatibility
    "audio/mpegurl",
    // Very common
    "audio/x-mpegurl",
    // Very common
    "application/x-mpegurl",
    // Included for completeness
    "video/x-mpegurl",
    "video/mpegurl",
    "application/mpegurl"
  ];
  return t.some(function(i) {
    return /maybe|probably/i.test(e.canPlayType(i));
  });
}();
Bi.supportsNativeDash = function() {
  return !Te || !Te.createElement || !X.getTech("Html5").isSupported() ? !1 : /maybe|probably/i.test(
    Te.createElement("video").canPlayType("application/dash+xml")
  );
}();
Bi.supportsTypeNatively = function(e) {
  return e === "hls" ? Bi.supportsNativeHls : e === "dash" ? Bi.supportsNativeDash : !1;
};
Bi.isSupported = function() {
  return X.log.warn(
    "HLS is no longer a tech. Please remove it from your player's techOrder."
  );
};
var uL = X.getComponent("Component"), cv = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a) {
    var s;
    if (s = e.call(
      this,
      r,
      X.mergeOptions(a.hls, a.vhs)
    ) || this, a.hls && Object.keys(a.hls).length && X.log.warn(
      "Using hls options is deprecated. Please rename `hls` to `vhs` in your options object."
    ), typeof a.initialBandwidth == "number" && (s.options_.bandwidth = a.initialBandwidth), s.logger_ = rn("VhsHandler"), r.options_ && r.options_.playerId) {
      var o = X(r.options_.playerId);
      o.hasOwnProperty("hls") || Object.defineProperty(o, "hls", {
        configurable: !0,
        get: function() {
          return X.log.warn(
            "player.hls is deprecated. Use player.tech().vhs instead."
          ), r.trigger({
            name: "hls-player-access",
            type: "usage"
          }), He(s);
        }
      }), o.hasOwnProperty("vhs") || Object.defineProperty(o, "vhs", {
        configurable: !0,
        get: function() {
          return X.log.warn(
            "player.vhs is deprecated. Use player.tech().vhs instead."
          ), r.trigger({
            name: "vhs-player-access",
            type: "usage"
          }), He(s);
        }
      }), o.hasOwnProperty("dash") || Object.defineProperty(o, "dash", {
        configurable: !0,
        get: function() {
          return X.log.warn(
            "player.dash is deprecated. Use player.tech().vhs instead."
          ), He(s);
        }
      }), s.player_ = o;
    }
    if (s.tech_ = r, s.source_ = n, s.stats = {}, s.ignoreNextSeekingEvent_ = !1, s.setOptions_(), s.options_.overrideNative && r.overrideNativeAudioTracks && r.overrideNativeVideoTracks)
      r.overrideNativeAudioTracks(!0), r.overrideNativeVideoTracks(!0);
    else if (s.options_.overrideNative && (r.featuresNativeVideoTracks || r.featuresNativeAudioTracks))
      throw new Error(
        "Overriding native HLS requires emulated tracks. See https://git.io/vMpjB"
      );
    return s.on(
      Te,
      [
        "fullscreenchange",
        "webkitfullscreenchange",
        "mozfullscreenchange",
        "MSFullscreenChange"
      ],
      function(u) {
        var l = Te.fullscreenElement || Te.webkitFullscreenElement || Te.mozFullScreenElement || Te.msFullscreenElement;
        l && l.contains(s.tech_.el()) ? s.masterPlaylistController_.fastQualityChange_() : s.masterPlaylistController_.checkABR_();
      }
    ), s.on(s.tech_, "seeking", function() {
      if (this.ignoreNextSeekingEvent_) {
        this.ignoreNextSeekingEvent_ = !1;
        return;
      }
      this.setCurrentTime(this.tech_.currentTime());
    }), s.on(s.tech_, "error", function() {
      this.tech_.error() && this.masterPlaylistController_ && this.masterPlaylistController_.pauseLoading();
    }), s.on(s.tech_, "play", s.play), s;
  }
  var i = t.prototype;
  return i.setOptions_ = function() {
    var r = this;
    if (this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.handleManifestRedirects = this.options_.handleManifestRedirects !== !1, this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions !== !1, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.smoothQualityChange = this.options_.smoothQualityChange || !1, this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage < "u" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || !1, this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, typeof this.options_.blacklistDuration != "number" && (this.options_.blacklistDuration = 5 * 60), typeof this.options_.bandwidth != "number" && this.options_.useBandwidthFromLocalStorage) {
      var a = x1();
      a && a.bandwidth && (this.options_.bandwidth = a.bandwidth, this.tech_.trigger({
        name: "vhs-bandwidth-from-local-storage",
        type: "usage"
      }), this.tech_.trigger({
        name: "hls-bandwidth-from-local-storage",
        type: "usage"
      })), a && a.throughput && (this.options_.throughput = a.throughput, this.tech_.trigger({
        name: "vhs-throughput-from-local-storage",
        type: "usage"
      }), this.tech_.trigger({
        name: "hls-throughput-from-local-storage",
        type: "usage"
      }));
    }
    typeof this.options_.bandwidth != "number" && (this.options_.bandwidth = Pi.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Pi.INITIAL_BANDWIDTH, [
      "withCredentials",
      "useDevicePixelRatio",
      "limitRenditionByPlayerDimensions",
      "bandwidth",
      "smoothQualityChange",
      "customTagParsers",
      "customTagMappers",
      "handleManifestRedirects",
      "cacheEncryptionKeys",
      "playlistSelector",
      "initialPlaylistSelector",
      "experimentalBufferBasedABR",
      "liveRangeSafeTimeDelta",
      "experimentalLLHLS",
      "useNetworkInformationApi",
      "useDtsForTimestampOffset",
      "experimentalExactManifestTimings",
      "experimentalLeastPixelDiffSelector"
    ].forEach(function(s) {
      typeof r.source_[s] < "u" && (r.options_[s] = r.source_[s]);
    }), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
  }, i.src = function(r, a) {
    var s = this;
    if (r) {
      this.setOptions_(), this.options_.src = oL(this.source_.src), this.options_.tech = this.tech_, this.options_.externVhs = Bi, this.options_.sourceType = My(a), this.options_.seekTo = function(l) {
        s.tech_.setCurrentTime(l);
      }, this.options_.smoothQualityChange && X.log.warn(
        "smoothQualityChange is deprecated and will be removed in the next major version"
      ), this.masterPlaylistController_ = new HP(
        this.options_
      );
      var o = X.mergeOptions(
        {
          liveRangeSafeTimeDelta: dn
        },
        this.options_,
        {
          masterPlaylistController: this.masterPlaylistController_,
          media: function() {
            return s.masterPlaylistController_.media();
          },
          seekable: function() {
            return s.seekable();
          }
        }
      );
      this.playbackWatcher_ = new XP(o), this.masterPlaylistController_.on("error", function() {
        var l = X.players[s.tech_.options_.playerId], c = s.masterPlaylistController_.error;
        typeof c == "object" && !c.code ? c.code = 3 : typeof c == "string" && (c = {
          code: 3,
          message: c
        }), l.error(c);
      });
      var u = this.options_.experimentalBufferBasedABR ? Bi.movingAverageBandwidthSelector(0.55) : Bi.STANDARD_PLAYLIST_SELECTOR;
      this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : u.bind(this), this.masterPlaylistController_.selectInitialPlaylist = Bi.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.masterPlaylistController_.masterPlaylistLoader_, this.mediaSource = this.masterPlaylistController_.mediaSource, Object.defineProperties(this, {
        bandwidth: {
          get: function() {
            var c = this.masterPlaylistController_.mainSegmentLoader_.bandwidth, h = W.navigator.connection || W.navigator.mozConnection || W.navigator.webkitConnection, d = 1e7;
            if (this.options_.useNetworkInformationApi && h) {
              var f = h.downlink * 1e3 * 1e3;
              f >= d && c >= d ? c = Math.max(
                c,
                f
              ) : c = f;
            }
            return c;
          },
          set: function(c) {
            this.masterPlaylistController_.mainSegmentLoader_.bandwidth = c, this.masterPlaylistController_.mainSegmentLoader_.throughput = {
              count: 0,
              rate: 0
            };
          }
        },
        selectPlaylist: {
          get: function() {
            return this.masterPlaylistController_.selectPlaylist;
          },
          set: function(c) {
            this.masterPlaylistController_.selectPlaylist = c.bind(this);
          }
        },
        /**
         * `systemBandwidth` is a combination of two serial processes bit-rates. The first
         * is the network bitrate provided by `bandwidth` and the second is the bitrate of
         * the entire process after that - decryption, transmuxing, and appending - provided
         * by `throughput`.
         *
         * Since the two process are serial, the overall system bandwidth is given by:
         *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)
         */
        systemBandwidth: {
          get: function() {
            var c = 1 / (this.bandwidth || 1), h;
            this.throughput > 0 ? h = 1 / this.throughput : h = 0;
            var d = Math.floor(1 / (c + h));
            return d;
          },
          set: function() {
            X.log.error('The "systemBandwidth" property is read-only');
          }
        },
        throughput: {
          get: function() {
            return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;
          },
          set: function(c) {
            this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = c, this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;
          }
        }
      }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, {
        audioAppendsToLoadedData: {
          get: function() {
            return s.masterPlaylistController_.audioAppendsToLoadedData_() || 0;
          },
          enumerable: !0
        },
        bandwidth: {
          enumerable: !0,
          get: function() {
            return s.bandwidth || 0;
          }
        },
        appendsToLoadedData: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.appendsToLoadedData_() || 0;
          }
        },
        mediaAppends: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaAppends_() || 0;
          }
        },
        buffered: {
          enumerable: !0,
          get: function() {
            return Oa(s.tech_.buffered());
          }
        },
        mediaBytesTransferred: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaBytesTransferred_() || 0;
          }
        },
        currentSource: {
          enumerable: !0,
          get: function() {
            return s.tech_.currentSource_;
          }
        },
        mediaRequests: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaRequests_() || 0;
          }
        },
        currentTech: {
          enumerable: !0,
          get: function() {
            return s.tech_.name_;
          }
        },
        mediaRequestsAborted: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaRequestsAborted_() || 0;
          }
        },
        currentTime: {
          enumerable: !0,
          get: function() {
            return s.tech_.currentTime();
          }
        },
        mediaRequestsErrored: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaRequestsErrored_() || 0;
          }
        },
        duration: {
          enumerable: !0,
          get: function() {
            return s.tech_.duration();
          }
        },
        mediaRequestsTimedout: {
          get: function() {
            return s.masterPlaylistController_.mediaRequestsTimedout_() || 0;
          },
          enumerable: !0
        },
        mainAppendsToLoadedData: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mainAppendsToLoadedData_() || 0;
          }
        },
        mediaTransferDuration: {
          get: function() {
            return s.masterPlaylistController_.mediaTransferDuration_() || 0;
          },
          enumerable: !0
        },
        master: {
          enumerable: !0,
          get: function() {
            return s.playlists.master;
          }
        },
        mediaSecondsLoaded: {
          get: function() {
            return s.masterPlaylistController_.mediaSecondsLoaded_() || 0;
          },
          enumerable: !0
        },
        playerDimensions: {
          enumerable: !0,
          get: function() {
            return s.tech_.currentDimensions();
          }
        },
        seekable: {
          enumerable: !0,
          get: function() {
            return Oa(s.tech_.seekable());
          }
        },
        timeToLoadedData: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.timeToLoadedData_() || 0;
          }
        },
        timestamp: {
          enumerable: !0,
          get: function() {
            return Date.now();
          }
        },
        videoPlaybackQuality: {
          enumerable: !0,
          get: function() {
            return s.tech_.getVideoPlaybackQuality();
          }
        }
      }), this.tech_.one(
        "canplay",
        this.masterPlaylistController_.setupFirstPlay.bind(
          this.masterPlaylistController_
        )
      ), this.tech_.on("bandwidthupdate", function() {
        s.options_.useBandwidthFromLocalStorage && sL({
          bandwidth: s.bandwidth,
          throughput: Math.round(s.throughput)
        });
      }), this.masterPlaylistController_.on("selectedinitialmedia", function() {
        qP(s);
      }), this.masterPlaylistController_.sourceUpdater_.on(
        "createdsourcebuffers",
        function() {
          s.setupEme_();
        }
      ), this.on(this.masterPlaylistController_, "progress", function() {
        this.tech_.trigger("progress");
      }), this.on(this.masterPlaylistController_, "firstplay", function() {
        this.ignoreNextSeekingEvent_ = !0;
      }), this.setupQualityLevels_(), this.tech_.el() && (this.mediaSourceUrl_ = W.URL.createObjectURL(
        this.masterPlaylistController_.mediaSource
      ), this.tech_.src(this.mediaSourceUrl_));
    }
  }, i.createKeySessions_ = function() {
    var r = this, a = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    this.logger_("waiting for EME key session creation"), nL({
      audioMedia: a && a.media(),
      mainPlaylists: this.playlists.master.playlists,
      player: this.player_,
      sourceKeySystems: this.source_.keySystems
    }).then(function() {
      r.logger_("created EME key session"), r.masterPlaylistController_.sourceUpdater_.initializedEme();
    }).catch(function(s) {
      r.logger_("error while creating EME key session", s), r.player_.error({
        code: 3,
        message: "Failed to initialize media keys for EME"
      });
    });
  }, i.handleWaitingForKey_ = function() {
    this.logger_(
      "waitingforkey fired, attempting to create any new key sessions"
    ), this.createKeySessions_();
  }, i.setupEme_ = function() {
    var r = this, a = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader, s = aL({
      audioMedia: a && a.media(),
      media: this.playlists.media(),
      player: this.player_,
      sourceKeySystems: this.source_.keySystems
    });
    if (this.player_.tech_.on("keystatuschange", function(o) {
      if (o.status === "output-restricted") {
        var u = r.masterPlaylistController_.master();
        if (!(!u || !u.playlists)) {
          var l = [];
          if (u.playlists.forEach(function(h) {
            h && h.attributes && h.attributes.RESOLUTION && h.attributes.RESOLUTION.height >= 720 && (!h.excludeUntil || h.excludeUntil < 1 / 0) && (h.excludeUntil = 1 / 0, l.push(h));
          }), l.length) {
            var c;
            (c = X.log).warn.apply(
              c,
              [
                'DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.'
              ].concat(l)
            ), r.masterPlaylistController_.fastQualityChange_();
          }
        }
      }
    }), this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this), this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_), X.browser.IE_VERSION === 11 || !s) {
      this.masterPlaylistController_.sourceUpdater_.initializedEme();
      return;
    }
    this.createKeySessions_();
  }, i.setupQualityLevels_ = function() {
    var r = this, a = X.players[this.tech_.options_.playerId];
    !a || !a.qualityLevels || this.qualityLevels_ || (this.qualityLevels_ = a.qualityLevels(), this.masterPlaylistController_.on("selectedinitialmedia", function() {
      tL(r.qualityLevels_, r);
    }), this.playlists.on("mediachange", function() {
      b1(r.qualityLevels_, r.playlists);
    }));
  }, t.version = function() {
    return {
      "@videojs/http-streaming": y1,
      "aes-decrypter": eL,
      "m3u8-parser": $P,
      "mpd-parser": JP,
      "mux.js": ZP
    };
  }, i.version = function() {
    return this.constructor.version();
  }, i.canChangeType = function() {
    return g1.canChangeType();
  }, i.play = function() {
    this.masterPlaylistController_.play();
  }, i.setCurrentTime = function(r) {
    this.masterPlaylistController_.setCurrentTime(r);
  }, i.duration = function() {
    return this.masterPlaylistController_.duration();
  }, i.seekable = function() {
    return this.masterPlaylistController_.seekable();
  }, i.dispose = function() {
    this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.masterPlaylistController_ && this.masterPlaylistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.player_ && (delete this.player_.vhs, delete this.player_.dash, delete this.player_.hls), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.tech_ && delete this.tech_.hls, this.mediaSourceUrl_ && W.URL.revokeObjectURL && (W.URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_), e.prototype.dispose.call(this);
  }, i.convertToProgramTime = function(r, a) {
    return mD({
      callback: a,
      playlist: this.masterPlaylistController_.media(),
      time: r
    });
  }, i.seekToProgramTime = function(r, a, s, o) {
    return s === void 0 && (s = !0), o === void 0 && (o = 2), gD({
      callback: a,
      pauseAfterSeek: s,
      playlist: this.masterPlaylistController_.media(),
      programTime: r,
      retryCount: o,
      seekTo: this.options_.seekTo,
      tech: this.options_.tech
    });
  }, t;
}(uL), yl = {
  VERSION: y1,
  canHandleSource: function(t, i) {
    i === void 0 && (i = {});
    var n = X.mergeOptions(X.options, i);
    return yl.canPlayType(t.type, n);
  },
  canPlayType: function(t, i) {
    var n = My(t);
    if (!n)
      return "";
    var r = yl.getOverrideNative(i), a = Bi.supportsTypeNatively(n), s = !a || r;
    return s ? "maybe" : "";
  },
  getOverrideNative: function(t) {
    t === void 0 && (t = {});
    var i = t, n = i.vhs, r = n === void 0 ? {} : n, a = i.hls, s = a === void 0 ? {} : a, o = !(X.browser.IS_ANY_SAFARI || X.browser.IS_IOS), u = r.overrideNative, l = u === void 0 ? o : u, c = s.overrideNative, h = c === void 0 ? !1 : c;
    return h || l;
  },
  handleSource: function(t, i, n) {
    n === void 0 && (n = {});
    var r = X.mergeOptions(X.options, n);
    return i.vhs = new cv(t, i, r), X.hasOwnProperty("hls") || Object.defineProperty(i, "hls", {
      configurable: !0,
      get: function() {
        return X.log.warn(
          "player.tech().hls is deprecated. Use player.tech().vhs instead."
        ), i.vhs;
      }
    }), i.vhs.xhr = Qb(), i.vhs.src(t.src, t.type), i.vhs;
  },
  name: "videojs-http-streaming"
}, lL = function() {
  return tc("avc1.4d400d,mp4a.40.2");
};
lL() && X.getTech("Html5").registerSourceHandler(yl, 0);
X.VhsHandler = cv;
Object.defineProperty(X, "HlsHandler", {
  configurable: !0,
  get: function() {
    return X.log.warn(
      "videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead."
    ), cv;
  }
});
X.VhsSourceHandler = yl;
Object.defineProperty(X, "HlsSourceHandler", {
  configurable: !0,
  get: function() {
    return X.log.warn(
      "videojs.HlsSourceHandler is deprecated. Use videojs.VhsSourceHandler instead."
    ), yl;
  }
});
X.Vhs = Bi;
Object.defineProperty(X, "Hls", {
  configurable: !0,
  get: function() {
    return X.log.warn("videojs.Hls is deprecated. Use videojs.Vhs instead."), Bi;
  }
});
X.use || (X.registerComponent("Hls", Bi), X.registerComponent("Vhs", Bi));
X.options.vhs = X.options.vhs || {};
X.options.hls = X.options.hls || {};
if (!X.getPlugin || !X.getPlugin("reloadSourceOnError")) {
  var cL = X.registerPlugin || X.plugin;
  cL("reloadSourceOnError", KP);
}
/* ! @name videojs-vr @version 1.7.2 @license Apache-2.0 */
W.THREE || (W.THREE = {});
for (const e in $v)
  try {
    W.THREE[e] = $v[e];
  } catch {
  }
import("../chunks/OrbitControls.CLHBWz99.js");
import("../chunks/DeviceOrientationControls.CCdbZgfJ.js");
import("../chunks/VREffect.YVShY77P.js");
import("../chunks/VRControls.js_g1t8t.js");
var hL = W.THREE.OrbitControls, dL = W.THREE.VREffect, fL = W.THREE.VRControls, pL = W.THREE.DeviceOrientationControls, vL = "1.7.2";
function mL(e, t, i, n) {
  var r = e * t + i * n;
  if (r > 0.499) {
    var a = 2 * Math.atan2(e, n), s = Math.PI / 2, o = 0;
    return new H(s, o, a);
  }
  if (r < -0.499) {
    var u = -2 * Math.atan2(e, n), l = -Math.PI / 2, c = 0;
    return new H(l, c, u);
  }
  var h = e * e, d = t * t, f = i * i, p = Math.atan2(2 * t * n - 2 * e * i, 1 - 2 * d - 2 * f), _ = Math.asin(2 * r), m = Math.atan2(2 * e * n - 2 * t * i, 1 - 2 * h - 2 * f);
  return new H(_, m, p);
}
var gL = /* @__PURE__ */ function() {
  function e(i) {
    this.object = i.camera, this.domElement = i.canvas, this.orbit = new hL(this.object, this.domElement), this.speed = 0.5, this.orbit.target.set(0, 0, -1), this.orbit.enableZoom = !1, this.orbit.enablePan = !1, this.orbit.rotateSpeed = -this.speed, i.orientation && (this.orientation = new pL(this.object)), i.halfView && (this.orbit.minAzimuthAngle = -Math.PI / 4, this.orbit.maxAzimuthAngle = Math.PI / 4);
  }
  var t = e.prototype;
  return t.update = function() {
    if (this.orientation) {
      this.orientation.update();
      var n = this.orientation.object.quaternion, r = mL(n.x, n.y, n.z, n.w);
      typeof this.lastAngle_ > "u" && (this.lastAngle_ = r), this.orbit.rotateLeft(
        (this.lastAngle_.z - r.z) * (1 + this.speed)
      ), this.orbit.rotateUp(
        (this.lastAngle_.y - r.y) * (1 + this.speed)
      ), this.lastAngle_ = r;
    }
    this.orbit.update();
  }, t.dispose = function() {
    this.orbit.dispose(), this.orientation && this.orientation.dispose();
  }, e;
}(), yL = function() {
  var e = Te.createElement("video");
  return e.crossOrigin = "anonymous", e.hasAttribute("crossorigin");
}(), sc = [
  "360",
  "360_LR",
  "360_TB",
  "360_CUBE",
  "EAC",
  "EAC_LR",
  "NONE",
  "AUTO",
  "Sphere",
  "Cube",
  "equirectangular",
  "180"
], Td = function(t) {
  if (t) {
    if (t = t.toString().trim(), /sphere/i.test(t))
      return "360";
    if (/cube/i.test(t))
      return "360_CUBE";
    if (/equirectangular/i.test(t))
      return "360";
    for (var i = 0; i < sc.length; i++)
      if (new RegExp("^" + sc[i] + "$", "i").test(t))
        return sc[i];
  }
}, _L = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this) || this, a.player = n, a.canvas = r, a.onMoveEnd = X.bind(
      He(a),
      a.onMoveEnd
    ), a.onMoveStart = X.bind(
      He(a),
      a.onMoveStart
    ), a.onMove = X.bind(He(a), a.onMove), a.onControlBarMove = X.bind(
      He(a),
      a.onControlBarMove
    ), a.player.controlBar.on(
      [
        "mousedown",
        "mousemove",
        "mouseup",
        "touchstart",
        "touchmove",
        "touchend"
      ],
      a.onControlBarMove
    ), a.oldReportUserActivity = a.player.reportUserActivity, a.player.reportUserActivity = function() {
    }, a.canvas.addEventListener("mousedown", a.onMoveStart), a.canvas.addEventListener("touchstart", a.onMoveStart), a.canvas.addEventListener("mousemove", a.onMove), a.canvas.addEventListener("touchmove", a.onMove), a.canvas.addEventListener("mouseup", a.onMoveEnd), a.canvas.addEventListener("touchend", a.onMoveEnd), a.shouldTogglePlay = !1, a;
  }
  var i = t.prototype;
  return i.togglePlay = function() {
    this.player.paused() ? this.player.play() : this.player.pause();
  }, i.onMoveStart = function(r) {
    if (!this.player.controls() || r.type === "mousedown" && !X.dom.isSingleLeftClick(r)) {
      this.shouldTogglePlay = !1;
      return;
    }
    this.shouldTogglePlay = !0, this.touchMoveCount_ = 0;
  }, i.onMoveEnd = function(r) {
    if (r.type === "touchend" && this.touchMoveCount_ < 10) {
      if (this.player.userActive() === !1) {
        this.player.userActive(!0);
        return;
      }
      this.player.userActive(!1);
      return;
    }
    this.shouldTogglePlay && r.type == "mouseup" && this.togglePlay();
  }, i.onMove = function(r) {
    this.touchMoveCount_++, this.shouldTogglePlay = !1;
  }, i.onControlBarMove = function(r) {
    this.player.userActive(!0);
  }, i.dispose = function() {
    this.canvas.removeEventListener("mousedown", this.onMoveStart), this.canvas.removeEventListener("touchstart", this.onMoveStart), this.canvas.removeEventListener("mousemove", this.onMove), this.canvas.removeEventListener("touchmove", this.onMove), this.canvas.removeEventListener("mouseup", this.onMoveEnd), this.canvas.removeEventListener("touchend", this.onMoveEnd), this.player.controlBar.off(
      [
        "mousedown",
        "mousemove",
        "mouseup",
        "touchstart",
        "touchmove",
        "touchend"
      ],
      this.onControlBarMove
    ), this.player.reportUserActivity = this.oldReportUserActivity;
  }, t;
}(X.EventTarget), bL = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r, a, s) {
    var o;
    o = e.call(this) || this;
    var u = X.mergeOptions(
      {
        ambisonicOrder: 1,
        // Safari uses the different AAC decoder than FFMPEG. The channel order is
        // The default 4ch AAC channel layout for FFMPEG AAC channel ordering.
        channelMap: X.browser.IS_SAFARI ? [2, 0, 1, 3] : [0, 1, 2, 3]
      },
      s
    );
    return o.videoElementSource = n.createMediaElementSource(a), o.foaRenderer = r.createFOARenderer(n, u), o.foaRenderer.initialize().then(
      function() {
        n.state === "suspended" && o.trigger({
          type: "audiocontext-suspended"
        }), o.videoElementSource.connect(o.foaRenderer.input), o.foaRenderer.output.connect(n.destination), o.initialized = !0, o.trigger({
          type: "omnitone-ready"
        });
      },
      function(l) {
        X.log.warn(
          "videojs-vr: Omnitone initializes failed with the following error: " + l + ")"
        );
      }
    ), o;
  }
  var i = t.prototype;
  return i.update = function(r) {
    this.initialized && this.foaRenderer.setRotationMatrixFromCamera(r.matrix);
  }, i.dispose = function() {
    this.initialized = !1, this.foaRenderer.setRenderingMode("bypass"), this.foaRenderer = null;
  }, t;
}(X.EventTarget), xL = X.getComponent("Button"), AL = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a;
    return a = e.call(this, n, r) || this, a.handleVrDisplayActivate_ = X.bind(
      He(a),
      a.handleVrDisplayActivate_
    ), a.handleVrDisplayDeactivate_ = X.bind(
      He(a),
      a.handleVrDisplayDeactivate_
    ), a.handleVrDisplayPresentChange_ = X.bind(
      He(a),
      a.handleVrDisplayPresentChange_
    ), a.handleOrientationChange_ = X.bind(
      He(a),
      a.handleOrientationChange_
    ), W.addEventListener(
      "orientationchange",
      a.handleOrientationChange_
    ), W.addEventListener(
      "vrdisplayactivate",
      a.handleVrDisplayActivate_
    ), W.addEventListener(
      "vrdisplaydeactivate",
      a.handleVrDisplayDeactivate_
    ), W.addEventListener(
      "vrdisplaypresentchange",
      a.handleVrDisplayPresentChange_
    ), X.browser.IS_ANDROID && a.on(n, "fullscreenchange", function() {
      n.isFullscreen() ? a.hide() : a.show();
    }), a;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-button-vr " + e.prototype.buildCSSClass.call(this);
  }, i.handleVrDisplayPresentChange_ = function() {
    !this.player_.vr().vrDisplay.isPresenting && this.active_ && this.handleVrDisplayDeactivate_(), this.player_.vr().vrDisplay.isPresenting && !this.active_ && this.handleVrDisplayActivate_();
  }, i.handleOrientationChange_ = function() {
    this.active_ && X.browser.IS_IOS && this.changeSize_();
  }, i.changeSize_ = function() {
    this.player_.width(W.innerWidth), this.player_.height(W.innerHeight), W.dispatchEvent(new W.Event("resize"));
  }, i.handleVrDisplayActivate_ = function() {
    X.browser.IS_IOS && (this.oldWidth_ = this.player_.currentWidth(), this.oldHeight_ = this.player_.currentHeight(), this.player_.enterFullWindow(), this.changeSize_()), this.active_ = !0;
  }, i.handleVrDisplayDeactivate_ = function() {
    X.browser.IS_IOS && (this.oldWidth_ && this.player_.width(this.oldWidth_), this.oldHeight_ && this.player_.height(this.oldHeight_), this.player_.exitFullWindow()), this.active_ = !1;
  }, i.handleClick = function(r) {
    this.active_ ? W.dispatchEvent(new W.Event("vrdisplaydeactivate")) : (!this.player_.hasStarted() && X.browser.IS_ANDROID && this.player_.play(), W.dispatchEvent(new W.Event("vrdisplayactivate")));
  }, i.dispose = function() {
    e.prototype.dispose.call(this), W.removeEventListener(
      "vrdisplayactivate",
      this.handleVrDisplayActivate_
    ), W.removeEventListener(
      "vrdisplaydeactivate",
      this.handleVrDisplayDeactivate_
    ), W.removeEventListener(
      "vrdisplaypresentchange",
      this.handleVrDisplayPresentChange_
    );
  }, t;
}(xL);
X.registerComponent("CardboardButton", AL);
var TL = X.getComponent("BigPlayButton"), EL = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.buildCSSClass = function() {
    return "vjs-big-vr-play-button " + e.prototype.buildCSSClass.call(this);
  }, t;
}(TL);
X.registerComponent("BigVrPlayButton", EL);
var wL = {
  debug: !1,
  forceCardboard: !1,
  omnitone: !1,
  omnitoneOptions: {},
  projection: "AUTO"
}, Cg = {
  "web-vr-hls-cors-not-supported": {
    headline: "360 HLS video not supported on this device",
    message: "Your browser/device does not support HLS 360 video. See <a href='http://webvr.info'>http://webvr.info</a> for assistance.",
    type: "360_NOT_SUPPORTED"
  },
  "web-vr-not-supported": {
    headline: "360 not supported on this device",
    message: "Your browser does not support 360. See <a href='http://webvr.info'>http://webvr.info</a> for assistance.",
    type: "360_NOT_SUPPORTED"
  },
  "web-vr-out-of-date": {
    headline: "360 is out of date",
    message: "Your browser supports 360 but not the latest version. See <a href='http://webvr.info'>http://webvr.info</a> for more info.",
    type: "360_OUT_OF_DATE"
  }
}, SL = X.getPlugin("plugin"), A1 = X.getComponent("Component"), jh = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, r) {
    var a, s = X.mergeOptions(wL, r);
    return a = e.call(this, n, s) || this, a.options_ = s, a.player_ = n, a.bigPlayButtonIndex_ = n.children().indexOf(n.getChild("BigPlayButton")) || 0, a.videojsErrorsSupport_ = !!X.errors, a.videojsErrorsSupport_ && n.errors({
      errors: Cg
    }), X.browser.IE_VERSION || !yL ? (a.player_.on("loadstart", function() {
      a.triggerError_({
        code: "web-vr-not-supported",
        dismiss: !1
      });
    }), He(a)) : (a.polyfill_ = new $h({
      // do not show rotate instructions
      ROTATE_INSTRUCTIONS_DISABLED: !0
    }), a.polyfill_ = new $h(), a.handleVrDisplayActivate_ = X.bind(
      He(a),
      a.handleVrDisplayActivate_
    ), a.handleVrDisplayDeactivate_ = X.bind(
      He(a),
      a.handleVrDisplayDeactivate_
    ), a.handleResize_ = X.bind(
      He(a),
      a.handleResize_
    ), a.animate_ = X.bind(
      He(a),
      a.animate_
    ), a.setProjection(a.options_.projection), a.on(
      n,
      "adstart",
      function() {
        return n.setTimeout(function() {
          if (!n.ads || !n.ads.videoElementRecycled()) {
            a.log(
              "video element not recycled for this ad, no need to reset"
            );
            return;
          }
          a.log("video element recycled for this ad, reseting"), a.reset(), a.one(n, "playing", a.init);
        });
      },
      1
    ), a.on(n, "loadedmetadata", a.init), a);
  }
  var i = t.prototype;
  return i.changeProjection_ = function(r) {
    var a = this;
    r = Td(r), r || (r = "NONE");
    var s = {
      x: 0,
      y: 0,
      z: 0
    };
    if (this.scene && this.scene.remove(this.movieScreen), r === "AUTO") {
      if (this.player_.mediainfo && this.player_.mediainfo.projection && this.player_.mediainfo.projection !== "AUTO") {
        var o = Td(
          this.player_.mediainfo.projection
        );
        return this.changeProjection_(o);
      }
      return this.changeProjection_("NONE");
    } else if (r === "360")
      this.movieGeometry = new pa(256, 32, 32), this.movieMaterial = new Ei({
        map: this.videoTexture,
        overdraw: !0,
        side: Ti
      }), this.movieScreen = new fi(this.movieGeometry, this.movieMaterial), this.movieScreen.position.set(s.x, s.y, s.z), this.movieScreen.scale.x = -1, this.movieScreen.quaternion.setFromAxisAngle(
        {
          x: 0,
          y: 1,
          z: 0
        },
        -Math.PI / 2
      ), this.scene.add(this.movieScreen);
    else if (r === "360_LR" || r === "360_TB") {
      for (var u = new On(256, 32, 32), l = u.faceVertexUvs[0], c = 0; c < l.length; c++)
        for (var h = 0; h < 3; h++)
          r === "360_LR" ? l[c][h].x *= 0.5 : (l[c][h].y *= 0.5, l[c][h].y += 0.5);
      this.movieGeometry = new je().fromGeometry(u), this.movieMaterial = new Ei({
        map: this.videoTexture,
        overdraw: !0,
        side: Ti
      }), this.movieScreen = new fi(this.movieGeometry, this.movieMaterial), this.movieScreen.scale.x = -1, this.movieScreen.quaternion.setFromAxisAngle(
        {
          x: 0,
          y: 1,
          z: 0
        },
        -Math.PI / 2
      ), this.movieScreen.layers.set(1), this.scene.add(this.movieScreen), u = new On(256, 32, 32), l = u.faceVertexUvs[0];
      for (var d = 0; d < l.length; d++)
        for (var f = 0; f < 3; f++)
          r === "360_LR" ? (l[d][f].x *= 0.5, l[d][f].x += 0.5) : l[d][f].y *= 0.5;
      this.movieGeometry = new je().fromGeometry(u), this.movieMaterial = new Ei({
        map: this.videoTexture,
        overdraw: !0,
        side: Ti
      }), this.movieScreen = new fi(this.movieGeometry, this.movieMaterial), this.movieScreen.scale.x = -1, this.movieScreen.quaternion.setFromAxisAngle(
        {
          x: 0,
          y: 1,
          z: 0
        },
        -Math.PI / 2
      ), this.movieScreen.layers.set(2), this.scene.add(this.movieScreen);
    } else if (r === "360_CUBE") {
      this.movieGeometry = new la(256, 256, 256), this.movieMaterial = new Ei({
        map: this.videoTexture,
        overdraw: !0,
        side: Ti
      });
      var p = [
        new ue(0, 0.5),
        new ue(0.333, 0.5),
        new ue(0.333, 1),
        new ue(0, 1)
      ], _ = [
        new ue(0.333, 0.5),
        new ue(0.666, 0.5),
        new ue(0.666, 1),
        new ue(0.333, 1)
      ], m = [
        new ue(0.666, 0.5),
        new ue(1, 0.5),
        new ue(1, 1),
        new ue(0.666, 1)
      ], x = [
        new ue(0, 0),
        new ue(0.333, 0),
        new ue(0.333, 0.5),
        new ue(0, 0.5)
      ], E = [
        new ue(0.333, 0),
        new ue(0.666, 0),
        new ue(0.666, 0.5),
        new ue(0.333, 0.5)
      ], M = [
        new ue(0.666, 0),
        new ue(1, 0),
        new ue(1, 0.5),
        new ue(0.666, 0.5)
      ];
      this.movieGeometry.faceVertexUvs[0] = [], this.movieGeometry.faceVertexUvs[0][0] = [_[2], _[1], _[3]], this.movieGeometry.faceVertexUvs[0][1] = [_[1], _[0], _[3]], this.movieGeometry.faceVertexUvs[0][2] = [p[2], p[1], p[3]], this.movieGeometry.faceVertexUvs[0][3] = [p[1], p[0], p[3]], this.movieGeometry.faceVertexUvs[0][4] = [m[2], m[1], m[3]], this.movieGeometry.faceVertexUvs[0][5] = [m[1], m[0], m[3]], this.movieGeometry.faceVertexUvs[0][6] = [
        x[2],
        x[1],
        x[3]
      ], this.movieGeometry.faceVertexUvs[0][7] = [
        x[1],
        x[0],
        x[3]
      ], this.movieGeometry.faceVertexUvs[0][8] = [E[2], E[1], E[3]], this.movieGeometry.faceVertexUvs[0][9] = [E[1], E[0], E[3]], this.movieGeometry.faceVertexUvs[0][10] = [M[2], M[1], M[3]], this.movieGeometry.faceVertexUvs[0][11] = [M[1], M[0], M[3]], this.movieScreen = new fi(this.movieGeometry, this.movieMaterial), this.movieScreen.position.set(s.x, s.y, s.z), this.movieScreen.rotation.y = -Math.PI, this.scene.add(this.movieScreen);
    } else if (r === "180") {
      var C = new On(256, 32, 32, Math.PI, Math.PI);
      C.scale(-1, 1, 1);
      for (var R = C.faceVertexUvs[0], k = 0; k < R.length; k++)
        for (var F = 0; F < 3; F++)
          R[k][F].x *= 0.5;
      this.movieGeometry = new je().fromGeometry(C), this.movieMaterial = new Ei({
        map: this.videoTexture,
        overdraw: !0
      }), this.movieScreen = new fi(this.movieGeometry, this.movieMaterial), this.movieScreen.layers.set(1), this.scene.add(this.movieScreen), C = new On(256, 32, 32, Math.PI, Math.PI), C.scale(-1, 1, 1), R = C.faceVertexUvs[0];
      for (var B = 0; B < R.length; B++)
        for (var I = 0; I < 3; I++)
          R[B][I].x *= 0.5, R[B][I].x += 0.5;
      this.movieGeometry = new je().fromGeometry(C), this.movieMaterial = new Ei({
        map: this.videoTexture,
        overdraw: !0
      }), this.movieScreen = new fi(this.movieGeometry, this.movieMaterial), this.movieScreen.layers.set(2), this.scene.add(this.movieScreen);
    } else if (r === "EAC" || r === "EAC_LR") {
      var V = function(oe, fe) {
        var he = 2;
        a.movieGeometry = new la(256, 256, 256), a.movieMaterial = new Mr({
          fragmentShader: `
varying vec2 vUv;
uniform sampler2D mapped;
uniform vec2 faceWH;
uniform vec2 vidWH;
uniform float contCorrect;

const float PI = 3.1415926535897932384626433832795;

void main() {
  vec2 corner = vUv - mod(vUv, faceWH) + vec2(0, contCorrect / vidWH.y);

  vec2 faceWHadj = faceWH - vec2(0, contCorrect * 2. / vidWH.y);

  vec2 p = (vUv - corner) / faceWHadj - .5;
  vec2 q = 2. / PI * atan(2. * p) + .5;

  vec2 eUv = corner + q * faceWHadj;

  gl_FragColor = texture2D(mapped, eUv);
}`,
          overdraw: !0,
          side: Ti,
          uniforms: {
            contCorrect: {
              value: he
            },
            faceWH: {
              value: new ue(0.3333333333333333, 0.5).applyMatrix3(fe)
            },
            mapMatrix: {
              value: oe
            },
            mapped: {
              value: a.videoTexture
            },
            vidWH: {
              value: new ue(
                a.videoTexture.image.videoWidth,
                a.videoTexture.image.videoHeight
              ).applyMatrix3(fe)
            }
          },
          vertexShader: `
varying vec2 vUv;
uniform mat3 mapMatrix;

void main() {
  vUv = (mapMatrix * vec3(uv, 1.)).xy;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
}`
        });
        for (var de = [
          new ue(0, 1 / 2),
          new ue(1 / 3, 1 / 2),
          new ue(1 / 3, 1),
          new ue(0, 1)
        ], G = [
          new ue(1 / 3, 1 / 2),
          new ue(2 / 3, 1 / 2),
          new ue(2 / 3, 1),
          new ue(1 / 3, 1)
        ], j = [
          new ue(2 / 3, 1 / 2),
          new ue(1, 1 / 2),
          new ue(1, 1),
          new ue(2 / 3, 1)
        ], se = [
          new ue(1 / 3, 0),
          new ue(1 / 3, 1 / 2),
          new ue(0, 1 / 2),
          new ue(0, 0)
        ], ie = [
          new ue(1 / 3, 1 / 2),
          new ue(1 / 3, 0),
          new ue(2 / 3, 0),
          new ue(2 / 3, 1 / 2)
        ], Ce = [
          new ue(1, 0),
          new ue(1, 1 / 2),
          new ue(2 / 3, 1 / 2),
          new ue(2 / 3, 0)
        ], K = 0, xe = [de, G, j, se, ie, Ce]; K < xe.length; K++) {
          for (var pe = xe[K], Re = a.videoTexture.image.videoHeight, _e = 1, Le = 0, Ee = pe, Ve = Array.isArray(Ee), ft = 0, Ee = Ve ? Ee : Ee[Symbol.iterator](); ; ) {
            var ct;
            if (Ve) {
              if (ft >= Ee.length) break;
              ct = Ee[ft++];
            } else {
              if (ft = Ee.next(), ft.done) break;
              ct = ft.value;
            }
            var kt = ct;
            kt.y < _e && (_e = kt.y), kt.y > Le && (Le = kt.y);
          }
          for (var yt = pe, Mt = Array.isArray(yt), Vt = 0, yt = Mt ? yt : yt[Symbol.iterator](); ; ) {
            var jt;
            if (Mt) {
              if (Vt >= yt.length) break;
              jt = yt[Vt++];
            } else {
              if (Vt = yt.next(), Vt.done) break;
              jt = Vt.value;
            }
            var Et = jt;
            Math.abs(Et.y - _e) < Number.EPSILON && (Et.y += he / Re), Math.abs(Et.y - Le) < Number.EPSILON && (Et.y -= he / Re), Et.x = Et.x / Re * (Re - he * 2) + he / Re;
          }
        }
        return a.movieGeometry.faceVertexUvs[0] = [], a.movieGeometry.faceVertexUvs[0][0] = [
          de[2],
          de[1],
          de[3]
        ], a.movieGeometry.faceVertexUvs[0][1] = [
          de[1],
          de[0],
          de[3]
        ], a.movieGeometry.faceVertexUvs[0][2] = [
          j[2],
          j[1],
          j[3]
        ], a.movieGeometry.faceVertexUvs[0][3] = [
          j[1],
          j[0],
          j[3]
        ], a.movieGeometry.faceVertexUvs[0][4] = [Ce[2], Ce[1], Ce[3]], a.movieGeometry.faceVertexUvs[0][5] = [Ce[1], Ce[0], Ce[3]], a.movieGeometry.faceVertexUvs[0][6] = [
          se[2],
          se[1],
          se[3]
        ], a.movieGeometry.faceVertexUvs[0][7] = [
          se[1],
          se[0],
          se[3]
        ], a.movieGeometry.faceVertexUvs[0][8] = [
          G[2],
          G[1],
          G[3]
        ], a.movieGeometry.faceVertexUvs[0][9] = [
          G[1],
          G[0],
          G[3]
        ], a.movieGeometry.faceVertexUvs[0][10] = [
          ie[2],
          ie[1],
          ie[3]
        ], a.movieGeometry.faceVertexUvs[0][11] = [
          ie[1],
          ie[0],
          ie[3]
        ], a.movieScreen = new fi(
          a.movieGeometry,
          a.movieMaterial
        ), a.movieScreen.position.set(s.x, s.y, s.z), a.movieScreen.rotation.y = -Math.PI, a.movieScreen;
      };
      if (r === "EAC")
        this.scene.add(V(new wi(), new wi()));
      else {
        var Q = new wi().set(0, 0.5, 0, 1, 0, 0, 0, 0, 1);
        V(
          new wi().set(0, -0.5, 0.5, 1, 0, 0, 0, 0, 1),
          Q
        ), this.movieScreen.layers.set(1), this.scene.add(this.movieScreen), V(
          new wi().set(0, -0.5, 1, 1, 0, 0, 0, 0, 1),
          Q
        ), this.movieScreen.layers.set(2), this.scene.add(this.movieScreen);
      }
    }
    this.currentProjection_ = r;
  }, i.triggerError_ = function(r) {
    if (this.videojsErrorsSupport_)
      this.player_.error(r);
    else {
      var a = Te.createElement("div");
      a.innerHTML = Cg[r.code].message;
      var s = a.textContent || a.innerText || "";
      this.player_.error({
        code: r.code,
        message: s
      });
    }
  }, i.log = function() {
    if (this.options_.debug) {
      for (var r = arguments.length, a = new Array(r), s = 0; s < r; s++)
        a[s] = arguments[s];
      a.forEach(function(o) {
        X.log("VR: ", o);
      });
    }
  }, i.handleVrDisplayActivate_ = function() {
    var r = this;
    this.vrDisplay && this.vrDisplay.requestPresent([
      {
        source: this.renderedCanvas
      }
    ]).then(function() {
      if (!(!r.vrDisplay.cardboardUI_ || !X.browser.IS_IOS)) {
        var a = [], s = function(l) {
          for (var c = 0; c < l.touches.length; c++)
            a.push(l.touches[c]);
        }, o = function(l) {
          a.length && (a.forEach(function(c) {
            var h = new W.MouseEvent("click", {
              clientX: c.clientX,
              clientY: c.clientY,
              screenX: c.screenX,
              screenY: c.screenY
            });
            r.renderedCanvas.dispatchEvent(h);
          }), a = []);
        };
        r.renderedCanvas.addEventListener(
          "touchstart",
          s
        ), r.renderedCanvas.addEventListener(
          "touchend",
          o
        ), r.iosRevertTouchToClick_ = function() {
          r.renderedCanvas.removeEventListener(
            "touchstart",
            s
          ), r.renderedCanvas.removeEventListener(
            "touchend",
            o
          ), r.iosRevertTouchToClick_ = null;
        };
      }
    });
  }, i.handleVrDisplayDeactivate_ = function() {
    !this.vrDisplay || !this.vrDisplay.isPresenting || (this.iosRevertTouchToClick_ && this.iosRevertTouchToClick_(), this.vrDisplay.exitPresent());
  }, i.requestAnimationFrame = function(r) {
    return this.vrDisplay ? this.vrDisplay.requestAnimationFrame(r) : this.player_.requestAnimationFrame(r);
  }, i.cancelAnimationFrame = function(r) {
    return this.vrDisplay ? this.vrDisplay.cancelAnimationFrame(r) : this.player_.cancelAnimationFrame(r);
  }, i.togglePlay_ = function() {
    this.player_.paused() ? this.player_.play() : this.player_.pause();
  }, i.animate_ = function() {
    if (this.initialized_) {
      if (this.getVideoEl_().readyState === this.getVideoEl_().HAVE_ENOUGH_DATA && this.videoTexture && (this.videoTexture.needsUpdate = !0), this.controls3d.update(), this.omniController && this.omniController.update(this.camera), this.effect.render(this.scene, this.camera), W.navigator.getGamepads)
        for (var r = W.navigator.getGamepads(), a = 0; a < r.length; ++a) {
          var s = r[a];
          if (!(!s || !s.timestamp || s.timestamp === this.prevTimestamps_[a])) {
            for (var o = 0; o < s.buttons.length; ++o)
              if (s.buttons[o].pressed) {
                this.togglePlay_(), this.prevTimestamps_[a] = s.timestamp;
                break;
              }
          }
        }
      this.camera.getWorldDirection(this.cameraVector), this.animationFrameId_ = this.requestAnimationFrame(this.animate_);
    }
  }, i.handleResize_ = function() {
    var r = this.player_.currentWidth(), a = this.player_.currentHeight();
    this.effect.setSize(r, a, !1), this.camera.aspect = r / a, this.camera.updateProjectionMatrix();
  }, i.setProjection = function(r) {
    if (!Td(r)) {
      X.log.error(
        "videojs-vr: please pass a valid projection " + sc.join(", ")
      );
      return;
    }
    this.currentProjection_ = r, this.defaultProjection_ = r;
  }, i.init = function() {
    var r = this;
    if (this.reset(), this.camera = new oi(
      75,
      this.player_.currentWidth() / this.player_.currentHeight(),
      1,
      1e3
    ), this.cameraVector = new H(), (this.currentProjection_ === "360_LR" || this.currentProjection_ === "360_TB" || this.currentProjection_ === "180" || this.currentProjection_ === "EAC_LR") && this.camera.layers.enable(1), this.scene = new Mu(), this.videoTexture = new vc(this.getVideoEl_()), this.videoTexture.generateMipmaps = !1, this.videoTexture.minFilter = Gi, this.videoTexture.magFilter = Gi, this.videoTexture.format = Ha, this.changeProjection_(this.currentProjection_), this.currentProjection_ === "NONE") {
      this.log("Projection is NONE, dont init"), this.reset();
      return;
    }
    this.player_.removeChild("BigPlayButton"), this.player_.addChild("BigVrPlayButton", {}, this.bigPlayButtonIndex_), this.player_.bigPlayButton = this.player_.getChild("BigVrPlayButton"), (this.options_.forceCardboard || X.browser.IS_ANDROID || X.browser.IS_IOS) && this.addCardboardButton_(), X.browser.IS_IOS && this.player_.controlBar && this.player_.controlBar.fullscreenToggle && this.player_.controlBar.fullscreenToggle.hide(), this.camera.position.set(0, 0, 0), this.renderer = new mh({
      alpha: !1,
      antialias: !0,
      clearColor: 16777215,
      devicePixelRatio: W.devicePixelRatio
    });
    var a = this.renderer.getContext("webgl"), s = a.texImage2D;
    a.texImage2D = function() {
      try {
        for (var l = arguments.length, c = new Array(l), h = 0; h < l; h++)
          c[h] = arguments[h];
        return s.apply(a, c);
      } catch (d) {
        throw r.reset(), r.player_.pause(), r.triggerError_({
          code: "web-vr-hls-cors-not-supported",
          dismiss: !1
        }), new Error(d);
      }
    }, this.renderer.setSize(
      this.player_.currentWidth(),
      this.player_.currentHeight(),
      !1
    ), this.effect = new dL(this.renderer), this.effect.setSize(
      this.player_.currentWidth(),
      this.player_.currentHeight(),
      !1
    ), this.vrDisplay = null, this.prevTimestamps_ = [], this.renderedCanvas = this.renderer.domElement, this.renderedCanvas.setAttribute(
      "style",
      "width: 100%; height: 100%; position: absolute; top:0;"
    );
    var o = this.getVideoEl_().style;
    if (this.player_.el().insertBefore(this.renderedCanvas, this.player_.el().firstChild), o.zIndex = "-1", o.opacity = "0", W.navigator.getVRDisplays ? (this.log("is supported, getting vr displays"), W.navigator.getVRDisplays().then(function(l) {
      if (l.length > 0 && (r.log("Displays found", l), r.vrDisplay = l[0], r.vrDisplay.isPolyfilled || (r.log("Real HMD found using VRControls", r.vrDisplay), r.addCardboardButton_(), r.controls3d = new fL(r.camera))), !r.controls3d) {
        r.log("no HMD found Using Orbit & Orientation Controls");
        var c = {
          camera: r.camera,
          canvas: r.renderedCanvas,
          // check if its a half sphere view projection
          halfView: r.currentProjection_ === "180",
          orientation: X.browser.IS_IOS || X.browser.IS_ANDROID || !1
        };
        r.options_.motionControls === !1 && (c.orientation = !1), r.controls3d = new gL(c), r.canvasPlayerControls = new _L(
          r.player_,
          r.renderedCanvas
        );
      }
      r.animationFrameId_ = r.requestAnimationFrame(
        r.animate_
      );
    })) : W.navigator.getVRDevices ? this.triggerError_({
      code: "web-vr-out-of-date",
      dismiss: !1
    }) : this.triggerError_({
      code: "web-vr-not-supported",
      dismiss: !1
    }), this.options_.omnitone) {
      var u = _h.getContext();
      this.omniController = new bL(
        u,
        this.options_.omnitone,
        this.getVideoEl_(),
        this.options_.omnitoneOptions
      ), this.omniController.one("audiocontext-suspended", function() {
        r.player.pause(), r.player.one("playing", function() {
          u.resume();
        });
      });
    }
    this.on(this.player_, "fullscreenchange", this.handleResize_), W.addEventListener(
      "vrdisplaypresentchange",
      this.handleResize_,
      !0
    ), W.addEventListener("resize", this.handleResize_, !0), W.addEventListener(
      "vrdisplayactivate",
      this.handleVrDisplayActivate_,
      !0
    ), W.addEventListener(
      "vrdisplaydeactivate",
      this.handleVrDisplayDeactivate_,
      !0
    ), this.initialized_ = !0, this.trigger("initialized");
  }, i.addCardboardButton_ = function() {
    this.player_.controlBar.getChild("CardboardButton") || this.player_.controlBar.addChild("CardboardButton", {});
  }, i.getVideoEl_ = function() {
    return this.player_.el().getElementsByTagName("video")[0];
  }, i.reset = function() {
    if (this.initialized_) {
      this.omniController && (this.omniController.off("audiocontext-suspended"), this.omniController.dispose(), this.omniController = void 0), this.controls3d && (this.controls3d.dispose(), this.controls3d = null), this.canvasPlayerControls && (this.canvasPlayerControls.dispose(), this.canvasPlayerControls = null), this.effect && (this.effect.dispose(), this.effect = null), W.removeEventListener("resize", this.handleResize_, !0), W.removeEventListener(
        "vrdisplaypresentchange",
        this.handleResize_,
        !0
      ), W.removeEventListener(
        "vrdisplayactivate",
        this.handleVrDisplayActivate_,
        !0
      ), W.removeEventListener(
        "vrdisplaydeactivate",
        this.handleVrDisplayDeactivate_,
        !0
      ), this.player_.getChild("BigPlayButton") || this.player_.addChild("BigPlayButton", {}, this.bigPlayButtonIndex_), this.player_.getChild("BigVrPlayButton") && this.player_.removeChild("BigVrPlayButton"), this.player_.getChild("CardboardButton") && this.player_.controlBar.removeChild("CardboardButton"), X.browser.IS_IOS && this.player_.controlBar && this.player_.controlBar.fullscreenToggle && this.player_.controlBar.fullscreenToggle.show();
      var r = this.getVideoEl_().style;
      r.zIndex = "", r.opacity = "", this.currentProjection_ = this.defaultProjection_, this.iosRevertTouchToClick_ && this.iosRevertTouchToClick_(), this.renderedCanvas && this.renderedCanvas.parentNode.removeChild(this.renderedCanvas), this.animationFrameId_ && this.cancelAnimationFrame(this.animationFrameId_), this.initialized_ = !1;
    }
  }, i.dispose = function() {
    e.prototype.dispose.call(this), this.reset();
  }, i.polyfillVersion = function() {
    return $h.version;
  }, t;
}(SL);
jh.prototype.setTimeout = A1.prototype.setTimeout;
jh.prototype.clearTimeout = A1.prototype.clearTimeout;
jh.VERSION = vL;
X.registerPlugin("vr", jh);
/* ! @name videojs-contrib-quality-levels @version 4.0.0 @license Apache-2.0 */
class CL {
  /**
   * Creates a QualityLevel
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   */
  constructor(t) {
    let i = this;
    return i.id = t.id, i.label = i.id, i.width = t.width, i.height = t.height, i.bitrate = t.bandwidth, i.frameRate = t.frameRate, i.enabled_ = t.enabled, Object.defineProperty(i, "enabled", {
      /**
       * Get whether the QualityLevel is enabled.
       *
       * @return {boolean} True if the QualityLevel is enabled.
       */
      get() {
        return i.enabled_();
      },
      /**
       * Enable or disable the QualityLevel.
       *
       * @param {boolean} enable true to enable QualityLevel, false to disable.
       */
      set(n) {
        i.enabled_(n);
      }
    }), i;
  }
}
class rh extends X.EventTarget {
  /**
   * Creates a QualityLevelList.
   */
  constructor() {
    super();
    let t = this;
    return t.levels_ = [], t.selectedIndex_ = -1, Object.defineProperty(t, "selectedIndex", {
      get() {
        return t.selectedIndex_;
      }
    }), Object.defineProperty(t, "length", {
      get() {
        return t.levels_.length;
      }
    }), t[Symbol.iterator] = () => t.levels_.values(), t;
  }
  /**
   * Adds a quality level to the list.
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   * @return {QualityLevel} the QualityLevel added to the list
   * @method addQualityLevel
   */
  addQualityLevel(t) {
    let i = this.getQualityLevelById(t.id);
    if (i)
      return i;
    const n = this.levels_.length;
    return i = new CL(t), "" + n in this || Object.defineProperty(this, n, {
      get() {
        return this.levels_[n];
      }
    }), this.levels_.push(i), this.trigger({
      qualityLevel: i,
      type: "addqualitylevel"
    }), i;
  }
  /**
   * Removes a quality level from the list.
   *
   * @param {QualityLevel} qualityLevel The QualityLevel to remove from the list.
   * @return {QualityLevel|null} the QualityLevel removed or null if nothing removed
   * @method removeQualityLevel
   */
  removeQualityLevel(t) {
    let i = null;
    for (let n = 0, r = this.length; n < r; n++)
      if (this[n] === t) {
        i = this.levels_.splice(n, 1)[0], this.selectedIndex_ === n ? this.selectedIndex_ = -1 : this.selectedIndex_ > n && this.selectedIndex_--;
        break;
      }
    return i && this.trigger({
      qualityLevel: t,
      type: "removequalitylevel"
    }), i;
  }
  /**
   * Searches for a QualityLevel with the given id.
   *
   * @param {string} id The id of the QualityLevel to find.
   * @return {QualityLevel|null} The QualityLevel with id, or null if not found.
   * @method getQualityLevelById
   */
  getQualityLevelById(t) {
    for (let i = 0, n = this.length; i < n; i++) {
      const r = this[i];
      if (r.id === t)
        return r;
    }
    return null;
  }
  /**
   * Resets the list of QualityLevels to empty
   *
   * @method dispose
   */
  dispose() {
    this.selectedIndex_ = -1, this.levels_.length = 0;
  }
}
rh.prototype.allowedEvents_ = {
  addqualitylevel: "addqualitylevel",
  change: "change",
  removequalitylevel: "removequalitylevel"
};
for (const e in rh.prototype.allowedEvents_)
  rh.prototype["on" + e] = null;
var T1 = "4.0.0";
const ML = function(e) {
  const t = e.qualityLevels, i = new rh(), n = function() {
    i.dispose(), e.qualityLevels = t, e.off("dispose", n);
  };
  return e.on("dispose", n), e.qualityLevels = () => i, e.qualityLevels.VERSION = T1, i;
}, E1 = function(e) {
  return ML(this, X.mergeOptions({}, e));
};
X.registerPlugin("qualityLevels", E1);
E1.VERSION = T1;
const DL = px`
  :host {
    --border-radius: 0px;
    --padding: 0px;
    --error-height: 200px;

    --cx-video-player-fallback-color: #5ebdc4;
    --cx-color-white: #ffffff;

    width: var(--width, auto);
    height: var(--height, auto);
    display: block;
  }

  .container {
    border-radius: var(--border-radius);
    padding: var(--padding, 0px);
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 100%;
  }

  .container--resizing {
    outline: 2px dashed var(--cx-color-primary);
    user-select: none;
  }

  .container--error video-js {
    min-height: var(--error-height);
  }

  #video-js-container {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .seekbar-container {
    position: absolute;
    left: 0;
    width: 100%;
    border-radius: 0;
    right: 0;
    bottom: 2.5em;
  }

  .vjs-unavailable-modal {
    background: rgba(0, 0, 0, 1) !important;
  }

  .vjs-unavailable-modal:before {
    color: var(--cx-color-white);
    content: 'X';
    display: block;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 4em;
    left: 0;
    line-height: 1;
    margin-top: -0.5em;
    position: absolute;
    text-shadow: 0.05em 0.05em 0.1em #000;
    text-align: center;
    top: 50%;
    vertical-align: middle;
    width: 100%;
  }

  .vjs-unavailable-modal .vjs-modal-dialog-content {
    text-align: center;
    font-size: 1.5em !important;
  }
  .vjs-modal-dialog .vjs-modal-dialog-content,
  .video-js .vjs-modal-dialog,
  .vjs-button > .vjs-icon-placeholder:before,
  .video-js .vjs-big-play-button .vjs-icon-placeholder:before {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 40;
  }
  .vjs-button > .vjs-icon-placeholder:before,
  .video-js .vjs-big-play-button .vjs-icon-placeholder:before {
    text-align: center;
  }
  @font-face {
    font-family: VideoJS;
    src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABDkAAsAAAAAG6gAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAPgAAAFZRiV3hY21hcAAAAYQAAADaAAADPv749/pnbHlmAAACYAAAC3AAABHQZg6OcWhlYWQAAA3QAAAAKwAAADYZw251aGhlYQAADfwAAAAdAAAAJA+RCLFobXR4AAAOHAAAABMAAACM744AAGxvY2EAAA4wAAAASAAAAEhF6kqubWF4cAAADngAAAAfAAAAIAE0AIFuYW1lAAAOmAAAASUAAAIK1cf1oHBvc3QAAA/AAAABJAAAAdPExYuNeJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGS7wTiBgZWBgaWQ5RkDA8MvCM0cwxDOeI6BgYmBlZkBKwhIc01hcPjI+FGJHcRdyA4RZgQRADK3CxEAAHic7dFZbsMgAEXRS0ycyZnnOeG7y+qC8pU1dHusIOXxuoxaOlwZYWQB0Aea4quIEN4E9LzKbKjzDeM6H/mua6Lmc/p8yhg0lvdYx15ZG8uOLQOGjMp3EzqmzJizYMmKNRu27Nhz4MiJMxeu3Ljz4Ekqm7T8P52G8PP3lnTOVk++Z6iN6QZzNN1F7ptuN7eGOjDUoaGODHVsuvU8MdTO9Hd5aqgzQ50b6sJQl4a6MtS1oW4MdWuoO0PdG+rBUI+GejLUs6FeDPVqqDdDvRvqw1CfhpqM9At0iFLaAAB4nJ1YDXBTVRZ+5/22TUlJ8we0pHlJm7RJf5O8F2j6EymlSPkpxaL8U2xpa3DKj0CBhc2IW4eWKSokIoLsuMqssM64f+jA4HSdWXXXscBq67IOs3FXZ1ZYWVyRFdo899yXtIBQZ90k7717zz3v3HPPOfd854YCCj9cL9dL0RQFOqCbGJnrHb5EayiKIWN8iA/hWBblo6hUWm8TtCDwE80WMJus/irwyxOdxeB0MDb14VNJHnXYoLLSl6FfCUYO9nYPTA8Epg9090LprfbBbZ2hY0UlJUXHQp3/vtWkS6EBv8+rPMq5u9692f/dNxJNiqwC1xPE9TCUgCsSdQWgE3XQD25lkG4CN2xmTcOXWBOyser6RN6KnGbKSbmQ3+d0OI1m2W8QzLLkI2sykrWAgJJEtA8vGGW/2Q+CmT3n8zS9wZwu2DCvtuZKZN3xkrLh36yCZuUomQSqGpY8t/25VfHVhw8z4ebGBtfLb0ya9PCaDc+8dGTvk2dsh6z7WzvowlXKUSWo9MJ15a3KrEP2loOr2Ojhw6iW6hf2BDdEccQvZGpaAy7YovSwq8kr7HGllxpd71rkS6G0Sf11sl9OvMK1+jwPPODxjUwkOim9CU3ix1wNjXDfmJSEn618Bs6lpWwUpU+8PCqLMY650zjq8VhCIP17NEKTx3eaLL+s5Pi6yJWaWjTHLR1jYzPSV9VF/6Ojdb/1kO3Mk3uhHC0x6gc1BjlKQ+nQFxTYdaJkZ7ySVxLBbhR1dsboNXp1tCYKW2LRaEzpYcIx2BKNxaL0ZaUnSqfFoiNhHKR/GkX6PWUSAaJelQaqZL1EpoHNsajSEyPSoJ9IjhIxTdjHLmwZvhRDOiFTY/YeQnvrVZmiTQtGncECXtFTBZLOVwwMRgoXHAkXzMzPn1nAJJ8jYSbMDaqN2waGLzNhih/bZynUBMpIWSg7VYi7DRx2m8ALkIdRCJwI6ArJx2EI8kaDWeTQKeAFk9fjl/1AvwktjQ1P7NjyMGQyfd4vjipX6M/i52D7Cq80kqlcxEcGXRr/FEcgs0u5uGgB4VWuMFfpdn2Re6Hi3PqzmxWKsz6+ae2Pn9hXXw/fqM859UiGC0oKYYILJBqJrsn1Z1E5qOs9rQCiUQRREjm8yJcbHF5cUJufX1vAHlefw0XgUoboS3ETfQlTxBC4SOtuE8VPRJTBSCQSjZCpk7Gqzu+masaZ2y7Zjehho4F3g82BNDkAHpORG4+OCS+f6JTPmtRn/PH1kch6d04sp7AQb25aQ/pqUyXeQ8vrebG8OYQdXOQ+585u0sdW9rqalzRURiJ+9F4MweRFrKUjl1GUYhH1A27WOHw5cTFSFPMo9EeUIGnQTZHIaJ7AHLaOKsOODaNF9jkBjYG2QEsQ2xjMUAx2bBEbeTBWMHwskBjngq56S/yfgkBnWBa4K9sqKtq2t1UI8S9He5XuBRbawAdatrQEAi30Aks2+LM8WeCbalVZkWNylvJ+dqJnzVb+OHlSoKW8nPCP7Rd+CcZ2DdWAGqJ2CBFOphgywFFCFBNtfAbGtNPBCwxvygHeYMZMY9ZboBqwq/pVrsbgN5tkv152ODlbMfiqwGMBgxa4Exz3QhovRIUp6acqZmQzRq0ypDXS2TPLT02YIkQETnOE445oOGxOmXAqUJNNG7XgupMjPq2ua9asrj5yY/yuKteO1Kx0YNJTufrirLe1mZnat7OL6rnUdCWenpW6I8mAnbsY8KWs1PuSovCW9A/Z25PQ24a7cNOqgmTkLmBMgh4THgc4b9k2IVv1/g/F5nGljwPLfOgHAzJzh45V/4+WenTzmMtR5Z7us2Tys909UHqrPY7KbckoxRvRHhmVc3cJGE97uml0R1S0jdULVl7EvZtDFVBF35N9cEdjpgmAiOlFZ+Dtoh93+D3zzHr8RRNZQhnCNMNbcegOvpEwZoL+06cJQ07h+th3fZ/7PVbVC6ngTAV/KoLFuO6+2KFcU651gEb5ugPSIb1D+Xp8V4+k3sEIGnw5mYe4If4k1lFYr6SCzmM2EQ8iWtmwjnBI9kTwe1TlfAmXh7H02by9fW2gsjKwtv0aaURKil4OdV7rDL1MXIFNrhdxohcZXYTnq47WisrKitaObbf5+yvkLi5J6lCNZZ+B6GC38VNBZBDidSS/+mSvh6s+srgC8pyKMvDtt+de3c9fU76ZPfuM8ud4Kv0fyP/LqfepMT/3oZxSqpZaTa1DaQYLY8TFsHYbWYsPoRhRWfL5eSSQbhUGgGC3YLbVMk6PitTFNGpAsNrC6D1VNBKgBHMejaiuRWEWGgsSDBTJjqWIl8kJLlsaLJ2tXDr6xGfT85bM2Q06a46x2HTgvdnV8z5YDy/27J4zt6x2VtkzjoYpkq36kaBr4eQSg7tyiVweWubXZugtadl58ydapfbORfKsDTuZ0OBgx4cfdjCf5tbWNITnL120fdOi1RV1C3uKGzNdwYLcMvZ3BxoPyTOCD1XvXTp7U10gWCVmTV9b3r2z0SkGWovb2hp9I89O8a2smlyaO8muMU+dRmtzp60IzAoFpjLr1n388boLyf0dRvxhsHZ0qbWqDkwqvvpkj4l0fY6EIXRi5sQSrAvsVYwXRy4qJ2EVtD1AN7a0HWth9ymvL1xc3WTUKK/TAHA/bXDVtVWfOMfuGxGZv4Ln/jVr9jc3j1yMv0tndmyt9Vq88Y9gH1wtLX3KWjot5++jWHgAoZZkQ14wGQ20Fli71UmKJAy4xKMSTGbVdybW7FDDAut9XpD5AzWrYO7zQ8qffqF8+Ynd/clrHcdyxGy3a/3+mfNnzC/cBsveTjnTvXf1o6vzOlZw7WtqtdmPK/Errz/6NNtD72zmNOZfbmYdTGHfoofqI79Oc+R2n1lrnL6pOm0Up7kwxhTW12Amm7WYkXR2qYrF2AmgmbAsxZjwy1xpg/m1Je2vrp8v/nz2xpmlBg4E9hrMU341wVpTOh/OfmGvAnra8q6uctr60ZQHV3Q+WMQJykMj8ZsWn2QBOmmHMB+m5pDIpTFonYigiaKAhGEiAHF7EliVnQkjoLVIMPtJpBKHYd3A8GYH9jJzrWwmHx5Qjp7vDAX0suGRym1vtm/9W1/HyR8vczfMs6Sk8DSv855/5dlX9oQq52hT8syyp2rx5Id17IAyAM3wIjQPMOHzytEB64q6D5zT91yNbnx3V/nqnd017S9Y0605k3izoXLpsxde2n38yoOV9s1LcjwzNjbdX6asnBVaBj/6/DwKwPkpcqbDG7BnsXoSqWnUAmottYF6jMSdVyYZh3zVXCjwTiwwHH6sGuRiEHQGzuRX6whZkp123oy1BWE2mEfJ/tvIRtM4ZM5bDXiMsPMaAKOTyc5uL57rqyyc5y5JE5pm1i2S2iUX0CcaQ6lC6Zog7JqSqZmYlosl2K6pwNA84zRnQW6SaALYZQGW5lhCtU/W34N6o+bKfZ8cf3/Cl/+iTX3wBzpOY4mRkeNf3rptycGSshQWgGbYt5jFc2e0+DglIrwl6DVWQ7BuwaJ3Xk1J4VL5urnLl/Wf+gHU/hZoZdKNym6lG+I34FaNeZKcSpJIo2IeCVvpdsDGfKvzJnAwmeD37Ow65ZWwSowpgwX5T69s/rB55dP5BcpgDKFV8p7q2sn/1uc93bVzT/w6UrCqDTWvfCq/oCD/qZXNoUj8BL5Kp6GU017frfNXkAtiiyf/SOCEeLqnd8R/Ql9GlCRfctS6k5chvIBuQ1zCCjoCHL2DHNHIXxMJ3kQeO8lbsUXONeSfA5EjcG6/E+KdhN4bP04vBhdi883+BFBzQbxFbvZzQeY9LNBZc0FNfn5NwfDn6rCTnTw6R8o+gfpf5hCom33cRuiTlss3KHmZjD+BPN+5gXuA2ziS/Q73mLxUkpbKN/eqwz5uK0X9F3h2d1V4nGNgZGBgAOJd776+iue3+crAzc4AAje5Bfcg0xz9YHEOBiYQBQA8FQlFAHicY2BkYGBnAAGOPgaG//85+hkYGVCBMgBGGwNYAAAAeJxjYGBgYB8EmKOPgQEAQ04BfgAAAAAAAA4AaAB+AMwA4AECAUIBbAGYAcICGAJYArQC4AMwA7AD3gQwBJYE3AUkBWYFigYgBmYGtAbqB1gIEghYCG4IhAi2COh4nGNgZGBgUGYoZWBnAAEmIOYCQgaG/2A+AwAYCQG2AHicXZBNaoNAGIZfE5PQCKFQ2lUps2oXBfOzzAESyDKBQJdGR2NQR3QSSE/QE/QEPUUPUHqsvsrXjTMw83zPvPMNCuAWP3DQDAejdm1GjzwS7pMmwi75XngAD4/CQ/oX4TFe4Qt7uMMbOzjuDc0EmXCP/C7cJ38Iu+RP4QEe8CU8pP8WHmOPX2EPz87TPo202ey2OjlnQSXV/6arOjWFmvszMWtd6CqwOlKHq6ovycLaWMWVydXKFFZnmVFlZU46tP7R2nI5ncbi/dDkfDtFBA2DDXbYkhKc+V0Bqs5Zt9JM1HQGBRTm/EezTmZNKtpcAMs9Yu6AK9caF76zoLWIWcfMGOSkVduvSWechqZsz040Ib2PY3urxBJTzriT95lipz+TN1fmAAAAeJxtkMl2wjAMRfOAhABlKm2h80C3+ajgCKKDY6cegP59TYBzukAL+z1Zsq8ctaJTTKPrsUQLbXQQI0EXKXroY4AbDDHCGBNMcYsZ7nCPB8yxwCOe8IwXvOIN7/jAJ76wxHfUqWX+OzgumWAjJMV17i0Ndlr6irLKO+qftdT7i6y4uFSUvCknay+lFYZIZaQcmfH/xIFdYn98bqhra1aKTM/6lWMnyaYirx1rFUQZFBkb2zJUtoXeJCeg0WnLtHeSFc3OtrnozNwqi0TkSpBMDB1nSde5oJXW23hTS2/T0LilglXX7dmFVxLnq5U0vYATHFk3zX3BOisoQHNDFDeZnqKDy9hRNawN7Vh727hFzcJ5c8TILrKZfH7tIPxAFP0BpLeJPA==)
      format('woff');
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-play,
  .video-js .vjs-play-control .vjs-icon-placeholder,
  .video-js .vjs-big-play-button .vjs-icon-placeholder:before {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-play:before,
  .video-js .vjs-play-control .vjs-icon-placeholder:before,
  .video-js .vjs-big-play-button .vjs-icon-placeholder:before {
    content: '\\f101';
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .vjs-icon-play-circle {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-play-circle:before {
    content: '\\f102';
  }
  .vjs-icon-pause,
  .video-js .vjs-play-control.vjs-playing .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-pause:before,
  .video-js .vjs-play-control.vjs-playing .vjs-icon-placeholder:before {
    content: '\\f103';
  }
  .vjs-icon-volume-mute,
  .video-js .vjs-mute-control.vjs-vol-0 .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-volume-mute:before,
  .video-js .vjs-mute-control.vjs-vol-0 .vjs-icon-placeholder:before {
    content: '\\f104';
  }
  .vjs-icon-volume-low,
  .video-js .vjs-mute-control.vjs-vol-1 .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-volume-low:before,
  .video-js .vjs-mute-control.vjs-vol-1 .vjs-icon-placeholder:before {
    content: '\\f105';
  }
  .vjs-icon-volume-mid,
  .video-js .vjs-mute-control.vjs-vol-2 .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-volume-mid:before,
  .video-js .vjs-mute-control.vjs-vol-2 .vjs-icon-placeholder:before {
    content: '\\f106';
  }
  .vjs-icon-volume-high,
  .video-js .vjs-mute-control .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-volume-high:before,
  .video-js .vjs-mute-control .vjs-icon-placeholder:before {
    content: '\\f107';
  }
  .vjs-icon-fullscreen-enter,
  .video-js .vjs-fullscreen-control .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-fullscreen-enter:before,
  .video-js .vjs-fullscreen-control .vjs-icon-placeholder:before {
    content: '\\f108';
  }
  .vjs-icon-fullscreen-exit,
  .video-js.vjs-fullscreen .vjs-fullscreen-control .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-fullscreen-exit:before,
  .video-js.vjs-fullscreen
    .vjs-fullscreen-control
    .vjs-icon-placeholder:before {
    content: '\\f109';
  }
  .vjs-icon-square {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-square:before {
    content: '\\f10a';
  }
  .vjs-icon-spinner {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-spinner:before {
    content: '\\f10b';
  }
  .vjs-icon-subtitles,
  .video-js .vjs-subs-caps-button .vjs-icon-placeholder,
  .video-js.video-js:lang(en-GB) .vjs-subs-caps-button .vjs-icon-placeholder,
  .video-js.video-js:lang(en-IE) .vjs-subs-caps-button .vjs-icon-placeholder,
  .video-js.video-js:lang(en-AU) .vjs-subs-caps-button .vjs-icon-placeholder,
  .video-js.video-js:lang(en-NZ) .vjs-subs-caps-button .vjs-icon-placeholder,
  .video-js .vjs-subtitles-button .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-subtitles:before,
  .video-js .vjs-subs-caps-button .vjs-icon-placeholder:before,
  .video-js.video-js:lang(en-GB)
    .vjs-subs-caps-button
    .vjs-icon-placeholder:before,
  .video-js.video-js:lang(en-IE)
    .vjs-subs-caps-button
    .vjs-icon-placeholder:before,
  .video-js.video-js:lang(en-AU)
    .vjs-subs-caps-button
    .vjs-icon-placeholder:before,
  .video-js.video-js:lang(en-NZ)
    .vjs-subs-caps-button
    .vjs-icon-placeholder:before,
  .video-js .vjs-subtitles-button .vjs-icon-placeholder:before {
    content: '\\f10c';
  }
  .vjs-icon-captions,
  .video-js:lang(en) .vjs-subs-caps-button .vjs-icon-placeholder,
  .video-js:lang(fr-CA) .vjs-subs-caps-button .vjs-icon-placeholder,
  .video-js .vjs-captions-button .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-captions:before,
  .video-js:lang(en) .vjs-subs-caps-button .vjs-icon-placeholder:before,
  .video-js:lang(fr-CA) .vjs-subs-caps-button .vjs-icon-placeholder:before,
  .video-js .vjs-captions-button .vjs-icon-placeholder:before {
    content: '\\f10d';
    color: var(--cx-color-white);
  }
  .vjs-icon-chapters,
  .video-js .vjs-chapters-button .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-chapters:before,
  .video-js .vjs-chapters-button .vjs-icon-placeholder:before {
    content: '\\f10e';
  }
  .vjs-icon-share {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-share:before {
    content: '\\f10f';
  }
  .vjs-icon-cog,
  .vjs-icon-cog .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .video-js .vjs-icon-cog:before {
    content: none;
  }
  .vjs-icon-cog .vjs-icon-placeholder:before {
    content: '\\f110';
  }
  .vjs-icon-circle,
  .vjs-seek-to-live-control .vjs-icon-placeholder,
  .video-js .vjs-volume-level,
  .video-js .vjs-play-progress {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-circle:before,
  .vjs-seek-to-live-control .vjs-icon-placeholder:before,
  .video-js .vjs-volume-level:before,
  .video-js .vjs-play-progress:before {
    content: '\\f111';
  }
  .vjs-icon-circle-outline {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-circle-outline:before {
    content: '\\f112';
  }
  .vjs-icon-circle-inner-circle {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-circle-inner-circle:before {
    content: '\\f113';
  }
  .vjs-icon-hd {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-hd:before {
    content: '\\f114';
  }
  .vjs-icon-cancel,
  .video-js .vjs-control.vjs-close-button .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-cancel:before,
  .video-js .vjs-control.vjs-close-button .vjs-icon-placeholder:before {
    content: '\\f115';
  }
  .vjs-icon-replay,
  .video-js .vjs-play-control.vjs-ended .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-replay:before,
  .video-js .vjs-play-control.vjs-ended .vjs-icon-placeholder:before {
    content: '\\f116';
  }
  .vjs-icon-facebook {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-facebook:before {
    content: '\\f117';
  }
  .vjs-icon-gplus {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-gplus:before {
    content: '\\f118';
  }
  .vjs-icon-linkedin {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-linkedin:before {
    content: '\\f119';
  }
  .vjs-icon-twitter {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-twitter:before {
    content: '\\f11a';
  }
  .vjs-icon-tumblr {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-tumblr:before {
    content: '\\f11b';
  }
  .vjs-icon-pinterest {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-pinterest:before {
    content: '\\f11c';
  }
  .vjs-icon-audio-description,
  .video-js .vjs-descriptions-button .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-audio-description:before,
  .video-js .vjs-descriptions-button .vjs-icon-placeholder:before {
    content: '\\f11d';
  }
  .vjs-icon-audio,
  .video-js .vjs-audio-button .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-audio:before,
  .video-js .vjs-audio-button .vjs-icon-placeholder:before {
    content: '\\f11e';
  }
  .vjs-icon-next-item {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-next-item:before {
    content: '\\f11f';
  }
  .vjs-icon-previous-item {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-previous-item:before {
    content: '\\f120';
  }
  .vjs-icon-picture-in-picture-enter,
  .video-js .vjs-picture-in-picture-control .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-picture-in-picture-enter:before,
  .video-js .vjs-picture-in-picture-control .vjs-icon-placeholder:before {
    content: '\\f121';
  }
  .vjs-icon-picture-in-picture-exit,
  .video-js.vjs-picture-in-picture
    .vjs-picture-in-picture-control
    .vjs-icon-placeholder {
    font-family: VideoJS;
    font-weight: normal;
    font-style: normal;
  }
  .vjs-icon-picture-in-picture-exit:before,
  .video-js.vjs-picture-in-picture
    .vjs-picture-in-picture-control
    .vjs-icon-placeholder:before {
    content: '\\f122';
  }
  .video-js {
    display: block;
    vertical-align: top;
    box-sizing: border-box;
    color: var(--cx-color-white);
    position: relative;
    padding: 0;
    font-size: 12px;
    line-height: 1;
    font-weight: normal;
    font-style: normal;
    font-family: 'Fira Sans', Arial, Helvetica, sans-serif;
    word-break: initial;
    background-color: var(--cx-color-neutral-0);
    --menu-background: var(--cx-panel-background-color);
    --menu-color: var(--cx-color-neutral);
  }
  .video-js.vjs-fullscreen {
    font-size: var(--cx-font-size-large);
  }
  .video-js.vjs-fullscreen cx-tooltip {
    --cx-tooltip-font-size: var(--cx-font-size-large);
  }
  .video-js:-moz-full-screen {
    position: absolute;
  }
  .video-js:-webkit-full-screen {
    width: 100% !important;
    height: 100% !important;
  }
  .video-js[tabindex='-1'] {
    outline: none;
  }
  .video-js ul {
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
    list-style-position: outside;
    margin-left: 0;
    margin-right: 0;
    margin-top: 0;
    margin-bottom: 0;
  }
  .video-js.vjs-fluid,
  .video-js.vjs-16-9,
  .video-js.vjs-4-3,
  .video-js.vjs-9-16,
  .video-js.vjs-1-1 {
    width: 100%;
    max-width: 100%;
  }
  .video-js.vjs-fluid:not(.vjs-audio-only-mode),
  .video-js.vjs-16-9:not(.vjs-audio-only-mode),
  .video-js.vjs-4-3:not(.vjs-audio-only-mode),
  .video-js.vjs-9-16:not(.vjs-audio-only-mode),
  .video-js.vjs-1-1:not(.vjs-audio-only-mode) {
    height: 0;
  }
  .video-js.vjs-16-9:not(.vjs-audio-only-mode) {
    padding-top: 56.25%;
  }
  .video-js.vjs-4-3:not(.vjs-audio-only-mode) {
    padding-top: 75%;
  }
  .video-js.vjs-9-16:not(.vjs-audio-only-mode) {
    padding-top: 177.7777777778%;
  }
  .video-js.vjs-1-1:not(.vjs-audio-only-mode) {
    padding-top: 100%;
  }
  .video-js.vjs-fill:not(.vjs-audio-only-mode) {
    width: 100%;
    height: 100%;
  }
  .video-js .vjs-tech {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  .video-js.vjs-audio-only-mode .vjs-tech {
    display: none;
  }
  body.vjs-full-window {
    padding: 0;
    margin: 0;
    height: 100%;
  }
  .vjs-full-window .video-js.vjs-fullscreen {
    position: fixed;
    overflow: hidden;
    z-index: 1000;
    left: 0;
    top: 0;
    bottom: 0;
    right: 0;
  }
  .video-js.vjs-fullscreen:not(.vjs-ios-native-fs) {
    width: 100% !important;
    height: 100% !important;
    padding-top: 0 !important;
  }
  .video-js.vjs-fullscreen.vjs-user-inactive {
    cursor: none;
  }
  .vjs-hidden {
    display: none !important;
  }
  .vjs-disabled {
    opacity: 0.5;
    cursor: default;
  }
  .video-js .vjs-offscreen {
    height: 1px;
    left: -9999px;
    position: absolute;
    top: 0;
    width: 1px;
  }
  .vjs-lock-showing {
    display: block !important;
    opacity: 1 !important;
    visibility: visible !important;
  }
  .vjs-no-js {
    padding: 20px;
    color: var(--cx-color-white);
    background-color: #000;
    font-size: 18px;
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
    width: 300px;
    height: 150px;
    margin: 0px auto;
  }
  .vjs-no-js a,
  .vjs-no-js a:visited {
    color: #66a8cc;
  }
  .video-js .vjs-big-play-button {
    font-size: 2.6em;
    line-height: 1.3em;
    width: 2em;
    height: 2em;
    aspect-ratio: 1/1;
    display: block;
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 0;
    cursor: pointer;
    opacity: 1;
    border: 0.06666em solid var(--cx-color-white);
    background-color: rgba(43, 51, 63, 0.7);
    border-radius: 100%;
    color: var(--cx-color-white);
    transition: all 0.4s;
  }
  .vjs-big-play-centered .vjs-big-play-button {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    margin-left: 0;
    margin-top: 0;
  }
  .video-js:hover .vjs-big-play-button,
  .video-js .vjs-big-play-button:focus {
    border-color: var(--cx-color-white);
    background-color: rgba(115, 133, 159, 0.5);
    transition: all 0s;
  }
  .vjs-controls-disabled .vjs-big-play-button,
  .vjs-has-started .vjs-big-play-button,
  .vjs-using-native-controls .vjs-big-play-button,
  .vjs-error .vjs-big-play-button {
    display: none;
  }
  .video-js.vjs-has-started.vjs-paused .vjs-big-play-button {
    display: block !important;
  }
  video-js.vjs-mini-player .vjs-big-play-button {
    opacity: 0;
    visibility: hidden;
  }
  video-js.vjs-mini-player .vjs-poster {
    display: none !important;
  }
  .video-js .vjs-button {
    background: none;
    border: none;
    color: inherit;
    display: inline-block;
    font-size: inherit;
    line-height: inherit;
    text-transform: none;
    text-decoration: none;
    transition: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }
  .vjs-control .vjs-button {
    width: 100%;
    height: 100%;
  }
  .video-js .vjs-control.vjs-close-button {
    cursor: pointer;
    height: 2.5em;
    position: absolute;
    right: 0;
    top: 0.5em;
    z-index: 40;
  }
  .video-js .vjs-modal-dialog {
    background: linear-gradient(
      180deg,
      rgba(0, 0, 0, 0.8),
      rgba(255, 255, 255, 0)
    );
    overflow: auto;
  }
  .video-js .vjs-modal-dialog > * {
    box-sizing: border-box;
  }
  .vjs-modal-dialog .vjs-modal-dialog-content {
    font-size: 1.2em;
    line-height: 1.5;
    padding: 20px 24px;
    z-index: 3;
  }
  .vjs-menu-button {
    cursor: pointer;
  }
  .vjs-button:not(.vjs-disabled):hover .vjs-icon-placeholder::before,
  .vjs-button:not(.vjs-disabled):has(.vjs-lock-showing)
    .vjs-icon-placeholder::before {
    color: var(--cx-video-player, var(--cx-video-player-fallback-color));
  }
  .vjs-menu-button.vjs-disabled {
    cursor: default;
  }
  .vjs-workinghover .vjs-menu-button.vjs-disabled:hover .vjs-menu {
    display: none;
  }
  .vjs-menu .vjs-menu-content {
    display: block;
    padding: 0;
    margin: 0;
    font-family: Arial, Helvetica, sans-serif;
    overflow: auto;
  }
  .vjs-menu .vjs-menu-content > * {
    box-sizing: border-box;
  }
  .vjs-scrubbing .vjs-control.vjs-menu-button:hover .vjs-menu {
    display: none;
  }
  .vjs-menu li {
    list-style: none;
    margin: 0;
    padding: 0.2em 0.4em;
    line-height: 1.4em;
    font-size: 1em;
    text-align: center;
    text-transform: none !important;
  }
  .vjs-menu-item {
    overflow-wrap: break-word;
  }
  .vjs-menu li.vjs-menu-item:focus {
    background-color: rgba(115, 133, 159, 0.5);
  }
  .vjs-menu li.vjs-selected:focus,
  .vjs-menu li.vjs-selected:hover,
  .js-focus-visible .vjs-menu li.vjs-selected:hover {
    background-color: var(--cx-color-white);
    color: #2b333f;
  }
  .video-js .vjs-menu *:not(.vjs-selected):focus:not(:focus-visible),
  .js-focus-visible .vjs-menu *:not(.vjs-selected):focus:not(.focus-visible) {
    background: none;
  }
  .vjs-menu li.vjs-menu-title {
    text-align: center;
    text-transform: uppercase;
    font-size: 1em;
    line-height: 2em;
    padding: 0;
    margin: 0 0 0.3em 0;
    font-weight: bold;
    cursor: default;
  }
  .vjs-menu-button-popup .vjs-menu {
    display: none;
    position: absolute;
    bottom: 0;
    width: 10em;
    left: -3em;
    height: 0em;
    margin-bottom: 1.5em;
    border-top-color: rgba(43, 51, 63, 0.7);
  }
  .vjs-menu-button-popup .vjs-menu .vjs-menu-content {
    background-color: rgba(43, 51, 63, 0.7);
    position: absolute;
    width: 100%;
    bottom: 1.5em;
    max-height: calc(472px - 3.7em);
  }
  .vjs-layout-tiny .vjs-menu-button-popup .vjs-menu .vjs-menu-content,
  .vjs-layout-x-small .vjs-menu-button-popup .vjs-menu .vjs-menu-content {
    max-height: 100px;
    overflow-y: auto;
  }
  .vjs-layout-small .vjs-menu-button-popup .vjs-menu .vjs-menu-content {
    max-height: 100px;
    overflow-y: auto;
  }
  .vjs-layout-medium .vjs-menu-button-popup .vjs-menu .vjs-menu-content {
    max-height: 150px;
    overflow-y: auto;
  }
  .vjs-layout-large .vjs-menu-button-popup .vjs-menu .vjs-menu-content,
  .vjs-layout-x-large .vjs-menu-button-popup .vjs-menu .vjs-menu-content,
  .vjs-layout-huge .vjs-menu-button-popup .vjs-menu .vjs-menu-content {
    max-height: calc(472px - 3.7em);
    overflow-y: auto;
  }
  .vjs-menu-button-popup .vjs-menu.vjs-lock-showing {
    display: block;
  }
  .vjs-workinghover .vjs-menu-button-popup.vjs-hover .vjs-menu {
    display: none;
  }
  .video-js .vjs-menu-button-inline {
    transition: all 0.4s;
    overflow: hidden;
  }
  .video-js .vjs-menu-button-inline:before {
    width: 2.222222222em;
  }
  .video-js .vjs-menu-button-inline:hover,
  .video-js .vjs-menu-button-inline:focus,
  .video-js .vjs-menu-button-inline.vjs-slider-active,
  .video-js.vjs-no-flex .vjs-menu-button-inline {
    width: 12em;
  }
  .vjs-menu-button-inline .vjs-menu {
    opacity: 0;
    height: 100%;
    width: auto;
    position: absolute;
    left: 4em;
    top: 0;
    padding: 0;
    margin: 0;
    transition: all 0.4s;
  }
  .vjs-menu-button-inline:hover .vjs-menu,
  .vjs-menu-button-inline:focus .vjs-menu,
  .vjs-menu-button-inline.vjs-slider-active .vjs-menu {
    display: block;
    opacity: 1;
  }
  .vjs-no-flex .vjs-menu-button-inline .vjs-menu {
    display: block;
    opacity: 1;
    position: relative;
    width: auto;
  }
  .vjs-no-flex .vjs-menu-button-inline:hover .vjs-menu,
  .vjs-no-flex .vjs-menu-button-inline:focus .vjs-menu,
  .vjs-no-flex .vjs-menu-button-inline.vjs-slider-active .vjs-menu {
    width: auto;
  }
  .vjs-menu-button-inline .vjs-menu-content {
    width: auto;
    height: 100%;
    margin: 0;
    overflow: hidden;
  }
  .video-js .vjs-control-bar {
    width: 100%;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2.5em;
    background-color: rgba(43, 51, 63, 0.7);
    display: none;
    visibility: hidden;
  }
  .vjs-has-started .vjs-control-bar,
  .vjs-audio-only-mode .vjs-control-bar {
    display: flex;
    opacity: 1;
    transition:
      visibility 0.1s,
      opacity 0.1s;
  }
  .vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar {
    visibility: visible;
    opacity: 0;
    pointer-events: none;
    transition:
      visibility 1s,
      opacity 1s;
  }
  .vjs-controls-disabled .vjs-control-bar,
  .vjs-using-native-controls .vjs-control-bar,
  .vjs-error .vjs-control-bar {
    display: none !important;
  }

  .vjs-audio.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar,
  .vjs-audio-only-mode.vjs-has-started.vjs-user-inactive.vjs-playing
    .vjs-control-bar {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }
  .vjs-has-started.vjs-no-flex .vjs-control-bar {
    display: table;
  }
  .video-js .vjs-control {
    position: relative;
    text-align: center;
    margin: 0;
    padding: 0;
    height: 100%;
    width: 2.5em;
    flex: none;
  }
  .video-js .vjs-control.vjs-visible-text {
    width: auto;
    padding-left: 1em;
    padding-right: 1em;
  }
  .vjs-button > .vjs-icon-placeholder:before {
    font-size: 1.5em;
    line-height: 1.67;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .vjs-button > .vjs-icon-placeholder {
    display: block;
  }
  .video-js .vjs-control:focus:before,
  .video-js .vjs-control:hover:before,
  .video-js .vjs-control:focus {
    text-shadow: 0em 0em 1em white;
  }
  .video-js *:not(.vjs-visible-text) > .vjs-control-text {
    border: 0;
    clip: rect(0 0 0 0);
    height: 1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
  }
  .vjs-no-flex .vjs-control {
    display: table-cell;
    vertical-align: middle;
  }
  .video-js .vjs-custom-control-spacer {
    display: none;
  }
  .video-js .vjs-progress-control {
    cursor: pointer;
    flex: auto;
    display: flex;
    align-items: center;
    min-width: 4em;
    touch-action: none;
  }
  .video-js .vjs-progress-control.disabled {
    cursor: default;
  }
  .vjs-live .vjs-progress-control {
    display: none;
  }
  .vjs-liveui .vjs-progress-control {
    display: flex;
    align-items: center;
  }
  .vjs-no-flex .vjs-progress-control {
    width: auto;
  }
  .video-js .vjs-progress-holder {
    flex: auto;
    transition: all 0.2s;
    height: 0.3em;
  }
  .video-js .vjs-progress-control .vjs-progress-holder {
    margin: 0 10px;
  }
  .video-js .vjs-progress-control:hover .vjs-progress-holder {
    font-size: 1.6666666667em;
  }
  .video-js .vjs-progress-control:hover .vjs-progress-holder.disabled {
    font-size: 1em;
  }
  .video-js .vjs-progress-holder .vjs-play-progress,
  .video-js .vjs-progress-holder .vjs-load-progress,
  .video-js .vjs-progress-holder .vjs-load-progress div {
    position: absolute;
    display: block;
    height: 100%;
    margin: 0;
    padding: 0;
    width: 0;
  }
  .video-js .vjs-play-progress {
    background-color: var(--cx-color-white);
  }
  .video-js .vjs-play-progress:before {
    font-size: 0.9em;
    position: absolute;
    right: -0.5em;
    top: -0.3333333333em;
    z-index: 1;
  }
  .video-js .vjs-load-progress {
    background: rgba(115, 133, 159, 0.5);
  }
  .video-js .vjs-load-progress div {
    background: rgba(115, 133, 159, 0.75);
  }
  .video-js .vjs-time-tooltip {
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 0.3em;
    color: #000;
    css-float: right;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 1em;
    padding: 6px 8px 8px 8px;
    pointer-events: none;
    position: absolute;
    top: -3.4em;
    visibility: hidden;
    z-index: 1;
  }
  .video-js .vjs-progress-holder:focus .vjs-time-tooltip {
    display: none;
  }
  .video-js .vjs-progress-control:hover .vjs-time-tooltip,
  .video-js
    .vjs-progress-control:hover
    .vjs-progress-holder:focus
    .vjs-time-tooltip {
    display: block;
    font-size: 0.6em;
    visibility: visible;
  }
  .video-js .vjs-progress-control.disabled:hover .vjs-time-tooltip {
    font-size: 1em;
  }
  .video-js .vjs-progress-control .vjs-mouse-display {
    display: none;
    position: absolute;
    width: 1px;
    height: 100%;
    background-color: #000;
    z-index: 10;
  }
  .vjs-no-flex .vjs-progress-control .vjs-mouse-display {
    z-index: 0;
  }
  .video-js .vjs-progress-control:hover .vjs-mouse-display {
    display: block;
  }
  .video-js.vjs-user-inactive .vjs-progress-control .vjs-mouse-display {
    visibility: hidden;
    opacity: 0;
    transition:
      visibility 1s,
      opacity 1s;
  }

  .video-js.vjs-user-inactive.vjs-no-flex
    .vjs-progress-control
    .vjs-mouse-display {
    display: none;
  }
  .vjs-mouse-display .vjs-time-tooltip {
    color: var(--cx-color-white);
    background-color: rgba(0, 0, 0, 0.8);
  }
  .video-js .vjs-slider {
    position: relative;
    cursor: pointer;
    padding: 0;
    margin: 0 0.45em 0 0.45em;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    background-color: transparent;
  }
  .video-js .vjs-slider.disabled {
    cursor: default;
  }
  .video-js .vjs-slider:focus {
    text-shadow: 0em 0em 1em white;
    box-shadow: 0 0 1em var(--cx-color-white);
  }
  .video-js .vjs-slider:after {
    content: '';
    display: block;
    position: absolute;
    width: 100%;
    height: 4px;
    background-color: rgba(115, 133, 159, 0.5);
    top: 50%;
    left: 0;
    transform: translateY(-50%);
    z-index: -1;
  }
  .video-js .vjs-mute-control {
    cursor: pointer;
    flex: none;
  }
  .video-js .vjs-volume-control {
    cursor: pointer;
    margin-right: 1em;
    display: flex;
  }
  .video-js .vjs-volume-control.vjs-volume-horizontal {
    width: 5em;
  }
  .video-js .vjs-volume-panel .vjs-volume-control {
    visibility: visible;
    opacity: 0;
    width: 1px;
    height: 1px;
    margin-left: -1px;
  }
  .video-js .vjs-volume-panel {
    transition: width 1s;
    display: flex;
  }
  .video-js .vjs-volume-panel.vjs-hover .vjs-volume-control,
  .video-js .vjs-volume-panel:active .vjs-volume-control,
  .video-js .vjs-volume-panel:focus .vjs-volume-control,
  .video-js .vjs-volume-panel .vjs-volume-control:active,
  .video-js .vjs-volume-panel.vjs-hover .vjs-mute-control ~ .vjs-volume-control,
  .video-js .vjs-volume-panel .vjs-volume-control.vjs-slider-active {
    visibility: visible;
    opacity: 1;
    position: relative;
    transition:
      visibility 0.1s,
      opacity 0.1s,
      height 0.1s,
      width 0.1s,
      left 0s,
      top 0s;
  }

  .video-js
    .vjs-volume-panel.vjs-hover
    .vjs-volume-control.vjs-volume-horizontal,
  .video-js .vjs-volume-panel:active .vjs-volume-control.vjs-volume-horizontal,
  .video-js .vjs-volume-panel:focus .vjs-volume-control.vjs-volume-horizontal,
  .video-js .vjs-volume-panel .vjs-volume-control:active.vjs-volume-horizontal,
  .video-js
    .vjs-volume-panel.vjs-hover
    .vjs-mute-control
    ~ .vjs-volume-control.vjs-volume-horizontal,
  .video-js
    .vjs-volume-panel
    .vjs-volume-control.vjs-slider-active.vjs-volume-horizontal {
    width: 6em;
    height: 100%;
    margin-right: 0;
  }

  .video-js .vjs-volume-panel.vjs-hover .vjs-volume-control.vjs-volume-vertical,
  .video-js .vjs-volume-panel:active .vjs-volume-control.vjs-volume-vertical,
  .video-js .vjs-volume-panel:focus .vjs-volume-control.vjs-volume-vertical,
  .video-js .vjs-volume-panel .vjs-volume-control:active.vjs-volume-vertical,
  .video-js
    .vjs-volume-panel.vjs-hover
    .vjs-mute-control
    ~ .vjs-volume-control.vjs-volume-vertical,
  .video-js
    .vjs-volume-panel
    .vjs-volume-control.vjs-slider-active.vjs-volume-vertical {
    left: -2.9em;
    transition: left 0s;
  }
  .video-js .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-hover,
  .video-js .vjs-volume-panel.vjs-volume-panel-horizontal:active,
  .video-js .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-slider-active {
    width: 11em;
    transition: width 0.1s;
  }

  .video-js .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-mute-toggle-only {
    width: 4em;
  }
  .video-js .vjs-volume-panel .vjs-volume-control.vjs-volume-vertical {
    height: 8em;
    width: 3em;
    left: -3000em;
    transition:
      visibility 0s,
      opacity 0s,
      height 0s 0s,
      width 0s 0s,
      left 0s 0s,
      top 0s 0s;
  }
  .video-js .vjs-volume-panel .vjs-volume-control.vjs-volume-horizontal {
    transition:
      visibility 1s,
      opacity 1s,
      height 1s 1s,
      width 1s,
      left 1s 1s,
      top 1s 1s;
  }

  .video-js.vjs-no-flex
    .vjs-volume-panel
    .vjs-volume-control.vjs-volume-horizontal {
    width: 7em;
    height: 2.5em;
    visibility: visible;
    opacity: 1;
    position: relative;
    transition: none;
  }
  .video-js.vjs-no-flex .vjs-volume-control.vjs-volume-vertical,
  .video-js.vjs-no-flex
    .vjs-volume-panel
    .vjs-volume-control.vjs-volume-vertical {
    position: absolute;
    bottom: 3em;
    left: 0.5em;
  }
  .video-js .vjs-volume-bar {
    margin: 0em;
  }
  .vjs-volume-bar.vjs-slider-horizontal {
    width: 6em;
    height: 100%;
  }
  .vjs-volume-bar.vjs-slider-vertical {
    width: 3em;
    padding: 0 1.2em;
    margin: 1.2em 0;
    height: 5.6em;
  }

  .video-js.vjs-layout-x-small
    .vjs-volume-control
    .vjs-volume-bar.vjs-slider-vertical,
  .video-js.vjs-layout-small
    .vjs-volume-control
    .vjs-volume-bar.vjs-slider-vertical,
  .video-js.vjs-layout-tiny
    .vjs-volume-control
    .vjs-volume-bar.vjs-slider-vertical {
    width: auto;
  }
  .vjs-volume-bar.vjs-slider-vertical:after {
    content: '';
    display: block;
    position: absolute;
    width: 0.3em;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.4);
    left: 50%;
    top: 0;
    transform: translateX(-50%);
    z-index: 1;
  }
  .video-js .vjs-volume-level {
    position: absolute;
    left: 50%;
    background-color: var(
      --cx-video-player,
      var(--cx-video-player-fallback-color)
    );
    transform: translateX(-50%);
    z-index: 2;
  }
  .video-js .vjs-volume-level:before {
    position: absolute;
    font-size: 1.2em;
    z-index: 1;
  }
  .vjs-slider-vertical .vjs-volume-level {
    width: 0.3em;
    bottom: 0;
    transform-origin: bottom;
  }
  .vjs-slider-vertical .vjs-volume-level:before {
    transform: translateY(-50%);
    left: -0.38em;
    z-index: 1;
    top: 0;
  }
  .vjs-slider-horizontal .vjs-volume-level {
    height: 4px;
  }
  .vjs-slider-horizontal .vjs-volume-level:before {
    top: -0.35em;
    right: -0.5em;
  }
  .video-js .vjs-volume-panel.vjs-volume-panel-vertical {
    width: 3em;
  }
  .vjs-volume-bar.vjs-slider-vertical .vjs-volume-level {
    height: 100%;
  }
  .vjs-volume-bar.vjs-slider-horizontal .vjs-volume-level {
    width: 100%;
  }
  .video-js .vjs-volume-vertical {
    width: 3em;
    height: 8em;
    bottom: 8em;
    background-color: rgba(43, 51, 63, 0.7);
  }
  .video-js .vjs-volume-horizontal .vjs-menu {
    left: -2em;
  }
  .video-js .vjs-volume-tooltip {
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 0.3em;
    color: #000;
    css-float: right;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 1em;
    padding: 6px 8px 8px 8px;
    pointer-events: none;
    position: absolute;
    top: -3.4em;
    visibility: hidden;
    z-index: 1;
  }
  .video-js .vjs-volume-control:hover .vjs-volume-tooltip,
  .video-js
    .vjs-volume-control:hover
    .vjs-progress-holder:focus
    .vjs-volume-tooltip {
    display: block;
    font-size: 1em;
    visibility: visible;
  }
  .video-js .vjs-volume-vertical:hover .vjs-volume-tooltip,
  .video-js
    .vjs-volume-vertical:hover
    .vjs-progress-holder:focus
    .vjs-volume-tooltip {
    left: 1em;
    top: -12px;
  }
  .video-js .vjs-volume-control.disabled:hover .vjs-volume-tooltip {
    font-size: 1em;
  }
  .video-js .vjs-volume-control .vjs-mouse-display {
    display: none;
    position: absolute;
    width: 100%;
    height: 1px;
    background-color: transparent;
    z-index: 1;
  }
  .video-js .vjs-volume-horizontal .vjs-mouse-display {
    width: 1px;
    height: 100%;
  }
  .vjs-no-flex .vjs-volume-control .vjs-mouse-display {
    z-index: 0;
  }
  .video-js .vjs-volume-control:hover .vjs-mouse-display {
    display: block;
  }
  .video-js.vjs-user-inactive .vjs-volume-control .vjs-mouse-display {
    visibility: hidden;
    opacity: 0;
    transition:
      visibility 1s,
      opacity 1s;
  }

  .video-js.vjs-user-inactive.vjs-no-flex
    .vjs-volume-control
    .vjs-mouse-display {
    display: none;
  }
  .vjs-mouse-display .vjs-volume-tooltip {
    color: var(--cx-tooltip-color);
    background-color: var(--cx-tooltip-background-color);
  }
  .vjs-poster {
    display: inline-block;
    vertical-align: middle;
    background-repeat: no-repeat;
    background-position: 50% 50%;
    background-size: contain;
    cursor: pointer;
    margin: 0;
    padding: 0;
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    height: 100%;
  }
  .video-js.vjs-light-mode .vjs-poster {
    background-color: white;
  }
  .video-js.vjs-dark-mode .vjs-poster {
    background-color: black;
  }
  .vjs-has-started .vjs-poster,
  .vjs-using-native-controls .vjs-poster {
    display: none;
  }
  .vjs-audio.vjs-has-started .vjs-poster,
  .vjs-has-started.vjs-audio-poster-mode .vjs-poster {
    display: block;
  }
  .video-js .vjs-live-control {
    display: flex;
    align-items: flex-start;
    flex: auto;
    font-size: 1em;
    line-height: 3em;
  }
  .vjs-no-flex .vjs-live-control {
    display: table-cell;
    width: auto;
    text-align: left;
  }
  .video-js:not(.vjs-live) .vjs-live-control,
  .video-js.vjs-liveui .vjs-live-control {
    display: none;
  }
  .video-js .vjs-seek-to-live-control {
    align-items: center;
    cursor: pointer;
    flex: none;
    display: inline-flex;
    height: 100%;
    padding-left: 0.5em;
    padding-right: 0.5em;
    font-size: 1em;
    line-height: 3em;
    width: auto;
    min-width: 4em;
  }
  .vjs-no-flex .vjs-seek-to-live-control {
    display: table-cell;
    width: auto;
    text-align: left;
  }
  .video-js.vjs-live:not(.vjs-liveui) .vjs-seek-to-live-control,
  .video-js:not(.vjs-live) .vjs-seek-to-live-control {
    display: none;
  }
  .vjs-seek-to-live-control.vjs-control.vjs-at-live-edge {
    cursor: auto;
  }
  .vjs-seek-to-live-control .vjs-icon-placeholder {
    margin-right: 0.5em;
    color: #888;
  }

  .vjs-seek-to-live-control.vjs-control.vjs-at-live-edge .vjs-icon-placeholder {
    color: red;
  }
  .video-js .vjs-time-control {
    flex: none;
    font-size: 1em;
    line-height: 3em;
    min-width: 2em;
    width: auto;
    padding-left: 1em;
    padding-right: 1em;
  }
  .vjs-live .vjs-time-control {
    display: none;
  }
  .video-js .vjs-current-time,
  .vjs-no-flex .vjs-current-time {
    display: none;
  }
  .video-js .vjs-duration,
  .vjs-no-flex .vjs-duration {
    display: none;
  }
  .vjs-time-divider {
    display: none;
    line-height: 3em;
  }
  .vjs-live .vjs-time-divider {
    display: none;
  }
  .video-js .vjs-play-control {
    cursor: pointer;
  }
  .video-js .vjs-play-control .vjs-icon-placeholder {
    flex: none;
  }
  .vjs-text-track-display {
    position: absolute;
    bottom: 3em;
    left: 0;
    right: 0;
    top: 0;
    pointer-events: none;
    z-index: 30;
  }
  .video-js.vjs-controls-disabled .vjs-text-track-display,
  .video-js.vjs-user-inactive.vjs-playing .vjs-text-track-display {
    bottom: 1em;
  }
  .video-js .vjs-text-track {
    font-size: 1.4em;
    text-align: center;
    margin-bottom: 0.1em;
  }
  .vjs-subtitles {
    color: var(--cx-color-white);
  }
  .vjs-captions {
    color: #fc6;
  }
  .vjs-tt-cue {
    display: block;
  }
  video::-webkit-media-text-track-display {
    transform: translateY(-3em);
  }
  .video-js.vjs-controls-disabled video::-webkit-media-text-track-display,
  .video-js.vjs-user-inactive.vjs-playing
    video::-webkit-media-text-track-display {
    transform: translateY(-1.5em);
  }
  .video-js .vjs-picture-in-picture-control {
    display: flex;
    cursor: pointer;
    flex: none;
  }
  .video-js.vjs-audio-only-mode .vjs-picture-in-picture-control {
    display: none;
  }
  .video-js .vjs-fullscreen-control {
    display: flex;
    cursor: pointer;
    flex: none;
  }
  .video-js.vjs-audio-only-mode .vjs-fullscreen-control {
    display: none;
  }
  .vjs-playback-rate > .vjs-menu-button,
  .vjs-playback-rate .vjs-playback-rate-value {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  .vjs-playback-rate .vjs-playback-rate-value {
    pointer-events: none;
    font-size: 1em;
    line-height: 2.5;
    text-align: center;
  }
  .vjs-error .vjs-error-display .vjs-modal-dialog-content {
    font-size: 1.4em;
    text-align: center;
  }
  .vjs-error .vjs-error-display:before {
    color: var(--cx-color-white);
    content: 'X';
    font-family: Arial, Helvetica, sans-serif;
    font-size: 4em;
    left: 0;
    line-height: 1;
    margin-top: -0.5em;
    position: absolute;
    text-shadow: 0.05em 0.05em 0.1em #000;
    text-align: center;
    top: 50%;
    vertical-align: middle;
    width: 100%;
  }
  .vjs-loading-spinner {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    margin: -25px 0 0 -25px;
    opacity: 0.85;
    text-align: left;
    border: 6px solid rgba(43, 51, 63, 0.7);
    box-sizing: border-box;
    background-clip: padding-box;
    width: 50px;
    height: 50px;
    border-radius: 25px;
    visibility: hidden;
    z-index: 40;
  }
  .vjs-seeking .vjs-loading-spinner,
  .vjs-waiting .vjs-loading-spinner {
    display: block;
    -webkit-animation: vjs-spinner-show 0s linear 0.3s forwards;
    animation: vjs-spinner-show 0s linear 0.3s forwards;
  }
  .vjs-loading-spinner:before,
  .vjs-loading-spinner:after {
    content: '';
    position: absolute;
    margin: -6px;
    box-sizing: inherit;
    width: inherit;
    height: inherit;
    border-radius: inherit;
    opacity: 1;
    border: inherit;
    border-color: transparent;
    border-top-color: white;
  }
  .vjs-seeking .vjs-loading-spinner:before,
  .vjs-seeking .vjs-loading-spinner:after,
  .vjs-waiting .vjs-loading-spinner:before,
  .vjs-waiting .vjs-loading-spinner:after {
    -webkit-animation:
      vjs-spinner-spin 1.1s cubic-bezier(0.6, 0.2, 0, 0.8) infinite,
      vjs-spinner-fade 1.1s linear infinite;
    animation:
      vjs-spinner-spin 1.1s cubic-bezier(0.6, 0.2, 0, 0.8) infinite,
      vjs-spinner-fade 1.1s linear infinite;
  }
  .vjs-seeking .vjs-loading-spinner:before,
  .vjs-waiting .vjs-loading-spinner:before {
    border-top-color: white;
  }
  .vjs-seeking .vjs-loading-spinner:after,
  .vjs-waiting .vjs-loading-spinner:after {
    border-top-color: white;
    -webkit-animation-delay: 0.44s;
    animation-delay: 0.44s;
  }
  @keyframes vjs-spinner-show {
    to {
      visibility: visible;
    }
  }
  @-webkit-keyframes vjs-spinner-show {
    to {
      visibility: visible;
    }
  }
  @keyframes vjs-spinner-spin {
    100% {
      transform: rotate(360deg);
    }
  }
  @-webkit-keyframes vjs-spinner-spin {
    100% {
      -webkit-transform: rotate(360deg);
    }
  }
  @keyframes vjs-spinner-fade {
    0% {
      border-top-color: #73859f;
    }
    20% {
      border-top-color: #73859f;
    }
    35% {
      border-top-color: white;
    }
    60% {
      border-top-color: #73859f;
    }
    100% {
      border-top-color: #73859f;
    }
  }
  @-webkit-keyframes vjs-spinner-fade {
    0% {
      border-top-color: #73859f;
    }
    20% {
      border-top-color: #73859f;
    }
    35% {
      border-top-color: white;
    }
    60% {
      border-top-color: #73859f;
    }
    100% {
      border-top-color: #73859f;
    }
  }
  .video-js.vjs-audio-only-mode .vjs-captions-button {
    display: none;
  }
  .vjs-chapters-button .vjs-menu ul {
    width: 24em;
  }
  .video-js.vjs-audio-only-mode .vjs-descriptions-button {
    display: none;
  }

  .video-js
    .vjs-subs-caps-button
    + .vjs-menu
    .vjs-captions-menu-item
    .vjs-menu-item-text
    .vjs-icon-placeholder {
    vertical-align: middle;
    display: inline-block;
    margin-bottom: -0.1em;
  }

  .video-js
    .vjs-subs-caps-button
    + .vjs-menu
    .vjs-captions-menu-item
    .vjs-menu-item-text
    .vjs-icon-placeholder:before {
    font-family: VideoJS;
    content: '';
    font-size: 1.5em;
    line-height: inherit;
  }
  .video-js.vjs-audio-only-mode .vjs-subs-caps-button {
    display: none;
  }

  .video-js
    .vjs-audio-button
    + .vjs-menu
    .vjs-main-desc-menu-item
    .vjs-menu-item-text
    .vjs-icon-placeholder {
    vertical-align: middle;
    display: inline-block;
    margin-bottom: -0.1em;
  }

  .video-js
    .vjs-audio-button
    + .vjs-menu
    .vjs-main-desc-menu-item
    .vjs-menu-item-text
    .vjs-icon-placeholder:before {
    font-family: VideoJS;
    content: ' ';
    font-size: 1.5em;
    line-height: inherit;
  }
  .video-js .vjs-audio-button .vjs-menu {
    width: 16em;
    left: -10em;
  }
  .video-js .vjs-subs-caps-button .vjs-menu {
    width: 12em;
    left: -8em;
  }
  .video-js .vjs-http-source-selector .vjs-menu {
    width: 12em;
    left: -8em;
  }
  .video-js .vjs-audio-button .vjs-menu-content,
  .video-js .vjs-http-source-selector .vjs-menu-content,
  .video-js .vjs-subs-caps-button .vjs-menu-content,
  .video-js .vjs-playback-rate .vjs-menu-content {
    background: var(--menu-background);
    overflow: hidden;
    border-radius: 8px;
    color: var(--menu-color);
    box-shadow:
      0px 5px 5px -3px rgba(0, 0, 0, 0.2),
      0px 8px 10px 1px rgba(0, 0, 0, 0.14),
      0px 3px 14px 2px rgba(0, 0, 0, 0.12);
  }
  .video-js .vjs-menu-item {
    padding: 8px 12px 8px 12px;
  }
  .video-js .vjs-audio-button .vjs-menu-item.vjs-selected,
  .video-js .vjs-http-source-selector .vjs-menu-item.vjs-selected,
  .video-js .vjs-subs-caps-button .vjs-menu-item.vjs-selected,
  .video-js .vjs-playback-rate .vjs-menu-item.vjs-selected {
    padding: 8px 12px 8px 12px;
    background-color: color-mix(
      in srgb,
      var(--cx-color-neutral-500),
      transparent 80%
    );
    border-radius: 8px;
    color: var(--menu-color);
  }
  .video-js .vjs-menu-item:hover {
    background: color-mix(
      in srgb,
      var(--cx-color-neutral-500),
      transparent 80%
    ) !important;
    border-radius: 8px !important;
    transition-duration: 0.2s !important;
    color: var(--menu-color);
  }
  .video-js .vjs-menu-item-text {
    white-space: nowrap;
    text-overflow: ellipsis;
    display: block;
    width: 100%;
    overflow: hidden;
  }
  .video-js .vjs-audio-button .vjs-menu-item-text,
  .video-js .vjs-subs-caps-button .vjs-menu-item-text {
    text-align: left;
  }
  .video-js.vjs-layout-small .vjs-current-time,
  .video-js.vjs-layout-small .vjs-time-divider,
  .video-js.vjs-layout-small .vjs-duration,
  .video-js.vjs-layout-small .vjs-remaining-time,
  .video-js.vjs-layout-small .vjs-playback-rate,
  .video-js.vjs-layout-small .vjs-volume-control,
  .video-js.vjs-layout-x-small .vjs-current-time,
  .video-js.vjs-layout-x-small .vjs-time-divider,
  .video-js.vjs-layout-x-small .vjs-duration,
  .video-js.vjs-layout-x-small .vjs-remaining-time,
  .video-js.vjs-layout-x-small .vjs-playback-rate,
  .video-js.vjs-layout-x-small .vjs-volume-control,
  .video-js.vjs-layout-tiny .vjs-current-time,
  .video-js.vjs-layout-tiny .vjs-time-divider,
  .video-js.vjs-layout-tiny .vjs-duration,
  .video-js.vjs-layout-tiny .vjs-remaining-time,
  .video-js.vjs-layout-tiny .vjs-playback-rate,
  .video-js.vjs-layout-tiny .vjs-volume-control,
  .video-js.vjs-layout-x-small .vjs-subs-caps-button,
  .video-js.vjs-layout-x-small .vjs-audio-button,
  .video-js.vjs-layout-x-small .vjs-http-source-selector {
    display: none;
  }
  .video-js.vjs-layout-x-small .vjs-volume-control,
  .video-js.vjs-layout-small .vjs-volume-control,
  .video-js.vjs-layout-tiny .vjs-volume-control {
    display: block;
  }

  .video-js.vjs-layout-small
    .vjs-volume-panel.vjs-volume-panel-horizontal:hover,
  .video-js.vjs-layout-small
    .vjs-volume-panel.vjs-volume-panel-horizontal:active,
  .video-js.vjs-layout-small
    .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-slider-active,
  .video-js.vjs-layout-small
    .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-hover,
  .video-js.vjs-layout-x-small
    .vjs-volume-panel.vjs-volume-panel-horizontal:hover,
  .video-js.vjs-layout-x-small
    .vjs-volume-panel.vjs-volume-panel-horizontal:active,
  .video-js.vjs-layout-x-small
    .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-slider-active,
  .video-js.vjs-layout-x-small
    .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-hover,
  .video-js.vjs-layout-tiny .vjs-volume-panel.vjs-volume-panel-horizontal:hover,
  .video-js.vjs-layout-tiny
    .vjs-volume-panel.vjs-volume-panel-horizontal:active,
  .video-js.vjs-layout-tiny
    .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-slider-active,
  .video-js.vjs-layout-tiny
    .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-hover {
    width: initial;
  }
  .vjs-modal-dialog.vjs-text-track-settings {
    background-color: rgba(43, 51, 63, 0.75);
    color: var(--cx-color-white);
    height: 70%;
  }
  .vjs-text-track-settings .vjs-modal-dialog-content {
    display: table;
  }
  .vjs-text-track-settings .vjs-track-settings-colors,
  .vjs-text-track-settings .vjs-track-settings-font,
  .vjs-text-track-settings .vjs-track-settings-controls {
    display: table-cell;
  }
  .vjs-text-track-settings .vjs-track-settings-controls {
    text-align: right;
    vertical-align: bottom;
  }
  @supports (display: grid) {
    .vjs-text-track-settings .vjs-modal-dialog-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr;
      padding: 20px 24px 0px 24px;
    }
    .vjs-track-settings-controls .vjs-default-button {
      margin-bottom: 20px;
    }
    .vjs-text-track-settings .vjs-track-settings-controls {
      grid-column: 1/-1;
    }
    .vjs-layout-small .vjs-text-track-settings .vjs-modal-dialog-content,
    .vjs-layout-x-small .vjs-text-track-settings .vjs-modal-dialog-content,
    .vjs-layout-tiny .vjs-text-track-settings .vjs-modal-dialog-content {
      grid-template-columns: 1fr;
    }
  }
  .vjs-track-setting > select {
    margin-right: 1em;
    margin-bottom: 0.5em;
  }
  .vjs-text-track-settings fieldset {
    margin: 5px;
    padding: 3px;
    border: none;
  }
  .vjs-text-track-settings fieldset span {
    display: inline-block;
  }
  .vjs-text-track-settings fieldset span > select {
    max-width: 7.3em;
  }
  .vjs-text-track-settings legend {
    color: var(--cx-color-white);
    margin: 0 0 5px 0;
  }
  .vjs-text-track-settings .vjs-label {
    position: absolute;
    clip: rect(1px, 1px, 1px, 1px);
    display: block;
    margin: 0 0 5px 0;
    padding: 0;
    border: 0;
    height: 1px;
    width: 1px;
    overflow: hidden;
  }
  .vjs-track-settings-controls button:focus,
  .vjs-track-settings-controls button:active {
    outline-style: solid;
    outline-width: medium;
    background-image: linear-gradient(
      0deg,
      var(--cx-color-white) 88%,
      #73859f 100%
    );
  }
  .vjs-track-settings-controls button:hover {
    color: rgba(43, 51, 63, 0.75);
  }
  .vjs-track-settings-controls button {
    background-color: var(--cx-color-white);
    background-image: linear-gradient(
      -180deg,
      var(--cx-color-white) 88%,
      #73859f 100%
    );
    color: #2b333f;
    cursor: pointer;
    border-radius: 2px;
  }
  .vjs-track-settings-controls .vjs-default-button {
    margin-right: 1em;
  }
  @media print {
    .video-js > *:not(.vjs-tech):not(.vjs-poster) {
      visibility: hidden;
    }
  }
  .vjs-resize-manager {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: none;
    z-index: -1000;
  }
  .js-focus-visible .video-js *:focus:not(.focus-visible) {
    outline: none;
  }
  .video-js *:focus:not(:focus-visible) {
    outline: none;
  }
  .vjs-has-started .vjs-control-bar {
    visibility: visible;
    z-index: 50;
  }

  .vjs-has-started.vjs-user-inactive.vjs-playing.segment-mode .vjs-control-bar {
    visibility: visible;
    opacity: 1;
  }
  .vjs-big-play-button {
    z-index: 35;
  }
  .vjs-remaining-time {
    visibility: hidden;
  }
  .vjs-control-bar .vjs-icon-placeholder,
  .vjs-big-play-button .vjs-icon-placeholder {
    display: block;
    width: 100%;
    height: 100%;
  }
  .seekbar-container {
    display: none;
  }
  .control-background {
    display: none;
  }
  .vjs-has-started.vjs-user-active .seekbar-container {
    display: block;
    visibility: visible;
  }
  .vjs-has-started.vjs-user-active .control-background {
    display: block;
    visibility: visible;
  }
  .vjs-has-started.vjs-user-inactive.vjs-paused .seekbar-container {
    display: block;
    visibility: visible;
  }
  .vjs-has-started.vjs-user-inactive.vjs-paused .control-background {
    display: block;
    visibility: visible;
  }

  .vjs-has-started.vjs-user-inactive.vjs-playing:not(.segment-mode)
    .seekbar-container {
    display: block;
    visibility: hidden;
    opacity: 0;
    transition:
      visibility 1.5s,
      opacity 1.5s;
  }

  .vjs-has-started.vjs-user-inactive.vjs-playing:not(.segment-mode)
    .control-background {
    display: block;
    visibility: hidden;
    opacity: 0;
    transition:
      visibility 1.5s,
      opacity 1.5s;
  }

  .vjs-has-started.vjs-user-inactive.vjs-playing.segment-mode
    .seekbar-container {
    display: block;
    visibility: visible;
    opacity: 1;
  }

  .vjs-has-started.vjs-user-inactive.vjs-playing.segment-mode
    .control-background {
    display: block;
    visibility: visible;
    opacity: 1;
  }
  .vjs-freeze-frame .vjs-loading-spinner {
    z-index: 60;
    display: block;
    visibility: visible;
    animation:
      vjs-spinner-spin 1.1s cubic-bezier(0.6, 0.2, 0, 0.8) infinite,
      vjs-spinner-fade 1.1s linear infinite;
    -webkit-animation:
      vjs-spinner-spin 1.1s cubic-bezier(0.6, 0.2, 0, 0.8) infinite,
      vjs-spinner-fade 1.1s linear infinite;
  }
  :hover.video-js .vjs-big-vr-play-button {
    transition:
      border-color 0.4s,
      outline 0.4s,
      background-color 0.4s;
  }
  .video-js .vjs-big-vr-play-button::before {
    content: '';
  }
  .video-js canvas {
    cursor: move;
  }
  .video-js .vjs-button-vr .vjs-icon-placeholder {
    height: 30px;
    width: 30px;
    display: inline-block;
    background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI0ZGRkZGRiI+CiAgICA8cGF0aCBkPSJNMjAuNzQgNkgzLjIxQzIuNTUgNiAyIDYuNTcgMiA3LjI4djEwLjQ0YzAgLjcuNTUgMS4yOCAxLjIzIDEuMjhoNC43OWMuNTIgMCAuOTYtLjMzIDEuMTQtLjc5bDEuNC0zLjQ4Yy4yMy0uNTkuNzktMS4wMSAxLjQ0LTEuMDFzMS4yMS40MiAxLjQ1IDEuMDFsMS4zOSAzLjQ4Yy4xOS40Ni42My43OSAxLjExLjc5aDQuNzljLjcxIDAgMS4yNi0uNTcgMS4yNi0xLjI4VjcuMjhjMC0uNy0uNTUtMS4yOC0xLjI2LTEuMjh6TTcuNSAxNC42MmMtMS4xNyAwLTIuMTMtLjk1LTIuMTMtMi4xMiAwLTEuMTcuOTYtMi4xMyAyLjEzLTIuMTMgMS4xOCAwIDIuMTIuOTYgMi4xMiAyLjEzcy0uOTUgMi4xMi0yLjEyIDIuMTJ6bTkgMGMtMS4xNyAwLTIuMTMtLjk1LTIuMTMtMi4xMiAwLTEuMTcuOTYtMi4xMyAyLjEzLTIuMTNzMi4xMi45NiAyLjEyIDIuMTMtLjk1IDIuMTItMi4xMiAyLjEyeiIvPgogICAgPHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgyNHYyNEgwVjB6Ii8+Cjwvc3ZnPgo=)
      no-repeat left center;
  }
  .vjs-icon-fullscreen-exit:before,
  .video-js.vjs-fixed-fullscreen
    .vjs-fullscreen-control
    .vjs-icon-placeholder:before {
    content: '\\f109';
  }
  .video-js .vjs-text-track-display > div > div > div {
    display: inline-block !important;
    text-shadow: 1px 1px 2px #000;
    transition: all ease 200ms;
    transform: translateY(0);
  }

  .video-js
    .vjs-text-track-display.vjs-text-track-display-show-timeline
    > div
    > div
    > div {
    transform: translateY(-3em);
  }

  .progress_bar {
    --primary-color: var(
      --cx-video-player,
      var(--cx-video-player-fallback-color)
    );
    position: absolute;
    width: 100%;
    left: 0;
    top: 50%;
    touch-action: none;
    transform: translateY(-50%);
    color: var(--cx-color-white);
    cursor: pointer;
    z-index: 200;
    user-select: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
  }
  @media not all and (hover: none) {
    .progress_bar:hover .progress_bar_chapter_i_w {
      transform: scaleY(1.2);
    }
    .progress_bar:hover .progress_bar_marker_i_t {
      transform: translateY(-50%) scaleY(1.2);
    }
    .progress_bar:hover .progress_bar_chapter_i_h {
      opacity: 1;
    }
    .progress_bar:hover .progress_bar_heat {
      transform: translateY(-0.85px);
    }
    .progress_bar:hover .progress_bar_heat-hover {
      opacity: 1 !important;
    }
    .progress_bar_dot {
      opacity: 0;
    }
    .progress_bar_dot_i {
      width: 15px;
      height: 15px;
    }
    .progress_bar:hover .progress_bar_dot {
      opacity: 1;
    }
  }
  .progress_bar_chapter {
    display: flex;
    position: relative;
    gap: 2px;
    transition: transform 0.12s ease;
    z-index: 1;
  }
  .progress_bar_chapter_i {
    flex: 1;
    position: relative;
  }
  .progress_bar_chapter_i_w {
    position: relative;
    height: 6px;
    background: rgba(255, 255, 255, 0.4);
    transition: transform 0.12s ease;
    overflow: hidden;
  }
  .progress_bar_chapter_i_w > div:not(.progress_bar_marker) {
    position: absolute;
    left: 0;
    top: 0;
  }
  .progress_bar_chapter_i_p,
  .progress_bar_chapter_i_h,
  .progress_bar_chapter_i_b {
    width: 100%;
    height: 100%;
    transform-origin: 0 0;
  }
  .progress_bar_chapter_i_h {
    background: rgba(255, 255, 255, 0.5);
    opacity: 0;
  }
  .progress_bar_chapter_i_p {
    transform: scaleX(0);
    background: var(--primary-color);
  }
  .progress_bar_chapter_i_b {
    transform: scaleX(0);
    background: rgba(255, 255, 255, 0.4);
  }
  .progress_bar_marker {
    transition: opacity 0.12s ease;
    position: absolute;
    width: 100%;
    height: 0;
    bottom: 0;
    z-index: 1;
  }
  .progress_bar_marker-hover {
    opacity: 0;
  }
  .progress_bar_marker_i {
    position: absolute;
    bottom: 0;
    height: 10px;
    width: auto;
    aspect-ratio: 1/1;
    transform: translate(-5px, 2px);
    transition: transform 0.12s ease;
    z-index: 1;
  }
  .progress_bar_marker_i_d {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgb(252, 190, 93);
    border: 1px solid var(--cx-color-white);
    pointer-events: none;
    box-sizing: border-box;
    position: relative;
    transition: transform 0.12s ease;
  }
  .progress_bar_marker_i_t {
    height: 6px;
    background: rgb(252, 190, 93);
    position: absolute;
    left: 5px;
    width: calc(100% - 5px);
    top: 50%;
    transform: translateY(-50%);
    z-index: 0;
    transition: transform 0.12s ease;
    box-sizing: border-box;
  }
  .progress_bar_marker_i_tip {
    position: absolute;
    display: none;
    bottom: 100%;
    font-size: 12px;
    border-radius: 2px;
    margin-bottom: 10px;
    padding: 3px 6px;
    white-space: nowrap;
    background: rgba(0, 0, 0, 0.7);
    pointer-events: none;
    opacity: 0;
    left: 50%;
    transform: translateX(-50%);
    transition: opacity 0.2s ease;
  }
  .progress_bar_marker_i:hover {
    z-index: 1;
  }
  .progress_bar_marker_i:hover .progress_bar_marker_i_tip {
    opacity: 1;
  }
  .progress_bar_heat {
    display: none !important;
    position: absolute;
    left: 0;
    right: 0;
    bottom: 10px;
    gap: 2px;
    height: 40px;
    transition:
      transform 0.2s ease,
      opacity 0.12s ease;
  }
  .progress_bar_heat-hover {
    opacity: 0;
  }
  .progress_bar_heat_i {
    flex: 1;
    height: 100%;
  }
  .progress_bar_heat_i svg {
    height: 100%;
  }
  .progress_bar_dot {
    display: block;
    position: absolute;
    top: 50%;
    left: 0;
    pointer-events: none;
    transition:
      opacity 0.2s ease,
      transform 0.2s ease;
    z-index: 1;
  }
  .progress_bar_dot > :first-child {
    transform: translate(-50%);
  }
  .progress_bar_dot_i {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.4);
    -webkit-box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.4);
    -moz-box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.4);
    background: var(--primary-color);
  }
  .progress_bar_thumb {
    display: none;
    position: absolute;
    left: 0;
    bottom: 30px;
    font-size: 13px;
    font-weight: 500;
    text-align: center;
    pointer-events: none;
    text-shadow: 0 0 4px #000;
  }
  .progress_bar_thumb_img {
    border: 1px solid var(--cx-color-white);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    margin-bottom: 2px;
    background-color: rgba(255, 255, 255, 0.3);
    background-repeat: no-repeat;
  }
  .progress_bar_thumb_title {
    min-height: 17px;
    word-break: break-all;
  }
`;
var PL = Object.defineProperty, LL = Object.getOwnPropertyDescriptor, Ut = (e, t, i, n) => {
  for (var r = n > 1 ? void 0 : n ? LL(t, i) : t, a = e.length - 1, s; a >= 0; a--)
    (s = e[a]) && (r = (n ? s(t, i, r) : s(r)) || r);
  return n && r && PL(t, i, r), r;
};
const RL = () => {
  const e = window.navigator && window.navigator.userAgent || "";
  return /Firefox/i.test(e);
};
let Pt = class extends hx {
  constructor() {
    super(...arguments), this.isLoaded = !1, this.isPlaying = !1, this.isError = !1, this.player = null, this.isFullscreen = !1, this.videoWidth = 0, this.videoHeight = 0, this._needScale = !1, this.src = "", this.type = "", this.poster = "", this.autoplay = !1, this.loop = !1, this.muted = !1, this.showControls = !1, this.autoPlayTimeout = null, this._onPause = () => {
      this.isPlaying = !1, this.emit("cx-pause", {
        detail: this
      });
    }, this._onPlay = () => {
      this.isPlaying = !0, this.emit("cx-play", {
        detail: this
      });
    }, this._onTimeUpdate = () => {
      this.emit("cx-time-update", {
        detail: {
          time: this.currentTime
        }
      });
    }, this._onEnded = () => {
      this.isPlaying = !1, this.emit("cx-ended", {
        detail: this
      });
    }, this._onSeeked = () => {
      this.emit("cx-seeked", {
        detail: this
      });
    }, this._onLoadedMetadata = () => {
      var e, t;
      this.isLoaded = !0, this.videoWidth = ((e = this.player) == null ? void 0 : e.videoWidth()) || 0, this.videoHeight = ((t = this.player) == null ? void 0 : t.videoHeight()) || 0, this.emit("cx-loaded-metadata", {
        detail: this
      });
    }, this._onError = () => {
      this.isLoaded = !0, this.emit("cx-error");
    }, this.onPlay = this._onPlay.bind(this), this.onPause = this._onPause.bind(this), this.onTimeUpdate = this._onTimeUpdate.bind(this), this.onEnded = this._onEnded.bind(this), this.onSeeked = this._onSeeked.bind(this), this.onLoadedMetadata = this._onLoadedMetadata.bind(this), this.onError = this._onError.bind(this);
  }
  get currentTime() {
    var e;
    return ((e = this.player) == null ? void 0 : e.currentTime()) || 0;
  }
  get duration() {
    var e;
    return ((e = this.player) == null ? void 0 : e.duration()) || 0;
  }
  cleanUp() {
    var t, i;
    if (this.removeVideoEventListeners(), !((t = this.player) != null && t.el()))
      return;
    const e = this.player;
    e != null && e.el() && !e.isDisposed() && (this.player = null), (i = e.isInPictureInPicture) != null && i.call(e) ? e.one("leavepictureinpicture", () => {
      e.dispose();
    }) : e.dispose(), this.player = null;
  }
  addVideoEventListeners() {
    var e;
    (e = this.player) != null && e.el() && (this.player.on("play", this.onPlay), this.player.on("pause", this.onPause), this.player.on("timeupdate", this.onTimeUpdate), this.player.on("ended", this.onEnded), this.player.on("seeked", this.onSeeked), this.player.on("loadedmetadata", this.onLoadedMetadata), this.player.on("error", this.onError));
  }
  removeVideoEventListeners() {
    var e;
    (e = this.player) != null && e.el() && (this.player.off("play", this.onPlay), this.player.off("pause", this.onPause), this.player.off("timeupdate", this.onTimeUpdate), this.player.off("ended", this.onEnded), this.player.off("seeked", this.onSeeked), this.player.off("loadedmetadata", this.onLoadedMetadata), this.player.off("error", this.onError));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.cleanUp();
  }
  attachSeekbar() {
    const e = this.videoJsContainer.getElementsByClassName("vjs-control-bar");
    e.length && e[0].before(this.seekbar);
  }
  setupVideoJsPlayer() {
    const e = {
      poster: this.poster,
      src: this.src,
      type: this.type
    }, t = {
      controlBar: {
        remainingTimeDisplay: !1,
        subsCapsButton: !1,
        volumePanel: { inline: !1 }
      },
      controls: this.showControls,
      fill: !0,
      inactivityTimeout: Ax,
      loop: this.loop,
      poster: e.poster,
      responsive: !0,
      retryOnError: !0,
      sources: [e]
    };
    if (this.player)
      this.player.src(this.src);
    else {
      const i = this.ownerDocument.createElement("video-js");
      i.classList.add("vjs-big-play-centered"), i.classList.add("vjs-main-video-player"), this.videoJsContainer.appendChild(i), X.log.level("off"), this.player = X(i, t, () => {
        var r;
        this.addVideoEventListeners(), this.autoplay && (this.player.muted(!0), RL() ? (this.autoPlayTimeout && clearTimeout(this.autoPlayTimeout), this.autoPlayTimeout = window.setTimeout(() => {
          this.player.play();
        }, Tx)) : this.player.play());
        const n = (r = this.player) == null ? void 0 : r.error();
        this.isError = !!n, this.isError ? this.isLoaded = !0 : (this.player.loop(this.loop), this.player.muted(this.muted), this.player.controls(this.showControls), this.attachSeekbar());
      });
    }
  }
  async handleLoopChange() {
    var e;
    (e = this.player) != null && e.el() && this.player.loop(this.loop);
  }
  async handleMutedChange() {
    var e;
    (e = this.player) != null && e.el() && this.player.muted(this.muted);
  }
  async handleControlsChange() {
    var e;
    (e = this.player) != null && e.el() && this.player.controls(this.showControls);
  }
  async handlePosterChange() {
    var e;
    (e = this.player) != null && e.el() && this.player.poster(this.poster);
  }
  async handleSetupPlayer() {
    this.src ? (await this.videoJsContainerAsync, this.setupVideoJsPlayer()) : (this.cleanUp(), this.isLoaded = !0);
  }
  handleSrcChange() {
    this.isLoaded = !1, this.src || (this.isLoaded = !0);
  }
  handleSizeChange() {
    let e = this.videoWidth, t = this.videoHeight, i = !1;
    !this.isLoaded || !this.src ? (e = this.width || "100%", t = this.height || "100%") : this.width && this.height ? (e = this.width, t = this.height) : (!this.width && !this.height && (e = "100%", this.width = e), i = !0);
    const n = this.parentElement, r = this.width && this.width.endsWith("%"), a = this.height && this.height.endsWith("%");
    if (i && n) {
      const u = window.getComputedStyle(n), l = parseFloat(u.paddingLeft || "0"), c = parseFloat(u.paddingRight || "0"), h = parseFloat(u.paddingTop || "0"), d = parseFloat(u.paddingBottom || "0"), f = n.clientWidth - l - c, p = n.clientHeight - h - d;
      if (this.width && !this.height) {
        if (r) {
          const _ = parseFloat(this.width) / 100;
          e = f * _;
        } else
          e = parseFloat(this.width);
        t = this.videoWidth ? e * (this.videoHeight / this.videoWidth) : t;
      }
      if (!this.width && this.height) {
        if (a) {
          const _ = parseFloat(this.height) / 100;
          t = p * _;
        } else
          t = parseFloat(this.height);
        e = this.videoHeight ? t * (this.videoWidth / this.videoHeight) : f;
      }
    }
    const s = typeof e == "string" ? e : `${e}px`, o = typeof t == "string" ? t : `${t}px`;
    if (a || t || this.isResizing) {
      const u = this.isResizing ? `${this.resizeSize.height}px` : a ? this.height : o;
      this.style.setProperty("--height", u);
    }
    if (r || e || this.isResizing) {
      const u = this.isResizing ? `${this.resizeSize.width}px` : r ? this.width : s;
      this.style.setProperty("--width", u);
    }
  }
  play() {
    this.player && this.player.play();
  }
  pause() {
    this.player && this.player.pause();
  }
  seek(e) {
    this.player && this.player.currentTime(e);
  }
  render() {
    return Rv`<cx-resize-observer
      @cx-resize=${this.handleSizeChange.bind(this)}
    >
      <div
        part="base"
        class=${mx({
      container: !0,
      "container--error": this.isError,
      "container--resizing": this.resizable && this.isResizeActive
    })}
        @click=${this.startResizing.bind(this)}
      >
        ${Iv(
      !this.src,
      () => Rv`<slot name="placeholder" part="placeholder">
              <cx-image
                width=${this.width}
                height=${this.height}
                skeleton=""
                src=${this.poster}
                alt="poster"
                object-fit="contain"
              ></cx-image>
            </slot>`
    )}
        <div part="video-js-container" id="video-js-container">
          <div part="seekbar" class="seekbar-container">
            <div
              part="progress-bar-container"
              class="progress-bar-container"
            ></div>
          </div>
        </div>
        ${Iv(
      this.resizable && this.isResizeActive,
      () => this.renderResizer()
    )}
      </div>
    </cx-resize-observer>`;
  }
};
Pt.styles = [dx, lx, DL];
Pt.dependencies = {
  "cx-icon": gx,
  "cx-image": cx,
  "cx-resize-observer": yx,
  "cx-skeleton": _x,
  "cx-space": bx,
  "cx-tooltip": xx
};
Ut([
  nh("#video-js-container")
], Pt.prototype, "videoJsContainer", 2);
Ut([
  nh(".seekbar-container")
], Pt.prototype, "seekbar", 2);
Ut([
  vx("#video-js-container")
], Pt.prototype, "videoJsContainerAsync", 2);
Ut([
  nh("video")
], Pt.prototype, "videoElement", 2);
Ut([
  nh(".progress-bar-container")
], Pt.prototype, "progressBarContainer", 2);
Ut([
  Qn()
], Pt.prototype, "isLoaded", 2);
Ut([
  Qn()
], Pt.prototype, "isPlaying", 2);
Ut([
  Qn()
], Pt.prototype, "isError", 2);
Ut([
  Qn()
], Pt.prototype, "player", 2);
Ut([
  Qn()
], Pt.prototype, "isFullscreen", 2);
Ut([
  Qn()
], Pt.prototype, "videoWidth", 2);
Ut([
  Qn()
], Pt.prototype, "videoHeight", 2);
Ut([
  Qn()
], Pt.prototype, "_needScale", 2);
Ut([
  fs({ reflect: !0, type: String })
], Pt.prototype, "src", 2);
Ut([
  fs({ reflect: !0, type: String })
], Pt.prototype, "type", 2);
Ut([
  fs({ reflect: !0, type: String })
], Pt.prototype, "poster", 2);
Ut([
  fs({ reflect: !0, type: Boolean })
], Pt.prototype, "autoplay", 2);
Ut([
  fs({ reflect: !0, type: Boolean })
], Pt.prototype, "loop", 2);
Ut([
  fs({ reflect: !0, type: Boolean })
], Pt.prototype, "muted", 2);
Ut([
  fs({ attribute: "show-controls", reflect: !0, type: Boolean })
], Pt.prototype, "showControls", 2);
Ut([
  Qn()
], Pt.prototype, "autoPlayTimeout", 2);
Ut([
  ds("loop", { waitUntilFirstUpdate: !0 })
], Pt.prototype, "handleLoopChange", 1);
Ut([
  ds("muted", { waitUntilFirstUpdate: !0 })
], Pt.prototype, "handleMutedChange", 1);
Ut([
  ds("showControls", { waitUntilFirstUpdate: !0 })
], Pt.prototype, "handleControlsChange", 1);
Ut([
  ds("poster", { waitUntilFirstUpdate: !0 })
], Pt.prototype, "handlePosterChange", 1);
Ut([
  ds(["src"])
], Pt.prototype, "handleSetupPlayer", 1);
Ut([
  ds("src")
], Pt.prototype, "handleSrcChange", 1);
Ut([
  ds([
    "width",
    "height",
    "videoWidth",
    "videoHeight",
    "isLoaded",
    "resizeSize"
  ])
], Pt.prototype, "handleSizeChange", 1);
Pt = Ut([
  fx("cx-video")
], Pt);
export {
  Pt as default,
  RL as isFirefox
};
