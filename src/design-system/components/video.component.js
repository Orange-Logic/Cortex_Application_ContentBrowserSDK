import { g as Cg, a as Qn, c as Fa } from "../chunks/_commonjsHelpers.BVfed4GL.js";
import { C as ux } from "../chunks/cortex-element.v9MiwbrF.js";
import { c as lx } from "../chunks/component.styles.BLcT4bOa.js";
import { w as Ad } from "../chunks/watch.ChG-_stu.js";
import { x as Rm } from "../chunks/lit-element.DRlPF2me.js";
import { t as cx } from "../chunks/custom-element.ttkHUa8w.js";
import { n as en } from "../chunks/property.CtZ87in4.js";
import { r as Kn } from "../chunks/state.-o_YRGMi.js";
import { e as ih } from "../chunks/query.BNveAlQo.js";
import { r as hx } from "../chunks/query-async.DsOC4YLE.js";
import { e as Im } from "../chunks/class-map.Cn0czwWq.js";
import { n as fx } from "../chunks/when.CDK1Tt5Y.js";
import dx from "./resize-observer.component.js";
import px from "./skeleton.component.js";
import { INACTIVITY_TIMEOUT as mx, AUTOPLAY_TIMEOUT as vx } from "./video.constants.js";
import gx from "./video.styles.js";
function ze(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Ns(e, t) {
  return Ns = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, Ns(e, t);
}
function Se(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Ns(e, t);
}
const yx = {}, _x = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: yx
}, Symbol.toStringTag, { value: "Module" })), bx = /* @__PURE__ */ Cg(_x);
var Om = typeof Fa < "u" ? Fa : typeof window < "u" ? window : {}, xx = bx, eu;
typeof document < "u" ? eu = document : (eu = Om["__GLOBAL_DOCUMENT_CACHE@4"], eu || (eu = Om["__GLOBAL_DOCUMENT_CACHE@4"] = xx));
var Mg = eu;
const Te = /* @__PURE__ */ Qn(Mg);
var tu;
typeof window < "u" ? tu = window : typeof Fa < "u" ? tu = Fa : typeof self < "u" ? tu = self : tu = {};
var nh = tu;
const j = /* @__PURE__ */ Qn(nh);
Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52));
Number.isInteger === void 0 && (Number.isInteger = function(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
});
Math.sign === void 0 && (Math.sign = function(e) {
  return e < 0 ? -1 : e > 0 ? 1 : +e;
});
"name" in Function.prototype || Object.defineProperty(Function.prototype, "name", {
  get: function() {
    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
  }
});
Object.assign === void 0 && function() {
  Object.assign = function(e) {
    if (e == null)
      throw new TypeError("Cannot convert undefined or null to object");
    for (var t = Object(e), r = 1; r < arguments.length; r++) {
      var n = arguments[r];
      if (n != null)
        for (var i in n)
          Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  };
}();
function $n() {
}
Object.assign($n.prototype, {
  addEventListener: function(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    var r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  },
  hasEventListener: function(e, t) {
    if (this._listeners === void 0) return !1;
    var r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  },
  removeEventListener: function(e, t) {
    if (this._listeners !== void 0) {
      var r = this._listeners, n = r[e];
      if (n !== void 0) {
        var i = n.indexOf(t);
        i !== -1 && n.splice(i, 1);
      }
    }
  },
  dispatchEvent: function(e) {
    if (this._listeners !== void 0) {
      var t = this._listeners, r = t[e.type];
      if (r !== void 0) {
        e.target = this;
        for (var n = r.slice(0), i = 0, a = n.length; i < a; i++)
          n[i].call(this, e);
      }
    }
  }
});
var Dg = "93", Ax = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, Pg = 0, Ef = 1, Lg = 2, Tx = 3, Ex = 0, wx = 1, Sx = 0, Td = 1, Rg = 2, yl = 0, Tr = 1, Ro = 2, Ed = 1, Cx = 2, ah = 0, wd = 1, ds = 2, sc = 0, _l = 1, Sd = 2, Cd = 3, Md = 4, Dd = 5, Pd = 100, Ig = 101, Og = 102, wf = 103, Sf = 104, Bg = 200, Fg = 201, kg = 202, Ng = 203, Ld = 204, Rd = 205, Ug = 206, Gg = 207, Vg = 208, Hg = 209, zg = 210, Wg = 0, jg = 1, qg = 2, oc = 3, Xg = 4, Yg = 5, Qg = 6, Kg = 7, bl = 0, $g = 1, Zg = 2, Zl = 0, Id = 1, Jg = 2, e0 = 3, t0 = 4, sh = 300, oh = 301, uc = 302, Od = 303, lc = 304, Bd = 305, uh = 306, lh = 307, On = 1e3, Ei = 1001, za = 1002, wi = 1003, ch = 1004, hh = 1005, Vr = 1006, Fd = 1007, xl = 1008, fh = 1009, r0 = 1010, i0 = 1011, pu = 1012, n0 = 1013, kd = 1014, Us = 1015, dh = 1016, a0 = 1017, s0 = 1018, o0 = 1019, mu = 1020, u0 = 1021, Wa = 1022, yn = 1023, l0 = 1024, c0 = 1025, Mx = yn, ka = 1026, Gs = 1027, Cf = 33776, Mf = 33777, Df = 33778, Pf = 33779, Lf = 35840, Rf = 35841, If = 35842, Of = 35843, h0 = 36196, f0 = 37808, d0 = 37809, p0 = 37810, m0 = 37811, v0 = 37812, g0 = 37813, y0 = 37814, _0 = 37815, b0 = 37816, x0 = 37817, A0 = 37818, T0 = 37819, E0 = 37820, w0 = 37821, S0 = 2200, C0 = 2201, M0 = 2202, vu = 2300, ou = 2301, Jl = 2302, ja = 2400, Ia = 2401, gu = 2402, Nd = 0, D0 = 1, P0 = 2, yu = 3e3, L0 = 3001, Ud = 3007, R0 = 3002, Dx = 3003, I0 = 3004, O0 = 3005, B0 = 3006, F0 = 3200, k0 = 3201, gt = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    for (var e = [], t = 0; t < 256; t++)
      e[t] = (t < 16 ? "0" : "") + t.toString(16);
    return function() {
      var n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, a = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0, o = e[n & 255] + e[n >> 8 & 255] + e[n >> 16 & 255] + e[n >> 24 & 255] + "-" + e[i & 255] + e[i >> 8 & 255] + "-" + e[i >> 16 & 15 | 64] + e[i >> 24 & 255] + "-" + e[a & 63 | 128] + e[a >> 8 & 255] + "-" + e[a >> 16 & 255] + e[a >> 24 & 255] + e[s & 255] + e[s >> 8 & 255] + e[s >> 16 & 255] + e[s >> 24 & 255];
      return o.toUpperCase();
    };
  }(),
  clamp: function(e, t, r) {
    return Math.max(t, Math.min(r, e));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function(e, t) {
    return (e % t + t) % t;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function(e, t, r, n, i) {
    return n + (e - t) * (i - n) / (r - t);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function(e, t, r) {
    return (1 - r) * e + r * t;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function(e, t, r) {
    return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t), e * e * (3 - 2 * e));
  },
  smootherstep: function(e, t, r) {
    return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t), e * e * e * (e * (e * 6 - 15) + 10));
  },
  // Random integer from <low, high> interval
  randInt: function(e, t) {
    return e + Math.floor(Math.random() * (t - e + 1));
  },
  // Random float from <low, high> interval
  randFloat: function(e, t) {
    return e + Math.random() * (t - e);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function(e) {
    return e * (0.5 - Math.random());
  },
  degToRad: function(e) {
    return e * gt.DEG2RAD;
  },
  radToDeg: function(e) {
    return e * gt.RAD2DEG;
  },
  isPowerOfTwo: function(e) {
    return (e & e - 1) === 0 && e !== 0;
  },
  ceilPowerOfTwo: function(e) {
    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
  },
  floorPowerOfTwo: function(e) {
    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
  }
};
function ue(e, t) {
  this.x = e || 0, this.y = t || 0;
}
Object.defineProperties(ue.prototype, {
  width: {
    get: function() {
      return this.x;
    },
    set: function(e) {
      this.x = e;
    }
  },
  height: {
    get: function() {
      return this.y;
    },
    set: function(e) {
      this.y = e;
    }
  }
});
Object.assign(ue.prototype, {
  isVector2: !0,
  set: function(e, t) {
    return this.x = e, this.y = t, this;
  },
  setScalar: function(e) {
    return this.x = e, this.y = e, this;
  },
  setX: function(e) {
    return this.x = e, this;
  },
  setY: function(e) {
    return this.y = e, this;
  },
  setComponent: function(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  },
  getComponent: function(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y);
  },
  copy: function(e) {
    return this.x = e.x, this.y = e.y, this;
  },
  add: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this);
  },
  addScalar: function(e) {
    return this.x += e, this.y += e, this;
  },
  addVectors: function(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  },
  addScaledVector: function(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  },
  sub: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this);
  },
  subScalar: function(e) {
    return this.x -= e, this.y -= e, this;
  },
  subVectors: function(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  },
  multiply: function(e) {
    return this.x *= e.x, this.y *= e.y, this;
  },
  multiplyScalar: function(e) {
    return this.x *= e, this.y *= e, this;
  },
  divide: function(e) {
    return this.x /= e.x, this.y /= e.y, this;
  },
  divideScalar: function(e) {
    return this.multiplyScalar(1 / e);
  },
  applyMatrix3: function(e) {
    var t = this.x, r = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * r + n[6], this.y = n[1] * t + n[4] * r + n[7], this;
  },
  min: function(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  },
  max: function(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  },
  clamp: function(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  },
  clampScalar: function() {
    var e = new ue(), t = new ue();
    return function(n, i) {
      return e.set(n, n), t.set(i, i), this.clamp(e, t);
    };
  }(),
  clampLength: function(e, t) {
    var r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this;
  },
  dot: function(e) {
    return this.x * e.x + this.y * e.y;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  angle: function() {
    var e = Math.atan2(this.y, this.x);
    return e < 0 && (e += 2 * Math.PI), e;
  },
  distanceTo: function(e) {
    return Math.sqrt(this.distanceToSquared(e));
  },
  distanceToSquared: function(e) {
    var t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  },
  manhattanDistanceTo: function(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  },
  setLength: function(e) {
    return this.normalize().multiplyScalar(e);
  },
  lerp: function(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  },
  lerpVectors: function(e, t, r) {
    return this.subVectors(t, e).multiplyScalar(r).add(e);
  },
  equals: function(e) {
    return e.x === this.x && e.y === this.y;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e;
  },
  fromBufferAttribute: function(e, t, r) {
    return r !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this;
  },
  rotateAround: function(e, t) {
    var r = Math.cos(t), n = Math.sin(t), i = this.x - e.x, a = this.y - e.y;
    return this.x = i * r - a * n + e.x, this.y = i * n + a * r + e.y, this;
  }
});
function at() {
  this.elements = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(at.prototype, {
  isMatrix4: !0,
  set: function(e, t, r, n, i, a, s, o, u, l, c, h, f, d, p, _) {
    var v = this.elements;
    return v[0] = e, v[4] = t, v[8] = r, v[12] = n, v[1] = i, v[5] = a, v[9] = s, v[13] = o, v[2] = u, v[6] = l, v[10] = c, v[14] = h, v[3] = f, v[7] = d, v[11] = p, v[15] = _, this;
  },
  identity: function() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  clone: function() {
    return new at().fromArray(this.elements);
  },
  copy: function(e) {
    var t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  },
  copyPosition: function(e) {
    var t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  },
  extractBasis: function(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  },
  makeBasis: function(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  extractRotation: function() {
    var e = new z();
    return function(r) {
      var n = this.elements, i = r.elements, a = 1 / e.setFromMatrixColumn(r, 0).length(), s = 1 / e.setFromMatrixColumn(r, 1).length(), o = 1 / e.setFromMatrixColumn(r, 2).length();
      return n[0] = i[0] * a, n[1] = i[1] * a, n[2] = i[2] * a, n[3] = 0, n[4] = i[4] * s, n[5] = i[5] * s, n[6] = i[6] * s, n[7] = 0, n[8] = i[8] * o, n[9] = i[9] * o, n[10] = i[10] * o, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
    };
  }(),
  makeRotationFromEuler: function(e) {
    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    var t = this.elements, r = e.x, n = e.y, i = e.z, a = Math.cos(r), s = Math.sin(r), o = Math.cos(n), u = Math.sin(n), l = Math.cos(i), c = Math.sin(i);
    if (e.order === "XYZ") {
      var h = a * l, f = a * c, d = s * l, p = s * c;
      t[0] = o * l, t[4] = -o * c, t[8] = u, t[1] = f + d * u, t[5] = h - p * u, t[9] = -s * o, t[2] = p - h * u, t[6] = d + f * u, t[10] = a * o;
    } else if (e.order === "YXZ") {
      var _ = o * l, v = o * c, x = u * l, E = u * c;
      t[0] = _ + E * s, t[4] = x * s - v, t[8] = a * u, t[1] = a * c, t[5] = a * l, t[9] = -s, t[2] = v * s - x, t[6] = E + _ * s, t[10] = a * o;
    } else if (e.order === "ZXY") {
      var _ = o * l, v = o * c, x = u * l, E = u * c;
      t[0] = _ - E * s, t[4] = -a * c, t[8] = x + v * s, t[1] = v + x * s, t[5] = a * l, t[9] = E - _ * s, t[2] = -a * u, t[6] = s, t[10] = a * o;
    } else if (e.order === "ZYX") {
      var h = a * l, f = a * c, d = s * l, p = s * c;
      t[0] = o * l, t[4] = d * u - f, t[8] = h * u + p, t[1] = o * c, t[5] = p * u + h, t[9] = f * u - d, t[2] = -u, t[6] = s * o, t[10] = a * o;
    } else if (e.order === "YZX") {
      var M = a * o, C = a * u, R = s * o, B = s * u;
      t[0] = o * l, t[4] = B - M * c, t[8] = R * c + C, t[1] = c, t[5] = a * l, t[9] = -s * l, t[2] = -u * l, t[6] = C * c + R, t[10] = M - B * c;
    } else if (e.order === "XZY") {
      var M = a * o, C = a * u, R = s * o, B = s * u;
      t[0] = o * l, t[4] = -c, t[8] = u * l, t[1] = M * c + B, t[5] = a * l, t[9] = C * c - R, t[2] = R * c - C, t[6] = s * l, t[10] = B * c + M;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  },
  makeRotationFromQuaternion: function() {
    var e = new z(0, 0, 0), t = new z(1, 1, 1);
    return function(n) {
      return this.compose(e, n, t);
    };
  }(),
  lookAt: function() {
    var e = new z(), t = new z(), r = new z();
    return function(i, a, s) {
      var o = this.elements;
      return r.subVectors(i, a), r.lengthSq() === 0 && (r.z = 1), r.normalize(), e.crossVectors(s, r), e.lengthSq() === 0 && (Math.abs(s.z) === 1 ? r.x += 1e-4 : r.z += 1e-4, r.normalize(), e.crossVectors(s, r)), e.normalize(), t.crossVectors(r, e), o[0] = e.x, o[4] = t.x, o[8] = r.x, o[1] = e.y, o[5] = t.y, o[9] = r.y, o[2] = e.z, o[6] = t.z, o[10] = r.z, this;
    };
  }(),
  multiply: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e);
  },
  premultiply: function(e) {
    return this.multiplyMatrices(e, this);
  },
  multiplyMatrices: function(e, t) {
    var r = e.elements, n = t.elements, i = this.elements, a = r[0], s = r[4], o = r[8], u = r[12], l = r[1], c = r[5], h = r[9], f = r[13], d = r[2], p = r[6], _ = r[10], v = r[14], x = r[3], E = r[7], M = r[11], C = r[15], R = n[0], B = n[4], k = n[8], F = n[12], I = n[1], H = n[5], Q = n[9], ee = n[13], oe = n[2], de = n[6], he = n[10], fe = n[14], V = n[3], G = n[7], se = n[11], re = n[15];
    return i[0] = a * R + s * I + o * oe + u * V, i[4] = a * B + s * H + o * de + u * G, i[8] = a * k + s * Q + o * he + u * se, i[12] = a * F + s * ee + o * fe + u * re, i[1] = l * R + c * I + h * oe + f * V, i[5] = l * B + c * H + h * de + f * G, i[9] = l * k + c * Q + h * he + f * se, i[13] = l * F + c * ee + h * fe + f * re, i[2] = d * R + p * I + _ * oe + v * V, i[6] = d * B + p * H + _ * de + v * G, i[10] = d * k + p * Q + _ * he + v * se, i[14] = d * F + p * ee + _ * fe + v * re, i[3] = x * R + E * I + M * oe + C * V, i[7] = x * B + E * H + M * de + C * G, i[11] = x * k + E * Q + M * he + C * se, i[15] = x * F + E * ee + M * fe + C * re, this;
  },
  multiplyScalar: function(e) {
    var t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  },
  applyToBufferAttribute: function() {
    var e = new z();
    return function(r) {
      for (var n = 0, i = r.count; n < i; n++)
        e.x = r.getX(n), e.y = r.getY(n), e.z = r.getZ(n), e.applyMatrix4(this), r.setXYZ(n, e.x, e.y, e.z);
      return r;
    };
  }(),
  determinant: function() {
    var e = this.elements, t = e[0], r = e[4], n = e[8], i = e[12], a = e[1], s = e[5], o = e[9], u = e[13], l = e[2], c = e[6], h = e[10], f = e[14], d = e[3], p = e[7], _ = e[11], v = e[15];
    return d * (+i * o * c - n * u * c - i * s * h + r * u * h + n * s * f - r * o * f) + p * (+t * o * f - t * u * h + i * a * h - n * a * f + n * u * l - i * o * l) + _ * (+t * u * c - t * s * f - i * a * c + r * a * f + i * s * l - r * u * l) + v * (-n * s * l - t * o * c + t * s * h + n * a * c - r * a * h + r * o * l);
  },
  transpose: function() {
    var e = this.elements, t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  },
  setPosition: function(e) {
    var t = this.elements;
    return t[12] = e.x, t[13] = e.y, t[14] = e.z, this;
  },
  getInverse: function(e, t) {
    var r = this.elements, n = e.elements, i = n[0], a = n[1], s = n[2], o = n[3], u = n[4], l = n[5], c = n[6], h = n[7], f = n[8], d = n[9], p = n[10], _ = n[11], v = n[12], x = n[13], E = n[14], M = n[15], C = d * E * h - x * p * h + x * c * _ - l * E * _ - d * c * M + l * p * M, R = v * p * h - f * E * h - v * c * _ + u * E * _ + f * c * M - u * p * M, B = f * x * h - v * d * h + v * l * _ - u * x * _ - f * l * M + u * d * M, k = v * d * c - f * x * c - v * l * p + u * x * p + f * l * E - u * d * E, F = i * C + a * R + s * B + o * k;
    if (F === 0) {
      var I = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
      if (t === !0)
        throw new Error(I);
      return console.warn(I), this.identity();
    }
    var H = 1 / F;
    return r[0] = C * H, r[1] = (x * p * o - d * E * o - x * s * _ + a * E * _ + d * s * M - a * p * M) * H, r[2] = (l * E * o - x * c * o + x * s * h - a * E * h - l * s * M + a * c * M) * H, r[3] = (d * c * o - l * p * o - d * s * h + a * p * h + l * s * _ - a * c * _) * H, r[4] = R * H, r[5] = (f * E * o - v * p * o + v * s * _ - i * E * _ - f * s * M + i * p * M) * H, r[6] = (v * c * o - u * E * o - v * s * h + i * E * h + u * s * M - i * c * M) * H, r[7] = (u * p * o - f * c * o + f * s * h - i * p * h - u * s * _ + i * c * _) * H, r[8] = B * H, r[9] = (v * d * o - f * x * o - v * a * _ + i * x * _ + f * a * M - i * d * M) * H, r[10] = (u * x * o - v * l * o + v * a * h - i * x * h - u * a * M + i * l * M) * H, r[11] = (f * l * o - u * d * o - f * a * h + i * d * h + u * a * _ - i * l * _) * H, r[12] = k * H, r[13] = (f * x * s - v * d * s + v * a * p - i * x * p - f * a * E + i * d * E) * H, r[14] = (v * l * s - u * x * s - v * a * c + i * x * c + u * a * E - i * l * E) * H, r[15] = (u * d * s - f * l * s + f * a * c - i * d * c - u * a * p + i * l * p) * H, this;
  },
  scale: function(e) {
    var t = this.elements, r = e.x, n = e.y, i = e.z;
    return t[0] *= r, t[4] *= n, t[8] *= i, t[1] *= r, t[5] *= n, t[9] *= i, t[2] *= r, t[6] *= n, t[10] *= i, t[3] *= r, t[7] *= n, t[11] *= i, this;
  },
  getMaxScaleOnAxis: function() {
    var e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, n));
  },
  makeTranslation: function(e, t, r) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationX: function(e) {
    var t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationY: function(e) {
    var t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationZ: function(e) {
    var t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationAxis: function(e, t) {
    var r = Math.cos(t), n = Math.sin(t), i = 1 - r, a = e.x, s = e.y, o = e.z, u = i * a, l = i * s;
    return this.set(
      u * a + r,
      u * s - n * o,
      u * o + n * s,
      0,
      u * s + n * o,
      l * s + r,
      l * o - n * a,
      0,
      u * o - n * s,
      l * o + n * a,
      i * o * o + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeScale: function(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeShear: function(e, t, r) {
    return this.set(
      1,
      t,
      r,
      0,
      e,
      1,
      r,
      0,
      e,
      t,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  compose: function(e, t, r) {
    var n = this.elements, i = t._x, a = t._y, s = t._z, o = t._w, u = i + i, l = a + a, c = s + s, h = i * u, f = i * l, d = i * c, p = a * l, _ = a * c, v = s * c, x = o * u, E = o * l, M = o * c, C = r.x, R = r.y, B = r.z;
    return n[0] = (1 - (p + v)) * C, n[1] = (f + M) * C, n[2] = (d - E) * C, n[3] = 0, n[4] = (f - M) * R, n[5] = (1 - (h + v)) * R, n[6] = (_ + x) * R, n[7] = 0, n[8] = (d + E) * B, n[9] = (_ - x) * B, n[10] = (1 - (h + p)) * B, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  },
  decompose: function() {
    var e = new z(), t = new at();
    return function(n, i, a) {
      var s = this.elements, o = e.set(s[0], s[1], s[2]).length(), u = e.set(s[4], s[5], s[6]).length(), l = e.set(s[8], s[9], s[10]).length(), c = this.determinant();
      c < 0 && (o = -o), n.x = s[12], n.y = s[13], n.z = s[14], t.copy(this);
      var h = 1 / o, f = 1 / u, d = 1 / l;
      return t.elements[0] *= h, t.elements[1] *= h, t.elements[2] *= h, t.elements[4] *= f, t.elements[5] *= f, t.elements[6] *= f, t.elements[8] *= d, t.elements[9] *= d, t.elements[10] *= d, i.setFromRotationMatrix(t), a.x = o, a.y = u, a.z = l, this;
    };
  }(),
  makePerspective: function(e, t, r, n, i, a) {
    a === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    var s = this.elements, o = 2 * i / (t - e), u = 2 * i / (r - n), l = (t + e) / (t - e), c = (r + n) / (r - n), h = -(a + i) / (a - i), f = -2 * a * i / (a - i);
    return s[0] = o, s[4] = 0, s[8] = l, s[12] = 0, s[1] = 0, s[5] = u, s[9] = c, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = f, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this;
  },
  makeOrthographic: function(e, t, r, n, i, a) {
    var s = this.elements, o = 1 / (t - e), u = 1 / (r - n), l = 1 / (a - i), c = (t + e) * o, h = (r + n) * u, f = (a + i) * l;
    return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -c, s[1] = 0, s[5] = 2 * u, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = -2 * l, s[14] = -f, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this;
  },
  equals: function(e) {
    for (var t = this.elements, r = e.elements, n = 0; n < 16; n++)
      if (t[n] !== r[n]) return !1;
    return !0;
  },
  fromArray: function(e, t) {
    t === void 0 && (t = 0);
    for (var r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  },
  toArray: function(e, t) {
    e === void 0 && (e = []), t === void 0 && (t = 0);
    var r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
});
function _r(e, t, r, n) {
  this._x = e || 0, this._y = t || 0, this._z = r || 0, this._w = n !== void 0 ? n : 1;
}
Object.assign(_r, {
  slerp: function(e, t, r, n) {
    return r.copy(e).slerp(t, n);
  },
  slerpFlat: function(e, t, r, n, i, a, s) {
    var o = r[n + 0], u = r[n + 1], l = r[n + 2], c = r[n + 3], h = i[a + 0], f = i[a + 1], d = i[a + 2], p = i[a + 3];
    if (c !== p || o !== h || u !== f || l !== d) {
      var _ = 1 - s, v = o * h + u * f + l * d + c * p, x = v >= 0 ? 1 : -1, E = 1 - v * v;
      if (E > Number.EPSILON) {
        var M = Math.sqrt(E), C = Math.atan2(M, v * x);
        _ = Math.sin(_ * C) / M, s = Math.sin(s * C) / M;
      }
      var R = s * x;
      if (o = o * _ + h * R, u = u * _ + f * R, l = l * _ + d * R, c = c * _ + p * R, _ === 1 - s) {
        var B = 1 / Math.sqrt(o * o + u * u + l * l + c * c);
        o *= B, u *= B, l *= B, c *= B;
      }
    }
    e[t] = o, e[t + 1] = u, e[t + 2] = l, e[t + 3] = c;
  }
});
Object.defineProperties(_r.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(e) {
      this._x = e, this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(e) {
      this._y = e, this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(e) {
      this._z = e, this.onChangeCallback();
    }
  },
  w: {
    get: function() {
      return this._w;
    },
    set: function(e) {
      this._w = e, this.onChangeCallback();
    }
  }
});
Object.assign(_r.prototype, {
  set: function(e, t, r, n) {
    return this._x = e, this._y = t, this._z = r, this._w = n, this.onChangeCallback(), this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this;
  },
  setFromEuler: function(e, t) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    var r = e._x, n = e._y, i = e._z, a = e.order, s = Math.cos, o = Math.sin, u = s(r / 2), l = s(n / 2), c = s(i / 2), h = o(r / 2), f = o(n / 2), d = o(i / 2);
    return a === "XYZ" ? (this._x = h * l * c + u * f * d, this._y = u * f * c - h * l * d, this._z = u * l * d + h * f * c, this._w = u * l * c - h * f * d) : a === "YXZ" ? (this._x = h * l * c + u * f * d, this._y = u * f * c - h * l * d, this._z = u * l * d - h * f * c, this._w = u * l * c + h * f * d) : a === "ZXY" ? (this._x = h * l * c - u * f * d, this._y = u * f * c + h * l * d, this._z = u * l * d + h * f * c, this._w = u * l * c - h * f * d) : a === "ZYX" ? (this._x = h * l * c - u * f * d, this._y = u * f * c + h * l * d, this._z = u * l * d - h * f * c, this._w = u * l * c + h * f * d) : a === "YZX" ? (this._x = h * l * c + u * f * d, this._y = u * f * c + h * l * d, this._z = u * l * d - h * f * c, this._w = u * l * c - h * f * d) : a === "XZY" && (this._x = h * l * c - u * f * d, this._y = u * f * c - h * l * d, this._z = u * l * d + h * f * c, this._w = u * l * c + h * f * d), t !== !1 && this.onChangeCallback(), this;
  },
  setFromAxisAngle: function(e, t) {
    var r = t / 2, n = Math.sin(r);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(r), this.onChangeCallback(), this;
  },
  setFromRotationMatrix: function(e) {
    var t = e.elements, r = t[0], n = t[4], i = t[8], a = t[1], s = t[5], o = t[9], u = t[2], l = t[6], c = t[10], h = r + s + c, f;
    return h > 0 ? (f = 0.5 / Math.sqrt(h + 1), this._w = 0.25 / f, this._x = (l - o) * f, this._y = (i - u) * f, this._z = (a - n) * f) : r > s && r > c ? (f = 2 * Math.sqrt(1 + r - s - c), this._w = (l - o) / f, this._x = 0.25 * f, this._y = (n + a) / f, this._z = (i + u) / f) : s > c ? (f = 2 * Math.sqrt(1 + s - r - c), this._w = (i - u) / f, this._x = (n + a) / f, this._y = 0.25 * f, this._z = (o + l) / f) : (f = 2 * Math.sqrt(1 + c - r - s), this._w = (a - n) / f, this._x = (i + u) / f, this._y = (o + l) / f, this._z = 0.25 * f), this.onChangeCallback(), this;
  },
  setFromUnitVectors: function() {
    var e = new z(), t, r = 1e-6;
    return function(i, a) {
      return e === void 0 && (e = new z()), t = i.dot(a) + 1, t < r ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, a), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize();
    };
  }(),
  inverse: function() {
    return this.conjugate();
  },
  conjugate: function() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
  },
  dot: function(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  },
  lengthSq: function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function() {
    var e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this;
  },
  multiply: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e);
  },
  premultiply: function(e) {
    return this.multiplyQuaternions(e, this);
  },
  multiplyQuaternions: function(e, t) {
    var r = e._x, n = e._y, i = e._z, a = e._w, s = t._x, o = t._y, u = t._z, l = t._w;
    return this._x = r * l + a * s + n * u - i * o, this._y = n * l + a * o + i * s - r * u, this._z = i * l + a * u + r * o - n * s, this._w = a * l - r * s - n * o - i * u, this.onChangeCallback(), this;
  },
  slerp: function(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    var r = this._x, n = this._y, i = this._z, a = this._w, s = a * e._w + r * e._x + n * e._y + i * e._z;
    if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1)
      return this._w = a, this._x = r, this._y = n, this._z = i, this;
    var o = Math.sqrt(1 - s * s);
    if (Math.abs(o) < 1e-3)
      return this._w = 0.5 * (a + this._w), this._x = 0.5 * (r + this._x), this._y = 0.5 * (n + this._y), this._z = 0.5 * (i + this._z), this;
    var u = Math.atan2(o, s), l = Math.sin((1 - t) * u) / o, c = Math.sin(t * u) / o;
    return this._w = a * l + this._w * c, this._x = r * l + this._x * c, this._y = n * l + this._y * c, this._z = i * l + this._z * c, this.onChangeCallback(), this;
  },
  equals: function(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  },
  onChange: function(e) {
    return this.onChangeCallback = e, this;
  },
  onChangeCallback: function() {
  }
});
function z(e, t, r) {
  this.x = e || 0, this.y = t || 0, this.z = r || 0;
}
Object.assign(z.prototype, {
  isVector3: !0,
  set: function(e, t, r) {
    return this.x = e, this.y = t, this.z = r, this;
  },
  setScalar: function(e) {
    return this.x = e, this.y = e, this.z = e, this;
  },
  setX: function(e) {
    return this.x = e, this;
  },
  setY: function(e) {
    return this.y = e, this;
  },
  setZ: function(e) {
    return this.z = e, this;
  },
  setComponent: function(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  },
  getComponent: function(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  },
  add: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this);
  },
  addScalar: function(e) {
    return this.x += e, this.y += e, this.z += e, this;
  },
  addVectors: function(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  },
  addScaledVector: function(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  },
  sub: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
  },
  subScalar: function(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  },
  subVectors: function(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  },
  multiply: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
  },
  multiplyScalar: function(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  },
  multiplyVectors: function(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  },
  applyEuler: function() {
    var e = new _r();
    return function(r) {
      return r && r.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(e.setFromEuler(r));
    };
  }(),
  applyAxisAngle: function() {
    var e = new _r();
    return function(r, n) {
      return this.applyQuaternion(e.setFromAxisAngle(r, n));
    };
  }(),
  applyMatrix3: function(e) {
    var t = this.x, r = this.y, n = this.z, i = e.elements;
    return this.x = i[0] * t + i[3] * r + i[6] * n, this.y = i[1] * t + i[4] * r + i[7] * n, this.z = i[2] * t + i[5] * r + i[8] * n, this;
  },
  applyMatrix4: function(e) {
    var t = this.x, r = this.y, n = this.z, i = e.elements, a = 1 / (i[3] * t + i[7] * r + i[11] * n + i[15]);
    return this.x = (i[0] * t + i[4] * r + i[8] * n + i[12]) * a, this.y = (i[1] * t + i[5] * r + i[9] * n + i[13]) * a, this.z = (i[2] * t + i[6] * r + i[10] * n + i[14]) * a, this;
  },
  applyQuaternion: function(e) {
    var t = this.x, r = this.y, n = this.z, i = e.x, a = e.y, s = e.z, o = e.w, u = o * t + a * n - s * r, l = o * r + s * t - i * n, c = o * n + i * r - a * t, h = -i * t - a * r - s * n;
    return this.x = u * o + h * -i + l * -s - c * -a, this.y = l * o + h * -a + c * -i - u * -s, this.z = c * o + h * -s + u * -a - l * -i, this;
  },
  project: function() {
    var e = new at();
    return function(r) {
      return e.multiplyMatrices(r.projectionMatrix, e.getInverse(r.matrixWorld)), this.applyMatrix4(e);
    };
  }(),
  unproject: function() {
    var e = new at();
    return function(r) {
      return e.multiplyMatrices(r.matrixWorld, e.getInverse(r.projectionMatrix)), this.applyMatrix4(e);
    };
  }(),
  transformDirection: function(e) {
    var t = this.x, r = this.y, n = this.z, i = e.elements;
    return this.x = i[0] * t + i[4] * r + i[8] * n, this.y = i[1] * t + i[5] * r + i[9] * n, this.z = i[2] * t + i[6] * r + i[10] * n, this.normalize();
  },
  divide: function(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  },
  divideScalar: function(e) {
    return this.multiplyScalar(1 / e);
  },
  min: function(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  },
  max: function(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  },
  clamp: function(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  },
  clampScalar: function() {
    var e = new z(), t = new z();
    return function(n, i) {
      return e.set(n, n, n), t.set(i, i, i), this.clamp(e, t);
    };
  }(),
  clampLength: function(e, t) {
    var r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  },
  dot: function(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  },
  // TODO lengthSquared?
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(e) {
    return this.normalize().multiplyScalar(e);
  },
  lerp: function(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  },
  lerpVectors: function(e, t, r) {
    return this.subVectors(t, e).multiplyScalar(r).add(e);
  },
  cross: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e);
  },
  crossVectors: function(e, t) {
    var r = e.x, n = e.y, i = e.z, a = t.x, s = t.y, o = t.z;
    return this.x = n * o - i * s, this.y = i * a - r * o, this.z = r * s - n * a, this;
  },
  projectOnVector: function(e) {
    var t = e.dot(this) / e.lengthSq();
    return this.copy(e).multiplyScalar(t);
  },
  projectOnPlane: function() {
    var e = new z();
    return function(r) {
      return e.copy(this).projectOnVector(r), this.sub(e);
    };
  }(),
  reflect: function() {
    var e = new z();
    return function(r) {
      return this.sub(e.copy(r).multiplyScalar(2 * this.dot(r)));
    };
  }(),
  angleTo: function(e) {
    var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
    return Math.acos(gt.clamp(t, -1, 1));
  },
  distanceTo: function(e) {
    return Math.sqrt(this.distanceToSquared(e));
  },
  distanceToSquared: function(e) {
    var t = this.x - e.x, r = this.y - e.y, n = this.z - e.z;
    return t * t + r * r + n * n;
  },
  manhattanDistanceTo: function(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  },
  setFromSpherical: function(e) {
    var t = Math.sin(e.phi) * e.radius;
    return this.x = t * Math.sin(e.theta), this.y = Math.cos(e.phi) * e.radius, this.z = t * Math.cos(e.theta), this;
  },
  setFromCylindrical: function(e) {
    return this.x = e.radius * Math.sin(e.theta), this.y = e.y, this.z = e.radius * Math.cos(e.theta), this;
  },
  setFromMatrixPosition: function(e) {
    var t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  },
  setFromMatrixScale: function(e) {
    var t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = n, this;
  },
  setFromMatrixColumn: function(e, t) {
    return this.fromArray(e.elements, t * 4);
  },
  equals: function(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  },
  fromBufferAttribute: function(e, t, r) {
    return r !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
});
function wr() {
  this.elements = [
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(wr.prototype, {
  isMatrix3: !0,
  set: function(e, t, r, n, i, a, s, o, u) {
    var l = this.elements;
    return l[0] = e, l[1] = n, l[2] = s, l[3] = t, l[4] = i, l[5] = o, l[6] = r, l[7] = a, l[8] = u, this;
  },
  identity: function() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  },
  clone: function() {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function(e) {
    var t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  },
  setFromMatrix4: function(e) {
    var t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  },
  applyToBufferAttribute: function() {
    var e = new z();
    return function(r) {
      for (var n = 0, i = r.count; n < i; n++)
        e.x = r.getX(n), e.y = r.getY(n), e.z = r.getZ(n), e.applyMatrix3(this), r.setXYZ(n, e.x, e.y, e.z);
      return r;
    };
  }(),
  multiply: function(e) {
    return this.multiplyMatrices(this, e);
  },
  premultiply: function(e) {
    return this.multiplyMatrices(e, this);
  },
  multiplyMatrices: function(e, t) {
    var r = e.elements, n = t.elements, i = this.elements, a = r[0], s = r[3], o = r[6], u = r[1], l = r[4], c = r[7], h = r[2], f = r[5], d = r[8], p = n[0], _ = n[3], v = n[6], x = n[1], E = n[4], M = n[7], C = n[2], R = n[5], B = n[8];
    return i[0] = a * p + s * x + o * C, i[3] = a * _ + s * E + o * R, i[6] = a * v + s * M + o * B, i[1] = u * p + l * x + c * C, i[4] = u * _ + l * E + c * R, i[7] = u * v + l * M + c * B, i[2] = h * p + f * x + d * C, i[5] = h * _ + f * E + d * R, i[8] = h * v + f * M + d * B, this;
  },
  multiplyScalar: function(e) {
    var t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  },
  determinant: function() {
    var e = this.elements, t = e[0], r = e[1], n = e[2], i = e[3], a = e[4], s = e[5], o = e[6], u = e[7], l = e[8];
    return t * a * l - t * s * u - r * i * l + r * s * o + n * i * u - n * a * o;
  },
  getInverse: function(e, t) {
    e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
    var r = e.elements, n = this.elements, i = r[0], a = r[1], s = r[2], o = r[3], u = r[4], l = r[5], c = r[6], h = r[7], f = r[8], d = f * u - l * h, p = l * c - f * o, _ = h * o - u * c, v = i * d + a * p + s * _;
    if (v === 0) {
      var x = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
      if (t === !0)
        throw new Error(x);
      return console.warn(x), this.identity();
    }
    var E = 1 / v;
    return n[0] = d * E, n[1] = (s * h - f * a) * E, n[2] = (l * a - s * u) * E, n[3] = p * E, n[4] = (f * i - s * c) * E, n[5] = (s * o - l * i) * E, n[6] = _ * E, n[7] = (a * c - h * i) * E, n[8] = (u * i - a * o) * E, this;
  },
  transpose: function() {
    var e, t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  },
  getNormalMatrix: function(e) {
    return this.setFromMatrix4(e).getInverse(this).transpose();
  },
  transposeIntoArray: function(e) {
    var t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  },
  setUvTransform: function(e, t, r, n, i, a, s) {
    var o = Math.cos(i), u = Math.sin(i);
    this.set(
      r * o,
      r * u,
      -r * (o * a + u * s) + a + e,
      -n * u,
      n * o,
      -n * (-u * a + o * s) + s + t,
      0,
      0,
      1
    );
  },
  scale: function(e, t) {
    var r = this.elements;
    return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= t, r[4] *= t, r[7] *= t, this;
  },
  rotate: function(e) {
    var t = Math.cos(e), r = Math.sin(e), n = this.elements, i = n[0], a = n[3], s = n[6], o = n[1], u = n[4], l = n[7];
    return n[0] = t * i + r * o, n[3] = t * a + r * u, n[6] = t * s + r * l, n[1] = -r * i + t * o, n[4] = -r * a + t * u, n[7] = -r * s + t * l, this;
  },
  translate: function(e, t) {
    var r = this.elements;
    return r[0] += e * r[2], r[3] += e * r[5], r[6] += e * r[8], r[1] += t * r[2], r[4] += t * r[5], r[7] += t * r[8], this;
  },
  equals: function(e) {
    for (var t = this.elements, r = e.elements, n = 0; n < 9; n++)
      if (t[n] !== r[n]) return !1;
    return !0;
  },
  fromArray: function(e, t) {
    t === void 0 && (t = 0);
    for (var r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  },
  toArray: function(e, t) {
    e === void 0 && (e = []), t === void 0 && (t = 0);
    var r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
});
var Px = 0;
function ir(e, t, r, n, i, a, s, o, u, l) {
  Object.defineProperty(this, "id", { value: Px++ }), this.uuid = gt.generateUUID(), this.name = "", this.image = e !== void 0 ? e : ir.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = t !== void 0 ? t : ir.DEFAULT_MAPPING, this.wrapS = r !== void 0 ? r : Ei, this.wrapT = n !== void 0 ? n : Ei, this.magFilter = i !== void 0 ? i : Vr, this.minFilter = a !== void 0 ? a : xl, this.anisotropy = u !== void 0 ? u : 1, this.format = s !== void 0 ? s : yn, this.type = o !== void 0 ? o : fh, this.offset = new ue(0, 0), this.repeat = new ue(1, 1), this.center = new ue(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new wr(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = l !== void 0 ? l : yu, this.version = 0, this.onUpdate = null;
}
ir.DEFAULT_IMAGE = void 0;
ir.DEFAULT_MAPPING = sh;
ir.prototype = Object.assign(Object.create($n.prototype), {
  constructor: ir,
  isTexture: !0,
  updateMatrix: function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this;
  },
  toJSON: function(e) {
    var t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    function r(a) {
      var s;
      if (a instanceof HTMLCanvasElement)
        s = a;
      else {
        s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), s.width = a.width, s.height = a.height;
        var o = s.getContext("2d");
        a instanceof ImageData ? o.putImageData(a, 0, 0) : o.drawImage(a, 0, 0, a.width, a.height);
      }
      return s.width > 2048 || s.height > 2048 ? s.toDataURL("image/jpeg", 0.6) : s.toDataURL("image/png");
    }
    var n = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY
    };
    if (this.image !== void 0) {
      var i = this.image;
      i.uuid === void 0 && (i.uuid = gt.generateUUID()), !t && e.images[i.uuid] === void 0 && (e.images[i.uuid] = {
        uuid: i.uuid,
        url: r(i)
      }), n.image = i.uuid;
    }
    return t || (e.textures[this.uuid] = n), n;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  },
  transformUv: function(e) {
    if (this.mapping === sh) {
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
        switch (this.wrapS) {
          case On:
            e.x = e.x - Math.floor(e.x);
            break;
          case Ei:
            e.x = e.x < 0 ? 0 : 1;
            break;
          case za:
            Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
            break;
        }
      if (e.y < 0 || e.y > 1)
        switch (this.wrapT) {
          case On:
            e.y = e.y - Math.floor(e.y);
            break;
          case Ei:
            e.y = e.y < 0 ? 0 : 1;
            break;
          case za:
            Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
            break;
        }
      this.flipY && (e.y = 1 - e.y);
    }
  }
});
Object.defineProperty(ir.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
function kt(e, t, r, n) {
  this.x = e || 0, this.y = t || 0, this.z = r || 0, this.w = n !== void 0 ? n : 1;
}
Object.assign(kt.prototype, {
  isVector4: !0,
  set: function(e, t, r, n) {
    return this.x = e, this.y = t, this.z = r, this.w = n, this;
  },
  setScalar: function(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  },
  setX: function(e) {
    return this.x = e, this;
  },
  setY: function(e) {
    return this.y = e, this;
  },
  setZ: function(e) {
    return this.z = e, this;
  },
  setW: function(e) {
    return this.w = e, this;
  },
  setComponent: function(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  },
  getComponent: function(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  },
  add: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this);
  },
  addScalar: function(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  },
  addVectors: function(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  },
  addScaledVector: function(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  },
  sub: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this);
  },
  subScalar: function(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  },
  subVectors: function(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  },
  multiplyScalar: function(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  },
  applyMatrix4: function(e) {
    var t = this.x, r = this.y, n = this.z, i = this.w, a = e.elements;
    return this.x = a[0] * t + a[4] * r + a[8] * n + a[12] * i, this.y = a[1] * t + a[5] * r + a[9] * n + a[13] * i, this.z = a[2] * t + a[6] * r + a[10] * n + a[14] * i, this.w = a[3] * t + a[7] * r + a[11] * n + a[15] * i, this;
  },
  divideScalar: function(e) {
    return this.multiplyScalar(1 / e);
  },
  setAxisAngleFromQuaternion: function(e) {
    this.w = 2 * Math.acos(e.w);
    var t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  },
  setAxisAngleFromRotationMatrix: function(e) {
    var t, r, n, i, a = 0.01, s = 0.1, o = e.elements, u = o[0], l = o[4], c = o[8], h = o[1], f = o[5], d = o[9], p = o[2], _ = o[6], v = o[10];
    if (Math.abs(l - h) < a && Math.abs(c - p) < a && Math.abs(d - _) < a) {
      if (Math.abs(l + h) < s && Math.abs(c + p) < s && Math.abs(d + _) < s && Math.abs(u + f + v - 3) < s)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      var x = (u + 1) / 2, E = (f + 1) / 2, M = (v + 1) / 2, C = (l + h) / 4, R = (c + p) / 4, B = (d + _) / 4;
      return x > E && x > M ? x < a ? (r = 0, n = 0.707106781, i = 0.707106781) : (r = Math.sqrt(x), n = C / r, i = R / r) : E > M ? E < a ? (r = 0.707106781, n = 0, i = 0.707106781) : (n = Math.sqrt(E), r = C / n, i = B / n) : M < a ? (r = 0.707106781, n = 0.707106781, i = 0) : (i = Math.sqrt(M), r = R / i, n = B / i), this.set(r, n, i, t), this;
    }
    var k = Math.sqrt((_ - d) * (_ - d) + (c - p) * (c - p) + (h - l) * (h - l));
    return Math.abs(k) < 1e-3 && (k = 1), this.x = (_ - d) / k, this.y = (c - p) / k, this.z = (h - l) / k, this.w = Math.acos((u + f + v - 1) / 2), this;
  },
  min: function(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  },
  max: function(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  },
  clamp: function(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  },
  clampScalar: /* @__PURE__ */ function() {
    var e, t;
    return function(n, i) {
      return e === void 0 && (e = new kt(), t = new kt()), e.set(n, n, n, n), t.set(i, i, i, i), this.clamp(e, t);
    };
  }(),
  clampLength: function(e, t) {
    var r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  },
  dot: function(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(e) {
    return this.normalize().multiplyScalar(e);
  },
  lerp: function(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  },
  lerpVectors: function(e, t, r) {
    return this.subVectors(t, e).multiplyScalar(r).add(e);
  },
  equals: function(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  },
  fromBufferAttribute: function(e, t, r) {
    return r !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
});
function qa(e, t, r) {
  this.width = e, this.height = t, this.scissor = new kt(0, 0, e, t), this.scissorTest = !1, this.viewport = new kt(0, 0, e, t), r = r || {}, r.minFilter === void 0 && (r.minFilter = Vr), this.texture = new ir(void 0, void 0, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !0, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !0, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null;
}
qa.prototype = Object.assign(Object.create($n.prototype), {
  constructor: qa,
  isWebGLRenderTarget: !0,
  setSize: function(e, t) {
    (this.width !== e || this.height !== t) && (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function Vs(e, t, r) {
  qa.call(this, e, t, r), this.activeCubeFace = 0, this.activeMipMapLevel = 0;
}
Vs.prototype = Object.create(qa.prototype);
Vs.prototype.constructor = Vs;
Vs.prototype.isWebGLRenderTargetCube = !0;
function Xa(e, t, r, n, i, a, s, o, u, l, c, h) {
  ir.call(this, null, a, s, o, u, l, n, i, c, h), this.image = { data: e, width: t, height: r }, this.magFilter = u !== void 0 ? u : wi, this.minFilter = l !== void 0 ? l : wi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
}
Xa.prototype = Object.create(ir.prototype);
Xa.prototype.constructor = Xa;
Xa.prototype.isDataTexture = !0;
function Hn(e, t) {
  this.min = e !== void 0 ? e : new z(1 / 0, 1 / 0, 1 / 0), this.max = t !== void 0 ? t : new z(-1 / 0, -1 / 0, -1 / 0);
}
Object.assign(Hn.prototype, {
  isBox3: !0,
  set: function(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  },
  setFromArray: function(e) {
    for (var t = 1 / 0, r = 1 / 0, n = 1 / 0, i = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, u = e.length; o < u; o += 3) {
      var l = e[o], c = e[o + 1], h = e[o + 2];
      l < t && (t = l), c < r && (r = c), h < n && (n = h), l > i && (i = l), c > a && (a = c), h > s && (s = h);
    }
    return this.min.set(t, r, n), this.max.set(i, a, s), this;
  },
  setFromBufferAttribute: function(e) {
    for (var t = 1 / 0, r = 1 / 0, n = 1 / 0, i = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, u = e.count; o < u; o++) {
      var l = e.getX(o), c = e.getY(o), h = e.getZ(o);
      l < t && (t = l), c < r && (r = c), h < n && (n = h), l > i && (i = l), c > a && (a = c), h > s && (s = h);
    }
    return this.min.set(t, r, n), this.max.set(i, a, s), this;
  },
  setFromPoints: function(e) {
    this.makeEmpty();
    for (var t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  },
  setFromCenterAndSize: function() {
    var e = new z();
    return function(r, n) {
      var i = e.copy(n).multiplyScalar(0.5);
      return this.min.copy(r).sub(i), this.max.copy(r).add(i), this;
    };
  }(),
  setFromObject: function(e) {
    return this.makeEmpty(), this.expandByObject(e);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  },
  makeEmpty: function() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new z()), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), e = new z()), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  },
  expandByPoint: function(e) {
    return this.min.min(e), this.max.max(e), this;
  },
  expandByVector: function(e) {
    return this.min.sub(e), this.max.add(e), this;
  },
  expandByScalar: function(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  },
  expandByObject: function() {
    var e, t, r, n = new z();
    function i(a) {
      var s = a.geometry;
      if (s !== void 0) {
        if (s.isGeometry) {
          var o = s.vertices;
          for (t = 0, r = o.length; t < r; t++)
            n.copy(o[t]), n.applyMatrix4(a.matrixWorld), e.expandByPoint(n);
        } else if (s.isBufferGeometry) {
          var u = s.attributes.position;
          if (u !== void 0)
            for (t = 0, r = u.count; t < r; t++)
              n.fromBufferAttribute(u, t).applyMatrix4(a.matrixWorld), e.expandByPoint(n);
        }
      }
    }
    return function(s) {
      return e = this, s.updateMatrixWorld(!0), s.traverse(i), this;
    };
  }(),
  containsPoint: function(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  },
  containsBox: function(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  },
  getParameter: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new z()), t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  },
  intersectsBox: function(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  },
  intersectsSphere: function() {
    var e = new z();
    return function(r) {
      return this.clampPoint(r.center, e), e.distanceToSquared(r.center) <= r.radius * r.radius;
    };
  }(),
  intersectsPlane: function(e) {
    var t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= e.constant && r >= e.constant;
  },
  intersectsTriangle: function() {
    var e = new z(), t = new z(), r = new z(), n = new z(), i = new z(), a = new z(), s = new z(), o = new z(), u = new z(), l = new z();
    function c(h) {
      var f, d;
      for (f = 0, d = h.length - 3; f <= d; f += 3) {
        s.fromArray(h, f);
        var p = u.x * Math.abs(s.x) + u.y * Math.abs(s.y) + u.z * Math.abs(s.z), _ = e.dot(s), v = t.dot(s), x = r.dot(s);
        if (Math.max(-Math.max(_, v, x), Math.min(_, v, x)) > p)
          return !1;
      }
      return !0;
    }
    return function(f) {
      if (this.isEmpty())
        return !1;
      this.getCenter(o), u.subVectors(this.max, o), e.subVectors(f.a, o), t.subVectors(f.b, o), r.subVectors(f.c, o), n.subVectors(t, e), i.subVectors(r, t), a.subVectors(e, r);
      var d = [
        0,
        -n.z,
        n.y,
        0,
        -i.z,
        i.y,
        0,
        -a.z,
        a.y,
        n.z,
        0,
        -n.x,
        i.z,
        0,
        -i.x,
        a.z,
        0,
        -a.x,
        -n.y,
        n.x,
        0,
        -i.y,
        i.x,
        0,
        -a.y,
        a.x,
        0
      ];
      return !c(d) || (d = [1, 0, 0, 0, 1, 0, 0, 0, 1], !c(d)) ? !1 : (l.crossVectors(n, i), d = [l.x, l.y, l.z], c(d));
    };
  }(),
  clampPoint: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new z()), t.copy(e).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var e = new z();
    return function(r) {
      var n = e.copy(r).clamp(this.min, this.max);
      return n.sub(r).length();
    };
  }(),
  getBoundingSphere: function() {
    var e = new z();
    return function(r) {
      return r === void 0 && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), r = new qi()), this.getCenter(r.center), r.radius = this.getSize(e).length() * 0.5, r;
    };
  }(),
  intersect: function(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  },
  union: function(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  },
  applyMatrix4: function(e) {
    if (this.isEmpty()) return this;
    var t = e.elements, r = t[0] * this.min.x, n = t[1] * this.min.x, i = t[2] * this.min.x, a = t[0] * this.max.x, s = t[1] * this.max.x, o = t[2] * this.max.x, u = t[4] * this.min.y, l = t[5] * this.min.y, c = t[6] * this.min.y, h = t[4] * this.max.y, f = t[5] * this.max.y, d = t[6] * this.max.y, p = t[8] * this.min.z, _ = t[9] * this.min.z, v = t[10] * this.min.z, x = t[8] * this.max.z, E = t[9] * this.max.z, M = t[10] * this.max.z;
    return this.min.x = Math.min(r, a) + Math.min(u, h) + Math.min(p, x) + t[12], this.min.y = Math.min(n, s) + Math.min(l, f) + Math.min(_, E) + t[13], this.min.z = Math.min(i, o) + Math.min(c, d) + Math.min(v, M) + t[14], this.max.x = Math.max(r, a) + Math.max(u, h) + Math.max(p, x) + t[12], this.max.y = Math.max(n, s) + Math.max(l, f) + Math.max(_, E) + t[13], this.max.z = Math.max(i, o) + Math.max(c, d) + Math.max(v, M) + t[14], this;
  },
  translate: function(e) {
    return this.min.add(e), this.max.add(e), this;
  },
  equals: function(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
});
function qi(e, t) {
  this.center = e !== void 0 ? e : new z(), this.radius = t !== void 0 ? t : 0;
}
Object.assign(qi.prototype, {
  set: function(e, t) {
    return this.center.copy(e), this.radius = t, this;
  },
  setFromPoints: function() {
    var e = new Hn();
    return function(r, n) {
      var i = this.center;
      n !== void 0 ? i.copy(n) : e.setFromPoints(r).getCenter(i);
      for (var a = 0, s = 0, o = r.length; s < o; s++)
        a = Math.max(a, i.distanceToSquared(r[s]));
      return this.radius = Math.sqrt(a), this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  },
  empty: function() {
    return this.radius <= 0;
  },
  containsPoint: function(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function(e) {
    return e.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function(e) {
    var t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  },
  intersectsBox: function(e) {
    return e.intersectsSphere(this);
  },
  intersectsPlane: function(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function(e, t) {
    var r = this.center.distanceToSquared(e);
    return t === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new z()), t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  },
  getBoundingBox: function(e) {
    return e === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new Hn()), e.set(this.center, this.center), e.expandByScalar(this.radius), e;
  },
  applyMatrix4: function(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  },
  translate: function(e) {
    return this.center.add(e), this;
  },
  equals: function(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
});
function Vi(e, t) {
  this.normal = e !== void 0 ? e : new z(1, 0, 0), this.constant = t !== void 0 ? t : 0;
}
Object.assign(Vi.prototype, {
  set: function(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  },
  setComponents: function(e, t, r, n) {
    return this.normal.set(e, t, r), this.constant = n, this;
  },
  setFromNormalAndCoplanarPoint: function(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  },
  setFromCoplanarPoints: function() {
    var e = new z(), t = new z();
    return function(n, i, a) {
      var s = e.subVectors(a, i).cross(t.subVectors(n, i)).normalize();
      return this.setFromNormalAndCoplanarPoint(s, n), this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  },
  normalize: function() {
    var e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  },
  negate: function() {
    return this.constant *= -1, this.normal.negate(), this;
  },
  distanceToPoint: function(e) {
    return this.normal.dot(e) + this.constant;
  },
  distanceToSphere: function(e) {
    return this.distanceToPoint(e.center) - e.radius;
  },
  projectPoint: function(e, t) {
    return t === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new z()), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  },
  intersectLine: function() {
    var e = new z();
    return function(r, n) {
      n === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new z());
      var i = r.delta(e), a = this.normal.dot(i);
      if (a === 0)
        return this.distanceToPoint(r.start) === 0 ? n.copy(r.start) : void 0;
      var s = -(r.start.dot(this.normal) + this.constant) / a;
      if (!(s < 0 || s > 1))
        return n.copy(i).multiplyScalar(s).add(r.start);
    };
  }(),
  intersectsLine: function(e) {
    var t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
    return t < 0 && r > 0 || r < 0 && t > 0;
  },
  intersectsBox: function(e) {
    return e.intersectsPlane(this);
  },
  intersectsSphere: function(e) {
    return e.intersectsPlane(this);
  },
  coplanarPoint: function(e) {
    return e === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new z()), e.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function() {
    var e = new z(), t = new wr();
    return function(n, i) {
      var a = i || t.getNormalMatrix(n), s = this.coplanarPoint(e).applyMatrix4(n), o = this.normal.applyMatrix3(a).normalize();
      return this.constant = -s.dot(o), this;
    };
  }(),
  translate: function(e) {
    return this.constant -= e.dot(this.normal), this;
  },
  equals: function(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
});
function ph(e, t, r, n, i, a) {
  this.planes = [
    e !== void 0 ? e : new Vi(),
    t !== void 0 ? t : new Vi(),
    r !== void 0 ? r : new Vi(),
    n !== void 0 ? n : new Vi(),
    i !== void 0 ? i : new Vi(),
    a !== void 0 ? a : new Vi()
  ];
}
Object.assign(ph.prototype, {
  set: function(e, t, r, n, i, a) {
    var s = this.planes;
    return s[0].copy(e), s[1].copy(t), s[2].copy(r), s[3].copy(n), s[4].copy(i), s[5].copy(a), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    for (var t = this.planes, r = 0; r < 6; r++)
      t[r].copy(e.planes[r]);
    return this;
  },
  setFromMatrix: function(e) {
    var t = this.planes, r = e.elements, n = r[0], i = r[1], a = r[2], s = r[3], o = r[4], u = r[5], l = r[6], c = r[7], h = r[8], f = r[9], d = r[10], p = r[11], _ = r[12], v = r[13], x = r[14], E = r[15];
    return t[0].setComponents(s - n, c - o, p - h, E - _).normalize(), t[1].setComponents(s + n, c + o, p + h, E + _).normalize(), t[2].setComponents(s + i, c + u, p + f, E + v).normalize(), t[3].setComponents(s - i, c - u, p - f, E - v).normalize(), t[4].setComponents(s - a, c - l, p - d, E - x).normalize(), t[5].setComponents(s + a, c + l, p + d, E + x).normalize(), this;
  },
  intersectsObject: function() {
    var e = new qi();
    return function(r) {
      var n = r.geometry;
      return n.boundingSphere === null && n.computeBoundingSphere(), e.copy(n.boundingSphere).applyMatrix4(r.matrixWorld), this.intersectsSphere(e);
    };
  }(),
  intersectsSprite: function() {
    var e = new qi();
    return function(r) {
      return e.center.set(0, 0, 0), e.radius = 0.7071067811865476, e.applyMatrix4(r.matrixWorld), this.intersectsSphere(e);
    };
  }(),
  intersectsSphere: function(e) {
    for (var t = this.planes, r = e.center, n = -e.radius, i = 0; i < 6; i++) {
      var a = t[i].distanceToPoint(r);
      if (a < n)
        return !1;
    }
    return !0;
  },
  intersectsBox: function() {
    var e = new z(), t = new z();
    return function(n) {
      for (var i = this.planes, a = 0; a < 6; a++) {
        var s = i[a];
        e.x = s.normal.x > 0 ? n.min.x : n.max.x, t.x = s.normal.x > 0 ? n.max.x : n.min.x, e.y = s.normal.y > 0 ? n.min.y : n.max.y, t.y = s.normal.y > 0 ? n.max.y : n.min.y, e.z = s.normal.z > 0 ? n.min.z : n.max.z, t.z = s.normal.z > 0 ? n.max.z : n.min.z;
        var o = s.distanceToPoint(e), u = s.distanceToPoint(t);
        if (o < 0 && u < 0)
          return !1;
      }
      return !0;
    };
  }(),
  containsPoint: function(e) {
    for (var t = this.planes, r = 0; r < 6; r++)
      if (t[r].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
});
var Lx = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif
`, Rx = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif
`, Ix = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif
`, Ox = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( PHYSICAL )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif
`, Bx = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Fx = `
vec3 transformed = vec3( position );
`, kx = `
vec3 objectNormal = vec3( normal );
`, Nx = `float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	if( decayExponent > 0.0 ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		return distanceFalloff * maxDistanceCutoffFactor;
#else
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
#endif
	}
	return 1.0;
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
	return specularColor * AB.x + AB.y;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
`, Ux = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif
`, Gx = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;
	}
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;
		}
		if ( clipped ) discard;
	#endif
#endif
`, Vx = `#if NUM_CLIPPING_PLANES > 0
	#if ! defined( PHYSICAL ) && ! defined( PHONG )
		varying vec3 vViewPosition;
	#endif
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif
`, Hx = `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
	varying vec3 vViewPosition;
#endif
`, zx = `#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )
	vViewPosition = - mvPosition.xyz;
#endif
`, Wx = `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`, jx = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif
`, qx = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`, Xx = `#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`, Yx = `#define PI 3.14159265359
#define PI2 6.28318530718
#define PI_HALF 1.5707963267949
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
`, Qx = `#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_textureSize (1024.0)
int getFaceFromDirection(vec3 direction) {
	vec3 absDirection = abs(direction);
	int face = -1;
	if( absDirection.x > absDirection.z ) {
		if(absDirection.x > absDirection.y )
			face = direction.x > 0.0 ? 0 : 3;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	else {
		if(absDirection.z > absDirection.y )
			face = direction.z > 0.0 ? 2 : 5;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	return face;
}
#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)
#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))
vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {
	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);
	float dxRoughness = dFdx(roughness);
	float dyRoughness = dFdy(roughness);
	vec3 dx = dFdx( vec * scale * dxRoughness );
	vec3 dy = dFdy( vec * scale * dyRoughness );
	float d = max( dot( dx, dx ), dot( dy, dy ) );
	d = clamp(d, 1.0, cubeUV_rangeClamp);
	float mipLevel = 0.5 * log2(d);
	return vec2(floor(mipLevel), fract(mipLevel));
}
#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)
#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)
vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {
	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;
	float a = 16.0 * cubeUV_rcpTextureSize;
	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );
	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;
	float powScale = exp2_packed.x * exp2_packed.y;
	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;
	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;
	bool bRes = mipLevel == 0.0;
	scale =  bRes && (scale < a) ? a : scale;
	vec3 r;
	vec2 offset;
	int face = getFaceFromDirection(direction);
	float rcpPowScale = 1.0 / powScale;
	if( face == 0) {
		r = vec3(direction.x, -direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 1) {
		r = vec3(direction.y, direction.x, direction.z);
		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 2) {
		r = vec3(direction.z, direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 3) {
		r = vec3(direction.x, direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else if( face == 4) {
		r = vec3(direction.y, direction.x, -direction.z);
		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else {
		r = vec3(direction.z, -direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	r = normalize(r);
	float texelOffset = 0.5 * cubeUV_rcpTextureSize;
	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;
	vec2 base = offset + vec2( texelOffset );
	return base + s * ( scale - 2.0 * texelOffset );
}
#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)
vec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {
	float roughnessVal = roughness* cubeUV_maxLods3;
	float r1 = floor(roughnessVal);
	float r2 = r1 + 1.0;
	float t = fract(roughnessVal);
	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);
	float s = mipInfo.y;
	float level0 = mipInfo.x;
	float level1 = level0 + 1.0;
	level1 = level1 > 5.0 ? 5.0 : level1;
	level0 += min( floor( s + 0.5 ), 5.0 );
	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);
	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));
	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);
	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));
	vec4 result = mix(color10, color20, t);
	return vec4(result.rgb, 1.0);
}
#endif
`, Kx = `vec3 transformedNormal = normalMatrix * objectNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
`, $x = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif
`, Zx = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );
#endif
`, Jx = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif
`, eA = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif
`, tA = `  gl_FragColor = linearToOutputTexel( gl_FragColor );
`, rA = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.xyz * value.w * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.x, max( value.g, value.b ) );
	float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M            = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.x, max( value.g, value.b ) );
	float D      = max( maxRange / maxRGB, 1.0 );
	D            = min( floor( D ) / 255.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
	Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract(Le);
	vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
	return vec4( max(vRGB, 0.0), 1.0 );
}
`, iA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToVertex, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		vec2 sampleUV;
		reflectVec = normalize( reflectVec );
		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
		vec4 envColor = texture2D( envMap, sampleUV );
	#elif defined( ENVMAP_TYPE_SPHERE )
		reflectVec = normalize( reflectVec );
		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	envColor = envMapTexelToLinear( envColor );
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif
`, nA = `#if defined( USE_ENVMAP ) || defined( PHYSICAL )
	uniform float reflectivity;
	uniform float envMapIntensity;
#endif
#ifdef USE_ENVMAP
	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
		varying vec3 vWorldPosition;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif
`, aA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif
`, sA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif
`, oA = `
#ifdef USE_FOG
fogDepth = -mvPosition.z;
#endif`, uA = `#ifdef USE_FOG
  varying float fogDepth;
#endif
`, lA = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif
`, cA = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif
`, hA = `#ifdef TOON
	uniform sampler2D gradientMap;
	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
		float dotNL = dot( normal, lightDirection );
		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
		#ifdef USE_GRADIENTMAP
			return texture2D( gradientMap, coord ).rgb;
		#else
			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
		#endif
	}
#endif
`, fA = `#ifdef USE_LIGHTMAP
	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
#endif
`, dA = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, pA = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
#endif
`, mA = `uniform vec3 ambientLightColor;
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
		float shadowCameraNear;
		float shadowCameraFar;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif
`, vA = `#if defined( USE_ENVMAP ) && defined( PHYSICAL )
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
		#else
			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV;
			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_SPHERE )
			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif
`, gA = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`, yA = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	#ifdef TOON
		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#else
		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		vec3 irradiance = dotNL * directLight.color;
	#endif
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)
`, _A = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
#ifdef STANDARD
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
#endif
`, bA = `struct PhysicalMaterial {
	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;
	#ifndef STANDARD
		float clearCoat;
		float clearCoatRoughness;
	#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifndef STANDARD
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	#ifndef STANDARD
		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	#ifndef STANDARD
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		float dotNL = dotNV;
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif
	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
	#ifndef STANDARD
		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );
	#endif
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}
`, xA = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = normalize( vViewPosition );
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
#endif
#if defined( RE_IndirectDiffuse )
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearCoatRadiance = vec3( 0.0 );
#endif
`, AA = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )
		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );
	#ifndef STANDARD
		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );
	#endif
#endif
`, TA = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );
#endif
`, EA = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, wA = `#ifdef USE_LOGDEPTHBUF
	uniform float logDepthBufFC;
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
	#endif
#endif
`, SA = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
	#endif
	uniform float logDepthBufFC;
#endif`, CA = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
	#else
		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
		gl_Position.z *= gl_Position.w;
	#endif
#endif
`, MA = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif
`, DA = `#ifdef USE_MAP
	uniform sampler2D map;
#endif
`, PA = `#ifdef USE_MAP
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
`, LA = `#ifdef USE_MAP
	uniform mat3 uvTransform;
	uniform sampler2D map;
#endif
`, RA = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif
`, IA = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, OA = `#ifdef USE_MORPHNORMALS
	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
#endif
`, BA = `#ifdef USE_MORPHTARGETS
	#ifndef USE_MORPHNORMALS
	uniform float morphTargetInfluences[ 8 ];
	#else
	uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`, FA = `#ifdef USE_MORPHTARGETS
	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
	#endif
#endif
`, kA = `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
#endif
`, NA = `#ifdef USE_NORMALMAP
	normal = perturbNormal2Arb( -vViewPosition, normal );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif
`, UA = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
		mapN.xy *= normalScale;
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif
`, GA = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`, VA = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif
`, HA = `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
gl_Position = projectionMatrix * mvPosition;
`, zA = `#if defined( DITHERING )
  gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif
`, WA = `#if defined( DITHERING )
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif
`, jA = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif
`, qA = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, XA = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {
		const vec2 offset = vec2( 0.0, 1.0 );
		vec2 texelSize = vec2( 1.0 ) / size;
		vec2 centroidUV = floor( uv * size + 0.5 ) / size;
		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );
		vec2 f = fract( uv * size + 0.5 );
		float a = mix( lb, lt, f.y );
		float b = mix( rb, rt, f.y );
		float c = mix( a, b, f.x );
		return c;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			shadow = (
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif
`, YA = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];
	#endif
	#if NUM_SPOT_LIGHTS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];
	#endif
	#if NUM_POINT_LIGHTS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];
	#endif
#endif
`, QA = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;
	}
	#endif
#endif
`, KA = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHTS > 0
	DirectionalLight directionalLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_SPOT_LIGHTS > 0
	SpotLight spotLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#endif
	#if NUM_POINT_LIGHTS > 0
	PointLight pointLight;
	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#endif
	#endif
	return shadow;
}
`, $A = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, ZA = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif
`, JA = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif
`, eT = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
#endif
`, tT = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, rT = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, iT = `#if defined( TONE_MAPPING )
  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif
`, nT = `#ifndef saturate
	#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
`, aT = `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
#endif`, sT = `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
`, oT = `#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, uT = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, lT = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
#endif`, cT = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = uv2;
#endif`, hT = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
#endif
`, fT = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldPosition;
void main() {
	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );
	gl_FragColor.a *= opacity;
}
`, dT = `varying vec3 vWorldPosition;
#include <common>
void main() {
	vWorldPosition = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}
`, pT = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );
	#endif
}
`, mT = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
}
`, vT = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}
`, gT = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}
`, yT = `uniform sampler2D tEquirect;
varying vec3 vWorldPosition;
#include <common>
void main() {
	vec3 direction = normalize( vWorldPosition );
	vec2 sampleUV;
	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;
	gl_FragColor = texture2D( tEquirect, sampleUV );
}
`, _T = `varying vec3 vWorldPosition;
#include <common>
void main() {
	vWorldPosition = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}
`, bT = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`, xT = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	vLineDistance = scale * lineDistance;
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}
`, AT = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`, TT = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`, ET = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_pars_maps>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`, wT = `#define LAMBERT
varying vec3 vLightFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_pars_maps>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`, ST = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_pars_maps>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`, CT = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`, MT = `#define PHYSICAL
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifndef STANDARD
	uniform float clearCoat;
	uniform float clearCoatRoughness;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <lights_pars_begin>
#include <lights_pars_maps>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`, DT = `#define PHYSICAL
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`, PT = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}
`, LT = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}
`, RT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <packing>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
`, IT = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#ifdef USE_SIZEATTENUATION
		gl_PointSize = size * ( scale / - mvPosition.z );
	#else
		gl_PointSize = size;
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}
`, OT = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <fog_fragment>
}
`, BT = `#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`, Ot = {
  alphamap_fragment: Lx,
  alphamap_pars_fragment: Rx,
  alphatest_fragment: Ix,
  aomap_fragment: Ox,
  aomap_pars_fragment: Bx,
  begin_vertex: Fx,
  beginnormal_vertex: kx,
  bsdfs: Nx,
  bumpmap_pars_fragment: Ux,
  clipping_planes_fragment: Gx,
  clipping_planes_pars_fragment: Vx,
  clipping_planes_pars_vertex: Hx,
  clipping_planes_vertex: zx,
  color_fragment: Wx,
  color_pars_fragment: jx,
  color_pars_vertex: qx,
  color_vertex: Xx,
  common: Yx,
  cube_uv_reflection_fragment: Qx,
  defaultnormal_vertex: Kx,
  displacementmap_pars_vertex: $x,
  displacementmap_vertex: Zx,
  emissivemap_fragment: Jx,
  emissivemap_pars_fragment: eA,
  encodings_fragment: tA,
  encodings_pars_fragment: rA,
  envmap_fragment: iA,
  envmap_pars_fragment: nA,
  envmap_pars_vertex: aA,
  envmap_vertex: sA,
  fog_vertex: oA,
  fog_pars_vertex: uA,
  fog_fragment: lA,
  fog_pars_fragment: cA,
  gradientmap_pars_fragment: hA,
  lightmap_fragment: fA,
  lightmap_pars_fragment: dA,
  lights_lambert_vertex: pA,
  lights_pars_begin: mA,
  lights_pars_maps: vA,
  lights_phong_fragment: gA,
  lights_phong_pars_fragment: yA,
  lights_physical_fragment: _A,
  lights_physical_pars_fragment: bA,
  lights_fragment_begin: xA,
  lights_fragment_maps: AA,
  lights_fragment_end: TA,
  logdepthbuf_fragment: EA,
  logdepthbuf_pars_fragment: wA,
  logdepthbuf_pars_vertex: SA,
  logdepthbuf_vertex: CA,
  map_fragment: MA,
  map_pars_fragment: DA,
  map_particle_fragment: PA,
  map_particle_pars_fragment: LA,
  metalnessmap_fragment: RA,
  metalnessmap_pars_fragment: IA,
  morphnormal_vertex: OA,
  morphtarget_pars_vertex: BA,
  morphtarget_vertex: FA,
  normal_fragment_begin: kA,
  normal_fragment_maps: NA,
  normalmap_pars_fragment: UA,
  packing: GA,
  premultiplied_alpha_fragment: VA,
  project_vertex: HA,
  dithering_fragment: zA,
  dithering_pars_fragment: WA,
  roughnessmap_fragment: jA,
  roughnessmap_pars_fragment: qA,
  shadowmap_pars_fragment: XA,
  shadowmap_pars_vertex: YA,
  shadowmap_vertex: QA,
  shadowmask_pars_fragment: KA,
  skinbase_vertex: $A,
  skinning_pars_vertex: ZA,
  skinning_vertex: JA,
  skinnormal_vertex: eT,
  specularmap_fragment: tT,
  specularmap_pars_fragment: rT,
  tonemapping_fragment: iT,
  tonemapping_pars_fragment: nT,
  uv_pars_fragment: aT,
  uv_pars_vertex: sT,
  uv_vertex: oT,
  uv2_pars_fragment: uT,
  uv2_pars_vertex: lT,
  uv2_vertex: cT,
  worldpos_vertex: hT,
  cube_frag: fT,
  cube_vert: dT,
  depth_frag: pT,
  depth_vert: mT,
  distanceRGBA_frag: vT,
  distanceRGBA_vert: gT,
  equirect_frag: yT,
  equirect_vert: _T,
  linedashed_frag: bT,
  linedashed_vert: xT,
  meshbasic_frag: AT,
  meshbasic_vert: TT,
  meshlambert_frag: ET,
  meshlambert_vert: wT,
  meshphong_frag: ST,
  meshphong_vert: CT,
  meshphysical_frag: MT,
  meshphysical_vert: DT,
  normal_frag: PT,
  normal_vert: LT,
  points_frag: RT,
  points_vert: IT,
  shadow_frag: OT,
  shadow_vert: BT
}, si = {
  merge: function(e) {
    for (var t = {}, r = 0; r < e.length; r++) {
      var n = this.clone(e[r]);
      for (var i in n)
        t[i] = n[i];
    }
    return t;
  },
  clone: function(e) {
    var t = {};
    for (var r in e) {
      t[r] = {};
      for (var n in e[r]) {
        var i = e[r][n];
        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[r][n] = i.clone() : Array.isArray(i) ? t[r][n] = i.slice() : t[r][n] = i;
      }
    }
    return t;
  }
}, FT = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
function je(e, t, r) {
  return t === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, t, r);
}
Object.assign(je.prototype, {
  isColor: !0,
  r: 1,
  g: 1,
  b: 1,
  set: function(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  },
  setScalar: function(e) {
    return this.r = e, this.g = e, this.b = e, this;
  },
  setHex: function(e) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
  },
  setRGB: function(e, t, r) {
    return this.r = e, this.g = t, this.b = r, this;
  },
  setHSL: /* @__PURE__ */ function() {
    function e(t, r, n) {
      return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (r - t) * 6 * n : n < 1 / 2 ? r : n < 2 / 3 ? t + (r - t) * 6 * (2 / 3 - n) : t;
    }
    return function(r, n, i) {
      if (r = gt.euclideanModulo(r, 1), n = gt.clamp(n, 0, 1), i = gt.clamp(i, 0, 1), n === 0)
        this.r = this.g = this.b = i;
      else {
        var a = i <= 0.5 ? i * (1 + n) : i + n - i * n, s = 2 * i - a;
        this.r = e(s, a, r + 1 / 3), this.g = e(s, a, r), this.b = e(s, a, r - 1 / 3);
      }
      return this;
    };
  }(),
  setStyle: function(e) {
    function t(h) {
      h !== void 0 && parseFloat(h) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    var r;
    if (r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
      var n, i = r[1], a = r[2];
      switch (i) {
        case "rgb":
        case "rgba":
          if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
            return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]), this;
          if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
            return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]), this;
          break;
        case "hsl":
        case "hsla":
          if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
            var s = parseFloat(n[1]) / 360, o = parseInt(n[2], 10) / 100, u = parseInt(n[3], 10) / 100;
            return t(n[5]), this.setHSL(s, o, u);
          }
          break;
      }
    } else if (r = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
      var l = r[1], c = l.length;
      if (c === 3)
        return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
      if (c === 6)
        return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this;
    }
    if (e && e.length > 0) {
      var l = FT[e];
      l !== void 0 ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + e);
    }
    return this;
  },
  clone: function() {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  },
  copyGammaToLinear: function(e, t) {
    return t === void 0 && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this;
  },
  copyLinearToGamma: function(e, t) {
    t === void 0 && (t = 2);
    var r = t > 0 ? 1 / t : 1;
    return this.r = Math.pow(e.r, r), this.g = Math.pow(e.g, r), this.b = Math.pow(e.b, r), this;
  },
  convertGammaToLinear: function(e) {
    return this.copyGammaToLinear(this, e), this;
  },
  convertLinearToGamma: function(e) {
    return this.copyLinearToGamma(this, e), this;
  },
  getHex: function() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function(e) {
    e === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 });
    var t = this.r, r = this.g, n = this.b, i = Math.max(t, r, n), a = Math.min(t, r, n), s, o, u = (a + i) / 2;
    if (a === i)
      s = 0, o = 0;
    else {
      var l = i - a;
      switch (o = u <= 0.5 ? l / (i + a) : l / (2 - i - a), i) {
        case t:
          s = (r - n) / l + (r < n ? 6 : 0);
          break;
        case r:
          s = (n - t) / l + 2;
          break;
        case n:
          s = (t - r) / l + 4;
          break;
      }
      s /= 6;
    }
    return e.h = s, e.s = o, e.l = u, e;
  },
  getStyle: function() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  },
  offsetHSL: /* @__PURE__ */ function() {
    var e = {};
    return function(t, r, n) {
      return this.getHSL(e), e.h += t, e.s += r, e.l += n, this.setHSL(e.h, e.s, e.l), this;
    };
  }(),
  add: function(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  },
  addColors: function(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  },
  addScalar: function(e) {
    return this.r += e, this.g += e, this.b += e, this;
  },
  sub: function(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  },
  multiply: function(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  },
  multiplyScalar: function(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  },
  lerp: function(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  },
  equals: function(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  },
  toJSON: function() {
    return this.getHex();
  }
});
var Xe = {
  common: {
    diffuse: { value: new je(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new wr() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new ue(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new je(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } }
  },
  points: {
    diffuse: { value: new je(15658734) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    uvTransform: { value: new wr() }
  }
}, Na = {
  basic: {
    uniforms: si.merge([
      Xe.common,
      Xe.specularmap,
      Xe.envmap,
      Xe.aomap,
      Xe.lightmap,
      Xe.fog
    ]),
    vertexShader: Ot.meshbasic_vert,
    fragmentShader: Ot.meshbasic_frag
  },
  lambert: {
    uniforms: si.merge([
      Xe.common,
      Xe.specularmap,
      Xe.envmap,
      Xe.aomap,
      Xe.lightmap,
      Xe.emissivemap,
      Xe.fog,
      Xe.lights,
      {
        emissive: { value: new je(0) }
      }
    ]),
    vertexShader: Ot.meshlambert_vert,
    fragmentShader: Ot.meshlambert_frag
  },
  phong: {
    uniforms: si.merge([
      Xe.common,
      Xe.specularmap,
      Xe.envmap,
      Xe.aomap,
      Xe.lightmap,
      Xe.emissivemap,
      Xe.bumpmap,
      Xe.normalmap,
      Xe.displacementmap,
      Xe.gradientmap,
      Xe.fog,
      Xe.lights,
      {
        emissive: { value: new je(0) },
        specular: { value: new je(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Ot.meshphong_vert,
    fragmentShader: Ot.meshphong_frag
  },
  standard: {
    uniforms: si.merge([
      Xe.common,
      Xe.envmap,
      Xe.aomap,
      Xe.lightmap,
      Xe.emissivemap,
      Xe.bumpmap,
      Xe.normalmap,
      Xe.displacementmap,
      Xe.roughnessmap,
      Xe.metalnessmap,
      Xe.fog,
      Xe.lights,
      {
        emissive: { value: new je(0) },
        roughness: { value: 0.5 },
        metalness: { value: 0.5 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: Ot.meshphysical_vert,
    fragmentShader: Ot.meshphysical_frag
  },
  points: {
    uniforms: si.merge([
      Xe.points,
      Xe.fog
    ]),
    vertexShader: Ot.points_vert,
    fragmentShader: Ot.points_frag
  },
  dashed: {
    uniforms: si.merge([
      Xe.common,
      Xe.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Ot.linedashed_vert,
    fragmentShader: Ot.linedashed_frag
  },
  depth: {
    uniforms: si.merge([
      Xe.common,
      Xe.displacementmap
    ]),
    vertexShader: Ot.depth_vert,
    fragmentShader: Ot.depth_frag
  },
  normal: {
    uniforms: si.merge([
      Xe.common,
      Xe.bumpmap,
      Xe.normalmap,
      Xe.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ot.normal_vert,
    fragmentShader: Ot.normal_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Ot.cube_vert,
    fragmentShader: Ot.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Ot.equirect_vert,
    fragmentShader: Ot.equirect_frag
  },
  distanceRGBA: {
    uniforms: si.merge([
      Xe.common,
      Xe.displacementmap,
      {
        referencePosition: { value: new z() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Ot.distanceRGBA_vert,
    fragmentShader: Ot.distanceRGBA_frag
  },
  shadow: {
    uniforms: si.merge([
      Xe.lights,
      Xe.fog,
      {
        color: { value: new je(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ot.shadow_vert,
    fragmentShader: Ot.shadow_frag
  }
};
Na.physical = {
  uniforms: si.merge([
    Na.standard.uniforms,
    {
      clearCoat: { value: 0 },
      clearCoatRoughness: { value: 0 }
    }
  ]),
  vertexShader: Ot.meshphysical_vert,
  fragmentShader: Ot.meshphysical_frag
};
function Gd() {
  var e = null, t = !1, r = null;
  function n(i, a) {
    t !== !1 && (r(i, a), e.requestAnimationFrame(n));
  }
  return {
    start: function() {
      t !== !0 && r !== null && (e.requestAnimationFrame(n), t = !0);
    },
    stop: function() {
      t = !1;
    },
    setAnimationLoop: function(i) {
      r = i;
    },
    setContext: function(i) {
      e = i;
    }
  };
}
function kT(e) {
  var t = /* @__PURE__ */ new WeakMap();
  function r(o, u) {
    var l = o.array, c = o.dynamic ? e.DYNAMIC_DRAW : e.STATIC_DRAW, h = e.createBuffer();
    e.bindBuffer(u, h), e.bufferData(u, l, c), o.onUploadCallback();
    var f = e.FLOAT;
    return l instanceof Float32Array ? f = e.FLOAT : l instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : l instanceof Uint16Array ? f = e.UNSIGNED_SHORT : l instanceof Int16Array ? f = e.SHORT : l instanceof Uint32Array ? f = e.UNSIGNED_INT : l instanceof Int32Array ? f = e.INT : l instanceof Int8Array ? f = e.BYTE : l instanceof Uint8Array && (f = e.UNSIGNED_BYTE), {
      buffer: h,
      type: f,
      bytesPerElement: l.BYTES_PER_ELEMENT,
      version: o.version
    };
  }
  function n(o, u, l) {
    var c = u.array, h = u.updateRange;
    e.bindBuffer(l, o), u.dynamic === !1 ? e.bufferData(l, c, e.STATIC_DRAW) : h.count === -1 ? e.bufferSubData(l, 0, c) : h.count === 0 ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(
      l,
      h.offset * c.BYTES_PER_ELEMENT,
      c.subarray(h.offset, h.offset + h.count)
    ), h.count = -1);
  }
  function i(o) {
    return o.isInterleavedBufferAttribute && (o = o.data), t.get(o);
  }
  function a(o) {
    o.isInterleavedBufferAttribute && (o = o.data);
    var u = t.get(o);
    u && (e.deleteBuffer(u.buffer), t.delete(o));
  }
  function s(o, u) {
    o.isInterleavedBufferAttribute && (o = o.data);
    var l = t.get(o);
    l === void 0 ? t.set(o, r(o, u)) : l.version < o.version && (n(l.buffer, o, u), l.version = o.version);
  }
  return {
    get: i,
    remove: a,
    update: s
  };
}
function ps(e, t, r, n) {
  this._x = e || 0, this._y = t || 0, this._z = r || 0, this._order = n || ps.DefaultOrder;
}
ps.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
ps.DefaultOrder = "XYZ";
Object.defineProperties(ps.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(e) {
      this._x = e, this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(e) {
      this._y = e, this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(e) {
      this._z = e, this.onChangeCallback();
    }
  },
  order: {
    get: function() {
      return this._order;
    },
    set: function(e) {
      this._order = e, this.onChangeCallback();
    }
  }
});
Object.assign(ps.prototype, {
  isEuler: !0,
  set: function(e, t, r, n) {
    return this._x = e, this._y = t, this._z = r, this._order = n || this._order, this.onChangeCallback(), this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this;
  },
  setFromRotationMatrix: function(e, t, r) {
    var n = gt.clamp, i = e.elements, a = i[0], s = i[4], o = i[8], u = i[1], l = i[5], c = i[9], h = i[2], f = i[6], d = i[10];
    return t = t || this._order, t === "XYZ" ? (this._y = Math.asin(n(o, -1, 1)), Math.abs(o) < 0.99999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(f, l), this._z = 0)) : t === "YXZ" ? (this._x = Math.asin(-n(c, -1, 1)), Math.abs(c) < 0.99999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(u, l)) : (this._y = Math.atan2(-h, a), this._z = 0)) : t === "ZXY" ? (this._x = Math.asin(n(f, -1, 1)), Math.abs(f) < 0.99999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(u, a))) : t === "ZYX" ? (this._y = Math.asin(-n(h, -1, 1)), Math.abs(h) < 0.99999 ? (this._x = Math.atan2(f, d), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-s, l))) : t === "YZX" ? (this._z = Math.asin(n(u, -1, 1)), Math.abs(u) < 0.99999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(o, d))) : t === "XZY" ? (this._z = Math.asin(-n(s, -1, 1)), Math.abs(s) < 0.99999 ? (this._x = Math.atan2(f, l), this._y = Math.atan2(o, a)) : (this._x = Math.atan2(-c, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, r !== !1 && this.onChangeCallback(), this;
  },
  setFromQuaternion: function() {
    var e = new at();
    return function(r, n, i) {
      return e.makeRotationFromQuaternion(r), this.setFromRotationMatrix(e, n, i);
    };
  }(),
  setFromVector3: function(e, t) {
    return this.set(e.x, e.y, e.z, t || this._order);
  },
  reorder: function() {
    var e = new _r();
    return function(r) {
      return e.setFromEuler(this), this.setFromQuaternion(e, r);
    };
  }(),
  equals: function(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  },
  fromArray: function(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this.onChangeCallback(), this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  },
  toVector3: function(e) {
    return e ? e.set(this._x, this._y, this._z) : new z(this._x, this._y, this._z);
  },
  onChange: function(e) {
    return this.onChangeCallback = e, this;
  },
  onChangeCallback: function() {
  }
});
function Vd() {
  this.mask = 1;
}
Object.assign(Vd.prototype, {
  set: function(e) {
    this.mask = 1 << e | 0;
  },
  enable: function(e) {
    this.mask |= 1 << e | 0;
  },
  toggle: function(e) {
    this.mask ^= 1 << e | 0;
  },
  disable: function(e) {
    this.mask &= ~(1 << e | 0);
  },
  test: function(e) {
    return (this.mask & e.mask) !== 0;
  }
});
var NT = 0;
function ke() {
  Object.defineProperty(this, "id", { value: NT++ }), this.uuid = gt.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ke.DefaultUp.clone();
  var e = new z(), t = new ps(), r = new _r(), n = new z(1, 1, 1);
  function i() {
    r.setFromEuler(t, !1);
  }
  function a() {
    t.setFromQuaternion(r, void 0, !1);
  }
  t.onChange(i), r.onChange(a), Object.defineProperties(this, {
    position: {
      enumerable: !0,
      value: e
    },
    rotation: {
      enumerable: !0,
      value: t
    },
    quaternion: {
      enumerable: !0,
      value: r
    },
    scale: {
      enumerable: !0,
      value: n
    },
    modelViewMatrix: {
      value: new at()
    },
    normalMatrix: {
      value: new wr()
    }
  }), this.matrix = new at(), this.matrixWorld = new at(), this.matrixAutoUpdate = ke.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Vd(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
}
ke.DefaultUp = new z(0, 1, 0);
ke.DefaultMatrixAutoUpdate = !0;
ke.prototype = Object.assign(Object.create($n.prototype), {
  constructor: ke,
  isObject3D: !0,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix: function(e) {
    this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(e) {
    return this.quaternion.premultiply(e), this;
  },
  setRotationFromAxisAngle: function(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  },
  setRotationFromEuler: function(e) {
    this.quaternion.setFromEuler(e, !0);
  },
  setRotationFromMatrix: function(e) {
    this.quaternion.setFromRotationMatrix(e);
  },
  setRotationFromQuaternion: function(e) {
    this.quaternion.copy(e);
  },
  rotateOnAxis: function() {
    var e = new _r();
    return function(r, n) {
      return e.setFromAxisAngle(r, n), this.quaternion.multiply(e), this;
    };
  }(),
  rotateOnWorldAxis: function() {
    var e = new _r();
    return function(r, n) {
      return e.setFromAxisAngle(r, n), this.quaternion.premultiply(e), this;
    };
  }(),
  rotateX: function() {
    var e = new z(1, 0, 0);
    return function(r) {
      return this.rotateOnAxis(e, r);
    };
  }(),
  rotateY: function() {
    var e = new z(0, 1, 0);
    return function(r) {
      return this.rotateOnAxis(e, r);
    };
  }(),
  rotateZ: function() {
    var e = new z(0, 0, 1);
    return function(r) {
      return this.rotateOnAxis(e, r);
    };
  }(),
  translateOnAxis: function() {
    var e = new z();
    return function(r, n) {
      return e.copy(r).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this;
    };
  }(),
  translateX: function() {
    var e = new z(1, 0, 0);
    return function(r) {
      return this.translateOnAxis(e, r);
    };
  }(),
  translateY: function() {
    var e = new z(0, 1, 0);
    return function(r) {
      return this.translateOnAxis(e, r);
    };
  }(),
  translateZ: function() {
    var e = new z(0, 0, 1);
    return function(r) {
      return this.translateOnAxis(e, r);
    };
  }(),
  localToWorld: function(e) {
    return e.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function() {
    var e = new at();
    return function(r) {
      return r.applyMatrix4(e.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function() {
    var e = new at(), t = new z();
    return function(n, i, a) {
      n.isVector3 ? t.copy(n) : t.set(n, i, a), this.isCamera ? e.lookAt(this.position, t, this.up) : e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e);
    };
  }(),
  add: function(e) {
    if (arguments.length > 1) {
      for (var t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, e.dispatchEvent({ type: "added" }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  },
  remove: function(e) {
    if (arguments.length > 1) {
      for (var t = 0; t < arguments.length; t++)
        this.remove(arguments[t]);
      return this;
    }
    var r = this.children.indexOf(e);
    return r !== -1 && (e.parent = null, e.dispatchEvent({ type: "removed" }), this.children.splice(r, 1)), this;
  },
  getObjectById: function(e) {
    return this.getObjectByProperty("id", e);
  },
  getObjectByName: function(e) {
    return this.getObjectByProperty("name", e);
  },
  getObjectByProperty: function(e, t) {
    if (this[e] === t) return this;
    for (var r = 0, n = this.children.length; r < n; r++) {
      var i = this.children[r], a = i.getObjectByProperty(e, t);
      if (a !== void 0)
        return a;
    }
  },
  getWorldPosition: function(e) {
    return e === void 0 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new z()), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function() {
    var e = new z(), t = new z();
    return function(n) {
      return n === void 0 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), n = new _r()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, n, t), n;
    };
  }(),
  getWorldScale: function() {
    var e = new z(), t = new _r();
    return function(n) {
      return n === void 0 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n = new z()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, n), n;
    };
  }(),
  getWorldDirection: function() {
    var e = new _r();
    return function(r) {
      return r === void 0 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), r = new z()), this.getWorldQuaternion(e), r.set(0, 0, 1).applyQuaternion(e);
    };
  }(),
  raycast: function() {
  },
  traverse: function(e) {
    e(this);
    for (var t = this.children, r = 0, n = t.length; r < n; r++)
      t[r].traverse(e);
  },
  traverseVisible: function(e) {
    if (this.visible !== !1) {
      e(this);
      for (var t = this.children, r = 0, n = t.length; r < n; r++)
        t[r].traverseVisible(e);
    }
  },
  traverseAncestors: function(e) {
    var t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    for (var t = this.children, r = 0, n = t.length; r < n; r++)
      t[r].updateMatrixWorld(e);
  },
  toJSON: function(e) {
    var t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {}
    }, r.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    var n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), n.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1);
    function i(v, x) {
      return v[x.uuid] === void 0 && (v[x.uuid] = x.toJSON(e)), x.uuid;
    }
    if (this.geometry !== void 0) {
      n.geometry = i(e.geometries, this.geometry);
      var a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        var s = a.shapes;
        if (Array.isArray(s))
          for (var o = 0, u = s.length; o < u; o++) {
            var l = s[o];
            i(e.shapes, l);
          }
        else
          i(e.shapes, s);
      }
    }
    if (this.material !== void 0)
      if (Array.isArray(this.material)) {
        for (var c = [], o = 0, u = this.material.length; o < u; o++)
          c.push(i(e.materials, this.material[o]));
        n.material = c;
      } else
        n.material = i(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (var o = 0; o < this.children.length; o++)
        n.children.push(this.children[o].toJSON(e).object);
    }
    if (t) {
      var h = _(e.geometries), f = _(e.materials), d = _(e.textures), p = _(e.images), s = _(e.shapes);
      h.length > 0 && (r.geometries = h), f.length > 0 && (r.materials = f), d.length > 0 && (r.textures = d), p.length > 0 && (r.images = p), s.length > 0 && (r.shapes = s);
    }
    return r.object = n, r;
    function _(v) {
      var x = [];
      for (var E in v) {
        var M = v[E];
        delete M.metadata, x.push(M);
      }
      return x;
    }
  },
  clone: function(e) {
    return new this.constructor().copy(this, e);
  },
  copy: function(e, t) {
    if (t === void 0 && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (var r = 0; r < e.children.length; r++) {
        var n = e.children[r];
        this.add(n.clone());
      }
    return this;
  }
});
function _n() {
  ke.call(this), this.type = "Camera", this.matrixWorldInverse = new at(), this.projectionMatrix = new at();
}
_n.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: _n,
  isCamera: !0,
  copy: function(e, t) {
    return ke.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this;
  },
  getWorldDirection: function() {
    var e = new _r();
    return function(r) {
      return r === void 0 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), r = new z()), this.getWorldQuaternion(e), r.set(0, 0, -1).applyQuaternion(e);
    };
  }(),
  updateMatrixWorld: function(e) {
    ke.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function Hs(e, t, r, n, i, a) {
  _n.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = n, this.near = i !== void 0 ? i : 0.1, this.far = a !== void 0 ? a : 2e3, this.updateProjectionMatrix();
}
Hs.prototype = Object.assign(Object.create(_n.prototype), {
  constructor: Hs,
  isOrthographicCamera: !0,
  copy: function(e, t) {
    return _n.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  },
  setViewOffset: function(e, t, r, n, i, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = n, this.view.width = i, this.view.height = a, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, i = r - e, a = r + e, s = n + t, o = n - t;
    if (this.view !== null && this.view.enabled) {
      var u = this.zoom / (this.view.width / this.view.fullWidth), l = this.zoom / (this.view.height / this.view.fullHeight), c = (this.right - this.left) / this.view.width, h = (this.top - this.bottom) / this.view.height;
      i += c * (this.view.offsetX / u), a = i + c * (this.view.width / u), s -= h * (this.view.offsetY / l), o = s - h * (this.view.height / l);
    }
    this.projectionMatrix.makeOrthographic(i, a, s, o, this.near, this.far);
  },
  toJSON: function(e) {
    var t = ke.prototype.toJSON.call(this, e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
});
function kn(e, t, r, n, i, a) {
  this.a = e, this.b = t, this.c = r, this.normal = n && n.isVector3 ? n : new z(), this.vertexNormals = Array.isArray(n) ? n : [], this.color = i && i.isColor ? i : new je(), this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = a !== void 0 ? a : 0;
}
Object.assign(kn.prototype, {
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
    for (var t = 0, r = e.vertexNormals.length; t < r; t++)
      this.vertexNormals[t] = e.vertexNormals[t].clone();
    for (var t = 0, r = e.vertexColors.length; t < r; t++)
      this.vertexColors[t] = e.vertexColors[t].clone();
    return this;
  }
});
var UT = 0;
function tt() {
  Object.defineProperty(this, "id", { value: UT += 2 }), this.uuid = gt.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
tt.prototype = Object.assign(Object.create($n.prototype), {
  constructor: tt,
  isGeometry: !0,
  applyMatrix: function(e) {
    for (var t = new wr().getNormalMatrix(e), r = 0, n = this.vertices.length; r < n; r++) {
      var i = this.vertices[r];
      i.applyMatrix4(e);
    }
    for (var r = 0, n = this.faces.length; r < n; r++) {
      var a = this.faces[r];
      a.normal.applyMatrix3(t).normalize();
      for (var s = 0, o = a.vertexNormals.length; s < o; s++)
        a.vertexNormals[s].applyMatrix3(t).normalize();
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
  },
  rotateX: function() {
    var e = new at();
    return function(r) {
      return e.makeRotationX(r), this.applyMatrix(e), this;
    };
  }(),
  rotateY: function() {
    var e = new at();
    return function(r) {
      return e.makeRotationY(r), this.applyMatrix(e), this;
    };
  }(),
  rotateZ: function() {
    var e = new at();
    return function(r) {
      return e.makeRotationZ(r), this.applyMatrix(e), this;
    };
  }(),
  translate: function() {
    var e = new at();
    return function(r, n, i) {
      return e.makeTranslation(r, n, i), this.applyMatrix(e), this;
    };
  }(),
  scale: function() {
    var e = new at();
    return function(r, n, i) {
      return e.makeScale(r, n, i), this.applyMatrix(e), this;
    };
  }(),
  lookAt: function() {
    var e = new ke();
    return function(r) {
      e.lookAt(r), e.updateMatrix(), this.applyMatrix(e.matrix);
    };
  }(),
  fromBufferGeometry: function(e) {
    var t = this, r = e.index !== null ? e.index.array : void 0, n = e.attributes, i = n.position.array, a = n.normal !== void 0 ? n.normal.array : void 0, s = n.color !== void 0 ? n.color.array : void 0, o = n.uv !== void 0 ? n.uv.array : void 0, u = n.uv2 !== void 0 ? n.uv2.array : void 0;
    u !== void 0 && (this.faceVertexUvs[1] = []);
    for (var l = [], c = [], h = [], f = 0, d = 0; f < i.length; f += 3, d += 2)
      t.vertices.push(new z(i[f], i[f + 1], i[f + 2])), a !== void 0 && l.push(new z(a[f], a[f + 1], a[f + 2])), s !== void 0 && t.colors.push(new je(s[f], s[f + 1], s[f + 2])), o !== void 0 && c.push(new ue(o[d], o[d + 1])), u !== void 0 && h.push(new ue(u[d], u[d + 1]));
    function p(C, R, B, k) {
      var F = a !== void 0 ? [l[C].clone(), l[R].clone(), l[B].clone()] : [], I = s !== void 0 ? [t.colors[C].clone(), t.colors[R].clone(), t.colors[B].clone()] : [], H = new kn(C, R, B, F, I, k);
      t.faces.push(H), o !== void 0 && t.faceVertexUvs[0].push([c[C].clone(), c[R].clone(), c[B].clone()]), u !== void 0 && t.faceVertexUvs[1].push([h[C].clone(), h[R].clone(), h[B].clone()]);
    }
    var _ = e.groups;
    if (_.length > 0)
      for (var f = 0; f < _.length; f++)
        for (var v = _[f], x = v.start, E = v.count, d = x, M = x + E; d < M; d += 3)
          r !== void 0 ? p(r[d], r[d + 1], r[d + 2], v.materialIndex) : p(d, d + 1, d + 2, v.materialIndex);
    else if (r !== void 0)
      for (var f = 0; f < r.length; f += 3)
        p(r[f], r[f + 1], r[f + 2]);
    else
      for (var f = 0; f < i.length / 3; f += 3)
        p(f, f + 1, f + 2);
    return this.computeFaceNormals(), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  },
  center: function() {
    var e = new z();
    return function() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this;
    };
  }(),
  normalize: function() {
    this.computeBoundingSphere();
    var e = this.boundingSphere.center, t = this.boundingSphere.radius, r = t === 0 ? 1 : 1 / t, n = new at();
    return n.set(
      r,
      0,
      0,
      -r * e.x,
      0,
      r,
      0,
      -r * e.y,
      0,
      0,
      r,
      -r * e.z,
      0,
      0,
      0,
      1
    ), this.applyMatrix(n), this;
  },
  computeFaceNormals: function() {
    for (var e = new z(), t = new z(), r = 0, n = this.faces.length; r < n; r++) {
      var i = this.faces[r], a = this.vertices[i.a], s = this.vertices[i.b], o = this.vertices[i.c];
      e.subVectors(o, s), t.subVectors(a, s), e.cross(t), e.normalize(), i.normal.copy(e);
    }
  },
  computeVertexNormals: function(e) {
    e === void 0 && (e = !0);
    var t, r, n, i, a, s;
    for (s = new Array(this.vertices.length), t = 0, r = this.vertices.length; t < r; t++)
      s[t] = new z();
    if (e) {
      var o, u, l, c = new z(), h = new z();
      for (n = 0, i = this.faces.length; n < i; n++)
        a = this.faces[n], o = this.vertices[a.a], u = this.vertices[a.b], l = this.vertices[a.c], c.subVectors(l, u), h.subVectors(o, u), c.cross(h), s[a.a].add(c), s[a.b].add(c), s[a.c].add(c);
    } else
      for (this.computeFaceNormals(), n = 0, i = this.faces.length; n < i; n++)
        a = this.faces[n], s[a.a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal);
    for (t = 0, r = this.vertices.length; t < r; t++)
      s[t].normalize();
    for (n = 0, i = this.faces.length; n < i; n++) {
      a = this.faces[n];
      var f = a.vertexNormals;
      f.length === 3 ? (f[0].copy(s[a.a]), f[1].copy(s[a.b]), f[2].copy(s[a.c])) : (f[0] = s[a.a].clone(), f[1] = s[a.b].clone(), f[2] = s[a.c].clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeFlatVertexNormals: function() {
    var e, t, r;
    for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
      r = this.faces[e];
      var n = r.vertexNormals;
      n.length === 3 ? (n[0].copy(r.normal), n[1].copy(r.normal), n[2].copy(r.normal)) : (n[0] = r.normal.clone(), n[1] = r.normal.clone(), n[2] = r.normal.clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeMorphNormals: function() {
    var e, t, r, n, i;
    for (r = 0, n = this.faces.length; r < n; r++)
      for (i = this.faces[r], i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++)
        i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
    var a = new tt();
    for (a.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        var s = this.morphNormals[e].faceNormals, o = this.morphNormals[e].vertexNormals, l, c;
        for (r = 0, n = this.faces.length; r < n; r++)
          l = new z(), c = { a: new z(), b: new z(), c: new z() }, s.push(l), o.push(c);
      }
      var u = this.morphNormals[e];
      a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals();
      var l, c;
      for (r = 0, n = this.faces.length; r < n; r++)
        i = this.faces[r], l = u.faceNormals[r], c = u.vertexNormals[r], l.copy(i.normal), c.a.copy(i.vertexNormals[0]), c.b.copy(i.vertexNormals[1]), c.c.copy(i.vertexNormals[2]);
    }
    for (r = 0, n = this.faces.length; r < n; r++)
      i = this.faces[r], i.normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals;
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new Hn()), this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new qi()), this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function(e, t, r) {
    if (!(e && e.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
      return;
    }
    var n, i = this.vertices.length, a = this.vertices, s = e.vertices, o = this.faces, u = e.faces, l = this.faceVertexUvs[0], c = e.faceVertexUvs[0], h = this.colors, f = e.colors;
    r === void 0 && (r = 0), t !== void 0 && (n = new wr().getNormalMatrix(t));
    for (var d = 0, p = s.length; d < p; d++) {
      var _ = s[d], v = _.clone();
      t !== void 0 && v.applyMatrix4(t), a.push(v);
    }
    for (var d = 0, p = f.length; d < p; d++)
      h.push(f[d].clone());
    for (d = 0, p = u.length; d < p; d++) {
      var x = u[d], E, M, C, R = x.vertexNormals, B = x.vertexColors;
      E = new kn(x.a + i, x.b + i, x.c + i), E.normal.copy(x.normal), n !== void 0 && E.normal.applyMatrix3(n).normalize();
      for (var k = 0, F = R.length; k < F; k++)
        M = R[k].clone(), n !== void 0 && M.applyMatrix3(n).normalize(), E.vertexNormals.push(M);
      E.color.copy(x.color);
      for (var k = 0, F = B.length; k < F; k++)
        C = B[k], E.vertexColors.push(C.clone());
      E.materialIndex = x.materialIndex + r, o.push(E);
    }
    for (d = 0, p = c.length; d < p; d++) {
      var I = c[d], H = [];
      if (I !== void 0) {
        for (var k = 0, F = I.length; k < F; k++)
          H.push(I[k].clone());
        l.push(H);
      }
    }
  },
  mergeMesh: function(e) {
    if (!(e && e.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e);
      return;
    }
    e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix);
  },
  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function() {
    var e = {}, t = [], r = [], n, i, a = 4, s = Math.pow(10, a), o, u, l, c, h, f;
    for (o = 0, u = this.vertices.length; o < u; o++)
      n = this.vertices[o], i = Math.round(n.x * s) + "_" + Math.round(n.y * s) + "_" + Math.round(n.z * s), e[i] === void 0 ? (e[i] = o, t.push(this.vertices[o]), r[o] = t.length - 1) : r[o] = r[e[i]];
    var d = [];
    for (o = 0, u = this.faces.length; o < u; o++) {
      l = this.faces[o], l.a = r[l.a], l.b = r[l.b], l.c = r[l.c], c = [l.a, l.b, l.c];
      for (var p = 0; p < 3; p++)
        if (c[p] === c[(p + 1) % 3]) {
          d.push(o);
          break;
        }
    }
    for (o = d.length - 1; o >= 0; o--) {
      var _ = d[o];
      for (this.faces.splice(_, 1), h = 0, f = this.faceVertexUvs.length; h < f; h++)
        this.faceVertexUvs[h].splice(_, 1);
    }
    var v = this.vertices.length - t.length;
    return this.vertices = t, v;
  },
  setFromPoints: function(e) {
    this.vertices = [];
    for (var t = 0, r = e.length; t < r; t++) {
      var n = e[t];
      this.vertices.push(new z(n.x, n.y, n.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function() {
    for (var e = this.faces, t = e.length, r = 0; r < t; r++)
      e[r]._id = r;
    function n(l, c) {
      return l.materialIndex - c.materialIndex;
    }
    e.sort(n);
    var i = this.faceVertexUvs[0], a = this.faceVertexUvs[1], s, o;
    i && i.length === t && (s = []), a && a.length === t && (o = []);
    for (var r = 0; r < t; r++) {
      var u = e[r]._id;
      s && s.push(i[u]), o && o.push(a[u]);
    }
    s && (this.faceVertexUvs[0] = s), o && (this.faceVertexUvs[1] = o);
  },
  toJSON: function() {
    var e = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), this.parameters !== void 0) {
      var t = this.parameters;
      for (var r in t)
        t[r] !== void 0 && (e[r] = t[r]);
      return e;
    }
    for (var n = [], i = 0; i < this.vertices.length; i++) {
      var a = this.vertices[i];
      n.push(a.x, a.y, a.z);
    }
    for (var s = [], o = [], u = {}, l = [], c = {}, h = [], f = {}, i = 0; i < this.faces.length; i++) {
      var d = this.faces[i], p = !0, _ = !1, v = this.faceVertexUvs[0][i] !== void 0, x = d.normal.length() > 0, E = d.vertexNormals.length > 0, M = d.color.r !== 1 || d.color.g !== 1 || d.color.b !== 1, C = d.vertexColors.length > 0, R = 0;
      if (R = I(R, 0, 0), R = I(R, 1, p), R = I(R, 2, _), R = I(R, 3, v), R = I(R, 4, x), R = I(R, 5, E), R = I(R, 6, M), R = I(R, 7, C), s.push(R), s.push(d.a, d.b, d.c), s.push(d.materialIndex), v) {
        var B = this.faceVertexUvs[0][i];
        s.push(
          ee(B[0]),
          ee(B[1]),
          ee(B[2])
        );
      }
      if (x && s.push(H(d.normal)), E) {
        var k = d.vertexNormals;
        s.push(
          H(k[0]),
          H(k[1]),
          H(k[2])
        );
      }
      if (M && s.push(Q(d.color)), C) {
        var F = d.vertexColors;
        s.push(
          Q(F[0]),
          Q(F[1]),
          Q(F[2])
        );
      }
    }
    function I(oe, de, he) {
      return he ? oe | 1 << de : oe & ~(1 << de);
    }
    function H(oe) {
      var de = oe.x.toString() + oe.y.toString() + oe.z.toString();
      return u[de] !== void 0 || (u[de] = o.length / 3, o.push(oe.x, oe.y, oe.z)), u[de];
    }
    function Q(oe) {
      var de = oe.r.toString() + oe.g.toString() + oe.b.toString();
      return c[de] !== void 0 || (c[de] = l.length, l.push(oe.getHex())), c[de];
    }
    function ee(oe) {
      var de = oe.x.toString() + oe.y.toString();
      return f[de] !== void 0 || (f[de] = h.length / 2, h.push(oe.x, oe.y)), f[de];
    }
    return e.data = {}, e.data.vertices = n, e.data.normals = o, l.length > 0 && (e.data.colors = l), h.length > 0 && (e.data.uvs = [h]), e.data.faces = s, e;
  },
  clone: function() {
    return new tt().copy(this);
  },
  copy: function(e) {
    var t, r, n, i, a, s;
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
    var o = e.vertices;
    for (t = 0, r = o.length; t < r; t++)
      this.vertices.push(o[t].clone());
    var u = e.colors;
    for (t = 0, r = u.length; t < r; t++)
      this.colors.push(u[t].clone());
    var l = e.faces;
    for (t = 0, r = l.length; t < r; t++)
      this.faces.push(l[t].clone());
    for (t = 0, r = e.faceVertexUvs.length; t < r; t++) {
      var c = e.faceVertexUvs[t];
      for (this.faceVertexUvs[t] === void 0 && (this.faceVertexUvs[t] = []), n = 0, i = c.length; n < i; n++) {
        var h = c[n], f = [];
        for (a = 0, s = h.length; a < s; a++) {
          var d = h[a];
          f.push(d.clone());
        }
        this.faceVertexUvs[t].push(f);
      }
    }
    var p = e.morphTargets;
    for (t = 0, r = p.length; t < r; t++) {
      var _ = {};
      if (_.name = p[t].name, p[t].vertices !== void 0)
        for (_.vertices = [], n = 0, i = p[t].vertices.length; n < i; n++)
          _.vertices.push(p[t].vertices[n].clone());
      if (p[t].normals !== void 0)
        for (_.normals = [], n = 0, i = p[t].normals.length; n < i; n++)
          _.normals.push(p[t].normals[n].clone());
      this.morphTargets.push(_);
    }
    var v = e.morphNormals;
    for (t = 0, r = v.length; t < r; t++) {
      var x = {};
      if (v[t].vertexNormals !== void 0)
        for (x.vertexNormals = [], n = 0, i = v[t].vertexNormals.length; n < i; n++) {
          var E = v[t].vertexNormals[n], M = {};
          M.a = E.a.clone(), M.b = E.b.clone(), M.c = E.c.clone(), x.vertexNormals.push(M);
        }
      if (v[t].faceNormals !== void 0)
        for (x.faceNormals = [], n = 0, i = v[t].faceNormals.length; n < i; n++)
          x.faceNormals.push(v[t].faceNormals[n].clone());
      this.morphNormals.push(x);
    }
    var C = e.skinWeights;
    for (t = 0, r = C.length; t < r; t++)
      this.skinWeights.push(C[t].clone());
    var R = e.skinIndices;
    for (t = 0, r = R.length; t < r; t++)
      this.skinIndices.push(R[t].clone());
    var B = e.lineDistances;
    for (t = 0, r = B.length; t < r; t++)
      this.lineDistances.push(B[t]);
    var k = e.boundingBox;
    k !== null && (this.boundingBox = k.clone());
    var F = e.boundingSphere;
    return F !== null && (this.boundingSphere = F.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function pt(e, t, r) {
  if (Array.isArray(e))
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r === !0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
Object.defineProperty(pt.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
Object.assign(pt.prototype, {
  isBufferAttribute: !0,
  onUploadCallback: function() {
  },
  setArray: function(e) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    return this.count = e !== void 0 ? e.length / this.itemSize : 0, this.array = e, this;
  },
  setDynamic: function(e) {
    return this.dynamic = e, this;
  },
  copy: function(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this;
  },
  copyAt: function(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (var n = 0, i = this.itemSize; n < i; n++)
      this.array[e + n] = t.array[r + n];
    return this;
  },
  copyArray: function(e) {
    return this.array.set(e), this;
  },
  copyColorsArray: function(e) {
    for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
      var a = e[n];
      a === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), a = new je()), t[r++] = a.r, t[r++] = a.g, t[r++] = a.b;
    }
    return this;
  },
  copyVector2sArray: function(e) {
    for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
      var a = e[n];
      a === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), a = new ue()), t[r++] = a.x, t[r++] = a.y;
    }
    return this;
  },
  copyVector3sArray: function(e) {
    for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
      var a = e[n];
      a === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new z()), t[r++] = a.x, t[r++] = a.y, t[r++] = a.z;
    }
    return this;
  },
  copyVector4sArray: function(e) {
    for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
      var a = e[n];
      a === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), a = new kt()), t[r++] = a.x, t[r++] = a.y, t[r++] = a.z, t[r++] = a.w;
    }
    return this;
  },
  set: function(e, t) {
    return t === void 0 && (t = 0), this.array.set(e, t), this;
  },
  getX: function(e) {
    return this.array[e * this.itemSize];
  },
  setX: function(e, t) {
    return this.array[e * this.itemSize] = t, this;
  },
  getY: function(e) {
    return this.array[e * this.itemSize + 1];
  },
  setY: function(e, t) {
    return this.array[e * this.itemSize + 1] = t, this;
  },
  getZ: function(e) {
    return this.array[e * this.itemSize + 2];
  },
  setZ: function(e, t) {
    return this.array[e * this.itemSize + 2] = t, this;
  },
  getW: function(e) {
    return this.array[e * this.itemSize + 3];
  },
  setW: function(e, t) {
    return this.array[e * this.itemSize + 3] = t, this;
  },
  setXY: function(e, t, r) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this;
  },
  setXYZ: function(e, t, r, n) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this;
  },
  setXYZW: function(e, t, r, n, i) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this.array[e + 3] = i, this;
  },
  onUpload: function(e) {
    return this.onUploadCallback = e, this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
});
function _u(e, t, r) {
  pt.call(this, new Int8Array(e), t, r);
}
_u.prototype = Object.create(pt.prototype);
_u.prototype.constructor = _u;
function bu(e, t, r) {
  pt.call(this, new Uint8Array(e), t, r);
}
bu.prototype = Object.create(pt.prototype);
bu.prototype.constructor = bu;
function xu(e, t, r) {
  pt.call(this, new Uint8ClampedArray(e), t, r);
}
xu.prototype = Object.create(pt.prototype);
xu.prototype.constructor = xu;
function Au(e, t, r) {
  pt.call(this, new Int16Array(e), t, r);
}
Au.prototype = Object.create(pt.prototype);
Au.prototype.constructor = Au;
function Ya(e, t, r) {
  pt.call(this, new Uint16Array(e), t, r);
}
Ya.prototype = Object.create(pt.prototype);
Ya.prototype.constructor = Ya;
function Tu(e, t, r) {
  pt.call(this, new Int32Array(e), t, r);
}
Tu.prototype = Object.create(pt.prototype);
Tu.prototype.constructor = Tu;
function Qa(e, t, r) {
  pt.call(this, new Uint32Array(e), t, r);
}
Qa.prototype = Object.create(pt.prototype);
Qa.prototype.constructor = Qa;
function Be(e, t, r) {
  pt.call(this, new Float32Array(e), t, r);
}
Be.prototype = Object.create(pt.prototype);
Be.prototype.constructor = Be;
function Eu(e, t, r) {
  pt.call(this, new Float64Array(e), t, r);
}
Eu.prototype = Object.create(pt.prototype);
Eu.prototype.constructor = Eu;
function N0() {
  this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
Object.assign(N0.prototype, {
  computeGroups: function(e) {
    for (var t, r = [], n = void 0, i = e.faces, a = 0; a < i.length; a++) {
      var s = i[a];
      s.materialIndex !== n && (n = s.materialIndex, t !== void 0 && (t.count = a * 3 - t.start, r.push(t)), t = {
        start: a * 3,
        materialIndex: n
      });
    }
    t !== void 0 && (t.count = a * 3 - t.start, r.push(t)), this.groups = r;
  },
  fromGeometry: function(e) {
    var t = e.faces, r = e.vertices, n = e.faceVertexUvs, i = n[0] && n[0].length > 0, a = n[1] && n[1].length > 0, s = e.morphTargets, o = s.length, u;
    if (o > 0) {
      u = [];
      for (var l = 0; l < o; l++)
        u[l] = [];
      this.morphTargets.position = u;
    }
    var c = e.morphNormals, h = c.length, f;
    if (h > 0) {
      f = [];
      for (var l = 0; l < h; l++)
        f[l] = [];
      this.morphTargets.normal = f;
    }
    var d = e.skinIndices, p = e.skinWeights, _ = d.length === r.length, v = p.length === r.length;
    t.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (var l = 0; l < t.length; l++) {
      var x = t[l];
      this.vertices.push(r[x.a], r[x.b], r[x.c]);
      var E = x.vertexNormals;
      if (E.length === 3)
        this.normals.push(E[0], E[1], E[2]);
      else {
        var M = x.normal;
        this.normals.push(M, M, M);
      }
      var C = x.vertexColors;
      if (C.length === 3)
        this.colors.push(C[0], C[1], C[2]);
      else {
        var R = x.color;
        this.colors.push(R, R, R);
      }
      if (i === !0) {
        var B = n[0][l];
        B !== void 0 ? this.uvs.push(B[0], B[1], B[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new ue(), new ue(), new ue()));
      }
      if (a === !0) {
        var B = n[1][l];
        B !== void 0 ? this.uvs2.push(B[0], B[1], B[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new ue(), new ue(), new ue()));
      }
      for (var k = 0; k < o; k++) {
        var F = s[k].vertices;
        u[k].push(F[x.a], F[x.b], F[x.c]);
      }
      for (var k = 0; k < h; k++) {
        var I = c[k].vertexNormals[l];
        f[k].push(I.a, I.b, I.c);
      }
      _ && this.skinIndices.push(d[x.a], d[x.b], d[x.c]), v && this.skinWeights.push(p[x.a], p[x.b], p[x.c]);
    }
    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this;
  }
});
function U0(e) {
  if (e.length === 0) return -1 / 0;
  for (var t = e[0], r = 1, n = e.length; r < n; ++r)
    e[r] > t && (t = e[r]);
  return t;
}
var GT = 1;
function Ge() {
  Object.defineProperty(this, "id", { value: GT += 2 }), this.uuid = gt.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
}
Ge.prototype = Object.assign(Object.create($n.prototype), {
  constructor: Ge,
  isBufferGeometry: !0,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(e) {
    Array.isArray(e) ? this.index = new (U0(e) > 65535 ? Qa : Ya)(e, 1) : this.index = e;
  },
  addAttribute: function(e, t) {
    return !(t && t.isBufferAttribute) && !(t && t.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new pt(arguments[1], arguments[2]))) : e === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this);
  },
  getAttribute: function(e) {
    return this.attributes[e];
  },
  removeAttribute: function(e) {
    return delete this.attributes[e], this;
  },
  addGroup: function(e, t, r) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r !== void 0 ? r : 0
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  },
  applyMatrix: function(e) {
    var t = this.attributes.position;
    t !== void 0 && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
    var r = this.attributes.normal;
    if (r !== void 0) {
      var n = new wr().getNormalMatrix(e);
      n.applyToBufferAttribute(r), r.needsUpdate = !0;
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  },
  rotateX: function() {
    var e = new at();
    return function(r) {
      return e.makeRotationX(r), this.applyMatrix(e), this;
    };
  }(),
  rotateY: function() {
    var e = new at();
    return function(r) {
      return e.makeRotationY(r), this.applyMatrix(e), this;
    };
  }(),
  rotateZ: function() {
    var e = new at();
    return function(r) {
      return e.makeRotationZ(r), this.applyMatrix(e), this;
    };
  }(),
  translate: function() {
    var e = new at();
    return function(r, n, i) {
      return e.makeTranslation(r, n, i), this.applyMatrix(e), this;
    };
  }(),
  scale: function() {
    var e = new at();
    return function(r, n, i) {
      return e.makeScale(r, n, i), this.applyMatrix(e), this;
    };
  }(),
  lookAt: function() {
    var e = new ke();
    return function(r) {
      e.lookAt(r), e.updateMatrix(), this.applyMatrix(e.matrix);
    };
  }(),
  center: function() {
    var e = new z();
    return function() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this;
    };
  }(),
  setFromObject: function(e) {
    var t = e.geometry;
    if (e.isPoints || e.isLine) {
      var r = new Be(t.vertices.length * 3, 3), n = new Be(t.colors.length * 3, 3);
      if (this.addAttribute("position", r.copyVector3sArray(t.vertices)), this.addAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
        var i = new Be(t.lineDistances.length, 1);
        this.addAttribute("lineDistance", i.copyArray(t.lineDistances));
      }
      t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone());
    } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
    return this;
  },
  setFromPoints: function(e) {
    for (var t = [], r = 0, n = e.length; r < n; r++) {
      var i = e[r];
      t.push(i.x, i.y, i.z || 0);
    }
    return this.addAttribute("position", new Be(t, 3)), this;
  },
  updateFromObject: function(e) {
    var t = e.geometry;
    if (e.isMesh) {
      var r = t.__directGeometry;
      if (t.elementsNeedUpdate === !0 && (r = void 0, t.elementsNeedUpdate = !1), r === void 0)
        return this.fromGeometry(t);
      r.verticesNeedUpdate = t.verticesNeedUpdate, r.normalsNeedUpdate = t.normalsNeedUpdate, r.colorsNeedUpdate = t.colorsNeedUpdate, r.uvsNeedUpdate = t.uvsNeedUpdate, r.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = r;
    }
    var n;
    return t.verticesNeedUpdate === !0 && (n = this.attributes.position, n !== void 0 && (n.copyVector3sArray(t.vertices), n.needsUpdate = !0), t.verticesNeedUpdate = !1), t.normalsNeedUpdate === !0 && (n = this.attributes.normal, n !== void 0 && (n.copyVector3sArray(t.normals), n.needsUpdate = !0), t.normalsNeedUpdate = !1), t.colorsNeedUpdate === !0 && (n = this.attributes.color, n !== void 0 && (n.copyColorsArray(t.colors), n.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (n = this.attributes.uv, n !== void 0 && (n.copyVector2sArray(t.uvs), n.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (n = this.attributes.lineDistance, n !== void 0 && (n.copyArray(t.lineDistances), n.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this;
  },
  fromGeometry: function(e) {
    return e.__directGeometry = new N0().fromGeometry(e), this.fromDirectGeometry(e.__directGeometry);
  },
  fromDirectGeometry: function(e) {
    var t = new Float32Array(e.vertices.length * 3);
    if (this.addAttribute("position", new pt(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
      var r = new Float32Array(e.normals.length * 3);
      this.addAttribute("normal", new pt(r, 3).copyVector3sArray(e.normals));
    }
    if (e.colors.length > 0) {
      var n = new Float32Array(e.colors.length * 3);
      this.addAttribute("color", new pt(n, 3).copyColorsArray(e.colors));
    }
    if (e.uvs.length > 0) {
      var i = new Float32Array(e.uvs.length * 2);
      this.addAttribute("uv", new pt(i, 2).copyVector2sArray(e.uvs));
    }
    if (e.uvs2.length > 0) {
      var a = new Float32Array(e.uvs2.length * 2);
      this.addAttribute("uv2", new pt(a, 2).copyVector2sArray(e.uvs2));
    }
    this.groups = e.groups;
    for (var s in e.morphTargets) {
      for (var o = [], u = e.morphTargets[s], l = 0, c = u.length; l < c; l++) {
        var h = u[l], f = new Be(h.length * 3, 3);
        o.push(f.copyVector3sArray(h));
      }
      this.morphAttributes[s] = o;
    }
    if (e.skinIndices.length > 0) {
      var d = new Be(e.skinIndices.length * 4, 4);
      this.addAttribute("skinIndex", d.copyVector4sArray(e.skinIndices));
    }
    if (e.skinWeights.length > 0) {
      var p = new Be(e.skinWeights.length * 4, 4);
      this.addAttribute("skinWeight", p.copyVector4sArray(e.skinWeights));
    }
    return e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), this;
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new Hn());
    var e = this.attributes.position;
    e !== void 0 ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  },
  computeBoundingSphere: function() {
    var e = new Hn(), t = new z();
    return function() {
      this.boundingSphere === null && (this.boundingSphere = new qi());
      var n = this.attributes.position;
      if (n) {
        var i = this.boundingSphere.center;
        e.setFromBufferAttribute(n), e.getCenter(i);
        for (var a = 0, s = 0, o = n.count; s < o; s++)
          t.x = n.getX(s), t.y = n.getY(s), t.z = n.getZ(s), a = Math.max(a, i.distanceToSquared(t));
        this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    };
  }(),
  computeFaceNormals: function() {
  },
  computeVertexNormals: function() {
    var e = this.index, t = this.attributes, r = this.groups;
    if (t.position) {
      var n = t.position.array;
      if (t.normal === void 0)
        this.addAttribute("normal", new pt(new Float32Array(n.length), 3));
      else
        for (var i = t.normal.array, a = 0, s = i.length; a < s; a++)
          i[a] = 0;
      var o = t.normal.array, u, l, c, h = new z(), f = new z(), d = new z(), p = new z(), _ = new z();
      if (e) {
        var v = e.array;
        r.length === 0 && this.addGroup(0, v.length);
        for (var x = 0, E = r.length; x < E; ++x)
          for (var M = r[x], C = M.start, R = M.count, a = C, s = C + R; a < s; a += 3)
            u = v[a + 0] * 3, l = v[a + 1] * 3, c = v[a + 2] * 3, h.fromArray(n, u), f.fromArray(n, l), d.fromArray(n, c), p.subVectors(d, f), _.subVectors(h, f), p.cross(_), o[u] += p.x, o[u + 1] += p.y, o[u + 2] += p.z, o[l] += p.x, o[l + 1] += p.y, o[l + 2] += p.z, o[c] += p.x, o[c + 1] += p.y, o[c + 2] += p.z;
      } else
        for (var a = 0, s = n.length; a < s; a += 9)
          h.fromArray(n, a), f.fromArray(n, a + 3), d.fromArray(n, a + 6), p.subVectors(d, f), _.subVectors(h, f), p.cross(_), o[a] = p.x, o[a + 1] = p.y, o[a + 2] = p.z, o[a + 3] = p.x, o[a + 4] = p.y, o[a + 5] = p.z, o[a + 6] = p.x, o[a + 7] = p.y, o[a + 8] = p.z;
      this.normalizeNormals(), t.normal.needsUpdate = !0;
    }
  },
  merge: function(e, t) {
    if (!(e && e.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
      return;
    }
    t === void 0 && (t = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    var r = this.attributes;
    for (var n in r)
      if (e.attributes[n] !== void 0)
        for (var i = r[n], a = i.array, s = e.attributes[n], o = s.array, u = s.itemSize, l = 0, c = u * t; l < o.length; l++, c++)
          a[c] = o[l];
    return this;
  },
  normalizeNormals: function() {
    var e = new z();
    return function() {
      for (var r = this.attributes.normal, n = 0, i = r.count; n < i; n++)
        e.x = r.getX(n), e.y = r.getY(n), e.z = r.getZ(n), e.normalize(), r.setXYZ(n, e.x, e.y, e.z);
    };
  }(),
  toNonIndexed: function() {
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    var e = new Ge(), t = this.index.array, r = this.attributes;
    for (var n in r) {
      for (var i = r[n], a = i.array, s = i.itemSize, o = new a.constructor(t.length * s), u = 0, l = 0, c = 0, h = t.length; c < h; c++) {
        u = t[c] * s;
        for (var f = 0; f < s; f++)
          o[l++] = a[u++];
      }
      e.addAttribute(n, new pt(o, s));
    }
    for (var d = this.groups, c = 0, h = d.length; c < h; c++) {
      var p = d[c];
      e.addGroup(p.start, p.count, p.materialIndex);
    }
    return e;
  },
  toJSON: function() {
    var e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      var t = this.parameters;
      for (var r in t)
        t[r] !== void 0 && (e[r] = t[r]);
      return e;
    }
    e.data = { attributes: {} };
    var n = this.index;
    if (n !== null) {
      var i = Array.prototype.slice.call(n.array);
      e.data.index = {
        type: n.array.constructor.name,
        array: i
      };
    }
    var a = this.attributes;
    for (var r in a) {
      var s = a[r], i = Array.prototype.slice.call(s.array);
      e.data.attributes[r] = {
        itemSize: s.itemSize,
        type: s.array.constructor.name,
        array: i,
        normalized: s.normalized
      };
    }
    var o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    var u = this.boundingSphere;
    return u !== null && (e.data.boundingSphere = {
      center: u.center.toArray(),
      radius: u.radius
    }), e;
  },
  clone: function() {
    return new Ge().copy(this);
  },
  copy: function(e) {
    var t, r, n;
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
    var i = e.index;
    i !== null && this.setIndex(i.clone());
    var a = e.attributes;
    for (t in a) {
      var s = a[t];
      this.addAttribute(t, s.clone());
    }
    var o = e.morphAttributes;
    for (t in o) {
      var u = [], l = o[t];
      for (r = 0, n = l.length; r < n; r++)
        u.push(l[r].clone());
      this.morphAttributes[t] = u;
    }
    var c = e.groups;
    for (r = 0, n = c.length; r < n; r++) {
      var h = c[r];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    var f = e.boundingBox;
    f !== null && (this.boundingBox = f.clone());
    var d = e.boundingSphere;
    return d !== null && (this.boundingSphere = d.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function ca(e, t, r, n, i, a) {
  tt.call(this), this.type = "BoxGeometry", this.parameters = {
    width: e,
    height: t,
    depth: r,
    widthSegments: n,
    heightSegments: i,
    depthSegments: a
  }, this.fromBufferGeometry(new Ka(e, t, r, n, i, a)), this.mergeVertices();
}
ca.prototype = Object.create(tt.prototype);
ca.prototype.constructor = ca;
function Ka(e, t, r, n, i, a) {
  Ge.call(this), this.type = "BoxBufferGeometry", this.parameters = {
    width: e,
    height: t,
    depth: r,
    widthSegments: n,
    heightSegments: i,
    depthSegments: a
  };
  var s = this;
  e = e || 1, t = t || 1, r = r || 1, n = Math.floor(n) || 1, i = Math.floor(i) || 1, a = Math.floor(a) || 1;
  var o = [], u = [], l = [], c = [], h = 0, f = 0;
  d("z", "y", "x", -1, -1, r, t, e, a, i, 0), d("z", "y", "x", 1, -1, r, t, -e, a, i, 1), d("x", "z", "y", 1, 1, e, r, t, n, a, 2), d("x", "z", "y", 1, -1, e, r, -t, n, a, 3), d("x", "y", "z", 1, -1, e, t, r, n, i, 4), d("x", "y", "z", -1, -1, e, t, -r, n, i, 5), this.setIndex(o), this.addAttribute("position", new Be(u, 3)), this.addAttribute("normal", new Be(l, 3)), this.addAttribute("uv", new Be(c, 2));
  function d(p, _, v, x, E, M, C, R, B, k, F) {
    var I = M / B, H = C / k, Q = M / 2, ee = C / 2, oe = R / 2, de = B + 1, he = k + 1, fe = 0, V = 0, G, se, re = new z();
    for (se = 0; se < he; se++) {
      var Ce = se * H - ee;
      for (G = 0; G < de; G++) {
        var K = G * I - Q;
        re[p] = K * x, re[_] = Ce * E, re[v] = oe, u.push(re.x, re.y, re.z), re[p] = 0, re[_] = 0, re[v] = R > 0 ? 1 : -1, l.push(re.x, re.y, re.z), c.push(G / B), c.push(1 - se / k), fe += 1;
      }
    }
    for (se = 0; se < k; se++)
      for (G = 0; G < B; G++) {
        var xe = h + G + de * se, pe = h + G + de * (se + 1), Re = h + (G + 1) + de * (se + 1), _e = h + (G + 1) + de * se;
        o.push(xe, pe, _e), o.push(pe, Re, _e), V += 6;
      }
    s.addGroup(f, V, F), f += V, h += fe;
  }
}
Ka.prototype = Object.create(Ge.prototype);
Ka.prototype.constructor = Ka;
function wu(e, t, r, n) {
  tt.call(this), this.type = "PlaneGeometry", this.parameters = {
    width: e,
    height: t,
    widthSegments: r,
    heightSegments: n
  }, this.fromBufferGeometry(new $a(e, t, r, n)), this.mergeVertices();
}
wu.prototype = Object.create(tt.prototype);
wu.prototype.constructor = wu;
function $a(e, t, r, n) {
  Ge.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
    width: e,
    height: t,
    widthSegments: r,
    heightSegments: n
  }, e = e || 1, t = t || 1;
  var i = e / 2, a = t / 2, s = Math.floor(r) || 1, o = Math.floor(n) || 1, u = s + 1, l = o + 1, c = e / s, h = t / o, f, d, p = [], _ = [], v = [], x = [];
  for (d = 0; d < l; d++) {
    var E = d * h - a;
    for (f = 0; f < u; f++) {
      var M = f * c - i;
      _.push(M, -E, 0), v.push(0, 0, 1), x.push(f / s), x.push(1 - d / o);
    }
  }
  for (d = 0; d < o; d++)
    for (f = 0; f < s; f++) {
      var C = f + u * d, R = f + u * (d + 1), B = f + 1 + u * (d + 1), k = f + 1 + u * d;
      p.push(C, R, k), p.push(R, B, k);
    }
  this.setIndex(p), this.addAttribute("position", new Be(_, 3)), this.addAttribute("normal", new Be(v, 3)), this.addAttribute("uv", new Be(x, 2));
}
$a.prototype = Object.create(Ge.prototype);
$a.prototype.constructor = $a;
var VT = 0;
function ft() {
  Object.defineProperty(this, "id", { value: VT++ }), this.uuid = gt.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = _l, this.side = yl, this.flatShading = !1, this.vertexColors = ah, this.opacity = 1, this.transparent = !1, this.blendSrc = Ld, this.blendDst = Rd, this.blendEquation = Pd, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = oc, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0;
}
ft.prototype = Object.assign(Object.create($n.prototype), {
  constructor: ft,
  isMaterial: !0,
  onBeforeCompile: function() {
  },
  setValues: function(e) {
    if (e !== void 0)
      for (var t in e) {
        var r = e[t];
        if (r === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        if (t === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = r === Ed;
          continue;
        }
        var n = this[t];
        if (n === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : t === "overdraw" ? this[t] = Number(r) : this[t] = r;
      }
  },
  toJSON: function(e) {
    var t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    var r = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearCoat !== void 0 && (r.clearCoat = this.clearCoat), this.clearCoatRoughness !== void 0 && (r.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, r.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.size !== void 0 && (r.size = this.size), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== _l && (r.blending = this.blending), this.flatShading === !0 && (r.flatShading = this.flatShading), this.side !== yl && (r.side = this.side), this.vertexColors !== ah && (r.vertexColors = this.vertexColors), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, this.rotation !== 0 && (r.rotation = this.rotation), this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (r.morphTargets = !0), this.skinning === !0 && (r.skinning = !0), this.visible === !1 && (r.visible = !1), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData);
    function n(s) {
      var o = [];
      for (var u in s) {
        var l = s[u];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      var i = n(e.textures), a = n(e.images);
      i.length > 0 && (r.textures = i), a.length > 0 && (r.images = a);
    }
    return r;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.overdraw = e.overdraw, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
    var t = e.clippingPlanes, r = null;
    if (t !== null) {
      var n = t.length;
      r = new Array(n);
      for (var i = 0; i !== n; ++i)
        r[i] = t[i].clone();
    }
    return this.clippingPlanes = r, this.shadowSide = e.shadowSide, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function Er(e) {
  ft.call(this), this.type = "MeshBasicMaterial", this.color = new je(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = bl, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e);
}
Er.prototype = Object.create(ft.prototype);
Er.prototype.constructor = Er;
Er.prototype.isMeshBasicMaterial = !0;
Er.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this;
};
function Mi(e) {
  ft.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
    derivatives: !1,
    // set to use derivatives
    fragDepth: !1,
    // set to use fragment depth values
    drawBuffers: !1,
    // set to use draw buffers
    shaderTextureLOD: !1
    // set to use shader texture LOD
  }, this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
}
Mi.prototype = Object.create(ft.prototype);
Mi.prototype.constructor = Mi;
Mi.prototype.isShaderMaterial = !0;
Mi.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = si.clone(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this;
};
Mi.prototype.toJSON = function(e) {
  var t = ft.prototype.toJSON.call(this, e);
  return t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t;
};
function ms(e, t) {
  this.origin = e !== void 0 ? e : new z(), this.direction = t !== void 0 ? t : new z();
}
Object.assign(ms.prototype, {
  set: function(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  },
  at: function(e, t) {
    return t === void 0 && (console.warn("THREE.Ray: .at() target is now required"), t = new z()), t.copy(this.direction).multiplyScalar(e).add(this.origin);
  },
  lookAt: function(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  },
  recast: function() {
    var e = new z();
    return function(r) {
      return this.origin.copy(this.at(r, e)), this;
    };
  }(),
  closestPointToPoint: function(e, t) {
    t === void 0 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new z()), t.subVectors(e, this.origin);
    var r = t.dot(this.direction);
    return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin);
  },
  distanceToPoint: function(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  },
  distanceSqToPoint: function() {
    var e = new z();
    return function(r) {
      var n = e.subVectors(r, this.origin).dot(this.direction);
      return n < 0 ? this.origin.distanceToSquared(r) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceToSquared(r));
    };
  }(),
  distanceSqToSegment: function() {
    var e = new z(), t = new z(), r = new z();
    return function(i, a, s, o) {
      e.copy(i).add(a).multiplyScalar(0.5), t.copy(a).sub(i).normalize(), r.copy(this.origin).sub(e);
      var u = i.distanceTo(a) * 0.5, l = -this.direction.dot(t), c = r.dot(this.direction), h = -r.dot(t), f = r.lengthSq(), d = Math.abs(1 - l * l), p, _, v, x;
      if (d > 0)
        if (p = l * h - c, _ = l * c - h, x = u * d, p >= 0)
          if (_ >= -x)
            if (_ <= x) {
              var E = 1 / d;
              p *= E, _ *= E, v = p * (p + l * _ + 2 * c) + _ * (l * p + _ + 2 * h) + f;
            } else
              _ = u, p = Math.max(0, -(l * _ + c)), v = -p * p + _ * (_ + 2 * h) + f;
          else
            _ = -u, p = Math.max(0, -(l * _ + c)), v = -p * p + _ * (_ + 2 * h) + f;
        else
          _ <= -x ? (p = Math.max(0, -(-l * u + c)), _ = p > 0 ? -u : Math.min(Math.max(-u, -h), u), v = -p * p + _ * (_ + 2 * h) + f) : _ <= x ? (p = 0, _ = Math.min(Math.max(-u, -h), u), v = _ * (_ + 2 * h) + f) : (p = Math.max(0, -(l * u + c)), _ = p > 0 ? u : Math.min(Math.max(-u, -h), u), v = -p * p + _ * (_ + 2 * h) + f);
      else
        _ = l > 0 ? -u : u, p = Math.max(0, -(l * _ + c)), v = -p * p + _ * (_ + 2 * h) + f;
      return s && s.copy(this.direction).multiplyScalar(p).add(this.origin), o && o.copy(t).multiplyScalar(_).add(e), v;
    };
  }(),
  intersectSphere: function() {
    var e = new z();
    return function(r, n) {
      e.subVectors(r.center, this.origin);
      var i = e.dot(this.direction), a = e.dot(e) - i * i, s = r.radius * r.radius;
      if (a > s) return null;
      var o = Math.sqrt(s - a), u = i - o, l = i + o;
      return u < 0 && l < 0 ? null : u < 0 ? this.at(l, n) : this.at(u, n);
    };
  }(),
  intersectsSphere: function(e) {
    return this.distanceToPoint(e.center) <= e.radius;
  },
  distanceToPlane: function(e) {
    var t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    var r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  },
  intersectPlane: function(e, t) {
    var r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  },
  intersectsPlane: function(e) {
    var t = e.distanceToPoint(this.origin);
    if (t === 0)
      return !0;
    var r = e.normal.dot(this.direction);
    return r * t < 0;
  },
  intersectBox: function(e, t) {
    var r, n, i, a, s, o, u = 1 / this.direction.x, l = 1 / this.direction.y, c = 1 / this.direction.z, h = this.origin;
    return u >= 0 ? (r = (e.min.x - h.x) * u, n = (e.max.x - h.x) * u) : (r = (e.max.x - h.x) * u, n = (e.min.x - h.x) * u), l >= 0 ? (i = (e.min.y - h.y) * l, a = (e.max.y - h.y) * l) : (i = (e.max.y - h.y) * l, a = (e.min.y - h.y) * l), r > a || i > n || ((i > r || r !== r) && (r = i), (a < n || n !== n) && (n = a), c >= 0 ? (s = (e.min.z - h.z) * c, o = (e.max.z - h.z) * c) : (s = (e.max.z - h.z) * c, o = (e.min.z - h.z) * c), r > o || s > n) || ((s > r || r !== r) && (r = s), (o < n || n !== n) && (n = o), n < 0) ? null : this.at(r >= 0 ? r : n, t);
  },
  intersectsBox: function() {
    var e = new z();
    return function(r) {
      return this.intersectBox(r, e) !== null;
    };
  }(),
  intersectTriangle: function() {
    var e = new z(), t = new z(), r = new z(), n = new z();
    return function(a, s, o, u, l) {
      t.subVectors(s, a), r.subVectors(o, a), n.crossVectors(t, r);
      var c = this.direction.dot(n), h;
      if (c > 0) {
        if (u) return null;
        h = 1;
      } else if (c < 0)
        h = -1, c = -c;
      else
        return null;
      e.subVectors(this.origin, a);
      var f = h * this.direction.dot(r.crossVectors(e, r));
      if (f < 0)
        return null;
      var d = h * this.direction.dot(t.cross(e));
      if (d < 0 || f + d > c)
        return null;
      var p = -h * e.dot(n);
      return p < 0 ? null : this.at(p / c, l);
    };
  }(),
  applyMatrix4: function(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  },
  equals: function(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
});
function Os(e, t) {
  this.start = e !== void 0 ? e : new z(), this.end = t !== void 0 ? t : new z();
}
Object.assign(Os.prototype, {
  set: function(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  },
  getCenter: function(e) {
    return e === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new z()), e.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function(e) {
    return e === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), e = new z()), e.subVectors(this.end, this.start);
  },
  distanceSq: function() {
    return this.start.distanceToSquared(this.end);
  },
  distance: function() {
    return this.start.distanceTo(this.end);
  },
  at: function(e, t) {
    return t === void 0 && (console.warn("THREE.Line3: .at() target is now required"), t = new z()), this.delta(t).multiplyScalar(e).add(this.start);
  },
  closestPointToPointParameter: function() {
    var e = new z(), t = new z();
    return function(n, i) {
      e.subVectors(n, this.start), t.subVectors(this.end, this.start);
      var a = t.dot(t), s = t.dot(e), o = s / a;
      return i && (o = gt.clamp(o, 0, 1)), o;
    };
  }(),
  closestPointToPoint: function(e, t, r) {
    var n = this.closestPointToPointParameter(e, t);
    return r === void 0 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), r = new z()), this.delta(r).multiplyScalar(n).add(this.start);
  },
  applyMatrix4: function(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  },
  equals: function(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
});
function Si(e, t, r) {
  this.a = e !== void 0 ? e : new z(), this.b = t !== void 0 ? t : new z(), this.c = r !== void 0 ? r : new z();
}
Object.assign(Si, {
  getNormal: function() {
    var e = new z();
    return function(r, n, i, a) {
      a === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), a = new z()), a.subVectors(i, n), e.subVectors(r, n), a.cross(e);
      var s = a.lengthSq();
      return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0);
    };
  }(),
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord: function() {
    var e = new z(), t = new z(), r = new z();
    return function(i, a, s, o, u) {
      e.subVectors(o, a), t.subVectors(s, a), r.subVectors(i, a);
      var l = e.dot(e), c = e.dot(t), h = e.dot(r), f = t.dot(t), d = t.dot(r), p = l * f - c * c;
      if (u === void 0 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), u = new z()), p === 0)
        return u.set(-2, -1, -1);
      var _ = 1 / p, v = (f * h - c * d) * _, x = (l * d - c * h) * _;
      return u.set(1 - v - x, x, v);
    };
  }(),
  containsPoint: function() {
    var e = new z();
    return function(r, n, i, a) {
      return Si.getBarycoord(r, n, i, a, e), e.x >= 0 && e.y >= 0 && e.x + e.y <= 1;
    };
  }()
});
Object.assign(Si.prototype, {
  set: function(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  },
  setFromPointsAndIndices: function(e, t, r, n) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  },
  getArea: function() {
    var e = new z(), t = new z();
    return function() {
      return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), e.cross(t).length() * 0.5;
    };
  }(),
  getMidpoint: function(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new z()), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function(e) {
    return Si.getNormal(this.a, this.b, this.c, e);
  },
  getPlane: function(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new z()), e.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function(e, t) {
    return Si.getBarycoord(e, this.a, this.b, this.c, t);
  },
  containsPoint: function(e) {
    return Si.containsPoint(e, this.a, this.b, this.c);
  },
  intersectsBox: function(e) {
    return e.intersectsTriangle(this);
  },
  closestPointToPoint: function() {
    var e = new Vi(), t = [new Os(), new Os(), new Os()], r = new z(), n = new z();
    return function(a, s) {
      s === void 0 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), s = new z());
      var o = 1 / 0;
      if (e.setFromCoplanarPoints(this.a, this.b, this.c), e.projectPoint(a, r), this.containsPoint(r) === !0)
        s.copy(r);
      else {
        t[0].set(this.a, this.b), t[1].set(this.b, this.c), t[2].set(this.c, this.a);
        for (var u = 0; u < t.length; u++) {
          t[u].closestPointToPoint(r, !0, n);
          var l = r.distanceToSquared(n);
          l < o && (o = l, s.copy(n));
        }
      }
      return s;
    };
  }(),
  equals: function(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
});
function dr(e, t) {
  ke.call(this), this.type = "Mesh", this.geometry = e !== void 0 ? e : new Ge(), this.material = t !== void 0 ? t : new Er({ color: Math.random() * 16777215 }), this.drawMode = Nd, this.updateMorphTargets();
}
dr.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: dr,
  isMesh: !0,
  setDrawMode: function(e) {
    this.drawMode = e;
  },
  copy: function(e) {
    return ke.prototype.copy.call(this, e), this.drawMode = e.drawMode, e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this;
  },
  updateMorphTargets: function() {
    var e = this.geometry, t, r, n;
    if (e.isBufferGeometry) {
      var i = e.morphAttributes, a = Object.keys(i);
      if (a.length > 0) {
        var s = i[a[0]];
        if (s !== void 0)
          for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, r = s.length; t < r; t++)
            n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
      }
    } else {
      var o = e.morphTargets;
      if (o !== void 0 && o.length > 0)
        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, r = o.length; t < r; t++)
          n = o[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
    }
  },
  raycast: function() {
    var e = new at(), t = new ms(), r = new qi(), n = new z(), i = new z(), a = new z(), s = new z(), o = new z(), u = new z(), l = new ue(), c = new ue(), h = new ue(), f = new z(), d = new z(), p = new z();
    function _(E, M, C, R, B, k, F) {
      return Si.getBarycoord(E, M, C, R, f), B.multiplyScalar(f.x), k.multiplyScalar(f.y), F.multiplyScalar(f.z), B.add(k).add(F), B.clone();
    }
    function v(E, M, C, R, B, k, F, I) {
      var H;
      if (M.side === Tr ? H = R.intersectTriangle(F, k, B, !0, I) : H = R.intersectTriangle(B, k, F, M.side !== Ro, I), H === null) return null;
      p.copy(I), p.applyMatrix4(E.matrixWorld);
      var Q = C.ray.origin.distanceTo(p);
      return Q < C.near || Q > C.far ? null : {
        distance: Q,
        point: p.clone(),
        object: E
      };
    }
    function x(E, M, C, R, B, k, F, I) {
      n.fromBufferAttribute(R, k), i.fromBufferAttribute(R, F), a.fromBufferAttribute(R, I);
      var H = v(E, E.material, M, C, n, i, a, d);
      if (H) {
        B && (l.fromBufferAttribute(B, k), c.fromBufferAttribute(B, F), h.fromBufferAttribute(B, I), H.uv = _(d, n, i, a, l, c, h));
        var Q = new kn(k, F, I);
        Si.getNormal(n, i, a, Q.normal), H.face = Q;
      }
      return H;
    }
    return function(M, C) {
      var R = this.geometry, B = this.material, k = this.matrixWorld;
      if (B !== void 0 && (R.boundingSphere === null && R.computeBoundingSphere(), r.copy(R.boundingSphere), r.applyMatrix4(k), M.ray.intersectsSphere(r) !== !1 && (e.getInverse(k), t.copy(M.ray).applyMatrix4(e), !(R.boundingBox !== null && t.intersectsBox(R.boundingBox) === !1)))) {
        var F;
        if (R.isBufferGeometry) {
          var I, H, Q, ee = R.index, oe = R.attributes.position, de = R.attributes.uv, he, fe;
          if (ee !== null)
            for (he = 0, fe = ee.count; he < fe; he += 3)
              I = ee.getX(he), H = ee.getX(he + 1), Q = ee.getX(he + 2), F = x(this, M, t, oe, de, I, H, Q), F && (F.faceIndex = Math.floor(he / 3), C.push(F));
          else if (oe !== void 0)
            for (he = 0, fe = oe.count; he < fe; he += 3)
              I = he, H = he + 1, Q = he + 2, F = x(this, M, t, oe, de, I, H, Q), F && (F.faceIndex = Math.floor(he / 3), C.push(F));
        } else if (R.isGeometry) {
          var V, G, se, re = Array.isArray(B), Ce = R.vertices, K = R.faces, xe, pe = R.faceVertexUvs[0];
          pe.length > 0 && (xe = pe);
          for (var Re = 0, _e = K.length; Re < _e; Re++) {
            var Le = K[Re], He = re ? B[Le.materialIndex] : B;
            if (He !== void 0) {
              if (V = Ce[Le.a], G = Ce[Le.b], se = Ce[Le.c], He.morphTargets === !0) {
                var dt = R.morphTargets, Ee = this.morphTargetInfluences;
                n.set(0, 0, 0), i.set(0, 0, 0), a.set(0, 0, 0);
                for (var ct = 0, Bt = dt.length; ct < Bt; ct++) {
                  var Mt = Ee[ct];
                  if (Mt !== 0) {
                    var Ht = dt[ct].vertices;
                    n.addScaledVector(s.subVectors(Ht[Le.a], V), Mt), i.addScaledVector(o.subVectors(Ht[Le.b], G), Mt), a.addScaledVector(u.subVectors(Ht[Le.c], se), Mt);
                  }
                }
                n.add(V), i.add(G), a.add(se), V = n, G = i, se = a;
              }
              if (F = v(this, He, M, t, V, G, se, d), F) {
                if (xe && xe[Re]) {
                  var yt = xe[Re];
                  l.copy(yt[0]), c.copy(yt[1]), h.copy(yt[2]), F.uv = _(d, V, G, se, l, c, h);
                }
                F.face = Le, F.faceIndex = Re, C.push(F);
              }
            }
          }
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function HT(e, t, r, n) {
  var i = new je(0), a = 0, s, o, u;
  function l(h, f, d, p) {
    var _ = f.background;
    _ === null ? c(i, a) : _ && _.isColor && (c(_, 1), p = !0), (e.autoClear || p) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), _ && _.isCubeTexture ? (u === void 0 && (u = new dr(
      new Ka(1, 1, 1),
      new Mi({
        uniforms: Na.cube.uniforms,
        vertexShader: Na.cube.vertexShader,
        fragmentShader: Na.cube.fragmentShader,
        side: Tr,
        depthTest: !0,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.removeAttribute("normal"), u.geometry.removeAttribute("uv"), u.onBeforeRender = function(v, x, E) {
      this.matrixWorld.copyPosition(E.matrixWorld);
    }, r.update(u)), u.material.uniforms.tCube.value = _, h.push(u, u.geometry, u.material, 0, null)) : _ && _.isTexture && (s === void 0 && (s = new Hs(-1, 1, 1, -1, 0, 1), o = new dr(
      new $a(2, 2),
      new Er({ depthTest: !1, depthWrite: !1, fog: !1 })
    ), r.update(o)), o.material.map = _, e.renderBufferDirect(s, null, o.geometry, o.material, o, null));
  }
  function c(h, f) {
    t.buffers.color.setClear(h.r, h.g, h.b, f, n);
  }
  return {
    getClearColor: function() {
      return i;
    },
    setClearColor: function(h, f) {
      i.set(h), a = f !== void 0 ? f : 1, c(i, a);
    },
    getClearAlpha: function() {
      return a;
    },
    setClearAlpha: function(h) {
      a = h, c(i, a);
    },
    render: l
  };
}
function zT(e, t, r) {
  var n;
  function i(o) {
    n = o;
  }
  function a(o, u) {
    e.drawArrays(n, o, u), r.update(u, n);
  }
  function s(o, u, l) {
    var c = t.get("ANGLE_instanced_arrays");
    if (c === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    c.drawArraysInstancedANGLE(n, u, l, o.maxInstancedCount), r.update(l, n, o.maxInstancedCount);
  }
  this.setMode = i, this.render = a, this.renderInstances = s;
}
function WT(e, t, r) {
  var n;
  function i() {
    if (n !== void 0) return n;
    var C = t.get("EXT_texture_filter_anisotropic");
    return C !== null ? n = e.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : n = 0, n;
  }
  function a(C) {
    if (C === "highp") {
      if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
        return "highp";
      C = "mediump";
    }
    return C === "mediump" && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  var s = r.precision !== void 0 ? r.precision : "highp", o = a(s);
  o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o);
  var u = r.logarithmicDepthBuffer === !0, l = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), c = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS), h = e.getParameter(e.MAX_TEXTURE_SIZE), f = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), d = e.getParameter(e.MAX_VERTEX_ATTRIBS), p = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), _ = e.getParameter(e.MAX_VARYING_VECTORS), v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), x = c > 0, E = !!t.get("OES_texture_float"), M = x && E;
  return {
    getMaxAnisotropy: i,
    getMaxPrecision: a,
    precision: s,
    logarithmicDepthBuffer: u,
    maxTextures: l,
    maxVertexTextures: c,
    maxTextureSize: h,
    maxCubemapSize: f,
    maxAttributes: d,
    maxVertexUniforms: p,
    maxVaryings: _,
    maxFragmentUniforms: v,
    vertexTextures: x,
    floatFragmentTextures: E,
    floatVertexTextures: M
  };
}
function jT() {
  var e = this, t = null, r = 0, n = !1, i = !1, a = new Vi(), s = new wr(), o = { value: null, needsUpdate: !1 };
  this.uniform = o, this.numPlanes = 0, this.numIntersection = 0, this.init = function(c, h, f) {
    var d = c.length !== 0 || h || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    r !== 0 || n;
    return n = h, t = l(c, f, 0), r = c.length, d;
  }, this.beginShadows = function() {
    i = !0, l(null);
  }, this.endShadows = function() {
    i = !1, u();
  }, this.setState = function(c, h, f, d, p, _) {
    if (!n || c === null || c.length === 0 || i && !f)
      i ? l(null) : u();
    else {
      var v = i ? 0 : r, x = v * 4, E = p.clippingState || null;
      o.value = E, E = l(c, d, x, _);
      for (var M = 0; M !== x; ++M)
        E[M] = t[M];
      p.clippingState = E, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += v;
    }
  };
  function u() {
    o.value !== t && (o.value = t, o.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
  }
  function l(c, h, f, d) {
    var p = c !== null ? c.length : 0, _ = null;
    if (p !== 0) {
      if (_ = o.value, d !== !0 || _ === null) {
        var v = f + p * 4, x = h.matrixWorldInverse;
        s.getNormalMatrix(x), (_ === null || _.length < v) && (_ = new Float32Array(v));
        for (var E = 0, M = f; E !== p; ++E, M += 4)
          a.copy(c[E]).applyMatrix4(x, s), a.normal.toArray(_, M), _[M + 3] = a.constant;
      }
      o.value = _, o.needsUpdate = !0;
    }
    return e.numPlanes = p, _;
  }
}
function qT(e) {
  var t = {};
  return {
    get: function(r) {
      if (t[r] !== void 0)
        return t[r];
      var n;
      switch (r) {
        case "WEBGL_depth_texture":
          n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          n = e.getExtension(r);
      }
      return n === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), t[r] = n, n;
    }
  };
}
function XT(e, t, r) {
  var n = {}, i = {};
  function a(l) {
    var c = l.target, h = n[c.id];
    h.index !== null && t.remove(h.index);
    for (var f in h.attributes)
      t.remove(h.attributes[f]);
    c.removeEventListener("dispose", a), delete n[c.id];
    var d = i[c.id];
    d && (t.remove(d), delete i[c.id]), d = i[h.id], d && (t.remove(d), delete i[h.id]), r.memory.geometries--;
  }
  function s(l, c) {
    var h = n[c.id];
    return h || (c.addEventListener("dispose", a), c.isBufferGeometry ? h = c : c.isGeometry && (c._bufferGeometry === void 0 && (c._bufferGeometry = new Ge().setFromObject(l)), h = c._bufferGeometry), n[c.id] = h, r.memory.geometries++, h);
  }
  function o(l) {
    var c = l.index, h = l.attributes;
    c !== null && t.update(c, e.ELEMENT_ARRAY_BUFFER);
    for (var f in h)
      t.update(h[f], e.ARRAY_BUFFER);
    var d = l.morphAttributes;
    for (var f in d)
      for (var p = d[f], _ = 0, v = p.length; _ < v; _++)
        t.update(p[_], e.ARRAY_BUFFER);
  }
  function u(l) {
    var c = i[l.id];
    if (c) return c;
    var h = [], f = l.index, d = l.attributes;
    if (f !== null)
      for (var p = f.array, _ = 0, v = p.length; _ < v; _ += 3) {
        var x = p[_ + 0], E = p[_ + 1], M = p[_ + 2];
        h.push(x, E, E, M, M, x);
      }
    else
      for (var p = d.position.array, _ = 0, v = p.length / 3 - 1; _ < v; _ += 3) {
        var x = _ + 0, E = _ + 1, M = _ + 2;
        h.push(x, E, E, M, M, x);
      }
    return c = new (U0(h) > 65535 ? Qa : Ya)(h, 1), t.update(c, e.ELEMENT_ARRAY_BUFFER), i[l.id] = c, c;
  }
  return {
    get: s,
    update: o,
    getWireframeAttribute: u
  };
}
function YT(e, t, r) {
  var n;
  function i(c) {
    n = c;
  }
  var a, s;
  function o(c) {
    a = c.type, s = c.bytesPerElement;
  }
  function u(c, h) {
    e.drawElements(n, h, a, c * s), r.update(h, n);
  }
  function l(c, h, f) {
    var d = t.get("ANGLE_instanced_arrays");
    if (d === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    d.drawElementsInstancedANGLE(n, f, a, h * s, c.maxInstancedCount), r.update(f, n, c.maxInstancedCount);
  }
  this.setMode = i, this.setIndex = o, this.render = u, this.renderInstances = l;
}
function QT(e) {
  var t = {
    geometries: 0,
    textures: 0
  }, r = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(a, s, o) {
    switch (o = o || 1, r.calls++, s) {
      case e.TRIANGLES:
        r.triangles += o * (a / 3);
        break;
      case e.TRIANGLE_STRIP:
      case e.TRIANGLE_FAN:
        r.triangles += o * (a - 2);
        break;
      case e.LINES:
        r.lines += o * (a / 2);
        break;
      case e.LINE_STRIP:
        r.lines += o * (a - 1);
        break;
      case e.LINE_LOOP:
        r.lines += o * a;
        break;
      case e.POINTS:
        r.points += o * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
        break;
    }
  }
  function i() {
    r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0;
  }
  return {
    memory: t,
    render: r,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function KT(e, t) {
  return Math.abs(t[1]) - Math.abs(e[1]);
}
function $T(e) {
  var t = {}, r = new Float32Array(8);
  function n(i, a, s, o) {
    var u = i.morphTargetInfluences, l = u.length, c = t[a.id];
    if (c === void 0) {
      c = [];
      for (var h = 0; h < l; h++)
        c[h] = [h, 0];
      t[a.id] = c;
    }
    for (var f = s.morphTargets && a.morphAttributes.position, d = s.morphNormals && a.morphAttributes.normal, h = 0; h < l; h++) {
      var p = c[h];
      p[1] !== 0 && (f && a.removeAttribute("morphTarget" + h), d && a.removeAttribute("morphNormal" + h));
    }
    for (var h = 0; h < l; h++) {
      var p = c[h];
      p[0] = h, p[1] = u[h];
    }
    c.sort(KT);
    for (var h = 0; h < 8; h++) {
      var p = c[h];
      if (p) {
        var _ = p[0], v = p[1];
        if (v) {
          f && a.addAttribute("morphTarget" + h, f[_]), d && a.addAttribute("morphNormal" + h, d[_]), r[h] = v;
          continue;
        }
      }
      r[h] = 0;
    }
    o.getUniforms().setValue(e, "morphTargetInfluences", r);
  }
  return {
    update: n
  };
}
function ZT(e, t) {
  var r = {};
  function n(a) {
    var s = t.render.frame, o = a.geometry, u = e.get(a, o);
    return r[u.id] !== s && (o.isGeometry && u.updateFromObject(a), e.update(u), r[u.id] = s), u;
  }
  function i() {
    r = {};
  }
  return {
    update: n,
    dispose: i
  };
}
function ha(e, t, r, n, i, a, s, o, u, l) {
  e = e !== void 0 ? e : [], t = t !== void 0 ? t : oh, ir.call(this, e, t, r, n, i, a, s, o, u, l), this.flipY = !1;
}
ha.prototype = Object.create(ir.prototype);
ha.prototype.constructor = ha;
ha.prototype.isCubeTexture = !0;
Object.defineProperty(ha.prototype, "images", {
  get: function() {
    return this.image;
  },
  set: function(e) {
    this.image = e;
  }
});
var G0 = new ir(), V0 = new ha();
function H0() {
  this.seq = [], this.map = {};
}
var Bm = [], Fm = [], km = new Float32Array(16), Nm = new Float32Array(9), Um = new Float32Array(4);
function Io(e, t, r) {
  var n = e[0];
  if (n <= 0 || n > 0) return e;
  var i = t * r, a = Bm[i];
  if (a === void 0 && (a = new Float32Array(i), Bm[i] = a), t !== 0) {
    n.toArray(a, 0);
    for (var s = 1, o = 0; s !== t; ++s)
      o += r, e[s].toArray(a, o);
  }
  return a;
}
function lr(e, t) {
  if (e.length !== t.length) return !1;
  for (var r = 0, n = e.length; r < n; r++)
    if (e[r] !== t[r]) return !1;
  return !0;
}
function kr(e, t) {
  for (var r = 0, n = t.length; r < n; r++)
    e[r] = t[r];
}
function z0(e, t) {
  var r = Fm[t];
  r === void 0 && (r = new Int32Array(t), Fm[t] = r);
  for (var n = 0; n !== t; ++n)
    r[n] = e.allocTextureUnit();
  return r;
}
function JT(e, t) {
  var r = this.cache;
  r[0] !== t && (e.uniform1f(this.addr, t), r[0] = t);
}
function e2(e, t) {
  var r = this.cache;
  r[0] !== t && (e.uniform1i(this.addr, t), r[0] = t);
}
function t2(e, t) {
  var r = this.cache;
  if (t.x !== void 0)
    (r[0] !== t.x || r[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y), r[0] = t.x, r[1] = t.y);
  else {
    if (lr(r, t)) return;
    e.uniform2fv(this.addr, t), kr(r, t);
  }
}
function r2(e, t) {
  var r = this.cache;
  if (t.x !== void 0)
    (r[0] !== t.x || r[1] !== t.y || r[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z), r[0] = t.x, r[1] = t.y, r[2] = t.z);
  else if (t.r !== void 0)
    (r[0] !== t.r || r[1] !== t.g || r[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b), r[0] = t.r, r[1] = t.g, r[2] = t.b);
  else {
    if (lr(r, t)) return;
    e.uniform3fv(this.addr, t), kr(r, t);
  }
}
function i2(e, t) {
  var r = this.cache;
  if (t.x !== void 0)
    (r[0] !== t.x || r[1] !== t.y || r[2] !== t.z || r[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = t.w);
  else {
    if (lr(r, t)) return;
    e.uniform4fv(this.addr, t), kr(r, t);
  }
}
function n2(e, t) {
  var r = this.cache, n = t.elements;
  if (n === void 0) {
    if (lr(r, t)) return;
    e.uniformMatrix2fv(this.addr, !1, t), kr(r, t);
  } else {
    if (lr(r, n)) return;
    Um.set(n), e.uniformMatrix2fv(this.addr, !1, Um), kr(r, n);
  }
}
function a2(e, t) {
  var r = this.cache, n = t.elements;
  if (n === void 0) {
    if (lr(r, t)) return;
    e.uniformMatrix3fv(this.addr, !1, t), kr(r, t);
  } else {
    if (lr(r, n)) return;
    Nm.set(n), e.uniformMatrix3fv(this.addr, !1, Nm), kr(r, n);
  }
}
function s2(e, t) {
  var r = this.cache, n = t.elements;
  if (n === void 0) {
    if (lr(r, t)) return;
    e.uniformMatrix4fv(this.addr, !1, t), kr(r, t);
  } else {
    if (lr(r, n)) return;
    km.set(n), e.uniformMatrix4fv(this.addr, !1, km), kr(r, n);
  }
}
function o2(e, t, r) {
  var n = this.cache, i = r.allocTextureUnit();
  n[0] !== i && (e.uniform1i(this.addr, i), n[0] = i), r.setTexture2D(t || G0, i);
}
function u2(e, t, r) {
  var n = this.cache, i = r.allocTextureUnit();
  n[0] !== i && (e.uniform1i(this.addr, i), n[0] = i), r.setTextureCube(t || V0, i);
}
function W0(e, t) {
  var r = this.cache;
  lr(r, t) || (e.uniform2iv(this.addr, t), kr(r, t));
}
function j0(e, t) {
  var r = this.cache;
  lr(r, t) || (e.uniform3iv(this.addr, t), kr(r, t));
}
function q0(e, t) {
  var r = this.cache;
  lr(r, t) || (e.uniform4iv(this.addr, t), kr(r, t));
}
function l2(e) {
  switch (e) {
    case 5126:
      return JT;
    case 35664:
      return t2;
    case 35665:
      return r2;
    case 35666:
      return i2;
    case 35674:
      return n2;
    case 35675:
      return a2;
    case 35676:
      return s2;
    case 35678:
    case 36198:
      return o2;
    case 35680:
      return u2;
    case 5124:
    case 35670:
      return e2;
    case 35667:
    case 35671:
      return W0;
    case 35668:
    case 35672:
      return j0;
    case 35669:
    case 35673:
      return q0;
  }
}
function c2(e, t) {
  var r = this.cache;
  lr(r, t) || (e.uniform1fv(this.addr, t), kr(r, t));
}
function h2(e, t) {
  var r = this.cache;
  lr(r, t) || (e.uniform1iv(this.addr, t), kr(r, t));
}
function f2(e, t) {
  var r = this.cache, n = Io(t, this.size, 2);
  lr(r, n) || (e.uniform2fv(this.addr, n), this.updateCache(n));
}
function d2(e, t) {
  var r = this.cache, n = Io(t, this.size, 3);
  lr(r, n) || (e.uniform3fv(this.addr, n), this.updateCache(n));
}
function p2(e, t) {
  var r = this.cache, n = Io(t, this.size, 4);
  lr(r, n) || (e.uniform4fv(this.addr, n), this.updateCache(n));
}
function m2(e, t) {
  var r = this.cache, n = Io(t, this.size, 4);
  lr(r, n) || (e.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n));
}
function v2(e, t) {
  var r = this.cache, n = Io(t, this.size, 9);
  lr(r, n) || (e.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n));
}
function g2(e, t) {
  var r = this.cache, n = Io(t, this.size, 16);
  lr(r, n) || (e.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n));
}
function y2(e, t, r) {
  var n = this.cache, i = t.length, a = z0(r, i);
  lr(n, a) === !1 && (e.uniform1iv(this.addr, a), kr(n, a));
  for (var s = 0; s !== i; ++s)
    r.setTexture2D(t[s] || G0, a[s]);
}
function _2(e, t, r) {
  var n = this.cache, i = t.length, a = z0(r, i);
  lr(n, a) === !1 && (e.uniform1iv(this.addr, a), kr(n, a));
  for (var s = 0; s !== i; ++s)
    r.setTextureCube(t[s] || V0, a[s]);
}
function b2(e) {
  switch (e) {
    case 5126:
      return c2;
    case 35664:
      return f2;
    case 35665:
      return d2;
    case 35666:
      return p2;
    case 35674:
      return m2;
    case 35675:
      return v2;
    case 35676:
      return g2;
    case 35678:
      return y2;
    case 35680:
      return _2;
    case 5124:
    case 35670:
      return h2;
    case 35667:
    case 35671:
      return W0;
    case 35668:
    case 35672:
      return j0;
    case 35669:
    case 35673:
      return q0;
  }
}
function x2(e, t, r) {
  this.id = e, this.addr = r, this.cache = [], this.setValue = l2(t.type);
}
function X0(e, t, r) {
  this.id = e, this.addr = r, this.cache = [], this.size = t.size, this.setValue = b2(t.type);
}
X0.prototype.updateCache = function(e) {
  var t = this.cache;
  e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), kr(t, e);
};
function Y0(e) {
  this.id = e, H0.call(this);
}
Y0.prototype.setValue = function(e, t) {
  for (var r = this.seq, n = 0, i = r.length; n !== i; ++n) {
    var a = r[n];
    a.setValue(e, t[a.id]);
  }
};
var jh = /([\w\d_]+)(\])?(\[|\.)?/g;
function Gm(e, t) {
  e.seq.push(t), e.map[t.id] = t;
}
function A2(e, t, r) {
  var n = e.name, i = n.length;
  for (jh.lastIndex = 0; ; ) {
    var a = jh.exec(n), s = jh.lastIndex, o = a[1], u = a[2] === "]", l = a[3];
    if (u && (o = o | 0), l === void 0 || l === "[" && s + 2 === i) {
      Gm(r, l === void 0 ? new x2(o, e, t) : new X0(o, e, t));
      break;
    } else {
      var c = r.map, h = c[o];
      h === void 0 && (h = new Y0(o), Gm(r, h)), r = h;
    }
  }
}
function ua(e, t, r) {
  H0.call(this), this.renderer = r;
  for (var n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), i = 0; i < n; ++i) {
    var a = e.getActiveUniform(t, i), s = e.getUniformLocation(t, a.name);
    A2(a, s, this);
  }
}
ua.prototype.setValue = function(e, t, r) {
  var n = this.map[t];
  n !== void 0 && n.setValue(e, r, this.renderer);
};
ua.prototype.setOptional = function(e, t, r) {
  var n = t[r];
  n !== void 0 && this.setValue(e, r, n);
};
ua.upload = function(e, t, r, n) {
  for (var i = 0, a = t.length; i !== a; ++i) {
    var s = t[i], o = r[s.id];
    o.needsUpdate !== !1 && s.setValue(e, o.value, n);
  }
};
ua.seqWithValue = function(e, t) {
  for (var r = [], n = 0, i = e.length; n !== i; ++n) {
    var a = e[n];
    a.id in t && r.push(a);
  }
  return r;
};
function T2(e) {
  for (var t = e.split(`
`), r = 0; r < t.length; r++)
    t[r] = r + 1 + ": " + t[r];
  return t.join(`
`);
}
function Vm(e, t, r) {
  var n = e.createShader(t);
  return e.shaderSource(n, r), e.compileShader(n), e.getShaderParameter(n, e.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), e.getShaderInfoLog(n) !== "" && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t === e.VERTEX_SHADER ? "vertex" : "fragment", e.getShaderInfoLog(n), T2(r)), n;
}
var E2 = 0;
function Q0(e) {
  switch (e) {
    case yu:
      return ["Linear", "( value )"];
    case L0:
      return ["sRGB", "( value )"];
    case R0:
      return ["RGBE", "( value )"];
    case I0:
      return ["RGBM", "( value, 7.0 )"];
    case O0:
      return ["RGBM", "( value, 16.0 )"];
    case B0:
      return ["RGBD", "( value, 256.0 )"];
    case Ud:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    default:
      throw new Error("unsupported encoding: " + e);
  }
}
function qh(e, t) {
  var r = Q0(t);
  return "vec4 " + e + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }";
}
function w2(e, t) {
  var r = Q0(t);
  return "vec4 " + e + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }";
}
function S2(e, t) {
  var r;
  switch (t) {
    case Id:
      r = "Linear";
      break;
    case Jg:
      r = "Reinhard";
      break;
    case e0:
      r = "Uncharted2";
      break;
    case t0:
      r = "OptimizedCineon";
      break;
    default:
      throw new Error("unsupported toneMapping: " + t);
  }
  return "vec3 " + e + "( vec3 color ) { return " + r + "ToneMapping( color ); }";
}
function C2(e, t, r) {
  e = e || {};
  var n = [
    e.derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
    (e.fragDepth || t.logarithmicDepthBuffer) && r.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
    e.drawBuffers && r.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
    (e.shaderTextureLOD || t.envMap) && r.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return n.filter(ru).join(`
`);
}
function M2(e) {
  var t = [];
  for (var r in e) {
    var n = e[r];
    n !== !1 && t.push("#define " + r + " " + n);
  }
  return t.join(`
`);
}
function D2(e, t) {
  for (var r = {}, n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), i = 0; i < n; i++) {
    var a = e.getActiveAttrib(t, i), s = a.name;
    r[s] = e.getAttribLocation(t, s);
  }
  return r;
}
function ru(e) {
  return e !== "";
}
function Hm(e, t) {
  return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights);
}
function zm(e, t) {
  return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
function Bf(e) {
  var t = /^[ \t]*#include +<([\w\d.]+)>/gm;
  function r(n, i) {
    var a = Ot[i];
    if (a === void 0)
      throw new Error("Can not resolve #include <" + i + ">");
    return Bf(a);
  }
  return e.replace(t, r);
}
function Wm(e) {
  var t = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  function r(n, i, a, s) {
    for (var o = "", u = parseInt(i); u < parseInt(a); u++)
      o += s.replace(/\[ i \]/g, "[ " + u + " ]");
    return o;
  }
  return e.replace(t, r);
}
function P2(e, t, r, n, i, a) {
  var s = e.context, o = n.defines, u = i.vertexShader, l = i.fragmentShader, c = "SHADOWMAP_TYPE_BASIC";
  a.shadowMapType === Td ? c = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === Rg && (c = "SHADOWMAP_TYPE_PCF_SOFT");
  var h = "ENVMAP_TYPE_CUBE", f = "ENVMAP_MODE_REFLECTION", d = "ENVMAP_BLENDING_MULTIPLY";
  if (a.envMap) {
    switch (n.envMap.mapping) {
      case oh:
      case uc:
        h = "ENVMAP_TYPE_CUBE";
        break;
      case uh:
      case lh:
        h = "ENVMAP_TYPE_CUBE_UV";
        break;
      case Od:
      case lc:
        h = "ENVMAP_TYPE_EQUIREC";
        break;
      case Bd:
        h = "ENVMAP_TYPE_SPHERE";
        break;
    }
    switch (n.envMap.mapping) {
      case uc:
      case lc:
        f = "ENVMAP_MODE_REFRACTION";
        break;
    }
    switch (n.combine) {
      case bl:
        d = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case $g:
        d = "ENVMAP_BLENDING_MIX";
        break;
      case Zg:
        d = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  var p = e.gammaFactor > 0 ? e.gammaFactor : 1, _ = C2(n.extensions, a, t), v = M2(o), x = s.createProgram(), E, M;
  n.isRawShaderMaterial ? (E = [
    v
  ].filter(ru).join(`
`), E.length > 0 && (E += `
`), M = [
    _,
    v
  ].filter(ru).join(`
`), M.length > 0 && (M += `
`)) : (E = [
    "precision " + a.precision + " float;",
    "precision " + a.precision + " int;",
    "#define SHADER_NAME " + i.name,
    v,
    a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    "#define GAMMA_FACTOR " + p,
    "#define MAX_BONES " + a.maxBones,
    a.useFog && a.fog ? "#define USE_FOG" : "",
    a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
    a.map ? "#define USE_MAP" : "",
    a.envMap ? "#define USE_ENVMAP" : "",
    a.envMap ? "#define " + f : "",
    a.lightMap ? "#define USE_LIGHTMAP" : "",
    a.aoMap ? "#define USE_AOMAP" : "",
    a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    a.bumpMap ? "#define USE_BUMPMAP" : "",
    a.normalMap ? "#define USE_NORMALMAP" : "",
    a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    a.specularMap ? "#define USE_SPECULARMAP" : "",
    a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    a.metalnessMap ? "#define USE_METALNESSMAP" : "",
    a.alphaMap ? "#define USE_ALPHAMAP" : "",
    a.vertexColors ? "#define USE_COLOR" : "",
    a.flatShading ? "#define FLAT_SHADED" : "",
    a.skinning ? "#define USE_SKINNING" : "",
    a.useVertexTexture ? "#define BONE_TEXTURE" : "",
    a.morphTargets ? "#define USE_MORPHTARGETS" : "",
    a.morphNormals && a.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    a.doubleSided ? "#define DOUBLE_SIDED" : "",
    a.flipSided ? "#define FLIP_SIDED" : "",
    a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    a.shadowMapEnabled ? "#define " + c : "",
    a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    a.logarithmicDepthBuffer && t.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_COLOR",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_MORPHTARGETS",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(ru).join(`
`), M = [
    _,
    "precision " + a.precision + " float;",
    "precision " + a.precision + " int;",
    "#define SHADER_NAME " + i.name,
    v,
    a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "",
    // add '.0' if integer
    "#define GAMMA_FACTOR " + p,
    a.useFog && a.fog ? "#define USE_FOG" : "",
    a.useFog && a.fogExp ? "#define FOG_EXP2" : "",
    a.map ? "#define USE_MAP" : "",
    a.envMap ? "#define USE_ENVMAP" : "",
    a.envMap ? "#define " + h : "",
    a.envMap ? "#define " + f : "",
    a.envMap ? "#define " + d : "",
    a.lightMap ? "#define USE_LIGHTMAP" : "",
    a.aoMap ? "#define USE_AOMAP" : "",
    a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    a.bumpMap ? "#define USE_BUMPMAP" : "",
    a.normalMap ? "#define USE_NORMALMAP" : "",
    a.specularMap ? "#define USE_SPECULARMAP" : "",
    a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    a.metalnessMap ? "#define USE_METALNESSMAP" : "",
    a.alphaMap ? "#define USE_ALPHAMAP" : "",
    a.vertexColors ? "#define USE_COLOR" : "",
    a.gradientMap ? "#define USE_GRADIENTMAP" : "",
    a.flatShading ? "#define FLAT_SHADED" : "",
    a.doubleSided ? "#define DOUBLE_SIDED" : "",
    a.flipSided ? "#define FLIP_SIDED" : "",
    a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    a.shadowMapEnabled ? "#define " + c : "",
    a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    a.logarithmicDepthBuffer && t.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "",
    a.envMap && t.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    a.toneMapping !== Zl ? "#define TONE_MAPPING" : "",
    a.toneMapping !== Zl ? Ot.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    a.toneMapping !== Zl ? S2("toneMapping", a.toneMapping) : "",
    a.dithering ? "#define DITHERING" : "",
    a.outputEncoding || a.mapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? Ot.encodings_pars_fragment : "",
    // this code is required here because it is used by the various encoding/decoding function defined below
    a.mapEncoding ? qh("mapTexelToLinear", a.mapEncoding) : "",
    a.envMapEncoding ? qh("envMapTexelToLinear", a.envMapEncoding) : "",
    a.emissiveMapEncoding ? qh("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "",
    a.outputEncoding ? w2("linearToOutputTexel", a.outputEncoding) : "",
    a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(ru).join(`
`)), u = Bf(u), u = Hm(u, a), u = zm(u, a), l = Bf(l), l = Hm(l, a), l = zm(l, a), u = Wm(u), l = Wm(l);
  var C = E + u, R = M + l, B = Vm(s, s.VERTEX_SHADER, C), k = Vm(s, s.FRAGMENT_SHADER, R);
  s.attachShader(x, B), s.attachShader(x, k), n.index0AttributeName !== void 0 ? s.bindAttribLocation(x, 0, n.index0AttributeName) : a.morphTargets === !0 && s.bindAttribLocation(x, 0, "position"), s.linkProgram(x);
  var F = s.getProgramInfoLog(x).trim(), I = s.getShaderInfoLog(B).trim(), H = s.getShaderInfoLog(k).trim(), Q = !0, ee = !0;
  s.getProgramParameter(x, s.LINK_STATUS) === !1 ? (Q = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "gl.VALIDATE_STATUS", s.getProgramParameter(x, s.VALIDATE_STATUS), "gl.getProgramInfoLog", F, I, H)) : F !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", F) : (I === "" || H === "") && (ee = !1), ee && (this.diagnostics = {
    runnable: Q,
    material: n,
    programLog: F,
    vertexShader: {
      log: I,
      prefix: E
    },
    fragmentShader: {
      log: H,
      prefix: M
    }
  }), s.deleteShader(B), s.deleteShader(k);
  var oe;
  this.getUniforms = function() {
    return oe === void 0 && (oe = new ua(s, x, e)), oe;
  };
  var de;
  return this.getAttributes = function() {
    return de === void 0 && (de = D2(s, x)), de;
  }, this.destroy = function() {
    s.deleteProgram(x), this.program = void 0;
  }, Object.defineProperties(this, {
    uniforms: {
      get: function() {
        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
      }
    },
    attributes: {
      get: function() {
        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes();
      }
    }
  }), this.name = i.name, this.id = E2++, this.code = r, this.usedTimes = 1, this.program = x, this.vertexShader = B, this.fragmentShader = k, this;
}
function L2(e, t, r) {
  var n = [], i = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "phong",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow"
  }, a = [
    "precision",
    "supportsVertexTextures",
    "map",
    "mapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "lightMap",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "fog",
    "useFog",
    "fogExp",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering"
  ];
  function s(u) {
    var l = u.skeleton, c = l.bones;
    if (r.floatVertexTextures)
      return 1024;
    var h = r.maxVertexUniforms, f = Math.floor((h - 20) / 4), d = Math.min(f, c.length);
    return d < c.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + c.length + " bones. This GPU supports " + d + "."), 0) : d;
  }
  function o(u, l) {
    var c;
    return u ? u.isTexture ? c = u.encoding : u.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = u.texture.encoding) : c = yu, c === yu && l && (c = Ud), c;
  }
  this.getParameters = function(u, l, c, h, f, d, p) {
    var _ = i[u.type], v = p.isSkinnedMesh ? s(p) : 0, x = r.precision;
    u.precision !== null && (x = r.getMaxPrecision(u.precision), x !== u.precision && console.warn("THREE.WebGLProgram.getParameters:", u.precision, "not supported, using", x, "instead."));
    var E = e.getRenderTarget(), M = {
      shaderID: _,
      precision: x,
      supportsVertexTextures: r.vertexTextures,
      outputEncoding: o(E ? E.texture : null, e.gammaOutput),
      map: !!u.map,
      mapEncoding: o(u.map, e.gammaInput),
      envMap: !!u.envMap,
      envMapMode: u.envMap && u.envMap.mapping,
      envMapEncoding: o(u.envMap, e.gammaInput),
      envMapCubeUV: !!u.envMap && (u.envMap.mapping === uh || u.envMap.mapping === lh),
      lightMap: !!u.lightMap,
      aoMap: !!u.aoMap,
      emissiveMap: !!u.emissiveMap,
      emissiveMapEncoding: o(u.emissiveMap, e.gammaInput),
      bumpMap: !!u.bumpMap,
      normalMap: !!u.normalMap,
      displacementMap: !!u.displacementMap,
      roughnessMap: !!u.roughnessMap,
      metalnessMap: !!u.metalnessMap,
      specularMap: !!u.specularMap,
      alphaMap: !!u.alphaMap,
      gradientMap: !!u.gradientMap,
      combine: u.combine,
      vertexColors: u.vertexColors,
      fog: !!h,
      useFog: u.fog,
      fogExp: h && h.isFogExp2,
      flatShading: u.flatShading,
      sizeAttenuation: u.sizeAttenuation,
      logarithmicDepthBuffer: r.logarithmicDepthBuffer,
      skinning: u.skinning && v > 0,
      maxBones: v,
      useVertexTexture: r.floatVertexTextures,
      morphTargets: u.morphTargets,
      morphNormals: u.morphNormals,
      maxMorphTargets: e.maxMorphTargets,
      maxMorphNormals: e.maxMorphNormals,
      numDirLights: l.directional.length,
      numPointLights: l.point.length,
      numSpotLights: l.spot.length,
      numRectAreaLights: l.rectArea.length,
      numHemiLights: l.hemi.length,
      numClippingPlanes: f,
      numClipIntersection: d,
      dithering: u.dithering,
      shadowMapEnabled: e.shadowMap.enabled && p.receiveShadow && c.length > 0,
      shadowMapType: e.shadowMap.type,
      toneMapping: e.toneMapping,
      physicallyCorrectLights: e.physicallyCorrectLights,
      premultipliedAlpha: u.premultipliedAlpha,
      alphaTest: u.alphaTest,
      doubleSided: u.side === Ro,
      flipSided: u.side === Tr,
      depthPacking: u.depthPacking !== void 0 ? u.depthPacking : !1
    };
    return M;
  }, this.getProgramCode = function(u, l) {
    var c = [];
    if (l.shaderID ? c.push(l.shaderID) : (c.push(u.fragmentShader), c.push(u.vertexShader)), u.defines !== void 0)
      for (var h in u.defines)
        c.push(h), c.push(u.defines[h]);
    for (var f = 0; f < a.length; f++)
      c.push(l[a[f]]);
    return c.push(u.onBeforeCompile.toString()), c.push(e.gammaOutput), c.join();
  }, this.acquireProgram = function(u, l, c, h) {
    for (var f, d = 0, p = n.length; d < p; d++) {
      var _ = n[d];
      if (_.code === h) {
        f = _, ++f.usedTimes;
        break;
      }
    }
    return f === void 0 && (f = new P2(e, t, h, u, l, c), n.push(f)), f;
  }, this.releaseProgram = function(u) {
    if (--u.usedTimes === 0) {
      var l = n.indexOf(u);
      n[l] = n[n.length - 1], n.pop(), u.destroy();
    }
  }, this.programs = n;
}
function R2() {
  var e = /* @__PURE__ */ new WeakMap();
  function t(a) {
    var s = e.get(a);
    return s === void 0 && (s = {}, e.set(a, s)), s;
  }
  function r(a) {
    e.delete(a);
  }
  function n(a, s, o) {
    e.get(a)[s] = o;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    remove: r,
    update: n,
    dispose: i
  };
}
function I2(e, t) {
  return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id;
}
function O2(e, t) {
  return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;
}
function B2() {
  var e = [], t = 0, r = [], n = [];
  function i() {
    t = 0, r.length = 0, n.length = 0;
  }
  function a(o, u, l, c, h) {
    var f = e[t];
    f === void 0 ? (f = {
      id: o.id,
      object: o,
      geometry: u,
      material: l,
      program: l.program,
      renderOrder: o.renderOrder,
      z: c,
      group: h
    }, e[t] = f) : (f.id = o.id, f.object = o, f.geometry = u, f.material = l, f.program = l.program, f.renderOrder = o.renderOrder, f.z = c, f.group = h), (l.transparent === !0 ? n : r).push(f), t++;
  }
  function s() {
    r.length > 1 && r.sort(I2), n.length > 1 && n.sort(O2);
  }
  return {
    opaque: r,
    transparent: n,
    init: i,
    push: a,
    sort: s
  };
}
function F2() {
  var e = {};
  function t(n, i) {
    var a = n.id + "," + i.id, s = e[a];
    return s === void 0 && (s = new B2(), e[a] = s), s;
  }
  function r() {
    e = {};
  }
  return {
    get: t,
    dispose: r
  };
}
function k2() {
  var e = {};
  return {
    get: function(t) {
      if (e[t.id] !== void 0)
        return e[t.id];
      var r;
      switch (t.type) {
        case "DirectionalLight":
          r = {
            direction: new z(),
            color: new je(),
            shadow: !1,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ue()
          };
          break;
        case "SpotLight":
          r = {
            position: new z(),
            direction: new z(),
            color: new je(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
            shadow: !1,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ue()
          };
          break;
        case "PointLight":
          r = {
            position: new z(),
            color: new je(),
            distance: 0,
            decay: 0,
            shadow: !1,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ue(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
        case "HemisphereLight":
          r = {
            direction: new z(),
            skyColor: new je(),
            groundColor: new je()
          };
          break;
        case "RectAreaLight":
          r = {
            color: new je(),
            position: new z(),
            halfWidth: new z(),
            halfHeight: new z()
            // TODO (abelnation): set RectAreaLight shadow uniforms
          };
          break;
      }
      return e[t.id] = r, r;
    }
  };
}
var N2 = 0;
function U2() {
  var e = new k2(), t = {
    id: N2++,
    hash: "",
    ambient: [0, 0, 0],
    directional: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  }, r = new z(), n = new at(), i = new at();
  function a(s, o, u) {
    for (var l = 0, c = 0, h = 0, f = 0, d = 0, p = 0, _ = 0, v = 0, x = u.matrixWorldInverse, E = 0, M = s.length; E < M; E++) {
      var C = s[E], R = C.color, B = C.intensity, k = C.distance, F = C.shadow && C.shadow.map ? C.shadow.map.texture : null;
      if (C.isAmbientLight)
        l += R.r * B, c += R.g * B, h += R.b * B;
      else if (C.isDirectionalLight) {
        var I = e.get(C);
        if (I.color.copy(C.color).multiplyScalar(C.intensity), I.direction.setFromMatrixPosition(C.matrixWorld), r.setFromMatrixPosition(C.target.matrixWorld), I.direction.sub(r), I.direction.transformDirection(x), I.shadow = C.castShadow, C.castShadow) {
          var H = C.shadow;
          I.shadowBias = H.bias, I.shadowRadius = H.radius, I.shadowMapSize = H.mapSize;
        }
        t.directionalShadowMap[f] = F, t.directionalShadowMatrix[f] = C.shadow.matrix, t.directional[f] = I, f++;
      } else if (C.isSpotLight) {
        var I = e.get(C);
        if (I.position.setFromMatrixPosition(C.matrixWorld), I.position.applyMatrix4(x), I.color.copy(R).multiplyScalar(B), I.distance = k, I.direction.setFromMatrixPosition(C.matrixWorld), r.setFromMatrixPosition(C.target.matrixWorld), I.direction.sub(r), I.direction.transformDirection(x), I.coneCos = Math.cos(C.angle), I.penumbraCos = Math.cos(C.angle * (1 - C.penumbra)), I.decay = C.distance === 0 ? 0 : C.decay, I.shadow = C.castShadow, C.castShadow) {
          var H = C.shadow;
          I.shadowBias = H.bias, I.shadowRadius = H.radius, I.shadowMapSize = H.mapSize;
        }
        t.spotShadowMap[p] = F, t.spotShadowMatrix[p] = C.shadow.matrix, t.spot[p] = I, p++;
      } else if (C.isRectAreaLight) {
        var I = e.get(C);
        I.color.copy(R).multiplyScalar(B), I.position.setFromMatrixPosition(C.matrixWorld), I.position.applyMatrix4(x), i.identity(), n.copy(C.matrixWorld), n.premultiply(x), i.extractRotation(n), I.halfWidth.set(C.width * 0.5, 0, 0), I.halfHeight.set(0, C.height * 0.5, 0), I.halfWidth.applyMatrix4(i), I.halfHeight.applyMatrix4(i), t.rectArea[_] = I, _++;
      } else if (C.isPointLight) {
        var I = e.get(C);
        if (I.position.setFromMatrixPosition(C.matrixWorld), I.position.applyMatrix4(x), I.color.copy(C.color).multiplyScalar(C.intensity), I.distance = C.distance, I.decay = C.distance === 0 ? 0 : C.decay, I.shadow = C.castShadow, C.castShadow) {
          var H = C.shadow;
          I.shadowBias = H.bias, I.shadowRadius = H.radius, I.shadowMapSize = H.mapSize, I.shadowCameraNear = H.camera.near, I.shadowCameraFar = H.camera.far;
        }
        t.pointShadowMap[d] = F, t.pointShadowMatrix[d] = C.shadow.matrix, t.point[d] = I, d++;
      } else if (C.isHemisphereLight) {
        var I = e.get(C);
        I.direction.setFromMatrixPosition(C.matrixWorld), I.direction.transformDirection(x), I.direction.normalize(), I.skyColor.copy(C.color).multiplyScalar(B), I.groundColor.copy(C.groundColor).multiplyScalar(B), t.hemi[v] = I, v++;
      }
    }
    t.ambient[0] = l, t.ambient[1] = c, t.ambient[2] = h, t.directional.length = f, t.spot.length = p, t.rectArea.length = _, t.point.length = d, t.hemi.length = v, t.hash = t.id + "," + f + "," + d + "," + p + "," + _ + "," + v + "," + o.length;
  }
  return {
    setup: a,
    state: t
  };
}
function G2() {
  var e = new U2(), t = [], r = [], n = [];
  function i() {
    t.length = 0, r.length = 0, n.length = 0;
  }
  function a(c) {
    t.push(c);
  }
  function s(c) {
    r.push(c);
  }
  function o(c) {
    n.push(c);
  }
  function u(c) {
    e.setup(t, r, c);
  }
  var l = {
    lightsArray: t,
    shadowsArray: r,
    spritesArray: n,
    lights: e
  };
  return {
    init: i,
    state: l,
    setupLights: u,
    pushLight: a,
    pushShadow: s,
    pushSprite: o
  };
}
function V2() {
  var e = {};
  function t(n, i) {
    var a = n.id + "," + i.id, s = e[a];
    return s === void 0 && (s = new G2(), e[a] = s), s;
  }
  function r() {
    e = {};
  }
  return {
    get: t,
    dispose: r
  };
}
function fa(e) {
  ft.call(this), this.type = "MeshDepthMaterial", this.depthPacking = F0, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e);
}
fa.prototype = Object.create(ft.prototype);
fa.prototype.constructor = fa;
fa.prototype.isMeshDepthMaterial = !0;
fa.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
};
function da(e) {
  ft.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new z(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e);
}
da.prototype = Object.create(ft.prototype);
da.prototype.constructor = da;
da.prototype.isMeshDistanceMaterial = !0;
da.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
};
function K0(e, t, r) {
  for (var n = new ph(), i = new at(), a = new ue(), s = new ue(r, r), o = new z(), u = new z(), l = 1, c = 2, h = (l | c) + 1, f = new Array(h), d = new Array(h), p = {}, _ = { 0: Tr, 1: yl, 2: Ro }, v = [
    new z(1, 0, 0),
    new z(-1, 0, 0),
    new z(0, 0, 1),
    new z(0, 0, -1),
    new z(0, 1, 0),
    new z(0, -1, 0)
  ], x = [
    new z(0, 1, 0),
    new z(0, 1, 0),
    new z(0, 1, 0),
    new z(0, 1, 0),
    new z(0, 0, 1),
    new z(0, 0, -1)
  ], E = [
    new kt(),
    new kt(),
    new kt(),
    new kt(),
    new kt(),
    new kt()
  ], M = 0; M !== h; ++M) {
    var C = (M & l) !== 0, R = (M & c) !== 0, B = new fa({
      depthPacking: k0,
      morphTargets: C,
      skinning: R
    });
    f[M] = B;
    var k = new da({
      morphTargets: C,
      skinning: R
    });
    d[M] = k;
  }
  var F = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Td, this.render = function(Q, ee, oe) {
    if (F.enabled !== !1 && !(F.autoUpdate === !1 && F.needsUpdate === !1) && Q.length !== 0) {
      var de = e.context, he = e.state;
      he.disable(de.BLEND), he.buffers.color.setClear(1, 1, 1, 1), he.buffers.depth.setTest(!0), he.setScissorTest(!1);
      for (var fe, V = 0, G = Q.length; V < G; V++) {
        var se = Q[V], re = se.shadow, Ce = se && se.isPointLight;
        if (re === void 0) {
          console.warn("THREE.WebGLShadowMap:", se, "has no shadow.");
          continue;
        }
        var K = re.camera;
        if (a.copy(re.mapSize), a.min(s), Ce) {
          var xe = a.x, pe = a.y;
          E[0].set(xe * 2, pe, xe, pe), E[1].set(0, pe, xe, pe), E[2].set(xe * 3, pe, xe, pe), E[3].set(xe, pe, xe, pe), E[4].set(xe * 3, 0, xe, pe), E[5].set(xe, 0, xe, pe), a.x *= 4, a.y *= 2;
        }
        if (re.map === null) {
          var Re = { minFilter: wi, magFilter: wi, format: yn };
          re.map = new qa(a.x, a.y, Re), re.map.texture.name = se.name + ".shadowMap", K.updateProjectionMatrix();
        }
        re.isSpotLightShadow && re.update(se);
        var _e = re.map, Le = re.matrix;
        u.setFromMatrixPosition(se.matrixWorld), K.position.copy(u), Ce ? (fe = 6, Le.makeTranslation(-u.x, -u.y, -u.z)) : (fe = 1, o.setFromMatrixPosition(se.target.matrixWorld), K.lookAt(o), K.updateMatrixWorld(), Le.set(
          0.5,
          0,
          0,
          0.5,
          0,
          0.5,
          0,
          0.5,
          0,
          0,
          0.5,
          0.5,
          0,
          0,
          0,
          1
        ), Le.multiply(K.projectionMatrix), Le.multiply(K.matrixWorldInverse)), e.setRenderTarget(_e), e.clear();
        for (var He = 0; He < fe; He++) {
          if (Ce) {
            o.copy(K.position), o.add(v[He]), K.up.copy(x[He]), K.lookAt(o), K.updateMatrixWorld();
            var dt = E[He];
            he.viewport(dt);
          }
          i.multiplyMatrices(K.projectionMatrix, K.matrixWorldInverse), n.setFromMatrix(i), H(ee, oe, K, Ce);
        }
      }
      F.needsUpdate = !1;
    }
  };
  function I(Q, ee, oe, de, he, fe) {
    var V = Q.geometry, G = null, se = f, re = Q.customDepthMaterial;
    if (oe && (se = d, re = Q.customDistanceMaterial), re)
      G = re;
    else {
      var Ce = !1;
      ee.morphTargets && (V && V.isBufferGeometry ? Ce = V.morphAttributes && V.morphAttributes.position && V.morphAttributes.position.length > 0 : V && V.isGeometry && (Ce = V.morphTargets && V.morphTargets.length > 0)), Q.isSkinnedMesh && ee.skinning === !1 && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", Q);
      var K = Q.isSkinnedMesh && ee.skinning, xe = 0;
      Ce && (xe |= l), K && (xe |= c), G = se[xe];
    }
    if (e.localClippingEnabled && ee.clipShadows === !0 && ee.clippingPlanes.length !== 0) {
      var pe = G.uuid, Re = ee.uuid, _e = p[pe];
      _e === void 0 && (_e = {}, p[pe] = _e);
      var Le = _e[Re];
      Le === void 0 && (Le = G.clone(), _e[Re] = Le), G = Le;
    }
    return G.visible = ee.visible, G.wireframe = ee.wireframe, G.side = ee.shadowSide != null ? ee.shadowSide : _[ee.side], G.clipShadows = ee.clipShadows, G.clippingPlanes = ee.clippingPlanes, G.clipIntersection = ee.clipIntersection, G.wireframeLinewidth = ee.wireframeLinewidth, G.linewidth = ee.linewidth, oe && G.isMeshDistanceMaterial && (G.referencePosition.copy(de), G.nearDistance = he, G.farDistance = fe), G;
  }
  function H(Q, ee, oe, de) {
    if (Q.visible !== !1) {
      var he = Q.layers.test(ee.layers);
      if (he && (Q.isMesh || Q.isLine || Q.isPoints) && Q.castShadow && (!Q.frustumCulled || n.intersectsObject(Q))) {
        Q.modelViewMatrix.multiplyMatrices(oe.matrixWorldInverse, Q.matrixWorld);
        var fe = t.update(Q), V = Q.material;
        if (Array.isArray(V))
          for (var G = fe.groups, se = 0, re = G.length; se < re; se++) {
            var Ce = G[se], K = V[Ce.materialIndex];
            if (K && K.visible) {
              var xe = I(Q, K, de, u, oe.near, oe.far);
              e.renderBufferDirect(oe, null, fe, xe, Q, Ce);
            }
          }
        else if (V.visible) {
          var xe = I(Q, V, de, u, oe.near, oe.far);
          e.renderBufferDirect(oe, null, fe, xe, Q, null);
        }
      }
      for (var pe = Q.children, Re = 0, _e = pe.length; Re < _e; Re++)
        H(pe[Re], ee, oe, de);
    }
  }
}
function zs(e, t, r, n, i, a, s, o, u) {
  ir.call(this, e, t, r, n, i, a, s, o, u), this.needsUpdate = !0;
}
zs.prototype = Object.create(ir.prototype);
zs.prototype.constructor = zs;
zs.prototype.isCanvasTexture = !0;
function H2(e, t, r, n, i) {
  var a, s, o, u, l, c, h = new z(), f = new _r(), d = new z();
  function p() {
    var x = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0.5,
      -0.5,
      1,
      0,
      0.5,
      0.5,
      1,
      1,
      -0.5,
      0.5,
      0,
      1
    ]), E = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    a = t.createBuffer(), s = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, a), t.bufferData(t.ARRAY_BUFFER, x, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, s), t.bufferData(t.ELEMENT_ARRAY_BUFFER, E, t.STATIC_DRAW), o = _(), u = {
      position: t.getAttribLocation(o, "position"),
      uv: t.getAttribLocation(o, "uv")
    }, l = {
      uvOffset: t.getUniformLocation(o, "uvOffset"),
      uvScale: t.getUniformLocation(o, "uvScale"),
      rotation: t.getUniformLocation(o, "rotation"),
      center: t.getUniformLocation(o, "center"),
      scale: t.getUniformLocation(o, "scale"),
      color: t.getUniformLocation(o, "color"),
      map: t.getUniformLocation(o, "map"),
      opacity: t.getUniformLocation(o, "opacity"),
      modelViewMatrix: t.getUniformLocation(o, "modelViewMatrix"),
      projectionMatrix: t.getUniformLocation(o, "projectionMatrix"),
      fogType: t.getUniformLocation(o, "fogType"),
      fogDensity: t.getUniformLocation(o, "fogDensity"),
      fogNear: t.getUniformLocation(o, "fogNear"),
      fogFar: t.getUniformLocation(o, "fogFar"),
      fogColor: t.getUniformLocation(o, "fogColor"),
      fogDepth: t.getUniformLocation(o, "fogDepth"),
      alphaTest: t.getUniformLocation(o, "alphaTest")
    };
    var M = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    M.width = 8, M.height = 8;
    var C = M.getContext("2d");
    C.fillStyle = "white", C.fillRect(0, 0, 8, 8), c = new zs(M);
  }
  this.render = function(x, E, M) {
    if (x.length !== 0) {
      o === void 0 && p(), r.useProgram(o), r.initAttributes(), r.enableAttribute(u.position), r.enableAttribute(u.uv), r.disableUnusedAttributes(), r.disable(t.CULL_FACE), r.enable(t.BLEND), t.bindBuffer(t.ARRAY_BUFFER, a), t.vertexAttribPointer(u.position, 2, t.FLOAT, !1, 2 * 8, 0), t.vertexAttribPointer(u.uv, 2, t.FLOAT, !1, 2 * 8, 8), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, s), t.uniformMatrix4fv(l.projectionMatrix, !1, M.projectionMatrix.elements), r.activeTexture(t.TEXTURE0), t.uniform1i(l.map, 0);
      var C = 0, R = 0, B = E.fog;
      B ? (t.uniform3f(l.fogColor, B.color.r, B.color.g, B.color.b), B.isFog ? (t.uniform1f(l.fogNear, B.near), t.uniform1f(l.fogFar, B.far), t.uniform1i(l.fogType, 1), C = 1, R = 1) : B.isFogExp2 && (t.uniform1f(l.fogDensity, B.density), t.uniform1i(l.fogType, 2), C = 2, R = 2)) : (t.uniform1i(l.fogType, 0), C = 0, R = 0);
      for (var k = 0, F = x.length; k < F; k++) {
        var I = x[k];
        I.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse, I.matrixWorld), I.z = -I.modelViewMatrix.elements[14];
      }
      x.sort(v);
      for (var H = [], Q = [], k = 0, F = x.length; k < F; k++) {
        var I = x[k], ee = I.material;
        if (ee.visible !== !1) {
          I.onBeforeRender(e, E, M, void 0, ee, void 0), t.uniform1f(l.alphaTest, ee.alphaTest), t.uniformMatrix4fv(l.modelViewMatrix, !1, I.modelViewMatrix.elements), I.matrixWorld.decompose(h, f, d), H[0] = d.x, H[1] = d.y, Q[0] = I.center.x - 0.5, Q[1] = I.center.y - 0.5;
          var oe = 0;
          E.fog && ee.fog && (oe = R), C !== oe && (t.uniform1i(l.fogType, oe), C = oe), ee.map !== null ? (t.uniform2f(l.uvOffset, ee.map.offset.x, ee.map.offset.y), t.uniform2f(l.uvScale, ee.map.repeat.x, ee.map.repeat.y)) : (t.uniform2f(l.uvOffset, 0, 0), t.uniform2f(l.uvScale, 1, 1)), t.uniform1f(l.opacity, ee.opacity), t.uniform3f(l.color, ee.color.r, ee.color.g, ee.color.b), t.uniform1f(l.rotation, ee.rotation), t.uniform2fv(l.center, Q), t.uniform2fv(l.scale, H), r.setBlending(ee.blending, ee.blendEquation, ee.blendSrc, ee.blendDst, ee.blendEquationAlpha, ee.blendSrcAlpha, ee.blendDstAlpha, ee.premultipliedAlpha), r.buffers.depth.setTest(ee.depthTest), r.buffers.depth.setMask(ee.depthWrite), r.buffers.color.setMask(ee.colorWrite), n.setTexture2D(ee.map || c, 0), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0), I.onAfterRender(e, E, M, void 0, ee, void 0);
        }
      }
      r.enable(t.CULL_FACE), r.reset();
    }
  };
  function _() {
    var x = t.createProgram(), E = t.createShader(t.VERTEX_SHADER), M = t.createShader(t.FRAGMENT_SHADER);
    return t.shaderSource(E, [
      "precision " + i.precision + " float;",
      "#define SHADER_NAME SpriteMaterial",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform float rotation;",
      "uniform vec2 center;",
      "uniform vec2 scale;",
      "uniform vec2 uvOffset;",
      "uniform vec2 uvScale;",
      "attribute vec2 position;",
      "attribute vec2 uv;",
      "varying vec2 vUV;",
      "varying float fogDepth;",
      "void main() {",
      "	vUV = uvOffset + uv * uvScale;",
      "	vec2 alignedPosition = ( position - center ) * scale;",
      "	vec2 rotatedPosition;",
      "	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;",
      "	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;",
      "	vec4 mvPosition;",
      "	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
      "	mvPosition.xy += rotatedPosition;",
      "	gl_Position = projectionMatrix * mvPosition;",
      "	fogDepth = - mvPosition.z;",
      "}"
    ].join(`
`)), t.shaderSource(M, [
      "precision " + i.precision + " float;",
      "#define SHADER_NAME SpriteMaterial",
      "uniform vec3 color;",
      "uniform sampler2D map;",
      "uniform float opacity;",
      "uniform int fogType;",
      "uniform vec3 fogColor;",
      "uniform float fogDensity;",
      "uniform float fogNear;",
      "uniform float fogFar;",
      "uniform float alphaTest;",
      "varying vec2 vUV;",
      "varying float fogDepth;",
      "void main() {",
      "	vec4 texture = texture2D( map, vUV );",
      "	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",
      "	if ( gl_FragColor.a < alphaTest ) discard;",
      "	if ( fogType > 0 ) {",
      "		float fogFactor = 0.0;",
      "		if ( fogType == 1 ) {",
      "			fogFactor = smoothstep( fogNear, fogFar, fogDepth );",
      "		} else {",
      "			const float LOG2 = 1.442695;",
      "			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );",
      "			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
      "		}",
      "		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );",
      "	}",
      "}"
    ].join(`
`)), t.compileShader(E), t.compileShader(M), t.attachShader(x, E), t.attachShader(x, M), t.linkProgram(x), x;
  }
  function v(x, E) {
    return x.renderOrder !== E.renderOrder ? x.renderOrder - E.renderOrder : x.z !== E.z ? E.z - x.z : E.id - x.id;
  }
}
function z2(e, t, r) {
  function n() {
    var ae = !1, Pe = new kt(), Ie = null, Ze = new kt(0, 0, 0, 0);
    return {
      setMask: function(Fe) {
        Ie !== Fe && !ae && (e.colorMask(Fe, Fe, Fe, Fe), Ie = Fe);
      },
      setLocked: function(Fe) {
        ae = Fe;
      },
      setClear: function(Fe, st, Ne, mt, Rt) {
        Rt === !0 && (Fe *= mt, st *= mt, Ne *= mt), Pe.set(Fe, st, Ne, mt), Ze.equals(Pe) === !1 && (e.clearColor(Fe, st, Ne, mt), Ze.copy(Pe));
      },
      reset: function() {
        ae = !1, Ie = null, Ze.set(-1, 0, 0, 0);
      }
    };
  }
  function i() {
    var ae = !1, Pe = null, Ie = null, Ze = null;
    return {
      setTest: function(Fe) {
        Fe ? Le(e.DEPTH_TEST) : He(e.DEPTH_TEST);
      },
      setMask: function(Fe) {
        Pe !== Fe && !ae && (e.depthMask(Fe), Pe = Fe);
      },
      setFunc: function(Fe) {
        if (Ie !== Fe) {
          if (Fe)
            switch (Fe) {
              case Wg:
                e.depthFunc(e.NEVER);
                break;
              case jg:
                e.depthFunc(e.ALWAYS);
                break;
              case qg:
                e.depthFunc(e.LESS);
                break;
              case oc:
                e.depthFunc(e.LEQUAL);
                break;
              case Xg:
                e.depthFunc(e.EQUAL);
                break;
              case Yg:
                e.depthFunc(e.GEQUAL);
                break;
              case Qg:
                e.depthFunc(e.GREATER);
                break;
              case Kg:
                e.depthFunc(e.NOTEQUAL);
                break;
              default:
                e.depthFunc(e.LEQUAL);
            }
          else
            e.depthFunc(e.LEQUAL);
          Ie = Fe;
        }
      },
      setLocked: function(Fe) {
        ae = Fe;
      },
      setClear: function(Fe) {
        Ze !== Fe && (e.clearDepth(Fe), Ze = Fe);
      },
      reset: function() {
        ae = !1, Pe = null, Ie = null, Ze = null;
      }
    };
  }
  function a() {
    var ae = !1, Pe = null, Ie = null, Ze = null, Fe = null, st = null, Ne = null, mt = null, Rt = null;
    return {
      setTest: function(ht) {
        ht ? Le(e.STENCIL_TEST) : He(e.STENCIL_TEST);
      },
      setMask: function(ht) {
        Pe !== ht && !ae && (e.stencilMask(ht), Pe = ht);
      },
      setFunc: function(ht, Ct, Lt) {
        (Ie !== ht || Ze !== Ct || Fe !== Lt) && (e.stencilFunc(ht, Ct, Lt), Ie = ht, Ze = Ct, Fe = Lt);
      },
      setOp: function(ht, Ct, Lt) {
        (st !== ht || Ne !== Ct || mt !== Lt) && (e.stencilOp(ht, Ct, Lt), st = ht, Ne = Ct, mt = Lt);
      },
      setLocked: function(ht) {
        ae = ht;
      },
      setClear: function(ht) {
        Rt !== ht && (e.clearStencil(ht), Rt = ht);
      },
      reset: function() {
        ae = !1, Pe = null, Ie = null, Ze = null, Fe = null, st = null, Ne = null, mt = null, Rt = null;
      }
    };
  }
  var s = new n(), o = new i(), u = new a(), l = e.getParameter(e.MAX_VERTEX_ATTRIBS), c = new Uint8Array(l), h = new Uint8Array(l), f = new Uint8Array(l), d = {}, p = null, _ = null, v = null, x = null, E = null, M = null, C = null, R = null, B = null, k = !1, F = null, I = null, H = null, Q = null, ee = null, oe = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS), de = !1, he = 0, fe = e.getParameter(e.VERSION);
  fe.indexOf("WebGL") !== -1 ? (he = parseFloat(/^WebGL\ ([0-9])/.exec(fe)[1]), de = he >= 1) : fe.indexOf("OpenGL ES") !== -1 && (he = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(fe)[1]), de = he >= 2);
  var V = null, G = {}, se = new kt(), re = new kt();
  function Ce(ae, Pe, Ie) {
    var Ze = new Uint8Array(4), Fe = e.createTexture();
    e.bindTexture(ae, Fe), e.texParameteri(ae, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(ae, e.TEXTURE_MAG_FILTER, e.NEAREST);
    for (var st = 0; st < Ie; st++)
      e.texImage2D(Pe + st, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, Ze);
    return Fe;
  }
  var K = {};
  K[e.TEXTURE_2D] = Ce(e.TEXTURE_2D, e.TEXTURE_2D, 1), K[e.TEXTURE_CUBE_MAP] = Ce(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), s.setClear(0, 0, 0, 1), o.setClear(1), u.setClear(0), Le(e.DEPTH_TEST), o.setFunc(oc), Mt(!1), Ht(Ef), Le(e.CULL_FACE), Le(e.BLEND), ct(_l);
  function xe() {
    for (var ae = 0, Pe = c.length; ae < Pe; ae++)
      c[ae] = 0;
  }
  function pe(ae) {
    Re(ae, 0);
  }
  function Re(ae, Pe) {
    if (c[ae] = 1, h[ae] === 0 && (e.enableVertexAttribArray(ae), h[ae] = 1), f[ae] !== Pe) {
      var Ie = t.get("ANGLE_instanced_arrays");
      Ie.vertexAttribDivisorANGLE(ae, Pe), f[ae] = Pe;
    }
  }
  function _e() {
    for (var ae = 0, Pe = h.length; ae !== Pe; ++ae)
      h[ae] !== c[ae] && (e.disableVertexAttribArray(ae), h[ae] = 0);
  }
  function Le(ae) {
    d[ae] !== !0 && (e.enable(ae), d[ae] = !0);
  }
  function He(ae) {
    d[ae] !== !1 && (e.disable(ae), d[ae] = !1);
  }
  function dt() {
    if (p === null && (p = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
      for (var ae = e.getParameter(e.COMPRESSED_TEXTURE_FORMATS), Pe = 0; Pe < ae.length; Pe++)
        p.push(ae[Pe]);
    return p;
  }
  function Ee(ae) {
    return _ !== ae ? (e.useProgram(ae), _ = ae, !0) : !1;
  }
  function ct(ae, Pe, Ie, Ze, Fe, st, Ne, mt) {
    if (ae !== sc ? Le(e.BLEND) : He(e.BLEND), ae !== Dd) {
      if (ae !== v || mt !== k)
        switch (ae) {
          case Sd:
            mt ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE, e.ONE, e.ONE)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE));
            break;
          case Cd:
            mt ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR));
            break;
          case Md:
            mt ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.SRC_COLOR));
            break;
          default:
            mt ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA));
        }
      x = null, E = null, M = null, C = null, R = null, B = null;
    } else
      Fe = Fe || Pe, st = st || Ie, Ne = Ne || Ze, (Pe !== x || Fe !== C) && (e.blendEquationSeparate(r.convert(Pe), r.convert(Fe)), x = Pe, C = Fe), (Ie !== E || Ze !== M || st !== R || Ne !== B) && (e.blendFuncSeparate(r.convert(Ie), r.convert(Ze), r.convert(st), r.convert(Ne)), E = Ie, M = Ze, R = st, B = Ne);
    v = ae, k = mt;
  }
  function Bt(ae, Pe) {
    ae.side === Ro ? He(e.CULL_FACE) : Le(e.CULL_FACE);
    var Ie = ae.side === Tr;
    Pe && (Ie = !Ie), Mt(Ie), ae.transparent === !0 ? ct(ae.blending, ae.blendEquation, ae.blendSrc, ae.blendDst, ae.blendEquationAlpha, ae.blendSrcAlpha, ae.blendDstAlpha, ae.premultipliedAlpha) : ct(sc), o.setFunc(ae.depthFunc), o.setTest(ae.depthTest), o.setMask(ae.depthWrite), s.setMask(ae.colorWrite), Gt(ae.polygonOffset, ae.polygonOffsetFactor, ae.polygonOffsetUnits);
  }
  function Mt(ae) {
    F !== ae && (ae ? e.frontFace(e.CW) : e.frontFace(e.CCW), F = ae);
  }
  function Ht(ae) {
    ae !== Pg ? (Le(e.CULL_FACE), ae !== I && (ae === Ef ? e.cullFace(e.BACK) : ae === Lg ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : He(e.CULL_FACE), I = ae;
  }
  function yt(ae) {
    ae !== H && (de && e.lineWidth(ae), H = ae);
  }
  function Gt(ae, Pe, Ie) {
    ae ? (Le(e.POLYGON_OFFSET_FILL), (Q !== Pe || ee !== Ie) && (e.polygonOffset(Pe, Ie), Q = Pe, ee = Ie)) : He(e.POLYGON_OFFSET_FILL);
  }
  function Et(ae) {
    ae ? Le(e.SCISSOR_TEST) : He(e.SCISSOR_TEST);
  }
  function gi(ae) {
    ae === void 0 && (ae = e.TEXTURE0 + oe - 1), V !== ae && (e.activeTexture(ae), V = ae);
  }
  function xt(ae, Pe) {
    V === null && gi();
    var Ie = G[V];
    Ie === void 0 && (Ie = { type: void 0, texture: void 0 }, G[V] = Ie), (Ie.type !== ae || Ie.texture !== Pe) && (e.bindTexture(ae, Pe || K[ae]), Ie.type = ae, Ie.texture = Pe);
  }
  function cr() {
    try {
      e.compressedTexImage2D.apply(e, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function Vt() {
    try {
      e.texImage2D.apply(e, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function yi(ae) {
    se.equals(ae) === !1 && (e.scissor(ae.x, ae.y, ae.z, ae.w), se.copy(ae));
  }
  function gr(ae) {
    re.equals(ae) === !1 && (e.viewport(ae.x, ae.y, ae.z, ae.w), re.copy(ae));
  }
  function ar() {
    for (var ae = 0; ae < h.length; ae++)
      h[ae] === 1 && (e.disableVertexAttribArray(ae), h[ae] = 0);
    d = {}, p = null, V = null, G = {}, _ = null, v = null, F = null, I = null, s.reset(), o.reset(), u.reset();
  }
  return {
    buffers: {
      color: s,
      depth: o,
      stencil: u
    },
    initAttributes: xe,
    enableAttribute: pe,
    enableAttributeAndDivisor: Re,
    disableUnusedAttributes: _e,
    enable: Le,
    disable: He,
    getCompressedTextureFormats: dt,
    useProgram: Ee,
    setBlending: ct,
    setMaterial: Bt,
    setFlipSided: Mt,
    setCullFace: Ht,
    setLineWidth: yt,
    setPolygonOffset: Gt,
    setScissorTest: Et,
    activeTexture: gi,
    bindTexture: xt,
    compressedTexImage2D: cr,
    texImage2D: Vt,
    scissor: yi,
    viewport: gr,
    reset: ar
  };
}
function W2(e, t, r, n, i, a, s) {
  var o = typeof WebGL2RenderingContext < "u" && e instanceof WebGL2RenderingContext, u = {}, l;
  function c(V, G) {
    if (V.width > G || V.height > G) {
      if ("data" in V) {
        console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + V.width + "x" + V.height + ").");
        return;
      }
      var se = G / Math.max(V.width, V.height), re = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      re.width = Math.floor(V.width * se), re.height = Math.floor(V.height * se);
      var Ce = re.getContext("2d");
      return Ce.drawImage(V, 0, 0, V.width, V.height, 0, 0, re.width, re.height), console.warn("THREE.WebGLRenderer: image is too big (" + V.width + "x" + V.height + "). Resized to " + re.width + "x" + re.height, V), re;
    }
    return V;
  }
  function h(V) {
    return gt.isPowerOfTwo(V.width) && gt.isPowerOfTwo(V.height);
  }
  function f(V) {
    if (V instanceof HTMLImageElement || V instanceof HTMLCanvasElement || V instanceof ImageBitmap) {
      l === void 0 && (l = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), l.width = gt.floorPowerOfTwo(V.width), l.height = gt.floorPowerOfTwo(V.height);
      var G = l.getContext("2d");
      return G.drawImage(V, 0, 0, l.width, l.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + V.width + "x" + V.height + "). Resized to " + l.width + "x" + l.height, V), l;
    }
    return V;
  }
  function d(V) {
    return V.wrapS !== Ei || V.wrapT !== Ei || V.minFilter !== wi && V.minFilter !== Vr;
  }
  function p(V, G) {
    return V.generateMipmaps && G && V.minFilter !== wi && V.minFilter !== Vr;
  }
  function _(V, G, se, re) {
    e.generateMipmap(V);
    var Ce = n.get(G);
    Ce.__maxMipLevel = Math.log(Math.max(se, re)) * Math.LOG2E;
  }
  function v(V) {
    return V === wi || V === ch || V === hh ? e.NEAREST : e.LINEAR;
  }
  function x(V) {
    var G = V.target;
    G.removeEventListener("dispose", x), M(G), G.isVideoTexture && delete u[G.id], s.memory.textures--;
  }
  function E(V) {
    var G = V.target;
    G.removeEventListener("dispose", E), C(G), s.memory.textures--;
  }
  function M(V) {
    var G = n.get(V);
    if (V.image && G.__image__webglTextureCube)
      e.deleteTexture(G.__image__webglTextureCube);
    else {
      if (G.__webglInit === void 0) return;
      e.deleteTexture(G.__webglTexture);
    }
    n.remove(V);
  }
  function C(V) {
    var G = n.get(V), se = n.get(V.texture);
    if (V) {
      if (se.__webglTexture !== void 0 && e.deleteTexture(se.__webglTexture), V.depthTexture && V.depthTexture.dispose(), V.isWebGLRenderTargetCube)
        for (var re = 0; re < 6; re++)
          e.deleteFramebuffer(G.__webglFramebuffer[re]), G.__webglDepthbuffer && e.deleteRenderbuffer(G.__webglDepthbuffer[re]);
      else
        e.deleteFramebuffer(G.__webglFramebuffer), G.__webglDepthbuffer && e.deleteRenderbuffer(G.__webglDepthbuffer);
      n.remove(V.texture), n.remove(V);
    }
  }
  function R(V, G) {
    var se = n.get(V);
    if (V.isVideoTexture && fe(V), V.version > 0 && se.__version !== V.version) {
      var re = V.image;
      if (re === void 0)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", V);
      else if (re.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", V);
      else {
        I(se, V, G);
        return;
      }
    }
    r.activeTexture(e.TEXTURE0 + G), r.bindTexture(e.TEXTURE_2D, se.__webglTexture);
  }
  function B(V, G) {
    var se = n.get(V);
    if (V.image.length === 6)
      if (V.version > 0 && se.__version !== V.version) {
        se.__image__webglTextureCube || (V.addEventListener("dispose", x), se.__image__webglTextureCube = e.createTexture(), s.memory.textures++), r.activeTexture(e.TEXTURE0 + G), r.bindTexture(e.TEXTURE_CUBE_MAP, se.__image__webglTextureCube), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, V.flipY);
        for (var re = V && V.isCompressedTexture, Ce = V.image[0] && V.image[0].isDataTexture, K = [], xe = 0; xe < 6; xe++)
          !re && !Ce ? K[xe] = c(V.image[xe], i.maxCubemapSize) : K[xe] = Ce ? V.image[xe].image : V.image[xe];
        var pe = K[0], Re = h(pe), _e = a.convert(V.format), Le = a.convert(V.type);
        F(e.TEXTURE_CUBE_MAP, V, Re);
        for (var xe = 0; xe < 6; xe++)
          if (!re)
            Ce ? r.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, _e, K[xe].width, K[xe].height, 0, _e, Le, K[xe].data) : r.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, _e, _e, Le, K[xe]);
          else
            for (var He, dt = K[xe].mipmaps, Ee = 0, ct = dt.length; Ee < ct; Ee++)
              He = dt[Ee], V.format !== yn && V.format !== Wa ? r.getCompressedTextureFormats().indexOf(_e) > -1 ? r.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ee, _e, He.width, He.height, 0, He.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : r.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, Ee, _e, He.width, He.height, 0, _e, Le, He.data);
        re ? se.__maxMipLevel = dt.length - 1 : se.__maxMipLevel = 0, p(V, Re) && _(e.TEXTURE_CUBE_MAP, V, pe.width, pe.height), se.__version = V.version, V.onUpdate && V.onUpdate(V);
      } else
        r.activeTexture(e.TEXTURE0 + G), r.bindTexture(e.TEXTURE_CUBE_MAP, se.__image__webglTextureCube);
  }
  function k(V, G) {
    r.activeTexture(e.TEXTURE0 + G), r.bindTexture(e.TEXTURE_CUBE_MAP, n.get(V).__webglTexture);
  }
  function F(V, G, se) {
    var re;
    if (se ? (e.texParameteri(V, e.TEXTURE_WRAP_S, a.convert(G.wrapS)), e.texParameteri(V, e.TEXTURE_WRAP_T, a.convert(G.wrapT)), e.texParameteri(V, e.TEXTURE_MAG_FILTER, a.convert(G.magFilter)), e.texParameteri(V, e.TEXTURE_MIN_FILTER, a.convert(G.minFilter))) : (e.texParameteri(V, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(V, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), (G.wrapS !== Ei || G.wrapT !== Ei) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", G), e.texParameteri(V, e.TEXTURE_MAG_FILTER, v(G.magFilter)), e.texParameteri(V, e.TEXTURE_MIN_FILTER, v(G.minFilter)), G.minFilter !== wi && G.minFilter !== Vr && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", G)), re = t.get("EXT_texture_filter_anisotropic"), re) {
      if (G.type === Us && t.get("OES_texture_float_linear") === null || G.type === dh && t.get("OES_texture_half_float_linear") === null) return;
      (G.anisotropy > 1 || n.get(G).__currentAnisotropy) && (e.texParameterf(V, re.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(G.anisotropy, i.getMaxAnisotropy())), n.get(G).__currentAnisotropy = G.anisotropy);
    }
  }
  function I(V, G, se) {
    V.__webglInit === void 0 && (V.__webglInit = !0, G.addEventListener("dispose", x), V.__webglTexture = e.createTexture(), s.memory.textures++), r.activeTexture(e.TEXTURE0 + se), r.bindTexture(e.TEXTURE_2D, V.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, G.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, G.unpackAlignment);
    var re = c(G.image, i.maxTextureSize);
    d(G) && h(re) === !1 && (re = f(re));
    var Ce = h(re), K = a.convert(G.format), xe = a.convert(G.type);
    F(e.TEXTURE_2D, G, Ce);
    var pe, Re = G.mipmaps;
    if (G.isDepthTexture) {
      var _e = e.DEPTH_COMPONENT;
      if (G.type === Us) {
        if (!o) throw new Error("Float Depth Texture only supported in WebGL2.0");
        _e = e.DEPTH_COMPONENT32F;
      } else o && (_e = e.DEPTH_COMPONENT16);
      G.format === ka && _e === e.DEPTH_COMPONENT && G.type !== pu && G.type !== kd && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), G.type = pu, xe = a.convert(G.type)), G.format === Gs && (_e = e.DEPTH_STENCIL, G.type !== mu && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), G.type = mu, xe = a.convert(G.type))), r.texImage2D(e.TEXTURE_2D, 0, _e, re.width, re.height, 0, K, xe, null);
    } else if (G.isDataTexture)
      if (Re.length > 0 && Ce) {
        for (var Le = 0, He = Re.length; Le < He; Le++)
          pe = Re[Le], r.texImage2D(e.TEXTURE_2D, Le, K, pe.width, pe.height, 0, K, xe, pe.data);
        G.generateMipmaps = !1, V.__maxMipLevel = Re.length - 1;
      } else
        r.texImage2D(e.TEXTURE_2D, 0, K, re.width, re.height, 0, K, xe, re.data), V.__maxMipLevel = 0;
    else if (G.isCompressedTexture) {
      for (var Le = 0, He = Re.length; Le < He; Le++)
        pe = Re[Le], G.format !== yn && G.format !== Wa ? r.getCompressedTextureFormats().indexOf(K) > -1 ? r.compressedTexImage2D(e.TEXTURE_2D, Le, K, pe.width, pe.height, 0, pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : r.texImage2D(e.TEXTURE_2D, Le, K, pe.width, pe.height, 0, K, xe, pe.data);
      V.__maxMipLevel = Re.length - 1;
    } else if (Re.length > 0 && Ce) {
      for (var Le = 0, He = Re.length; Le < He; Le++)
        pe = Re[Le], r.texImage2D(e.TEXTURE_2D, Le, K, K, xe, pe);
      G.generateMipmaps = !1, V.__maxMipLevel = Re.length - 1;
    } else
      r.texImage2D(e.TEXTURE_2D, 0, K, K, xe, re), V.__maxMipLevel = 0;
    p(G, Ce) && _(e.TEXTURE_2D, G, re.width, re.height), V.__version = G.version, G.onUpdate && G.onUpdate(G);
  }
  function H(V, G, se, re) {
    var Ce = a.convert(G.texture.format), K = a.convert(G.texture.type);
    r.texImage2D(re, 0, Ce, G.width, G.height, 0, Ce, K, null), e.bindFramebuffer(e.FRAMEBUFFER, V), e.framebufferTexture2D(e.FRAMEBUFFER, se, re, n.get(G.texture).__webglTexture, 0), e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  function Q(V, G) {
    e.bindRenderbuffer(e.RENDERBUFFER, V), G.depthBuffer && !G.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, G.width, G.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, V)) : G.depthBuffer && G.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, G.width, G.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, V)) : e.renderbufferStorage(e.RENDERBUFFER, e.RGBA4, G.width, G.height), e.bindRenderbuffer(e.RENDERBUFFER, null);
  }
  function ee(V, G) {
    var se = G && G.isWebGLRenderTargetCube;
    if (se) throw new Error("Depth Texture with cube render targets is not supported");
    if (e.bindFramebuffer(e.FRAMEBUFFER, V), !(G.depthTexture && G.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(G.depthTexture).__webglTexture || G.depthTexture.image.width !== G.width || G.depthTexture.image.height !== G.height) && (G.depthTexture.image.width = G.width, G.depthTexture.image.height = G.height, G.depthTexture.needsUpdate = !0), R(G.depthTexture, 0);
    var re = n.get(G.depthTexture).__webglTexture;
    if (G.depthTexture.format === ka)
      e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, re, 0);
    else if (G.depthTexture.format === Gs)
      e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, re, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function oe(V) {
    var G = n.get(V), se = V.isWebGLRenderTargetCube === !0;
    if (V.depthTexture) {
      if (se) throw new Error("target.depthTexture not supported in Cube render targets");
      ee(G.__webglFramebuffer, V);
    } else if (se) {
      G.__webglDepthbuffer = [];
      for (var re = 0; re < 6; re++)
        e.bindFramebuffer(e.FRAMEBUFFER, G.__webglFramebuffer[re]), G.__webglDepthbuffer[re] = e.createRenderbuffer(), Q(G.__webglDepthbuffer[re], V);
    } else
      e.bindFramebuffer(e.FRAMEBUFFER, G.__webglFramebuffer), G.__webglDepthbuffer = e.createRenderbuffer(), Q(G.__webglDepthbuffer, V);
    e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  function de(V) {
    var G = n.get(V), se = n.get(V.texture);
    V.addEventListener("dispose", E), se.__webglTexture = e.createTexture(), s.memory.textures++;
    var re = V.isWebGLRenderTargetCube === !0, Ce = h(V);
    if (re) {
      G.__webglFramebuffer = [];
      for (var K = 0; K < 6; K++)
        G.__webglFramebuffer[K] = e.createFramebuffer();
    } else
      G.__webglFramebuffer = e.createFramebuffer();
    if (re) {
      r.bindTexture(e.TEXTURE_CUBE_MAP, se.__webglTexture), F(e.TEXTURE_CUBE_MAP, V.texture, Ce);
      for (var K = 0; K < 6; K++)
        H(G.__webglFramebuffer[K], V, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + K);
      p(V.texture, Ce) && _(e.TEXTURE_CUBE_MAP, V.texture, V.width, V.height), r.bindTexture(e.TEXTURE_CUBE_MAP, null);
    } else
      r.bindTexture(e.TEXTURE_2D, se.__webglTexture), F(e.TEXTURE_2D, V.texture, Ce), H(G.__webglFramebuffer, V, e.COLOR_ATTACHMENT0, e.TEXTURE_2D), p(V.texture, Ce) && _(e.TEXTURE_2D, V.texture, V.width, V.height), r.bindTexture(e.TEXTURE_2D, null);
    V.depthBuffer && oe(V);
  }
  function he(V) {
    var G = V.texture, se = h(V);
    if (p(G, se)) {
      var re = V.isWebGLRenderTargetCube ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D, Ce = n.get(G).__webglTexture;
      r.bindTexture(re, Ce), _(re, G, V.width, V.height), r.bindTexture(re, null);
    }
  }
  function fe(V) {
    var G = V.id, se = s.render.frame;
    u[G] !== se && (u[G] = se, V.update());
  }
  this.setTexture2D = R, this.setTextureCube = B, this.setTextureCubeDynamic = k, this.setupRenderTarget = de, this.updateRenderTargetMipmap = he;
}
function $0(e, t) {
  function r(n) {
    var i;
    if (n === On) return e.REPEAT;
    if (n === Ei) return e.CLAMP_TO_EDGE;
    if (n === za) return e.MIRRORED_REPEAT;
    if (n === wi) return e.NEAREST;
    if (n === ch) return e.NEAREST_MIPMAP_NEAREST;
    if (n === hh) return e.NEAREST_MIPMAP_LINEAR;
    if (n === Vr) return e.LINEAR;
    if (n === Fd) return e.LINEAR_MIPMAP_NEAREST;
    if (n === xl) return e.LINEAR_MIPMAP_LINEAR;
    if (n === fh) return e.UNSIGNED_BYTE;
    if (n === a0) return e.UNSIGNED_SHORT_4_4_4_4;
    if (n === s0) return e.UNSIGNED_SHORT_5_5_5_1;
    if (n === o0) return e.UNSIGNED_SHORT_5_6_5;
    if (n === r0) return e.BYTE;
    if (n === i0) return e.SHORT;
    if (n === pu) return e.UNSIGNED_SHORT;
    if (n === n0) return e.INT;
    if (n === kd) return e.UNSIGNED_INT;
    if (n === Us) return e.FLOAT;
    if (n === dh && (i = t.get("OES_texture_half_float"), i !== null))
      return i.HALF_FLOAT_OES;
    if (n === u0) return e.ALPHA;
    if (n === Wa) return e.RGB;
    if (n === yn) return e.RGBA;
    if (n === l0) return e.LUMINANCE;
    if (n === c0) return e.LUMINANCE_ALPHA;
    if (n === ka) return e.DEPTH_COMPONENT;
    if (n === Gs) return e.DEPTH_STENCIL;
    if (n === Pd) return e.FUNC_ADD;
    if (n === Ig) return e.FUNC_SUBTRACT;
    if (n === Og) return e.FUNC_REVERSE_SUBTRACT;
    if (n === Bg) return e.ZERO;
    if (n === Fg) return e.ONE;
    if (n === kg) return e.SRC_COLOR;
    if (n === Ng) return e.ONE_MINUS_SRC_COLOR;
    if (n === Ld) return e.SRC_ALPHA;
    if (n === Rd) return e.ONE_MINUS_SRC_ALPHA;
    if (n === Ug) return e.DST_ALPHA;
    if (n === Gg) return e.ONE_MINUS_DST_ALPHA;
    if (n === Vg) return e.DST_COLOR;
    if (n === Hg) return e.ONE_MINUS_DST_COLOR;
    if (n === zg) return e.SRC_ALPHA_SATURATE;
    if ((n === Cf || n === Mf || n === Df || n === Pf) && (i = t.get("WEBGL_compressed_texture_s3tc"), i !== null)) {
      if (n === Cf) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (n === Mf) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (n === Df) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (n === Pf) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    if ((n === Lf || n === Rf || n === If || n === Of) && (i = t.get("WEBGL_compressed_texture_pvrtc"), i !== null)) {
      if (n === Lf) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (n === Rf) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (n === If) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (n === Of) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (n === h0 && (i = t.get("WEBGL_compressed_texture_etc1"), i !== null))
      return i.COMPRESSED_RGB_ETC1_WEBGL;
    if ((n === f0 || n === d0 || n === p0 || n === m0 || n === v0 || n === g0 || n === y0 || n === _0 || n === b0 || n === x0 || n === A0 || n === T0 || n === E0 || n === w0) && (i = t.get("WEBGL_compressed_texture_astc"), i !== null))
      return n;
    if ((n === wf || n === Sf) && (i = t.get("EXT_blend_minmax"), i !== null)) {
      if (n === wf) return i.MIN_EXT;
      if (n === Sf) return i.MAX_EXT;
    }
    return n === mu && (i = t.get("WEBGL_depth_texture"), i !== null) ? i.UNSIGNED_INT_24_8_WEBGL : 0;
  }
  return { convert: r };
}
function or(e, t, r, n) {
  _n.call(this), this.type = "PerspectiveCamera", this.fov = e !== void 0 ? e : 50, this.zoom = 1, this.near = r !== void 0 ? r : 0.1, this.far = n !== void 0 ? n : 2e3, this.focus = 10, this.aspect = t !== void 0 ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
}
or.prototype = Object.assign(Object.create(_n.prototype), {
  constructor: or,
  isPerspectiveCamera: !0,
  copy: function(e, t) {
    return _n.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  },
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function(e) {
    var t = 0.5 * this.getFilmHeight() / e;
    this.fov = gt.RAD2DEG * 2 * Math.atan(t), this.updateProjectionMatrix();
  },
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function() {
    var e = Math.tan(gt.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  },
  getEffectiveFOV: function() {
    return gt.RAD2DEG * 2 * Math.atan(
      Math.tan(gt.DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   var w = 1920;
   *   var h = 1080;
   *   var fullWidth = w * 3;
   *   var fullHeight = h * 2;
   *
   *   --A--
   *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function(e, t, r, n, i, a) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = n, this.view.width = i, this.view.height = a, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var e = this.near, t = e * Math.tan(
      gt.DEG2RAD * 0.5 * this.fov
    ) / this.zoom, r = 2 * t, n = this.aspect * r, i = -0.5 * n, a = this.view;
    if (this.view !== null && this.view.enabled) {
      var s = a.fullWidth, o = a.fullHeight;
      i += a.offsetX * n / s, t -= a.offsetY * r / o, n *= a.width / s, r *= a.height / o;
    }
    var u = this.filmOffset;
    u !== 0 && (i += e * u / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + n, t, t - r, e, this.far);
  },
  toJSON: function(e) {
    var t = ke.prototype.toJSON.call(this, e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
});
function Su(e) {
  or.call(this), this.cameras = e || [];
}
Su.prototype = Object.assign(Object.create(or.prototype), {
  constructor: Su,
  isArrayCamera: !0
});
function Z0(e) {
  var t = this, r = null, n = null, i = null, a = new at(), s = new at();
  typeof window < "u" && "VRFrameData" in window && (n = new window.VRFrameData(), window.addEventListener("vrdisplaypresentchange", v, !1));
  var o = new at(), u = new _r(), l = new z(), c = new or();
  c.bounds = new kt(0, 0, 0.5, 1), c.layers.enable(1);
  var h = new or();
  h.bounds = new kt(0.5, 0, 0.5, 1), h.layers.enable(2);
  var f = new Su([c, h]);
  f.layers.enable(1), f.layers.enable(2);
  function d() {
    return r !== null && r.isPresenting === !0;
  }
  var p, _;
  function v() {
    if (d()) {
      var E = r.getEyeParameters("left"), M = E.renderWidth, C = E.renderHeight;
      _ = e.getPixelRatio(), p = e.getSize(), e.setDrawingBufferSize(M * 2, C, 1), x.start();
    } else t.enabled && (e.setDrawingBufferSize(p.width, p.height, _), x.stop());
  }
  this.enabled = !1, this.userHeight = 1.6, this.getDevice = function() {
    return r;
  }, this.setDevice = function(E) {
    E !== void 0 && (r = E), x.setContext(E);
  }, this.setPoseTarget = function(E) {
    E !== void 0 && (i = E);
  }, this.getCamera = function(E) {
    if (r === null) return E;
    r.depthNear = E.near, r.depthFar = E.far, r.getFrameData(n);
    var M = r.stageParameters;
    M ? a.fromArray(M.sittingToStandingTransform) : a.makeTranslation(0, t.userHeight, 0);
    var C = n.pose, R = i !== null ? i : E;
    if (R.matrix.copy(a), R.matrix.decompose(R.position, R.quaternion, R.scale), C.orientation !== null && (u.fromArray(C.orientation), R.quaternion.multiply(u)), C.position !== null && (u.setFromRotationMatrix(a), l.fromArray(C.position), l.applyQuaternion(u), R.position.add(l)), R.updateMatrixWorld(), r.isPresenting === !1) return E;
    c.near = E.near, h.near = E.near, c.far = E.far, h.far = E.far, f.matrixWorld.copy(E.matrixWorld), f.matrixWorldInverse.copy(E.matrixWorldInverse), c.matrixWorldInverse.fromArray(n.leftViewMatrix), h.matrixWorldInverse.fromArray(n.rightViewMatrix), s.getInverse(a), c.matrixWorldInverse.multiply(s), h.matrixWorldInverse.multiply(s);
    var B = R.parent;
    B !== null && (o.getInverse(B.matrixWorld), c.matrixWorldInverse.multiply(o), h.matrixWorldInverse.multiply(o)), c.matrixWorld.getInverse(c.matrixWorldInverse), h.matrixWorld.getInverse(h.matrixWorldInverse), c.projectionMatrix.fromArray(n.leftProjectionMatrix), h.projectionMatrix.fromArray(n.rightProjectionMatrix), f.projectionMatrix.copy(c.projectionMatrix);
    var k = r.getLayers();
    if (k.length) {
      var F = k[0];
      F.leftBounds !== null && F.leftBounds.length === 4 && c.bounds.fromArray(F.leftBounds), F.rightBounds !== null && F.rightBounds.length === 4 && h.bounds.fromArray(F.rightBounds);
    }
    return f;
  }, this.getStandingMatrix = function() {
    return a;
  }, this.isPresenting = d;
  var x = new Gd();
  this.setAnimationLoop = function(E) {
    x.setAnimationLoop(E);
  }, this.submitFrame = function() {
    d() && r.submitFrame();
  }, this.dispose = function() {
    typeof window < "u" && window.removeEventListener("vrdisplaypresentchange", v);
  };
}
function j2(e) {
  var t = e.context, r = null, n = null, i = null, a = null;
  function s() {
    return n !== null && i !== null;
  }
  var o = new or();
  o.layers.enable(1), o.viewport = new kt();
  var u = new or();
  u.layers.enable(2), u.viewport = new kt();
  var l = new Su([o, u]);
  l.layers.enable(1), l.layers.enable(2), this.enabled = !1, this.getDevice = function() {
    return r;
  }, this.setDevice = function(p) {
    p !== void 0 && (r = p), t.setCompatibleXRDevice(p);
  }, this.setSession = function(p, _) {
    n = p, n !== null && (n.addEventListener("end", function() {
      e.setFramebuffer(null), d.stop();
    }), n.baseLayer = new XRWebGLLayer(n, t), n.requestFrameOfReference(_.frameOfReferenceType).then(function(v) {
      i = v, e.setFramebuffer(n.baseLayer.framebuffer), d.setContext(n), d.start();
    }));
  };
  function c(p, _) {
    _ === null ? p.matrixWorld.copy(p.matrix) : p.matrixWorld.multiplyMatrices(_.matrixWorld, p.matrix), p.matrixWorldInverse.getInverse(p.matrixWorld);
  }
  this.getCamera = function(p) {
    if (s()) {
      var _ = p.parent, v = l.cameras;
      c(l, _);
      for (var x = 0; x < v.length; x++)
        c(v[x], _);
      p.matrixWorld.copy(l.matrixWorld);
      for (var E = p.children, x = 0, M = E.length; x < M; x++)
        E[x].updateMatrixWorld(!0);
      return l;
    }
    return p;
  }, this.isPresenting = s;
  var h = null;
  function f(p, _) {
    a = _.getDevicePose(i);
    for (var v = n.baseLayer, x = _.views, E = 0; E < x.length; E++) {
      var M = x[E], C = v.getViewport(M), R = a.getViewMatrix(M), B = l.cameras[E];
      B.matrix.fromArray(R).getInverse(B.matrix), B.projectionMatrix.fromArray(M.projectionMatrix), B.viewport.set(C.x, C.y, C.width, C.height), E === 0 && (l.matrix.copy(B.matrix), l.projectionMatrix.copy(B.projectionMatrix));
    }
    h && h();
  }
  var d = new Gd();
  d.setAnimationLoop(f), this.setAnimationLoop = function(p) {
    h = p;
  }, this.getStandingMatrix = function() {
    return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4();
  }, this.submitFrame = function() {
  };
}
function mh(e) {
  console.log("THREE.WebGLRenderer", Dg), e = e || {};
  var t = e.canvas !== void 0 ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), r = e.context !== void 0 ? e.context : null, n = e.alpha !== void 0 ? e.alpha : !1, i = e.depth !== void 0 ? e.depth : !0, a = e.stencil !== void 0 ? e.stencil : !0, s = e.antialias !== void 0 ? e.antialias : !1, o = e.premultipliedAlpha !== void 0 ? e.premultipliedAlpha : !0, u = e.preserveDrawingBuffer !== void 0 ? e.preserveDrawingBuffer : !1, l = e.powerPreference !== void 0 ? e.powerPreference : "default", c = null, h = null;
  this.domElement = t, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Id, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
  var f = this, d = !1, p = null, _ = null, v = null, x = -1, E = "", M = null, C = null, R = new kt(), B = new kt(), k = null, F = 0, I = t.width, H = t.height, Q = 1, ee = new kt(0, 0, I, H), oe = new kt(0, 0, I, H), de = !1, he = new ph(), fe = new jT(), V = !1, G = !1, se = new at(), re = new z();
  function Ce() {
    return _ === null ? Q : 1;
  }
  var K;
  try {
    var xe = {
      alpha: n,
      depth: i,
      stencil: a,
      antialias: s,
      premultipliedAlpha: o,
      preserveDrawingBuffer: u,
      powerPreference: l
    };
    if (t.addEventListener("webglcontextlost", ae, !1), t.addEventListener("webglcontextrestored", Pe, !1), K = r || t.getContext("webgl", xe) || t.getContext("experimental-webgl", xe), K === null)
      throw t.getContext("webgl") !== null ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    K.getShaderPrecisionFormat === void 0 && (K.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (O) {
    console.error("THREE.WebGLRenderer: " + O.message);
  }
  var pe, Re, _e, Le, He, dt, Ee, ct, Bt, Mt, Ht, yt, Gt, Et, gi, xt, cr, Vt;
  function yi() {
    pe = new qT(K), pe.get("WEBGL_depth_texture"), pe.get("OES_texture_float"), pe.get("OES_texture_float_linear"), pe.get("OES_texture_half_float"), pe.get("OES_texture_half_float_linear"), pe.get("OES_standard_derivatives"), pe.get("OES_element_index_uint"), pe.get("ANGLE_instanced_arrays"), Vt = new $0(K, pe), Re = new WT(K, pe, e), _e = new z2(K, pe, Vt), _e.scissor(B.copy(oe).multiplyScalar(Q)), _e.viewport(R.copy(ee).multiplyScalar(Q)), Le = new QT(K), He = new R2(), dt = new W2(K, pe, _e, He, Re, Vt, Le), Ee = new kT(K), ct = new XT(K, Ee, Le), Bt = new ZT(ct, Le), Et = new $T(K), Mt = new L2(f, pe, Re), Ht = new F2(), yt = new V2(), Gt = new HT(f, _e, Bt, o), gi = new zT(K, pe, Le), xt = new YT(K, pe, Le), cr = new H2(f, K, _e, dt, Re), Le.programs = Mt.programs, f.context = K, f.capabilities = Re, f.extensions = pe, f.properties = He, f.renderLists = Ht, f.state = _e, f.info = Le;
  }
  yi();
  var gr = "xr" in navigator ? new j2(f) : new Z0(f);
  this.vr = gr;
  var ar = new K0(f, Bt, Re.maxTextureSize);
  this.shadowMap = ar, this.getContext = function() {
    return K;
  }, this.getContextAttributes = function() {
    return K.getContextAttributes();
  }, this.forceContextLoss = function() {
    var O = pe.get("WEBGL_lose_context");
    O && O.loseContext();
  }, this.forceContextRestore = function() {
    var O = pe.get("WEBGL_lose_context");
    O && O.restoreContext();
  }, this.getPixelRatio = function() {
    return Q;
  }, this.setPixelRatio = function(O) {
    O !== void 0 && (Q = O, this.setSize(I, H, !1));
  }, this.getSize = function() {
    return {
      width: I,
      height: H
    };
  }, this.setSize = function(O, W, J) {
    if (gr.isPresenting()) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    I = O, H = W, t.width = O * Q, t.height = W * Q, J !== !1 && (t.style.width = O + "px", t.style.height = W + "px"), this.setViewport(0, 0, O, W);
  }, this.getDrawingBufferSize = function() {
    return {
      width: I * Q,
      height: H * Q
    };
  }, this.setDrawingBufferSize = function(O, W, J) {
    I = O, H = W, Q = J, t.width = O * J, t.height = W * J, this.setViewport(0, 0, O, W);
  }, this.getCurrentViewport = function() {
    return R;
  }, this.setViewport = function(O, W, J, ge) {
    ee.set(O, H - W - ge, J, ge), _e.viewport(R.copy(ee).multiplyScalar(Q));
  }, this.setScissor = function(O, W, J, ge) {
    oe.set(O, H - W - ge, J, ge), _e.scissor(B.copy(oe).multiplyScalar(Q));
  }, this.setScissorTest = function(O) {
    _e.setScissorTest(de = O);
  }, this.getClearColor = function() {
    return Gt.getClearColor();
  }, this.setClearColor = function() {
    Gt.setClearColor.apply(Gt, arguments);
  }, this.getClearAlpha = function() {
    return Gt.getClearAlpha();
  }, this.setClearAlpha = function() {
    Gt.setClearAlpha.apply(Gt, arguments);
  }, this.clear = function(O, W, J) {
    var ge = 0;
    (O === void 0 || O) && (ge |= K.COLOR_BUFFER_BIT), (W === void 0 || W) && (ge |= K.DEPTH_BUFFER_BIT), (J === void 0 || J) && (ge |= K.STENCIL_BUFFER_BIT), K.clear(ge);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.clearTarget = function(O, W, J, ge) {
    this.setRenderTarget(O), this.clear(W, J, ge);
  }, this.dispose = function() {
    t.removeEventListener("webglcontextlost", ae, !1), t.removeEventListener("webglcontextrestored", Pe, !1), Ht.dispose(), yt.dispose(), He.dispose(), Bt.dispose(), gr.dispose(), ht.stop();
  };
  function ae(O) {
    O.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), d = !0;
  }
  function Pe() {
    console.log("THREE.WebGLRenderer: Context Restored."), d = !1, yi();
  }
  function Ie(O) {
    var W = O.target;
    W.removeEventListener("dispose", Ie), Ze(W);
  }
  function Ze(O) {
    Fe(O), He.remove(O);
  }
  function Fe(O) {
    var W = He.get(O).program;
    O.program = void 0, W !== void 0 && Mt.releaseProgram(W);
  }
  function st(O, W, J) {
    O.render(function(ge) {
      f.renderBufferImmediate(ge, W, J);
    });
  }
  this.renderBufferImmediate = function(O, W, J) {
    _e.initAttributes();
    var ge = He.get(O);
    O.hasPositions && !ge.position && (ge.position = K.createBuffer()), O.hasNormals && !ge.normal && (ge.normal = K.createBuffer()), O.hasUvs && !ge.uv && (ge.uv = K.createBuffer()), O.hasColors && !ge.color && (ge.color = K.createBuffer());
    var Me = W.getAttributes();
    if (O.hasPositions && (K.bindBuffer(K.ARRAY_BUFFER, ge.position), K.bufferData(K.ARRAY_BUFFER, O.positionArray, K.DYNAMIC_DRAW), _e.enableAttribute(Me.position), K.vertexAttribPointer(Me.position, 3, K.FLOAT, !1, 0, 0)), O.hasNormals) {
      if (K.bindBuffer(K.ARRAY_BUFFER, ge.normal), !J.isMeshPhongMaterial && !J.isMeshStandardMaterial && !J.isMeshNormalMaterial && J.flatShading === !0)
        for (var We = 0, Ke = O.count * 3; We < Ke; We += 9) {
          var we = O.normalArray, et = (we[We + 0] + we[We + 3] + we[We + 6]) / 3, nt = (we[We + 1] + we[We + 4] + we[We + 7]) / 3, rt = (we[We + 2] + we[We + 5] + we[We + 8]) / 3;
          we[We + 0] = et, we[We + 1] = nt, we[We + 2] = rt, we[We + 3] = et, we[We + 4] = nt, we[We + 5] = rt, we[We + 6] = et, we[We + 7] = nt, we[We + 8] = rt;
        }
      K.bufferData(K.ARRAY_BUFFER, O.normalArray, K.DYNAMIC_DRAW), _e.enableAttribute(Me.normal), K.vertexAttribPointer(Me.normal, 3, K.FLOAT, !1, 0, 0);
    }
    O.hasUvs && J.map && (K.bindBuffer(K.ARRAY_BUFFER, ge.uv), K.bufferData(K.ARRAY_BUFFER, O.uvArray, K.DYNAMIC_DRAW), _e.enableAttribute(Me.uv), K.vertexAttribPointer(Me.uv, 2, K.FLOAT, !1, 0, 0)), O.hasColors && J.vertexColors !== ah && (K.bindBuffer(K.ARRAY_BUFFER, ge.color), K.bufferData(K.ARRAY_BUFFER, O.colorArray, K.DYNAMIC_DRAW), _e.enableAttribute(Me.color), K.vertexAttribPointer(Me.color, 3, K.FLOAT, !1, 0, 0)), _e.disableUnusedAttributes(), K.drawArrays(K.TRIANGLES, 0, O.count), O.count = 0;
  }, this.renderBufferDirect = function(O, W, J, ge, Me, We) {
    var Ke = Me.isMesh && Me.matrixWorld.determinant() < 0;
    _e.setMaterial(ge, Ke);
    var we = Fi(O, W, ge, Me), et = J.id + "_" + we.id + "_" + (ge.wireframe === !0), nt = !1;
    et !== E && (E = et, nt = !0), Me.morphTargetInfluences && (Et.update(Me, J, ge, we), nt = !0);
    var rt = J.index, Tt = J.attributes.position, Qe = 1;
    ge.wireframe === !0 && (rt = ct.getWireframeAttribute(J), Qe = 2);
    var Dt, bt = gi;
    rt !== null && (Dt = Ee.get(rt), bt = xt, bt.setIndex(Dt)), nt && (Ne(ge, we, J), rt !== null && K.bindBuffer(K.ELEMENT_ARRAY_BUFFER, Dt.buffer));
    var Jt = 1 / 0;
    rt !== null ? Jt = rt.count : Tt !== void 0 && (Jt = Tt.count);
    var hr = J.drawRange.start * Qe, Nr = J.drawRange.count * Qe, Cr = We !== null ? We.start * Qe : 0, sn = We !== null ? We.count * Qe : 1 / 0, na = Math.max(hr, Cr), aa = Math.min(Jt, hr + Nr, Cr + sn) - 1, sa = Math.max(0, aa - na + 1);
    if (sa !== 0) {
      if (Me.isMesh)
        if (ge.wireframe === !0)
          _e.setLineWidth(ge.wireframeLinewidth * Ce()), bt.setMode(K.LINES);
        else
          switch (Me.drawMode) {
            case Nd:
              bt.setMode(K.TRIANGLES);
              break;
            case D0:
              bt.setMode(K.TRIANGLE_STRIP);
              break;
            case P0:
              bt.setMode(K.TRIANGLE_FAN);
              break;
          }
      else if (Me.isLine) {
        var It = ge.linewidth;
        It === void 0 && (It = 1), _e.setLineWidth(It * Ce()), Me.isLineSegments ? bt.setMode(K.LINES) : Me.isLineLoop ? bt.setMode(K.LINE_LOOP) : bt.setMode(K.LINE_STRIP);
      } else Me.isPoints && bt.setMode(K.POINTS);
      J && J.isInstancedBufferGeometry ? J.maxInstancedCount > 0 && bt.renderInstances(J, na, sa) : bt.render(na, sa);
    }
  };
  function Ne(O, W, J) {
    if (J && J.isInstancedBufferGeometry && pe.get("ANGLE_instanced_arrays") === null) {
      console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    _e.initAttributes();
    var ge = J.attributes, Me = W.getAttributes(), We = O.defaultAttributeValues;
    for (var Ke in Me) {
      var we = Me[Ke];
      if (we >= 0) {
        var et = ge[Ke];
        if (et !== void 0) {
          var nt = et.normalized, rt = et.itemSize, Tt = Ee.get(et);
          if (Tt === void 0) continue;
          var Qe = Tt.buffer, Dt = Tt.type, bt = Tt.bytesPerElement;
          if (et.isInterleavedBufferAttribute) {
            var Jt = et.data, hr = Jt.stride, Nr = et.offset;
            Jt && Jt.isInstancedInterleavedBuffer ? (_e.enableAttributeAndDivisor(we, Jt.meshPerAttribute), J.maxInstancedCount === void 0 && (J.maxInstancedCount = Jt.meshPerAttribute * Jt.count)) : _e.enableAttribute(we), K.bindBuffer(K.ARRAY_BUFFER, Qe), K.vertexAttribPointer(we, rt, Dt, nt, hr * bt, Nr * bt);
          } else
            et.isInstancedBufferAttribute ? (_e.enableAttributeAndDivisor(we, et.meshPerAttribute), J.maxInstancedCount === void 0 && (J.maxInstancedCount = et.meshPerAttribute * et.count)) : _e.enableAttribute(we), K.bindBuffer(K.ARRAY_BUFFER, Qe), K.vertexAttribPointer(we, rt, Dt, nt, 0, 0);
        } else if (We !== void 0) {
          var Cr = We[Ke];
          if (Cr !== void 0)
            switch (Cr.length) {
              case 2:
                K.vertexAttrib2fv(we, Cr);
                break;
              case 3:
                K.vertexAttrib3fv(we, Cr);
                break;
              case 4:
                K.vertexAttrib4fv(we, Cr);
                break;
              default:
                K.vertexAttrib1fv(we, Cr);
            }
        }
      }
    }
    _e.disableUnusedAttributes();
  }
  this.compile = function(O, W) {
    h = yt.get(O, W), h.init(), O.traverse(function(J) {
      J.isLight && (h.pushLight(J), J.castShadow && h.pushShadow(J));
    }), h.setupLights(W), O.traverse(function(J) {
      if (J.material)
        if (Array.isArray(J.material))
          for (var ge = 0; ge < J.material.length; ge++)
            _t(J.material[ge], O.fog, J);
        else
          _t(J.material, O.fog, J);
    });
  };
  var mt = null;
  function Rt() {
    gr.isPresenting() || mt && mt();
  }
  var ht = new Gd();
  ht.setAnimationLoop(Rt), ht.setContext(window), this.setAnimationLoop = function(O) {
    mt = O, gr.setAnimationLoop(O), ht.start();
  }, this.render = function(O, W, J, ge) {
    if (!(W && W.isCamera)) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (!d) {
      E = "", x = -1, M = null, O.autoUpdate === !0 && O.updateMatrixWorld(), W.parent === null && W.updateMatrixWorld(), gr.enabled && (W = gr.getCamera(W)), h = yt.get(O, W), h.init(), O.onBeforeRender(f, O, W, J), se.multiplyMatrices(W.projectionMatrix, W.matrixWorldInverse), he.setFromMatrix(se), G = this.localClippingEnabled, V = fe.init(this.clippingPlanes, G, W), c = Ht.get(O, W), c.init(), Ct(O, W, f.sortObjects), f.sortObjects === !0 && c.sort(), V && fe.beginShadows();
      var Me = h.state.shadowsArray;
      ar.render(Me, O, W), h.setupLights(W), V && fe.endShadows(), this.info.autoReset && this.info.reset(), J === void 0 && (J = null), this.setRenderTarget(J), Gt.render(c, O, W, ge);
      var We = c.opaque, Ke = c.transparent;
      if (O.overrideMaterial) {
        var we = O.overrideMaterial;
        We.length && Lt(We, O, W, we), Ke.length && Lt(Ke, O, W, we);
      } else
        We.length && Lt(We, O, W), Ke.length && Lt(Ke, O, W);
      var et = h.state.spritesArray;
      cr.render(et, O, W), J && dt.updateRenderTargetMipmap(J), _e.buffers.depth.setTest(!0), _e.buffers.depth.setMask(!0), _e.buffers.color.setMask(!0), _e.setPolygonOffset(!1), O.onAfterRender(f, O, W), gr.enabled && gr.submitFrame(), c = null, h = null;
    }
  };
  function Ct(O, W, J) {
    if (O.visible !== !1) {
      var ge = O.layers.test(W.layers);
      if (ge) {
        if (O.isLight)
          h.pushLight(O), O.castShadow && h.pushShadow(O);
        else if (O.isSprite)
          (!O.frustumCulled || he.intersectsSprite(O)) && h.pushSprite(O);
        else if (O.isImmediateRenderObject)
          J && re.setFromMatrixPosition(O.matrixWorld).applyMatrix4(se), c.push(O, null, O.material, re.z, null);
        else if ((O.isMesh || O.isLine || O.isPoints) && (O.isSkinnedMesh && O.skeleton.update(), !O.frustumCulled || he.intersectsObject(O))) {
          J && re.setFromMatrixPosition(O.matrixWorld).applyMatrix4(se);
          var Me = Bt.update(O), We = O.material;
          if (Array.isArray(We))
            for (var Ke = Me.groups, we = 0, et = Ke.length; we < et; we++) {
              var nt = Ke[we], rt = We[nt.materialIndex];
              rt && rt.visible && c.push(O, Me, rt, re.z, nt);
            }
          else We.visible && c.push(O, Me, We, re.z, null);
        }
      }
      for (var Tt = O.children, we = 0, et = Tt.length; we < et; we++)
        Ct(Tt[we], W, J);
    }
  }
  function Lt(O, W, J, ge) {
    for (var Me = 0, We = O.length; Me < We; Me++) {
      var Ke = O[Me], we = Ke.object, et = Ke.geometry, nt = ge === void 0 ? Ke.material : ge, rt = Ke.group;
      if (J.isArrayCamera) {
        C = J;
        for (var Tt = J.cameras, Qe = 0, Dt = Tt.length; Qe < Dt; Qe++) {
          var bt = Tt[Qe];
          if (we.layers.test(bt.layers)) {
            if ("viewport" in bt)
              _e.viewport(R.copy(bt.viewport));
            else {
              var Jt = bt.bounds, hr = Jt.x * I, Nr = Jt.y * H, Cr = Jt.z * I, sn = Jt.w * H;
              _e.viewport(R.set(hr, Nr, Cr, sn).multiplyScalar(Q));
            }
            wt(we, W, bt, et, nt, rt);
          }
        }
      } else
        C = null, wt(we, W, J, et, nt, rt);
    }
  }
  function wt(O, W, J, ge, Me, We) {
    if (O.onBeforeRender(f, W, J, ge, Me, We), h = yt.get(W, C || J), O.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse, O.matrixWorld), O.normalMatrix.getNormalMatrix(O.modelViewMatrix), O.isImmediateRenderObject) {
      var Ke = O.isMesh && O.matrixWorld.determinant() < 0;
      _e.setMaterial(Me, Ke);
      var we = Fi(J, W.fog, Me, O);
      E = "", st(O, we, Me);
    } else
      f.renderBufferDirect(J, W.fog, ge, Me, O, We);
    O.onAfterRender(f, W, J, ge, Me, We), h = yt.get(W, C || J);
  }
  function _t(O, W, J) {
    var ge = He.get(O), Me = h.state.lights, We = h.state.shadowsArray, Ke = Mt.getParameters(
      O,
      Me.state,
      We,
      W,
      fe.numPlanes,
      fe.numIntersection,
      J
    ), we = Mt.getProgramCode(O, Ke), et = ge.program, nt = !0;
    if (et === void 0)
      O.addEventListener("dispose", Ie);
    else if (et.code !== we)
      Fe(O);
    else if (ge.lightsHash !== Me.state.hash)
      He.update(O, "lightsHash", Me.state.hash), nt = !1;
    else {
      if (Ke.shaderID !== void 0)
        return;
      nt = !1;
    }
    if (nt) {
      if (Ke.shaderID) {
        var rt = Na[Ke.shaderID];
        ge.shader = {
          name: O.type,
          uniforms: si.clone(rt.uniforms),
          vertexShader: rt.vertexShader,
          fragmentShader: rt.fragmentShader
        };
      } else
        ge.shader = {
          name: O.type,
          uniforms: O.uniforms,
          vertexShader: O.vertexShader,
          fragmentShader: O.fragmentShader
        };
      O.onBeforeCompile(ge.shader, f), et = Mt.acquireProgram(O, ge.shader, Ke, we), ge.program = et, O.program = et;
    }
    var Tt = et.getAttributes();
    if (O.morphTargets) {
      O.numSupportedMorphTargets = 0;
      for (var Qe = 0; Qe < f.maxMorphTargets; Qe++)
        Tt["morphTarget" + Qe] >= 0 && O.numSupportedMorphTargets++;
    }
    if (O.morphNormals) {
      O.numSupportedMorphNormals = 0;
      for (var Qe = 0; Qe < f.maxMorphNormals; Qe++)
        Tt["morphNormal" + Qe] >= 0 && O.numSupportedMorphNormals++;
    }
    var Dt = ge.shader.uniforms;
    (!O.isShaderMaterial && !O.isRawShaderMaterial || O.clipping === !0) && (ge.numClippingPlanes = fe.numPlanes, ge.numIntersection = fe.numIntersection, Dt.clippingPlanes = fe.uniform), ge.fog = W, ge.lightsHash = Me.state.hash, O.lights && (Dt.ambientLightColor.value = Me.state.ambient, Dt.directionalLights.value = Me.state.directional, Dt.spotLights.value = Me.state.spot, Dt.rectAreaLights.value = Me.state.rectArea, Dt.pointLights.value = Me.state.point, Dt.hemisphereLights.value = Me.state.hemi, Dt.directionalShadowMap.value = Me.state.directionalShadowMap, Dt.directionalShadowMatrix.value = Me.state.directionalShadowMatrix, Dt.spotShadowMap.value = Me.state.spotShadowMap, Dt.spotShadowMatrix.value = Me.state.spotShadowMatrix, Dt.pointShadowMap.value = Me.state.pointShadowMap, Dt.pointShadowMatrix.value = Me.state.pointShadowMatrix);
    var bt = ge.program.getUniforms(), Jt = ua.seqWithValue(bt.seq, Dt);
    ge.uniformsList = Jt;
  }
  function Fi(O, W, J, ge) {
    F = 0;
    var Me = He.get(J), We = h.state.lights;
    if (V && (G || O !== M)) {
      var Ke = O === M && J.id === x;
      fe.setState(
        J.clippingPlanes,
        J.clipIntersection,
        J.clipShadows,
        O,
        Me,
        Ke
      );
    }
    J.needsUpdate === !1 && (Me.program === void 0 || J.fog && Me.fog !== W || J.lights && Me.lightsHash !== We.state.hash || Me.numClippingPlanes !== void 0 && (Me.numClippingPlanes !== fe.numPlanes || Me.numIntersection !== fe.numIntersection)) && (J.needsUpdate = !0), J.needsUpdate && (_t(J, W, ge), J.needsUpdate = !1);
    var we = !1, et = !1, nt = !1, rt = Me.program, Tt = rt.getUniforms(), Qe = Me.shader.uniforms;
    if (_e.useProgram(rt.program) && (we = !0, et = !0, nt = !0), J.id !== x && (x = J.id, et = !0), we || O !== M) {
      if (Tt.setValue(K, "projectionMatrix", O.projectionMatrix), Re.logarithmicDepthBuffer && Tt.setValue(
        K,
        "logDepthBufFC",
        2 / (Math.log(O.far + 1) / Math.LN2)
      ), M !== (C || O) && (M = C || O, et = !0, nt = !0), J.isShaderMaterial || J.isMeshPhongMaterial || J.isMeshStandardMaterial || J.envMap) {
        var Dt = Tt.map.cameraPosition;
        Dt !== void 0 && Dt.setValue(
          K,
          re.setFromMatrixPosition(O.matrixWorld)
        );
      }
      (J.isMeshPhongMaterial || J.isMeshLambertMaterial || J.isMeshBasicMaterial || J.isMeshStandardMaterial || J.isShaderMaterial || J.skinning) && Tt.setValue(K, "viewMatrix", O.matrixWorldInverse);
    }
    if (J.skinning) {
      Tt.setOptional(K, ge, "bindMatrix"), Tt.setOptional(K, ge, "bindMatrixInverse");
      var bt = ge.skeleton;
      if (bt) {
        var Jt = bt.bones;
        if (Re.floatVertexTextures) {
          if (bt.boneTexture === void 0) {
            var hr = Math.sqrt(Jt.length * 4);
            hr = gt.ceilPowerOfTwo(hr), hr = Math.max(hr, 4);
            var Nr = new Float32Array(hr * hr * 4);
            Nr.set(bt.boneMatrices);
            var Cr = new Xa(Nr, hr, hr, yn, Us);
            Cr.needsUpdate = !0, bt.boneMatrices = Nr, bt.boneTexture = Cr, bt.boneTextureSize = hr;
          }
          Tt.setValue(K, "boneTexture", bt.boneTexture), Tt.setValue(K, "boneTextureSize", bt.boneTextureSize);
        } else
          Tt.setOptional(K, bt, "boneMatrices");
      }
    }
    return et && (Tt.setValue(K, "toneMappingExposure", f.toneMappingExposure), Tt.setValue(K, "toneMappingWhitePoint", f.toneMappingWhitePoint), J.lights && Sn(Qe, nt), W && J.fog && an(Qe, W), J.isMeshBasicMaterial ? ni(Qe, J) : J.isMeshLambertMaterial ? (ni(Qe, J), ia(Qe, J)) : J.isMeshPhongMaterial ? (ni(Qe, J), J.isMeshToonMaterial ? zo(Qe, J) : ki(Qe, J)) : J.isMeshStandardMaterial ? (ni(Qe, J), J.isMeshPhysicalMaterial ? _i(Qe, J) : _s(Qe, J)) : J.isMeshDepthMaterial ? (ni(Qe, J), Or(Qe, J)) : J.isMeshDistanceMaterial ? (ni(Qe, J), wn(Qe, J)) : J.isMeshNormalMaterial ? (ni(Qe, J), Ni(Qe, J)) : J.isLineBasicMaterial ? (ra(Qe, J), J.isLineDashedMaterial && xr(Qe, J)) : J.isPointsMaterial ? Xt(Qe, J) : J.isShadowMaterial && (Qe.color.value = J.color, Qe.opacity.value = J.opacity), Qe.ltc_1 !== void 0 && (Qe.ltc_1.value = Xe.LTC_1), Qe.ltc_2 !== void 0 && (Qe.ltc_2.value = Xe.LTC_2), ua.upload(K, Me.uniformsList, Qe, f)), J.isShaderMaterial && J.uniformsNeedUpdate === !0 && (ua.upload(K, Me.uniformsList, Qe, f), J.uniformsNeedUpdate = !1), Tt.setValue(K, "modelViewMatrix", ge.modelViewMatrix), Tt.setValue(K, "normalMatrix", ge.normalMatrix), Tt.setValue(K, "modelMatrix", ge.matrixWorld), rt;
  }
  function ni(O, W) {
    O.opacity.value = W.opacity, W.color && (O.diffuse.value = W.color), W.emissive && O.emissive.value.copy(W.emissive).multiplyScalar(W.emissiveIntensity), W.map && (O.map.value = W.map), W.alphaMap && (O.alphaMap.value = W.alphaMap), W.specularMap && (O.specularMap.value = W.specularMap), W.envMap && (O.envMap.value = W.envMap, O.flipEnvMap.value = W.envMap && W.envMap.isCubeTexture ? -1 : 1, O.reflectivity.value = W.reflectivity, O.refractionRatio.value = W.refractionRatio, O.maxMipLevel.value = He.get(W.envMap).__maxMipLevel), W.lightMap && (O.lightMap.value = W.lightMap, O.lightMapIntensity.value = W.lightMapIntensity), W.aoMap && (O.aoMap.value = W.aoMap, O.aoMapIntensity.value = W.aoMapIntensity);
    var J;
    W.map ? J = W.map : W.specularMap ? J = W.specularMap : W.displacementMap ? J = W.displacementMap : W.normalMap ? J = W.normalMap : W.bumpMap ? J = W.bumpMap : W.roughnessMap ? J = W.roughnessMap : W.metalnessMap ? J = W.metalnessMap : W.alphaMap ? J = W.alphaMap : W.emissiveMap && (J = W.emissiveMap), J !== void 0 && (J.isWebGLRenderTarget && (J = J.texture), J.matrixAutoUpdate === !0 && J.updateMatrix(), O.uvTransform.value.copy(J.matrix));
  }
  function ra(O, W) {
    O.diffuse.value = W.color, O.opacity.value = W.opacity;
  }
  function xr(O, W) {
    O.dashSize.value = W.dashSize, O.totalSize.value = W.dashSize + W.gapSize, O.scale.value = W.scale;
  }
  function Xt(O, W) {
    O.diffuse.value = W.color, O.opacity.value = W.opacity, O.size.value = W.size * Q, O.scale.value = H * 0.5, O.map.value = W.map, W.map !== null && (W.map.matrixAutoUpdate === !0 && W.map.updateMatrix(), O.uvTransform.value.copy(W.map.matrix));
  }
  function an(O, W) {
    O.fogColor.value = W.color, W.isFog ? (O.fogNear.value = W.near, O.fogFar.value = W.far) : W.isFogExp2 && (O.fogDensity.value = W.density);
  }
  function ia(O, W) {
    W.emissiveMap && (O.emissiveMap.value = W.emissiveMap);
  }
  function ki(O, W) {
    O.specular.value = W.specular, O.shininess.value = Math.max(W.shininess, 1e-4), W.emissiveMap && (O.emissiveMap.value = W.emissiveMap), W.bumpMap && (O.bumpMap.value = W.bumpMap, O.bumpScale.value = W.bumpScale, W.side === Tr && (O.bumpScale.value *= -1)), W.normalMap && (O.normalMap.value = W.normalMap, O.normalScale.value.copy(W.normalScale), W.side === Tr && O.normalScale.value.negate()), W.displacementMap && (O.displacementMap.value = W.displacementMap, O.displacementScale.value = W.displacementScale, O.displacementBias.value = W.displacementBias);
  }
  function zo(O, W) {
    ki(O, W), W.gradientMap && (O.gradientMap.value = W.gradientMap);
  }
  function _s(O, W) {
    O.roughness.value = W.roughness, O.metalness.value = W.metalness, W.roughnessMap && (O.roughnessMap.value = W.roughnessMap), W.metalnessMap && (O.metalnessMap.value = W.metalnessMap), W.emissiveMap && (O.emissiveMap.value = W.emissiveMap), W.bumpMap && (O.bumpMap.value = W.bumpMap, O.bumpScale.value = W.bumpScale, W.side === Tr && (O.bumpScale.value *= -1)), W.normalMap && (O.normalMap.value = W.normalMap, O.normalScale.value.copy(W.normalScale), W.side === Tr && O.normalScale.value.negate()), W.displacementMap && (O.displacementMap.value = W.displacementMap, O.displacementScale.value = W.displacementScale, O.displacementBias.value = W.displacementBias), W.envMap && (O.envMapIntensity.value = W.envMapIntensity);
  }
  function _i(O, W) {
    O.clearCoat.value = W.clearCoat, O.clearCoatRoughness.value = W.clearCoatRoughness, _s(O, W);
  }
  function Or(O, W) {
    W.displacementMap && (O.displacementMap.value = W.displacementMap, O.displacementScale.value = W.displacementScale, O.displacementBias.value = W.displacementBias);
  }
  function wn(O, W) {
    W.displacementMap && (O.displacementMap.value = W.displacementMap, O.displacementScale.value = W.displacementScale, O.displacementBias.value = W.displacementBias), O.referencePosition.value.copy(W.referencePosition), O.nearDistance.value = W.nearDistance, O.farDistance.value = W.farDistance;
  }
  function Ni(O, W) {
    W.bumpMap && (O.bumpMap.value = W.bumpMap, O.bumpScale.value = W.bumpScale, W.side === Tr && (O.bumpScale.value *= -1)), W.normalMap && (O.normalMap.value = W.normalMap, O.normalScale.value.copy(W.normalScale), W.side === Tr && O.normalScale.value.negate()), W.displacementMap && (O.displacementMap.value = W.displacementMap, O.displacementScale.value = W.displacementScale, O.displacementBias.value = W.displacementBias);
  }
  function Sn(O, W) {
    O.ambientLightColor.needsUpdate = W, O.directionalLights.needsUpdate = W, O.pointLights.needsUpdate = W, O.spotLights.needsUpdate = W, O.rectAreaLights.needsUpdate = W, O.hemisphereLights.needsUpdate = W;
  }
  function Zt() {
    var O = F;
    return O >= Re.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + O + " texture units while this GPU supports only " + Re.maxTextures), F += 1, O;
  }
  this.allocTextureUnit = Zt, this.setTexture2D = /* @__PURE__ */ function() {
    var O = !1;
    return function(J, ge) {
      J && J.isWebGLRenderTarget && (O || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), O = !0), J = J.texture), dt.setTexture2D(J, ge);
    };
  }(), this.setTexture = /* @__PURE__ */ function() {
    var O = !1;
    return function(J, ge) {
      O || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), O = !0), dt.setTexture2D(J, ge);
    };
  }(), this.setTextureCube = /* @__PURE__ */ function() {
    var O = !1;
    return function(J, ge) {
      J && J.isWebGLRenderTargetCube && (O || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), O = !0), J = J.texture), J && J.isCubeTexture || Array.isArray(J.image) && J.image.length === 6 ? dt.setTextureCube(J, ge) : dt.setTextureCubeDynamic(J, ge);
    };
  }(), this.setFramebuffer = function(O) {
    p = O;
  }, this.getRenderTarget = function() {
    return _;
  }, this.setRenderTarget = function(O) {
    _ = O, O && He.get(O).__webglFramebuffer === void 0 && dt.setupRenderTarget(O);
    var W = p, J = !1;
    if (O) {
      var ge = He.get(O).__webglFramebuffer;
      O.isWebGLRenderTargetCube ? (W = ge[O.activeCubeFace], J = !0) : W = ge, R.copy(O.viewport), B.copy(O.scissor), k = O.scissorTest;
    } else
      R.copy(ee).multiplyScalar(Q), B.copy(oe).multiplyScalar(Q), k = de;
    if (v !== W && (K.bindFramebuffer(K.FRAMEBUFFER, W), v = W), _e.viewport(R), _e.scissor(B), _e.setScissorTest(k), J) {
      var Me = He.get(O.texture);
      K.framebufferTexture2D(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, K.TEXTURE_CUBE_MAP_POSITIVE_X + O.activeCubeFace, Me.__webglTexture, O.activeMipMapLevel);
    }
  }, this.readRenderTargetPixels = function(O, W, J, ge, Me, We) {
    if (!(O && O.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    var Ke = He.get(O).__webglFramebuffer;
    if (Ke) {
      var we = !1;
      Ke !== v && (K.bindFramebuffer(K.FRAMEBUFFER, Ke), we = !0);
      try {
        var et = O.texture, nt = et.format, rt = et.type;
        if (nt !== yn && Vt.convert(nt) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_FORMAT)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (rt !== fh && Vt.convert(rt) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(rt === Us && (pe.get("OES_texture_float") || pe.get("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !(rt === dh && pe.get("EXT_color_buffer_half_float"))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        K.checkFramebufferStatus(K.FRAMEBUFFER) === K.FRAMEBUFFER_COMPLETE ? W >= 0 && W <= O.width - ge && J >= 0 && J <= O.height - Me && K.readPixels(W, J, ge, Me, Vt.convert(nt), Vt.convert(rt), We) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        we && K.bindFramebuffer(K.FRAMEBUFFER, v);
      }
    }
  }, this.copyFramebufferToTexture = function(O, W, J) {
    var ge = W.image.width, Me = W.image.height, We = Vt.convert(W.format);
    this.setTexture2D(W, 0), K.copyTexImage2D(K.TEXTURE_2D, J || 0, We, O.x, O.y, ge, Me, 0);
  }, this.copyTextureToTexture = function(O, W, J, ge) {
    var Me = W.image.width, We = W.image.height, Ke = Vt.convert(J.format), we = Vt.convert(J.type);
    this.setTexture2D(J, 0), W.isDataTexture ? K.texSubImage2D(K.TEXTURE_2D, ge || 0, O.x, O.y, Me, We, Ke, we, W.image.data) : K.texSubImage2D(K.TEXTURE_2D, ge || 0, O.x, O.y, Ke, we, W.image);
  };
}
function Ws(e, t) {
  this.name = "", this.color = new je(e), this.density = t !== void 0 ? t : 25e-5;
}
Ws.prototype.isFogExp2 = !0;
Ws.prototype.clone = function() {
  return new Ws(this.color, this.density);
};
Ws.prototype.toJSON = function() {
  return {
    type: "FogExp2",
    color: this.color.getHex(),
    density: this.density
  };
};
function js(e, t, r) {
  this.name = "", this.color = new je(e), this.near = t !== void 0 ? t : 1, this.far = r !== void 0 ? r : 1e3;
}
js.prototype.isFog = !0;
js.prototype.clone = function() {
  return new js(this.color, this.near, this.far);
};
js.prototype.toJSON = function() {
  return {
    type: "Fog",
    color: this.color.getHex(),
    near: this.near,
    far: this.far
  };
};
function Cu() {
  ke.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0;
}
Cu.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: Cu,
  copy: function(e, t) {
    return ke.prototype.copy.call(this, e, t), e.background !== null && (this.background = e.background.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  },
  toJSON: function(e) {
    var t = ke.prototype.toJSON.call(this, e);
    return this.background !== null && (t.object.background = this.background.toJSON(e)), this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  }
});
function pa(e) {
  ft.call(this), this.type = "SpriteMaterial", this.color = new je(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(e);
}
pa.prototype = Object.create(ft.prototype);
pa.prototype.constructor = pa;
pa.prototype.isSpriteMaterial = !0;
pa.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this;
};
function Mu(e) {
  ke.call(this), this.type = "Sprite", this.material = e !== void 0 ? e : new pa(), this.center = new ue(0.5, 0.5);
}
Mu.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: Mu,
  isSprite: !0,
  raycast: function() {
    var e = new z(), t = new z(), r = new z();
    return function(i, a) {
      t.setFromMatrixPosition(this.matrixWorld), i.ray.closestPointToPoint(t, e), r.setFromMatrixScale(this.matrixWorld);
      var s = r.x * r.y / 4;
      if (!(t.distanceToSquared(e) > s)) {
        var o = i.ray.origin.distanceTo(e);
        o < i.near || o > i.far || a.push({
          distance: o,
          point: e.clone(),
          face: null,
          object: this
        });
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.material).copy(this);
  },
  copy: function(e) {
    return ke.prototype.copy.call(this, e), e.center !== void 0 && this.center.copy(e.center), this;
  }
});
function Du() {
  ke.call(this), this.type = "LOD", Object.defineProperties(this, {
    levels: {
      enumerable: !0,
      value: []
    }
  });
}
Du.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: Du,
  copy: function(e) {
    ke.prototype.copy.call(this, e, !1);
    for (var t = e.levels, r = 0, n = t.length; r < n; r++) {
      var i = t[r];
      this.addLevel(i.object.clone(), i.distance);
    }
    return this;
  },
  addLevel: function(e, t) {
    t === void 0 && (t = 0), t = Math.abs(t);
    for (var r = this.levels, n = 0; n < r.length && !(t < r[n].distance); n++)
      ;
    r.splice(n, 0, { distance: t, object: e }), this.add(e);
  },
  getObjectForDistance: function(e) {
    for (var t = this.levels, r = 1, n = t.length; r < n && !(e < t[r].distance); r++)
      ;
    return t[r - 1].object;
  },
  raycast: function() {
    var e = new z();
    return function(r, n) {
      e.setFromMatrixPosition(this.matrixWorld);
      var i = r.ray.origin.distanceTo(e);
      this.getObjectForDistance(i).raycast(r, n);
    };
  }(),
  update: function() {
    var e = new z(), t = new z();
    return function(n) {
      var i = this.levels;
      if (i.length > 1) {
        e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
        var a = e.distanceTo(t);
        i[0].object.visible = !0;
        for (var s = 1, o = i.length; s < o && a >= i[s].distance; s++)
          i[s - 1].object.visible = !1, i[s].object.visible = !0;
        for (; s < o; s++)
          i[s].object.visible = !1;
      }
    };
  }(),
  toJSON: function(e) {
    var t = ke.prototype.toJSON.call(this, e);
    t.object.levels = [];
    for (var r = this.levels, n = 0, i = r.length; n < i; n++) {
      var a = r[n];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance
      });
    }
    return t;
  }
});
function Pu(e, t) {
  if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(this.bones.length * 16), t === void 0)
    this.calculateInverses();
  else if (this.bones.length === t.length)
    this.boneInverses = t.slice(0);
  else {
    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
    for (var r = 0, n = this.bones.length; r < n; r++)
      this.boneInverses.push(new at());
  }
}
Object.assign(Pu.prototype, {
  calculateInverses: function() {
    this.boneInverses = [];
    for (var e = 0, t = this.bones.length; e < t; e++) {
      var r = new at();
      this.bones[e] && r.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(r);
    }
  },
  pose: function() {
    var e, t, r;
    for (t = 0, r = this.bones.length; t < r; t++)
      e = this.bones[t], e && e.matrixWorld.getInverse(this.boneInverses[t]);
    for (t = 0, r = this.bones.length; t < r; t++)
      e = this.bones[t], e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale));
  },
  update: function() {
    var e = new at(), t = new at();
    return function() {
      for (var n = this.bones, i = this.boneInverses, a = this.boneMatrices, s = this.boneTexture, o = 0, u = n.length; o < u; o++) {
        var l = n[o] ? n[o].matrixWorld : t;
        e.multiplyMatrices(l, i[o]), e.toArray(a, o * 16);
      }
      s !== void 0 && (s.needsUpdate = !0);
    };
  }(),
  clone: function() {
    return new Pu(this.bones, this.boneInverses);
  },
  getBoneByName: function(e) {
    for (var t = 0, r = this.bones.length; t < r; t++) {
      var n = this.bones[t];
      if (n.name === e)
        return n;
    }
  }
});
function cc() {
  ke.call(this), this.type = "Bone";
}
cc.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: cc,
  isBone: !0
});
function hc(e, t) {
  dr.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new at(), this.bindMatrixInverse = new at();
  var r = this.initBones(), n = new Pu(r);
  this.bind(n, this.matrixWorld), this.normalizeSkinWeights();
}
hc.prototype = Object.assign(Object.create(dr.prototype), {
  constructor: hc,
  isSkinnedMesh: !0,
  initBones: function() {
    var e = [], t, r, n, i;
    if (this.geometry && this.geometry.bones !== void 0) {
      for (n = 0, i = this.geometry.bones.length; n < i; n++)
        r = this.geometry.bones[n], t = new cc(), e.push(t), t.name = r.name, t.position.fromArray(r.pos), t.quaternion.fromArray(r.rotq), r.scl !== void 0 && t.scale.fromArray(r.scl);
      for (n = 0, i = this.geometry.bones.length; n < i; n++)
        r = this.geometry.bones[n], r.parent !== -1 && r.parent !== null && e[r.parent] !== void 0 ? e[r.parent].add(e[n]) : this.add(e[n]);
    }
    return this.updateMatrixWorld(!0), e;
  },
  bind: function(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t);
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    var e, t;
    if (this.geometry && this.geometry.isGeometry)
      for (t = 0; t < this.geometry.skinWeights.length; t++) {
        var r = this.geometry.skinWeights[t];
        e = 1 / r.manhattanLength(), e !== 1 / 0 ? r.multiplyScalar(e) : r.set(1, 0, 0, 0);
      }
    else if (this.geometry && this.geometry.isBufferGeometry) {
      var n = new kt(), i = this.geometry.attributes.skinWeight;
      for (t = 0; t < i.count; t++)
        n.x = i.getX(t), n.y = i.getY(t), n.z = i.getZ(t), n.w = i.getW(t), e = 1 / n.manhattanLength(), e !== 1 / 0 ? n.multiplyScalar(e) : n.set(1, 0, 0, 0), i.setXYZW(t, n.x, n.y, n.z, n.w);
    }
  },
  updateMatrixWorld: function(e) {
    dr.prototype.updateMatrixWorld.call(this, e), this.bindMode === "attached" ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === "detached" ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  },
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function qt(e) {
  ft.call(this), this.type = "LineBasicMaterial", this.color = new je(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e);
}
qt.prototype = Object.create(ft.prototype);
qt.prototype.constructor = qt;
qt.prototype.isLineBasicMaterial = !0;
qt.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this;
};
function hi(e, t, r) {
  if (r === 1)
    return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new Yt(e, t);
  ke.call(this), this.type = "Line", this.geometry = e !== void 0 ? e : new Ge(), this.material = t !== void 0 ? t : new qt({ color: Math.random() * 16777215 });
}
hi.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: hi,
  isLine: !0,
  computeLineDistances: function() {
    var e = new z(), t = new z();
    return function() {
      var n = this.geometry;
      if (n.isBufferGeometry)
        if (n.index === null) {
          for (var i = n.attributes.position, a = [0], s = 1, o = i.count; s < o; s++)
            e.fromBufferAttribute(i, s - 1), t.fromBufferAttribute(i, s), a[s] = a[s - 1], a[s] += e.distanceTo(t);
          n.addAttribute("lineDistance", new Be(a, 1));
        } else
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else if (n.isGeometry) {
        var u = n.vertices, a = n.lineDistances;
        a[0] = 0;
        for (var s = 1, o = u.length; s < o; s++)
          a[s] = a[s - 1], a[s] += u[s - 1].distanceTo(u[s]);
      }
      return this;
    };
  }(),
  raycast: function() {
    var e = new at(), t = new ms(), r = new qi();
    return function(i, a) {
      var s = i.linePrecision, o = s * s, u = this.geometry, l = this.matrixWorld;
      if (u.boundingSphere === null && u.computeBoundingSphere(), r.copy(u.boundingSphere), r.applyMatrix4(l), i.ray.intersectsSphere(r) !== !1) {
        e.getInverse(l), t.copy(i.ray).applyMatrix4(e);
        var c = new z(), h = new z(), f = new z(), d = new z(), p = this && this.isLineSegments ? 2 : 1;
        if (u.isBufferGeometry) {
          var _ = u.index, v = u.attributes, x = v.position.array;
          if (_ !== null)
            for (var E = _.array, M = 0, C = E.length - 1; M < C; M += p) {
              var R = E[M], B = E[M + 1];
              c.fromArray(x, R * 3), h.fromArray(x, B * 3);
              var k = t.distanceSqToSegment(c, h, d, f);
              if (!(k > o)) {
                d.applyMatrix4(this.matrixWorld);
                var F = i.ray.origin.distanceTo(d);
                F < i.near || F > i.far || a.push({
                  distance: F,
                  // What do we want? intersection point on the ray or on the segment??
                  // point: raycaster.ray.at( distance ),
                  point: f.clone().applyMatrix4(this.matrixWorld),
                  index: M,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
          else
            for (var M = 0, C = x.length / 3 - 1; M < C; M += p) {
              c.fromArray(x, 3 * M), h.fromArray(x, 3 * M + 3);
              var k = t.distanceSqToSegment(c, h, d, f);
              if (!(k > o)) {
                d.applyMatrix4(this.matrixWorld);
                var F = i.ray.origin.distanceTo(d);
                F < i.near || F > i.far || a.push({
                  distance: F,
                  // What do we want? intersection point on the ray or on the segment??
                  // point: raycaster.ray.at( distance ),
                  point: f.clone().applyMatrix4(this.matrixWorld),
                  index: M,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
        } else if (u.isGeometry)
          for (var I = u.vertices, H = I.length, M = 0; M < H - 1; M += p) {
            var k = t.distanceSqToSegment(I[M], I[M + 1], d, f);
            if (!(k > o)) {
              d.applyMatrix4(this.matrixWorld);
              var F = i.ray.origin.distanceTo(d);
              F < i.near || F > i.far || a.push({
                distance: F,
                // What do we want? intersection point on the ray or on the segment??
                // point: raycaster.ray.at( distance ),
                point: f.clone().applyMatrix4(this.matrixWorld),
                index: M,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function Yt(e, t) {
  hi.call(this, e, t), this.type = "LineSegments";
}
Yt.prototype = Object.assign(Object.create(hi.prototype), {
  constructor: Yt,
  isLineSegments: !0,
  computeLineDistances: function() {
    var e = new z(), t = new z();
    return function() {
      var n = this.geometry;
      if (n.isBufferGeometry)
        if (n.index === null) {
          for (var i = n.attributes.position, a = [], s = 0, o = i.count; s < o; s += 2)
            e.fromBufferAttribute(i, s), t.fromBufferAttribute(i, s + 1), a[s] = s === 0 ? 0 : a[s - 1], a[s + 1] = a[s] + e.distanceTo(t);
          n.addAttribute("lineDistance", new Be(a, 1));
        } else
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else if (n.isGeometry)
        for (var u = n.vertices, a = n.lineDistances, s = 0, o = u.length; s < o; s += 2)
          e.copy(u[s]), t.copy(u[s + 1]), a[s] = s === 0 ? 0 : a[s - 1], a[s + 1] = a[s] + e.distanceTo(t);
      return this;
    };
  }()
});
function fc(e, t) {
  hi.call(this, e, t), this.type = "LineLoop";
}
fc.prototype = Object.assign(Object.create(hi.prototype), {
  constructor: fc,
  isLineLoop: !0
});
function Xi(e) {
  ft.call(this), this.type = "PointsMaterial", this.color = new je(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(e);
}
Xi.prototype = Object.create(ft.prototype);
Xi.prototype.constructor = Xi;
Xi.prototype.isPointsMaterial = !0;
Xi.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this;
};
function qs(e, t) {
  ke.call(this), this.type = "Points", this.geometry = e !== void 0 ? e : new Ge(), this.material = t !== void 0 ? t : new Xi({ color: Math.random() * 16777215 });
}
qs.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: qs,
  isPoints: !0,
  raycast: function() {
    var e = new at(), t = new ms(), r = new qi();
    return function(i, a) {
      var s = this, o = this.geometry, u = this.matrixWorld, l = i.params.Points.threshold;
      if (o.boundingSphere === null && o.computeBoundingSphere(), r.copy(o.boundingSphere), r.applyMatrix4(u), r.radius += l, i.ray.intersectsSphere(r) === !1) return;
      e.getInverse(u), t.copy(i.ray).applyMatrix4(e);
      var c = l / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = c * c, f = new z(), d = new z();
      function p(F, I) {
        var H = t.distanceSqToPoint(F);
        if (H < h) {
          t.closestPointToPoint(F, d), d.applyMatrix4(u);
          var Q = i.ray.origin.distanceTo(d);
          if (Q < i.near || Q > i.far) return;
          a.push({
            distance: Q,
            distanceToRay: Math.sqrt(H),
            point: d.clone(),
            index: I,
            face: null,
            object: s
          });
        }
      }
      if (o.isBufferGeometry) {
        var _ = o.index, v = o.attributes, x = v.position.array;
        if (_ !== null)
          for (var E = _.array, M = 0, C = E.length; M < C; M++) {
            var R = E[M];
            f.fromArray(x, R * 3), p(f, R);
          }
        else
          for (var M = 0, B = x.length / 3; M < B; M++)
            f.fromArray(x, M * 3), p(f, M);
      } else
        for (var k = o.vertices, M = 0, B = k.length; M < B; M++)
          p(k[M], M);
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function dc() {
  ke.call(this), this.type = "Group";
}
dc.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: dc,
  isGroup: !0
});
function pc(e, t, r, n, i, a, s, o, u) {
  ir.call(this, e, t, r, n, i, a, s, o, u), this.generateMipmaps = !1;
}
pc.prototype = Object.assign(Object.create(ir.prototype), {
  constructor: pc,
  isVideoTexture: !0,
  update: function() {
    var e = this.image;
    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
});
function Xs(e, t, r, n, i, a, s, o, u, l, c, h) {
  ir.call(this, null, a, s, o, u, l, n, i, c, h), this.image = { width: t, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
}
Xs.prototype = Object.create(ir.prototype);
Xs.prototype.constructor = Xs;
Xs.prototype.isCompressedTexture = !0;
function Lu(e, t, r, n, i, a, s, o, u, l) {
  if (l = l !== void 0 ? l : ka, l !== ka && l !== Gs)
    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  r === void 0 && l === ka && (r = pu), r === void 0 && l === Gs && (r = mu), ir.call(this, null, n, i, a, s, o, l, r, u), this.image = { width: e, height: t }, this.magFilter = s !== void 0 ? s : wi, this.minFilter = o !== void 0 ? o : wi, this.flipY = !1, this.generateMipmaps = !1;
}
Lu.prototype = Object.create(ir.prototype);
Lu.prototype.constructor = Lu;
Lu.prototype.isDepthTexture = !0;
function Ys(e) {
  Ge.call(this), this.type = "WireframeGeometry";
  var t = [], r, n, i, a, s, o = [0, 0], u = {}, l, c, h, f, d = ["a", "b", "c"], p;
  if (e && e.isGeometry) {
    var _ = e.faces;
    for (r = 0, i = _.length; r < i; r++) {
      var v = _[r];
      for (n = 0; n < 3; n++)
        c = v[d[n]], h = v[d[(n + 1) % 3]], o[0] = Math.min(c, h), o[1] = Math.max(c, h), f = o[0] + "," + o[1], u[f] === void 0 && (u[f] = { index1: o[0], index2: o[1] });
    }
    for (f in u)
      l = u[f], p = e.vertices[l.index1], t.push(p.x, p.y, p.z), p = e.vertices[l.index2], t.push(p.x, p.y, p.z);
  } else if (e && e.isBufferGeometry) {
    var x, E, M, C, R, B, k, F;
    if (p = new z(), e.index !== null) {
      for (x = e.attributes.position, E = e.index, M = e.groups, M.length === 0 && (M = [{ start: 0, count: E.count, materialIndex: 0 }]), a = 0, s = M.length; a < s; ++a)
        for (C = M[a], R = C.start, B = C.count, r = R, i = R + B; r < i; r += 3)
          for (n = 0; n < 3; n++)
            c = E.getX(r + n), h = E.getX(r + (n + 1) % 3), o[0] = Math.min(c, h), o[1] = Math.max(c, h), f = o[0] + "," + o[1], u[f] === void 0 && (u[f] = { index1: o[0], index2: o[1] });
      for (f in u)
        l = u[f], p.fromBufferAttribute(x, l.index1), t.push(p.x, p.y, p.z), p.fromBufferAttribute(x, l.index2), t.push(p.x, p.y, p.z);
    } else
      for (x = e.attributes.position, r = 0, i = x.count / 3; r < i; r++)
        for (n = 0; n < 3; n++)
          k = 3 * r + n, p.fromBufferAttribute(x, k), t.push(p.x, p.y, p.z), F = 3 * r + (n + 1) % 3, p.fromBufferAttribute(x, F), t.push(p.x, p.y, p.z);
  }
  this.addAttribute("position", new Be(t, 3));
}
Ys.prototype = Object.create(Ge.prototype);
Ys.prototype.constructor = Ys;
function Ru(e, t, r) {
  tt.call(this), this.type = "ParametricGeometry", this.parameters = {
    func: e,
    slices: t,
    stacks: r
  }, this.fromBufferGeometry(new Qs(e, t, r)), this.mergeVertices();
}
Ru.prototype = Object.create(tt.prototype);
Ru.prototype.constructor = Ru;
function Qs(e, t, r) {
  Ge.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
    func: e,
    slices: t,
    stacks: r
  };
  var n = [], i = [], a = [], s = [], o = 1e-5, u = new z(), l = new z(), c = new z(), h = new z(), f = new z(), d, p;
  e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  var _ = t + 1;
  for (d = 0; d <= r; d++) {
    var v = d / r;
    for (p = 0; p <= t; p++) {
      var x = p / t;
      e(x, v, l), i.push(l.x, l.y, l.z), x - o >= 0 ? (e(x - o, v, c), h.subVectors(l, c)) : (e(x + o, v, c), h.subVectors(c, l)), v - o >= 0 ? (e(x, v - o, c), f.subVectors(l, c)) : (e(x, v + o, c), f.subVectors(c, l)), u.crossVectors(h, f).normalize(), a.push(u.x, u.y, u.z), s.push(x, v);
    }
  }
  for (d = 0; d < r; d++)
    for (p = 0; p < t; p++) {
      var E = d * _ + p, M = d * _ + p + 1, C = (d + 1) * _ + p + 1, R = (d + 1) * _ + p;
      n.push(E, M, R), n.push(M, C, R);
    }
  this.setIndex(n), this.addAttribute("position", new Be(i, 3)), this.addAttribute("normal", new Be(a, 3)), this.addAttribute("uv", new Be(s, 2));
}
Qs.prototype = Object.create(Ge.prototype);
Qs.prototype.constructor = Qs;
function Iu(e, t, r, n) {
  tt.call(this), this.type = "PolyhedronGeometry", this.parameters = {
    vertices: e,
    indices: t,
    radius: r,
    detail: n
  }, this.fromBufferGeometry(new fi(e, t, r, n)), this.mergeVertices();
}
Iu.prototype = Object.create(tt.prototype);
Iu.prototype.constructor = Iu;
function fi(e, t, r, n) {
  Ge.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
    vertices: e,
    indices: t,
    radius: r,
    detail: n
  }, r = r || 1, n = n || 0;
  var i = [], a = [];
  s(n), u(r), l(), this.addAttribute("position", new Be(i, 3)), this.addAttribute("normal", new Be(i.slice(), 3)), this.addAttribute("uv", new Be(a, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  function s(x) {
    for (var E = new z(), M = new z(), C = new z(), R = 0; R < t.length; R += 3)
      f(t[R + 0], E), f(t[R + 1], M), f(t[R + 2], C), o(E, M, C, x);
  }
  function o(x, E, M, C) {
    var R = Math.pow(2, C), B = [], k, F;
    for (k = 0; k <= R; k++) {
      B[k] = [];
      var I = x.clone().lerp(M, k / R), H = E.clone().lerp(M, k / R), Q = R - k;
      for (F = 0; F <= Q; F++)
        F === 0 && k === R ? B[k][F] = I : B[k][F] = I.clone().lerp(H, F / Q);
    }
    for (k = 0; k < R; k++)
      for (F = 0; F < 2 * (R - k) - 1; F++) {
        var ee = Math.floor(F / 2);
        F % 2 === 0 ? (h(B[k][ee + 1]), h(B[k + 1][ee]), h(B[k][ee])) : (h(B[k][ee + 1]), h(B[k + 1][ee + 1]), h(B[k + 1][ee]));
      }
  }
  function u(x) {
    for (var E = new z(), M = 0; M < i.length; M += 3)
      E.x = i[M + 0], E.y = i[M + 1], E.z = i[M + 2], E.normalize().multiplyScalar(x), i[M + 0] = E.x, i[M + 1] = E.y, i[M + 2] = E.z;
  }
  function l() {
    for (var x = new z(), E = 0; E < i.length; E += 3) {
      x.x = i[E + 0], x.y = i[E + 1], x.z = i[E + 2];
      var M = _(x) / 2 / Math.PI + 0.5, C = v(x) / Math.PI + 0.5;
      a.push(M, 1 - C);
    }
    d(), c();
  }
  function c() {
    for (var x = 0; x < a.length; x += 6) {
      var E = a[x + 0], M = a[x + 2], C = a[x + 4], R = Math.max(E, M, C), B = Math.min(E, M, C);
      R > 0.9 && B < 0.1 && (E < 0.2 && (a[x + 0] += 1), M < 0.2 && (a[x + 2] += 1), C < 0.2 && (a[x + 4] += 1));
    }
  }
  function h(x) {
    i.push(x.x, x.y, x.z);
  }
  function f(x, E) {
    var M = x * 3;
    E.x = e[M + 0], E.y = e[M + 1], E.z = e[M + 2];
  }
  function d() {
    for (var x = new z(), E = new z(), M = new z(), C = new z(), R = new ue(), B = new ue(), k = new ue(), F = 0, I = 0; F < i.length; F += 9, I += 6) {
      x.set(i[F + 0], i[F + 1], i[F + 2]), E.set(i[F + 3], i[F + 4], i[F + 5]), M.set(i[F + 6], i[F + 7], i[F + 8]), R.set(a[I + 0], a[I + 1]), B.set(a[I + 2], a[I + 3]), k.set(a[I + 4], a[I + 5]), C.copy(x).add(E).add(M).divideScalar(3);
      var H = _(C);
      p(R, I + 0, x, H), p(B, I + 2, E, H), p(k, I + 4, M, H);
    }
  }
  function p(x, E, M, C) {
    C < 0 && x.x === 1 && (a[E] = x.x - 1), M.x === 0 && M.z === 0 && (a[E] = C / 2 / Math.PI + 0.5);
  }
  function _(x) {
    return Math.atan2(x.z, -x.x);
  }
  function v(x) {
    return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
  }
}
fi.prototype = Object.create(Ge.prototype);
fi.prototype.constructor = fi;
function Ou(e, t) {
  tt.call(this), this.type = "TetrahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new Ks(e, t)), this.mergeVertices();
}
Ou.prototype = Object.create(tt.prototype);
Ou.prototype.constructor = Ou;
function Ks(e, t) {
  var r = [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
  ], n = [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
  ];
  fi.call(this, r, n, e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
Ks.prototype = Object.create(fi.prototype);
Ks.prototype.constructor = Ks;
function Bu(e, t) {
  tt.call(this), this.type = "OctahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new Za(e, t)), this.mergeVertices();
}
Bu.prototype = Object.create(tt.prototype);
Bu.prototype.constructor = Bu;
function Za(e, t) {
  var r = [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
  ], n = [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
  ];
  fi.call(this, r, n, e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
Za.prototype = Object.create(fi.prototype);
Za.prototype.constructor = Za;
function Fu(e, t) {
  tt.call(this), this.type = "IcosahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new $s(e, t)), this.mergeVertices();
}
Fu.prototype = Object.create(tt.prototype);
Fu.prototype.constructor = Fu;
function $s(e, t) {
  var r = (1 + Math.sqrt(5)) / 2, n = [
    -1,
    r,
    0,
    1,
    r,
    0,
    -1,
    -r,
    0,
    1,
    -r,
    0,
    0,
    -1,
    r,
    0,
    1,
    r,
    0,
    -1,
    -r,
    0,
    1,
    -r,
    r,
    0,
    -1,
    r,
    0,
    1,
    -r,
    0,
    -1,
    -r,
    0,
    1
  ], i = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ];
  fi.call(this, n, i, e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
$s.prototype = Object.create(fi.prototype);
$s.prototype.constructor = $s;
function ku(e, t) {
  tt.call(this), this.type = "DodecahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new Zs(e, t)), this.mergeVertices();
}
ku.prototype = Object.create(tt.prototype);
ku.prototype.constructor = ku;
function Zs(e, t) {
  var r = (1 + Math.sqrt(5)) / 2, n = 1 / r, i = [
    // (1, 1, 1)
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    // (0, 1/, )
    0,
    -n,
    -r,
    0,
    -n,
    r,
    0,
    n,
    -r,
    0,
    n,
    r,
    // (1/, , 0)
    -n,
    -r,
    0,
    -n,
    r,
    0,
    n,
    -r,
    0,
    n,
    r,
    0,
    // (, 0, 1/)
    -r,
    0,
    -n,
    r,
    0,
    -n,
    -r,
    0,
    n,
    r,
    0,
    n
  ], a = [
    3,
    11,
    7,
    3,
    7,
    15,
    3,
    15,
    13,
    7,
    19,
    17,
    7,
    17,
    6,
    7,
    6,
    15,
    17,
    4,
    8,
    17,
    8,
    10,
    17,
    10,
    6,
    8,
    0,
    16,
    8,
    16,
    2,
    8,
    2,
    10,
    0,
    12,
    1,
    0,
    1,
    18,
    0,
    18,
    16,
    6,
    10,
    2,
    6,
    2,
    13,
    6,
    13,
    15,
    2,
    16,
    18,
    2,
    18,
    3,
    2,
    3,
    13,
    18,
    1,
    9,
    18,
    9,
    11,
    18,
    11,
    3,
    4,
    14,
    12,
    4,
    12,
    0,
    4,
    0,
    8,
    11,
    9,
    5,
    11,
    5,
    19,
    11,
    19,
    7,
    19,
    5,
    14,
    19,
    14,
    4,
    19,
    4,
    17,
    1,
    12,
    14,
    1,
    14,
    5,
    1,
    5,
    9
  ];
  fi.call(this, i, a, e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
Zs.prototype = Object.create(fi.prototype);
Zs.prototype.constructor = Zs;
function Nu(e, t, r, n, i, a) {
  tt.call(this), this.type = "TubeGeometry", this.parameters = {
    path: e,
    tubularSegments: t,
    radius: r,
    radialSegments: n,
    closed: i
  }, a !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed.");
  var s = new Js(e, t, r, n, i);
  this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, this.fromBufferGeometry(s), this.mergeVertices();
}
Nu.prototype = Object.create(tt.prototype);
Nu.prototype.constructor = Nu;
function Js(e, t, r, n, i) {
  Ge.call(this), this.type = "TubeBufferGeometry", this.parameters = {
    path: e,
    tubularSegments: t,
    radius: r,
    radialSegments: n,
    closed: i
  }, t = t || 64, r = r || 1, n = n || 8, i = i || !1;
  var a = e.computeFrenetFrames(t, i);
  this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
  var s = new z(), o = new z(), u = new ue(), l = new z(), c, h, f = [], d = [], p = [], _ = [];
  v(), this.setIndex(_), this.addAttribute("position", new Be(f, 3)), this.addAttribute("normal", new Be(d, 3)), this.addAttribute("uv", new Be(p, 2));
  function v() {
    for (c = 0; c < t; c++)
      x(c);
    x(i === !1 ? t : 0), M(), E();
  }
  function x(C) {
    l = e.getPointAt(C / t, l);
    var R = a.normals[C], B = a.binormals[C];
    for (h = 0; h <= n; h++) {
      var k = h / n * Math.PI * 2, F = Math.sin(k), I = -Math.cos(k);
      o.x = I * R.x + F * B.x, o.y = I * R.y + F * B.y, o.z = I * R.z + F * B.z, o.normalize(), d.push(o.x, o.y, o.z), s.x = l.x + r * o.x, s.y = l.y + r * o.y, s.z = l.z + r * o.z, f.push(s.x, s.y, s.z);
    }
  }
  function E() {
    for (h = 1; h <= t; h++)
      for (c = 1; c <= n; c++) {
        var C = (n + 1) * (h - 1) + (c - 1), R = (n + 1) * h + (c - 1), B = (n + 1) * h + c, k = (n + 1) * (h - 1) + c;
        _.push(C, R, k), _.push(R, B, k);
      }
  }
  function M() {
    for (c = 0; c <= t; c++)
      for (h = 0; h <= n; h++)
        u.x = c / t, u.y = h / n, p.push(u.x, u.y);
  }
}
Js.prototype = Object.create(Ge.prototype);
Js.prototype.constructor = Js;
function Uu(e, t, r, n, i, a, s) {
  tt.call(this), this.type = "TorusKnotGeometry", this.parameters = {
    radius: e,
    tube: t,
    tubularSegments: r,
    radialSegments: n,
    p: i,
    q: a
  }, s !== void 0 && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new eo(e, t, r, n, i, a)), this.mergeVertices();
}
Uu.prototype = Object.create(tt.prototype);
Uu.prototype.constructor = Uu;
function eo(e, t, r, n, i, a) {
  Ge.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
    radius: e,
    tube: t,
    tubularSegments: r,
    radialSegments: n,
    p: i,
    q: a
  }, e = e || 1, t = t || 0.4, r = Math.floor(r) || 64, n = Math.floor(n) || 8, i = i || 2, a = a || 3;
  var s = [], o = [], u = [], l = [], c, h, f = new z(), d = new z(), p = new z(), _ = new z(), v = new z(), x = new z(), E = new z();
  for (c = 0; c <= r; ++c) {
    var M = c / r * i * Math.PI * 2;
    for (Q(M, i, a, e, p), Q(M + 0.01, i, a, e, _), x.subVectors(_, p), E.addVectors(_, p), v.crossVectors(x, E), E.crossVectors(v, x), v.normalize(), E.normalize(), h = 0; h <= n; ++h) {
      var C = h / n * Math.PI * 2, R = -t * Math.cos(C), B = t * Math.sin(C);
      f.x = p.x + (R * E.x + B * v.x), f.y = p.y + (R * E.y + B * v.y), f.z = p.z + (R * E.z + B * v.z), o.push(f.x, f.y, f.z), d.subVectors(f, p).normalize(), u.push(d.x, d.y, d.z), l.push(c / r), l.push(h / n);
    }
  }
  for (h = 1; h <= r; h++)
    for (c = 1; c <= n; c++) {
      var k = (n + 1) * (h - 1) + (c - 1), F = (n + 1) * h + (c - 1), I = (n + 1) * h + c, H = (n + 1) * (h - 1) + c;
      s.push(k, F, H), s.push(F, I, H);
    }
  this.setIndex(s), this.addAttribute("position", new Be(o, 3)), this.addAttribute("normal", new Be(u, 3)), this.addAttribute("uv", new Be(l, 2));
  function Q(ee, oe, de, he, fe) {
    var V = Math.cos(ee), G = Math.sin(ee), se = de / oe * ee, re = Math.cos(se);
    fe.x = he * (2 + re) * 0.5 * V, fe.y = he * (2 + re) * G * 0.5, fe.z = he * Math.sin(se) * 0.5;
  }
}
eo.prototype = Object.create(Ge.prototype);
eo.prototype.constructor = eo;
function Gu(e, t, r, n, i) {
  tt.call(this), this.type = "TorusGeometry", this.parameters = {
    radius: e,
    tube: t,
    radialSegments: r,
    tubularSegments: n,
    arc: i
  }, this.fromBufferGeometry(new to(e, t, r, n, i)), this.mergeVertices();
}
Gu.prototype = Object.create(tt.prototype);
Gu.prototype.constructor = Gu;
function to(e, t, r, n, i) {
  Ge.call(this), this.type = "TorusBufferGeometry", this.parameters = {
    radius: e,
    tube: t,
    radialSegments: r,
    tubularSegments: n,
    arc: i
  }, e = e || 1, t = t || 0.4, r = Math.floor(r) || 8, n = Math.floor(n) || 6, i = i || Math.PI * 2;
  var a = [], s = [], o = [], u = [], l = new z(), c = new z(), h = new z(), f, d;
  for (f = 0; f <= r; f++)
    for (d = 0; d <= n; d++) {
      var p = d / n * i, _ = f / r * Math.PI * 2;
      c.x = (e + t * Math.cos(_)) * Math.cos(p), c.y = (e + t * Math.cos(_)) * Math.sin(p), c.z = t * Math.sin(_), s.push(c.x, c.y, c.z), l.x = e * Math.cos(p), l.y = e * Math.sin(p), h.subVectors(c, l).normalize(), o.push(h.x, h.y, h.z), u.push(d / n), u.push(f / r);
    }
  for (f = 1; f <= r; f++)
    for (d = 1; d <= n; d++) {
      var v = (n + 1) * f + d - 1, x = (n + 1) * (f - 1) + d - 1, E = (n + 1) * (f - 1) + d, M = (n + 1) * f + d;
      a.push(v, x, M), a.push(x, E, M);
    }
  this.setIndex(a), this.addAttribute("position", new Be(s, 3)), this.addAttribute("normal", new Be(o, 3)), this.addAttribute("uv", new Be(u, 2));
}
to.prototype = Object.create(Ge.prototype);
to.prototype.constructor = to;
var q2 = {
  triangulate: function(e, t, r) {
    r = r || 2;
    var n = t && t.length, i = n ? t[0] * r : e.length, a = J0(e, 0, i, r, !0), s = [];
    if (!a) return s;
    var o, u, l, c, h, f, d;
    if (n && (a = $2(e, t, a, r)), e.length > 80 * r) {
      o = l = e[0], u = c = e[1];
      for (var p = r; p < i; p += r)
        h = e[p], f = e[p + 1], h < o && (o = h), f < u && (u = f), h > l && (l = h), f > c && (c = f);
      d = Math.max(l - o, c - u), d = d !== 0 ? 1 / d : 0;
    }
    return Hu(a, s, r, o, u, d), s;
  }
};
function J0(e, t, r, n, i) {
  var a, s;
  if (i === oE(e, t, r, n) > 0)
    for (a = t; a < r; a += n) s = jm(a, e[a], e[a + 1], s);
  else
    for (a = r - n; a >= t; a -= n) s = jm(a, e[a], e[a + 1], s);
  return s && Oa(s, s.next) && (Wu(s), s = s.next), s;
}
function Vu(e, t) {
  if (!e) return e;
  t || (t = e);
  var r = e, n;
  do
    if (n = !1, !r.steiner && (Oa(r, r.next) || Jr(r.prev, r, r.next) === 0)) {
      if (Wu(r), r = t = r.prev, r === r.next) break;
      n = !0;
    } else
      r = r.next;
  while (n || r !== t);
  return t;
}
function Hu(e, t, r, n, i, a, s) {
  if (e) {
    !s && a && tE(e, n, i, a);
    for (var o = e, u, l; e.prev !== e.next; ) {
      if (u = e.prev, l = e.next, a ? Y2(e, n, i, a) : X2(e)) {
        t.push(u.i / r), t.push(e.i / r), t.push(l.i / r), Wu(e), e = l.next, o = l.next;
        continue;
      }
      if (e = l, e === o) {
        s ? s === 1 ? (e = Q2(e, t, r), Hu(e, t, r, n, i, a, 2)) : s === 2 && K2(e, t, r, n, i, a) : Hu(Vu(e), t, r, n, i, a, 1);
        break;
      }
    }
  }
}
function X2(e) {
  var t = e.prev, r = e, n = e.next;
  if (Jr(t, r, n) >= 0) return !1;
  for (var i = e.next.next; i !== e.prev; ) {
    if (mc(t.x, t.y, r.x, r.y, n.x, n.y, i.x, i.y) && Jr(i.prev, i, i.next) >= 0)
      return !1;
    i = i.next;
  }
  return !0;
}
function Y2(e, t, r, n) {
  var i = e.prev, a = e, s = e.next;
  if (Jr(i, a, s) >= 0) return !1;
  for (var o = i.x < a.x ? i.x < s.x ? i.x : s.x : a.x < s.x ? a.x : s.x, u = i.y < a.y ? i.y < s.y ? i.y : s.y : a.y < s.y ? a.y : s.y, l = i.x > a.x ? i.x > s.x ? i.x : s.x : a.x > s.x ? a.x : s.x, c = i.y > a.y ? i.y > s.y ? i.y : s.y : a.y > s.y ? a.y : s.y, h = Ff(o, u, t, r, n), f = Ff(l, c, t, r, n), d = e.nextZ; d && d.z <= f; ) {
    if (d !== e.prev && d !== e.next && mc(i.x, i.y, a.x, a.y, s.x, s.y, d.x, d.y) && Jr(d.prev, d, d.next) >= 0) return !1;
    d = d.nextZ;
  }
  for (d = e.prevZ; d && d.z >= h; ) {
    if (d !== e.prev && d !== e.next && mc(i.x, i.y, a.x, a.y, s.x, s.y, d.x, d.y) && Jr(d.prev, d, d.next) >= 0) return !1;
    d = d.prevZ;
  }
  return !0;
}
function Q2(e, t, r) {
  var n = e;
  do {
    var i = n.prev, a = n.next.next;
    !Oa(i, a) && ey(i, n, n.next, a) && zu(i, a) && zu(a, i) && (t.push(i.i / r), t.push(n.i / r), t.push(a.i / r), Wu(n), Wu(n.next), n = e = a), n = n.next;
  } while (n !== e);
  return n;
}
function K2(e, t, r, n, i, a) {
  var s = e;
  do {
    for (var o = s.next.next; o !== s.prev; ) {
      if (s.i !== o.i && nE(s, o)) {
        var u = ty(s, o);
        s = Vu(s, s.next), u = Vu(u, u.next), Hu(s, t, r, n, i, a), Hu(u, t, r, n, i, a);
        return;
      }
      o = o.next;
    }
    s = s.next;
  } while (s !== e);
}
function $2(e, t, r, n) {
  var i = [], a, s, o, u, l;
  for (a = 0, s = t.length; a < s; a++)
    o = t[a] * n, u = a < s - 1 ? t[a + 1] * n : e.length, l = J0(e, o, u, n, !1), l === l.next && (l.steiner = !0), i.push(iE(l));
  for (i.sort(Z2), a = 0; a < i.length; a++)
    J2(i[a], r), r = Vu(r, r.next);
  return r;
}
function Z2(e, t) {
  return e.x - t.x;
}
function J2(e, t) {
  if (t = eE(e, t), t) {
    var r = ty(t, e);
    Vu(r, r.next);
  }
}
function eE(e, t) {
  var r = t, n = e.x, i = e.y, a = -1 / 0, s;
  do {
    if (i <= r.y && i >= r.next.y && r.next.y !== r.y) {
      var o = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
      if (o <= n && o > a) {
        if (a = o, o === n) {
          if (i === r.y) return r;
          if (i === r.next.y) return r.next;
        }
        s = r.x < r.next.x ? r : r.next;
      }
    }
    r = r.next;
  } while (r !== t);
  if (!s) return null;
  if (n === a) return s.prev;
  var u = s, l = s.x, c = s.y, h = 1 / 0, f;
  for (r = s.next; r !== u; )
    n >= r.x && r.x >= l && n !== r.x && mc(i < c ? n : a, i, l, c, i < c ? a : n, i, r.x, r.y) && (f = Math.abs(i - r.y) / (n - r.x), (f < h || f === h && r.x > s.x) && zu(r, e) && (s = r, h = f)), r = r.next;
  return s;
}
function tE(e, t, r, n) {
  var i = e;
  do
    i.z === null && (i.z = Ff(i.x, i.y, t, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== e);
  i.prevZ.nextZ = null, i.prevZ = null, rE(i);
}
function rE(e) {
  var t, r, n, i, a, s, o, u, l = 1;
  do {
    for (r = e, e = null, a = null, s = 0; r; ) {
      for (s++, n = r, o = 0, t = 0; t < l && (o++, n = n.nextZ, !!n); t++)
        ;
      for (u = l; o > 0 || u > 0 && n; )
        o !== 0 && (u === 0 || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, u--), a ? a.nextZ = i : e = i, i.prevZ = a, a = i;
      r = n;
    }
    a.nextZ = null, l *= 2;
  } while (s > 1);
  return e;
}
function Ff(e, t, r, n, i) {
  return e = 32767 * (e - r) * i, t = 32767 * (t - n) * i, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1;
}
function iE(e) {
  var t = e, r = e;
  do
    t.x < r.x && (r = t), t = t.next;
  while (t !== e);
  return r;
}
function mc(e, t, r, n, i, a, s, o) {
  return (i - s) * (t - o) - (e - s) * (a - o) >= 0 && (e - s) * (n - o) - (r - s) * (t - o) >= 0 && (r - s) * (a - o) - (i - s) * (n - o) >= 0;
}
function nE(e, t) {
  return e.next.i !== t.i && e.prev.i !== t.i && !aE(e, t) && zu(e, t) && zu(t, e) && sE(e, t);
}
function Jr(e, t, r) {
  return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y);
}
function Oa(e, t) {
  return e.x === t.x && e.y === t.y;
}
function ey(e, t, r, n) {
  return Oa(e, t) && Oa(r, n) || Oa(e, n) && Oa(r, t) ? !0 : Jr(e, t, r) > 0 != Jr(e, t, n) > 0 && Jr(r, n, e) > 0 != Jr(r, n, t) > 0;
}
function aE(e, t) {
  var r = e;
  do {
    if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && ey(r, r.next, e, t))
      return !0;
    r = r.next;
  } while (r !== e);
  return !1;
}
function zu(e, t) {
  return Jr(e.prev, e, e.next) < 0 ? Jr(e, t, e.next) >= 0 && Jr(e, e.prev, t) >= 0 : Jr(e, t, e.prev) < 0 || Jr(e, e.next, t) < 0;
}
function sE(e, t) {
  var r = e, n = !1, i = (e.x + t.x) / 2, a = (e.y + t.y) / 2;
  do
    r.y > a != r.next.y > a && r.next.y !== r.y && i < (r.next.x - r.x) * (a - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
  while (r !== e);
  return n;
}
function ty(e, t) {
  var r = new kf(e.i, e.x, e.y), n = new kf(t.i, t.x, t.y), i = e.next, a = t.prev;
  return e.next = t, t.prev = e, r.next = i, i.prev = r, n.next = r, r.prev = n, a.next = n, n.prev = a, n;
}
function jm(e, t, r, n) {
  var i = new kf(e, t, r);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function Wu(e) {
  e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
}
function kf(e, t, r) {
  this.i = e, this.x = t, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function oE(e, t, r, n) {
  for (var i = 0, a = t, s = r - n; a < r; a += n)
    i += (e[s] - e[a]) * (e[a + 1] + e[s + 1]), s = a;
  return i;
}
var Nn = {
  // calculate area of the contour polygon
  area: function(e) {
    for (var t = e.length, r = 0, n = t - 1, i = 0; i < t; n = i++)
      r += e[n].x * e[i].y - e[i].x * e[n].y;
    return r * 0.5;
  },
  isClockWise: function(e) {
    return Nn.area(e) < 0;
  },
  triangulateShape: function(e, t) {
    var r = [], n = [], i = [];
    qm(e), Xm(r, e);
    var a = e.length;
    t.forEach(qm);
    for (var s = 0; s < t.length; s++)
      n.push(a), a += t[s].length, Xm(r, t[s]);
    for (var o = q2.triangulate(r, n), s = 0; s < o.length; s += 3)
      i.push(o.slice(s, s + 3));
    return i;
  }
};
function qm(e) {
  var t = e.length;
  t > 2 && e[t - 1].equals(e[0]) && e.pop();
}
function Xm(e, t) {
  for (var r = 0; r < t.length; r++)
    e.push(t[r].x), e.push(t[r].y);
}
function Ja(e, t) {
  tt.call(this), this.type = "ExtrudeGeometry", this.parameters = {
    shapes: e,
    options: t
  }, this.fromBufferGeometry(new bn(e, t)), this.mergeVertices();
}
Ja.prototype = Object.create(tt.prototype);
Ja.prototype.constructor = Ja;
Ja.prototype.toJSON = function() {
  var e = tt.prototype.toJSON.call(this), t = this.parameters.shapes, r = this.parameters.options;
  return ry(t, r, e);
};
function bn(e, t) {
  Ge.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
    shapes: e,
    options: t
  }, e = Array.isArray(e) ? e : [e];
  for (var r = this, n = [], i = [], a = 0, s = e.length; a < s; a++) {
    var o = e[a];
    u(o);
  }
  this.addAttribute("position", new Be(n, 3)), this.addAttribute("uv", new Be(i, 2)), this.computeVertexNormals();
  function u(l) {
    var c = [], h = t.curveSegments !== void 0 ? t.curveSegments : 12, f = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 100, p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, _ = t.bevelThickness !== void 0 ? t.bevelThickness : 6, v = t.bevelSize !== void 0 ? t.bevelSize : _ - 2, x = t.bevelSegments !== void 0 ? t.bevelSegments : 3, E = t.extrudePath, M = t.UVGenerator !== void 0 ? t.UVGenerator : uE;
    t.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), d = t.amount);
    var C, R = !1, B, k, F, I;
    E && (C = E.getSpacedPoints(f), R = !0, p = !1, B = E.computeFrenetFrames(f, !1), k = new z(), F = new z(), I = new z()), p || (x = 0, _ = 0, v = 0);
    var H, Q, ee, oe = l.extractPoints(h), de = oe.shape, he = oe.holes, fe = !Nn.isClockWise(de);
    if (fe)
      for (de = de.reverse(), Q = 0, ee = he.length; Q < ee; Q++)
        H = he[Q], Nn.isClockWise(H) && (he[Q] = H.reverse());
    var V = Nn.triangulateShape(de, he), G = de;
    for (Q = 0, ee = he.length; Q < ee; Q++)
      H = he[Q], de = de.concat(H);
    function se(Pe, Ie, Ze) {
      return Ie || console.error("THREE.ExtrudeGeometry: vec does not exist"), Ie.clone().multiplyScalar(Ze).add(Pe);
    }
    var re, Ce, K, xe, pe, Re = de.length, _e, Le = V.length;
    function He(Pe, Ie, Ze) {
      var Fe, st, Ne, mt = Pe.x - Ie.x, Rt = Pe.y - Ie.y, ht = Ze.x - Pe.x, Ct = Ze.y - Pe.y, Lt = mt * mt + Rt * Rt, wt = mt * Ct - Rt * ht;
      if (Math.abs(wt) > Number.EPSILON) {
        var _t = Math.sqrt(Lt), Fi = Math.sqrt(ht * ht + Ct * Ct), ni = Ie.x - Rt / _t, ra = Ie.y + mt / _t, xr = Ze.x - Ct / Fi, Xt = Ze.y + ht / Fi, an = ((xr - ni) * Ct - (Xt - ra) * ht) / (mt * Ct - Rt * ht);
        Fe = ni + mt * an - Pe.x, st = ra + Rt * an - Pe.y;
        var ia = Fe * Fe + st * st;
        if (ia <= 2)
          return new ue(Fe, st);
        Ne = Math.sqrt(ia / 2);
      } else {
        var ki = !1;
        mt > Number.EPSILON ? ht > Number.EPSILON && (ki = !0) : mt < -Number.EPSILON ? ht < -Number.EPSILON && (ki = !0) : Math.sign(Rt) === Math.sign(Ct) && (ki = !0), ki ? (Fe = -Rt, st = mt, Ne = Math.sqrt(Lt)) : (Fe = mt, st = Rt, Ne = Math.sqrt(Lt / 2));
      }
      return new ue(Fe / Ne, st / Ne);
    }
    for (var dt = [], Ee = 0, ct = G.length, Bt = ct - 1, Mt = Ee + 1; Ee < ct; Ee++, Bt++, Mt++)
      Bt === ct && (Bt = 0), Mt === ct && (Mt = 0), dt[Ee] = He(G[Ee], G[Bt], G[Mt]);
    var Ht = [], yt, Gt = dt.concat();
    for (Q = 0, ee = he.length; Q < ee; Q++) {
      for (H = he[Q], yt = [], Ee = 0, ct = H.length, Bt = ct - 1, Mt = Ee + 1; Ee < ct; Ee++, Bt++, Mt++)
        Bt === ct && (Bt = 0), Mt === ct && (Mt = 0), yt[Ee] = He(H[Ee], H[Bt], H[Mt]);
      Ht.push(yt), Gt = Gt.concat(yt);
    }
    for (re = 0; re < x; re++) {
      for (K = re / x, xe = _ * Math.cos(K * Math.PI / 2), Ce = v * Math.sin(K * Math.PI / 2), Ee = 0, ct = G.length; Ee < ct; Ee++)
        pe = se(G[Ee], dt[Ee], Ce), Vt(pe.x, pe.y, -xe);
      for (Q = 0, ee = he.length; Q < ee; Q++)
        for (H = he[Q], yt = Ht[Q], Ee = 0, ct = H.length; Ee < ct; Ee++)
          pe = se(H[Ee], yt[Ee], Ce), Vt(pe.x, pe.y, -xe);
    }
    for (Ce = v, Ee = 0; Ee < Re; Ee++)
      pe = p ? se(de[Ee], Gt[Ee], Ce) : de[Ee], R ? (F.copy(B.normals[0]).multiplyScalar(pe.x), k.copy(B.binormals[0]).multiplyScalar(pe.y), I.copy(C[0]).add(F).add(k), Vt(I.x, I.y, I.z)) : Vt(pe.x, pe.y, 0);
    var Et;
    for (Et = 1; Et <= f; Et++)
      for (Ee = 0; Ee < Re; Ee++)
        pe = p ? se(de[Ee], Gt[Ee], Ce) : de[Ee], R ? (F.copy(B.normals[Et]).multiplyScalar(pe.x), k.copy(B.binormals[Et]).multiplyScalar(pe.y), I.copy(C[Et]).add(F).add(k), Vt(I.x, I.y, I.z)) : Vt(pe.x, pe.y, d / f * Et);
    for (re = x - 1; re >= 0; re--) {
      for (K = re / x, xe = _ * Math.cos(K * Math.PI / 2), Ce = v * Math.sin(K * Math.PI / 2), Ee = 0, ct = G.length; Ee < ct; Ee++)
        pe = se(G[Ee], dt[Ee], Ce), Vt(pe.x, pe.y, d + xe);
      for (Q = 0, ee = he.length; Q < ee; Q++)
        for (H = he[Q], yt = Ht[Q], Ee = 0, ct = H.length; Ee < ct; Ee++)
          pe = se(H[Ee], yt[Ee], Ce), R ? Vt(pe.x, pe.y + C[f - 1].y, C[f - 1].x + xe) : Vt(pe.x, pe.y, d + xe);
    }
    gi(), xt();
    function gi() {
      var Pe = n.length / 3;
      if (p) {
        var Ie = 0, Ze = Re * Ie;
        for (Ee = 0; Ee < Le; Ee++)
          _e = V[Ee], yi(_e[2] + Ze, _e[1] + Ze, _e[0] + Ze);
        for (Ie = f + x * 2, Ze = Re * Ie, Ee = 0; Ee < Le; Ee++)
          _e = V[Ee], yi(_e[0] + Ze, _e[1] + Ze, _e[2] + Ze);
      } else {
        for (Ee = 0; Ee < Le; Ee++)
          _e = V[Ee], yi(_e[2], _e[1], _e[0]);
        for (Ee = 0; Ee < Le; Ee++)
          _e = V[Ee], yi(_e[0] + Re * f, _e[1] + Re * f, _e[2] + Re * f);
      }
      r.addGroup(Pe, n.length / 3 - Pe, 0);
    }
    function xt() {
      var Pe = n.length / 3, Ie = 0;
      for (cr(G, Ie), Ie += G.length, Q = 0, ee = he.length; Q < ee; Q++)
        H = he[Q], cr(H, Ie), Ie += H.length;
      r.addGroup(Pe, n.length / 3 - Pe, 1);
    }
    function cr(Pe, Ie) {
      var Ze, Fe;
      for (Ee = Pe.length; --Ee >= 0; ) {
        Ze = Ee, Fe = Ee - 1, Fe < 0 && (Fe = Pe.length - 1);
        var st = 0, Ne = f + x * 2;
        for (st = 0; st < Ne; st++) {
          var mt = Re * st, Rt = Re * (st + 1), ht = Ie + Ze + mt, Ct = Ie + Fe + mt, Lt = Ie + Fe + Rt, wt = Ie + Ze + Rt;
          gr(ht, Ct, Lt, wt);
        }
      }
    }
    function Vt(Pe, Ie, Ze) {
      c.push(Pe), c.push(Ie), c.push(Ze);
    }
    function yi(Pe, Ie, Ze) {
      ar(Pe), ar(Ie), ar(Ze);
      var Fe = n.length / 3, st = M.generateTopUV(r, n, Fe - 3, Fe - 2, Fe - 1);
      ae(st[0]), ae(st[1]), ae(st[2]);
    }
    function gr(Pe, Ie, Ze, Fe) {
      ar(Pe), ar(Ie), ar(Fe), ar(Ie), ar(Ze), ar(Fe);
      var st = n.length / 3, Ne = M.generateSideWallUV(r, n, st - 6, st - 3, st - 2, st - 1);
      ae(Ne[0]), ae(Ne[1]), ae(Ne[3]), ae(Ne[1]), ae(Ne[2]), ae(Ne[3]);
    }
    function ar(Pe) {
      n.push(c[Pe * 3 + 0]), n.push(c[Pe * 3 + 1]), n.push(c[Pe * 3 + 2]);
    }
    function ae(Pe) {
      i.push(Pe.x), i.push(Pe.y);
    }
  }
}
bn.prototype = Object.create(Ge.prototype);
bn.prototype.constructor = bn;
bn.prototype.toJSON = function() {
  var e = Ge.prototype.toJSON.call(this), t = this.parameters.shapes, r = this.parameters.options;
  return ry(t, r, e);
};
var uE = {
  generateTopUV: function(e, t, r, n, i) {
    var a = t[r * 3], s = t[r * 3 + 1], o = t[n * 3], u = t[n * 3 + 1], l = t[i * 3], c = t[i * 3 + 1];
    return [
      new ue(a, s),
      new ue(o, u),
      new ue(l, c)
    ];
  },
  generateSideWallUV: function(e, t, r, n, i, a) {
    var s = t[r * 3], o = t[r * 3 + 1], u = t[r * 3 + 2], l = t[n * 3], c = t[n * 3 + 1], h = t[n * 3 + 2], f = t[i * 3], d = t[i * 3 + 1], p = t[i * 3 + 2], _ = t[a * 3], v = t[a * 3 + 1], x = t[a * 3 + 2];
    return Math.abs(o - c) < 0.01 ? [
      new ue(s, 1 - u),
      new ue(l, 1 - h),
      new ue(f, 1 - p),
      new ue(_, 1 - x)
    ] : [
      new ue(o, 1 - u),
      new ue(c, 1 - h),
      new ue(d, 1 - p),
      new ue(v, 1 - x)
    ];
  }
};
function ry(e, t, r) {
  if (r.shapes = [], Array.isArray(e))
    for (var n = 0, i = e.length; n < i; n++) {
      var a = e[n];
      r.shapes.push(a.uuid);
    }
  else
    r.shapes.push(e.uuid);
  return t.extrudePath !== void 0 && (r.options.extrudePath = t.extrudePath.toJSON()), r;
}
function ju(e, t) {
  tt.call(this), this.type = "TextGeometry", this.parameters = {
    text: e,
    parameters: t
  }, this.fromBufferGeometry(new ro(e, t)), this.mergeVertices();
}
ju.prototype = Object.create(tt.prototype);
ju.prototype.constructor = ju;
function ro(e, t) {
  t = t || {};
  var r = t.font;
  if (!(r && r.isFont))
    return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new tt();
  var n = r.generateShapes(e, t.size, t.curveSegments);
  t.depth = t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), bn.call(this, n, t), this.type = "TextBufferGeometry";
}
ro.prototype = Object.create(bn.prototype);
ro.prototype.constructor = ro;
function Bn(e, t, r, n, i, a, s) {
  tt.call(this), this.type = "SphereGeometry", this.parameters = {
    radius: e,
    widthSegments: t,
    heightSegments: r,
    phiStart: n,
    phiLength: i,
    thetaStart: a,
    thetaLength: s
  }, this.fromBufferGeometry(new ma(e, t, r, n, i, a, s)), this.mergeVertices();
}
Bn.prototype = Object.create(tt.prototype);
Bn.prototype.constructor = Bn;
function ma(e, t, r, n, i, a, s) {
  Ge.call(this), this.type = "SphereBufferGeometry", this.parameters = {
    radius: e,
    widthSegments: t,
    heightSegments: r,
    phiStart: n,
    phiLength: i,
    thetaStart: a,
    thetaLength: s
  }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), r = Math.max(2, Math.floor(r) || 6), n = n !== void 0 ? n : 0, i = i !== void 0 ? i : Math.PI * 2, a = a !== void 0 ? a : 0, s = s !== void 0 ? s : Math.PI;
  var o = a + s, u, l, c = 0, h = [], f = new z(), d = new z(), p = [], _ = [], v = [], x = [];
  for (l = 0; l <= r; l++) {
    var E = [], M = l / r;
    for (u = 0; u <= t; u++) {
      var C = u / t;
      f.x = -e * Math.cos(n + C * i) * Math.sin(a + M * s), f.y = e * Math.cos(a + M * s), f.z = e * Math.sin(n + C * i) * Math.sin(a + M * s), _.push(f.x, f.y, f.z), d.set(f.x, f.y, f.z).normalize(), v.push(d.x, d.y, d.z), x.push(C, 1 - M), E.push(c++);
    }
    h.push(E);
  }
  for (l = 0; l < r; l++)
    for (u = 0; u < t; u++) {
      var R = h[l][u + 1], B = h[l][u], k = h[l + 1][u], F = h[l + 1][u + 1];
      (l !== 0 || a > 0) && p.push(R, B, F), (l !== r - 1 || o < Math.PI) && p.push(B, k, F);
    }
  this.setIndex(p), this.addAttribute("position", new Be(_, 3)), this.addAttribute("normal", new Be(v, 3)), this.addAttribute("uv", new Be(x, 2));
}
ma.prototype = Object.create(Ge.prototype);
ma.prototype.constructor = ma;
function qu(e, t, r, n, i, a) {
  tt.call(this), this.type = "RingGeometry", this.parameters = {
    innerRadius: e,
    outerRadius: t,
    thetaSegments: r,
    phiSegments: n,
    thetaStart: i,
    thetaLength: a
  }, this.fromBufferGeometry(new io(e, t, r, n, i, a)), this.mergeVertices();
}
qu.prototype = Object.create(tt.prototype);
qu.prototype.constructor = qu;
function io(e, t, r, n, i, a) {
  Ge.call(this), this.type = "RingBufferGeometry", this.parameters = {
    innerRadius: e,
    outerRadius: t,
    thetaSegments: r,
    phiSegments: n,
    thetaStart: i,
    thetaLength: a
  }, e = e || 0.5, t = t || 1, i = i !== void 0 ? i : 0, a = a !== void 0 ? a : Math.PI * 2, r = r !== void 0 ? Math.max(3, r) : 8, n = n !== void 0 ? Math.max(1, n) : 1;
  var s = [], o = [], u = [], l = [], c, h = e, f = (t - e) / n, d = new z(), p = new ue(), _, v;
  for (_ = 0; _ <= n; _++) {
    for (v = 0; v <= r; v++)
      c = i + v / r * a, d.x = h * Math.cos(c), d.y = h * Math.sin(c), o.push(d.x, d.y, d.z), u.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, l.push(p.x, p.y);
    h += f;
  }
  for (_ = 0; _ < n; _++) {
    var x = _ * (r + 1);
    for (v = 0; v < r; v++) {
      c = v + x;
      var E = c, M = c + r + 1, C = c + r + 2, R = c + 1;
      s.push(E, M, R), s.push(M, C, R);
    }
  }
  this.setIndex(s), this.addAttribute("position", new Be(o, 3)), this.addAttribute("normal", new Be(u, 3)), this.addAttribute("uv", new Be(l, 2));
}
io.prototype = Object.create(Ge.prototype);
io.prototype.constructor = io;
function Xu(e, t, r, n) {
  tt.call(this), this.type = "LatheGeometry", this.parameters = {
    points: e,
    segments: t,
    phiStart: r,
    phiLength: n
  }, this.fromBufferGeometry(new no(e, t, r, n)), this.mergeVertices();
}
Xu.prototype = Object.create(tt.prototype);
Xu.prototype.constructor = Xu;
function no(e, t, r, n) {
  Ge.call(this), this.type = "LatheBufferGeometry", this.parameters = {
    points: e,
    segments: t,
    phiStart: r,
    phiLength: n
  }, t = Math.floor(t) || 12, r = r || 0, n = n || Math.PI * 2, n = gt.clamp(n, 0, Math.PI * 2);
  var i = [], a = [], s = [], o, u = 1 / t, l = new z(), c = new ue(), h, f;
  for (h = 0; h <= t; h++) {
    var d = r + h * u * n, p = Math.sin(d), _ = Math.cos(d);
    for (f = 0; f <= e.length - 1; f++)
      l.x = e[f].x * p, l.y = e[f].y, l.z = e[f].x * _, a.push(l.x, l.y, l.z), c.x = h / t, c.y = f / (e.length - 1), s.push(c.x, c.y);
  }
  for (h = 0; h < t; h++)
    for (f = 0; f < e.length - 1; f++) {
      o = f + h * e.length;
      var v = o, x = o + e.length, E = o + e.length + 1, M = o + 1;
      i.push(v, x, M), i.push(x, E, M);
    }
  if (this.setIndex(i), this.addAttribute("position", new Be(a, 3)), this.addAttribute("uv", new Be(s, 2)), this.computeVertexNormals(), n === Math.PI * 2) {
    var C = this.attributes.normal.array, R = new z(), B = new z(), k = new z();
    for (o = t * e.length * 3, h = 0, f = 0; h < e.length; h++, f += 3)
      R.x = C[f + 0], R.y = C[f + 1], R.z = C[f + 2], B.x = C[o + f + 0], B.y = C[o + f + 1], B.z = C[o + f + 2], k.addVectors(R, B).normalize(), C[f + 0] = C[o + f + 0] = k.x, C[f + 1] = C[o + f + 1] = k.y, C[f + 2] = C[o + f + 2] = k.z;
  }
}
no.prototype = Object.create(Ge.prototype);
no.prototype.constructor = no;
function es(e, t) {
  tt.call(this), this.type = "ShapeGeometry", typeof t == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
    shapes: e,
    curveSegments: t
  }, this.fromBufferGeometry(new ts(e, t)), this.mergeVertices();
}
es.prototype = Object.create(tt.prototype);
es.prototype.constructor = es;
es.prototype.toJSON = function() {
  var e = tt.prototype.toJSON.call(this), t = this.parameters.shapes;
  return iy(t, e);
};
function ts(e, t) {
  Ge.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
    shapes: e,
    curveSegments: t
  }, t = t || 12;
  var r = [], n = [], i = [], a = [], s = 0, o = 0;
  if (Array.isArray(e) === !1)
    l(e);
  else
    for (var u = 0; u < e.length; u++)
      l(e[u]), this.addGroup(s, o, u), s += o, o = 0;
  this.setIndex(r), this.addAttribute("position", new Be(n, 3)), this.addAttribute("normal", new Be(i, 3)), this.addAttribute("uv", new Be(a, 2));
  function l(c) {
    var h, f, d, p = n.length / 3, _ = c.extractPoints(t), v = _.shape, x = _.holes;
    if (Nn.isClockWise(v) === !1)
      for (v = v.reverse(), h = 0, f = x.length; h < f; h++)
        d = x[h], Nn.isClockWise(d) === !0 && (x[h] = d.reverse());
    var E = Nn.triangulateShape(v, x);
    for (h = 0, f = x.length; h < f; h++)
      d = x[h], v = v.concat(d);
    for (h = 0, f = v.length; h < f; h++) {
      var M = v[h];
      n.push(M.x, M.y, 0), i.push(0, 0, 1), a.push(M.x, M.y);
    }
    for (h = 0, f = E.length; h < f; h++) {
      var C = E[h], R = C[0] + p, B = C[1] + p, k = C[2] + p;
      r.push(R, B, k), o += 3;
    }
  }
}
ts.prototype = Object.create(Ge.prototype);
ts.prototype.constructor = ts;
ts.prototype.toJSON = function() {
  var e = Ge.prototype.toJSON.call(this), t = this.parameters.shapes;
  return iy(t, e);
};
function iy(e, t) {
  if (t.shapes = [], Array.isArray(e))
    for (var r = 0, n = e.length; r < n; r++) {
      var i = e[r];
      t.shapes.push(i.uuid);
    }
  else
    t.shapes.push(e.uuid);
  return t;
}
function ao(e, t) {
  Ge.call(this), this.type = "EdgesGeometry", this.parameters = {
    thresholdAngle: t
  }, t = t !== void 0 ? t : 1;
  var r = [], n = Math.cos(gt.DEG2RAD * t), i = [0, 0], a = {}, s, o, u, l = ["a", "b", "c"], c;
  e.isBufferGeometry ? (c = new tt(), c.fromBufferGeometry(e)) : c = e.clone(), c.mergeVertices(), c.computeFaceNormals();
  for (var h = c.vertices, f = c.faces, d = 0, p = f.length; d < p; d++)
    for (var _ = f[d], v = 0; v < 3; v++)
      s = _[l[v]], o = _[l[(v + 1) % 3]], i[0] = Math.min(s, o), i[1] = Math.max(s, o), u = i[0] + "," + i[1], a[u] === void 0 ? a[u] = { index1: i[0], index2: i[1], face1: d, face2: void 0 } : a[u].face2 = d;
  for (u in a) {
    var x = a[u];
    if (x.face2 === void 0 || f[x.face1].normal.dot(f[x.face2].normal) <= n) {
      var E = h[x.index1];
      r.push(E.x, E.y, E.z), E = h[x.index2], r.push(E.x, E.y, E.z);
    }
  }
  this.addAttribute("position", new Be(r, 3));
}
ao.prototype = Object.create(Ge.prototype);
ao.prototype.constructor = ao;
function rs(e, t, r, n, i, a, s, o) {
  tt.call(this), this.type = "CylinderGeometry", this.parameters = {
    radiusTop: e,
    radiusBottom: t,
    height: r,
    radialSegments: n,
    heightSegments: i,
    openEnded: a,
    thetaStart: s,
    thetaLength: o
  }, this.fromBufferGeometry(new zn(e, t, r, n, i, a, s, o)), this.mergeVertices();
}
rs.prototype = Object.create(tt.prototype);
rs.prototype.constructor = rs;
function zn(e, t, r, n, i, a, s, o) {
  Ge.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
    radiusTop: e,
    radiusBottom: t,
    height: r,
    radialSegments: n,
    heightSegments: i,
    openEnded: a,
    thetaStart: s,
    thetaLength: o
  };
  var u = this;
  e = e !== void 0 ? e : 1, t = t !== void 0 ? t : 1, r = r || 1, n = Math.floor(n) || 8, i = Math.floor(i) || 1, a = a !== void 0 ? a : !1, s = s !== void 0 ? s : 0, o = o !== void 0 ? o : Math.PI * 2;
  var l = [], c = [], h = [], f = [], d = 0, p = [], _ = r / 2, v = 0;
  x(), a === !1 && (e > 0 && E(!0), t > 0 && E(!1)), this.setIndex(l), this.addAttribute("position", new Be(c, 3)), this.addAttribute("normal", new Be(h, 3)), this.addAttribute("uv", new Be(f, 2));
  function x() {
    var M, C, R = new z(), B = new z(), k = 0, F = (t - e) / r;
    for (C = 0; C <= i; C++) {
      var I = [], H = C / i, Q = H * (t - e) + e;
      for (M = 0; M <= n; M++) {
        var ee = M / n, oe = ee * o + s, de = Math.sin(oe), he = Math.cos(oe);
        B.x = Q * de, B.y = -H * r + _, B.z = Q * he, c.push(B.x, B.y, B.z), R.set(de, F, he).normalize(), h.push(R.x, R.y, R.z), f.push(ee, 1 - H), I.push(d++);
      }
      p.push(I);
    }
    for (M = 0; M < n; M++)
      for (C = 0; C < i; C++) {
        var fe = p[C][M], V = p[C + 1][M], G = p[C + 1][M + 1], se = p[C][M + 1];
        l.push(fe, V, se), l.push(V, G, se), k += 6;
      }
    u.addGroup(v, k, 0), v += k;
  }
  function E(M) {
    var C, R, B, k = new ue(), F = new z(), I = 0, H = M === !0 ? e : t, Q = M === !0 ? 1 : -1;
    for (R = d, C = 1; C <= n; C++)
      c.push(0, _ * Q, 0), h.push(0, Q, 0), f.push(0.5, 0.5), d++;
    for (B = d, C = 0; C <= n; C++) {
      var ee = C / n, oe = ee * o + s, de = Math.cos(oe), he = Math.sin(oe);
      F.x = H * he, F.y = _ * Q, F.z = H * de, c.push(F.x, F.y, F.z), h.push(0, Q, 0), k.x = de * 0.5 + 0.5, k.y = he * 0.5 * Q + 0.5, f.push(k.x, k.y), d++;
    }
    for (C = 0; C < n; C++) {
      var fe = R + C, V = B + C;
      M === !0 ? l.push(V, V + 1, fe) : l.push(V + 1, V, fe), I += 3;
    }
    u.addGroup(v, I, M === !0 ? 1 : 2), v += I;
  }
}
zn.prototype = Object.create(Ge.prototype);
zn.prototype.constructor = zn;
function Yu(e, t, r, n, i, a, s) {
  rs.call(this, 0, e, t, r, n, i, a, s), this.type = "ConeGeometry", this.parameters = {
    radius: e,
    height: t,
    radialSegments: r,
    heightSegments: n,
    openEnded: i,
    thetaStart: a,
    thetaLength: s
  };
}
Yu.prototype = Object.create(rs.prototype);
Yu.prototype.constructor = Yu;
function Qu(e, t, r, n, i, a, s) {
  zn.call(this, 0, e, t, r, n, i, a, s), this.type = "ConeBufferGeometry", this.parameters = {
    radius: e,
    height: t,
    radialSegments: r,
    heightSegments: n,
    openEnded: i,
    thetaStart: a,
    thetaLength: s
  };
}
Qu.prototype = Object.create(zn.prototype);
Qu.prototype.constructor = Qu;
function Ku(e, t, r, n) {
  tt.call(this), this.type = "CircleGeometry", this.parameters = {
    radius: e,
    segments: t,
    thetaStart: r,
    thetaLength: n
  }, this.fromBufferGeometry(new so(e, t, r, n)), this.mergeVertices();
}
Ku.prototype = Object.create(tt.prototype);
Ku.prototype.constructor = Ku;
function so(e, t, r, n) {
  Ge.call(this), this.type = "CircleBufferGeometry", this.parameters = {
    radius: e,
    segments: t,
    thetaStart: r,
    thetaLength: n
  }, e = e || 1, t = t !== void 0 ? Math.max(3, t) : 8, r = r !== void 0 ? r : 0, n = n !== void 0 ? n : Math.PI * 2;
  var i = [], a = [], s = [], o = [], u, l, c = new z(), h = new ue();
  for (a.push(0, 0, 0), s.push(0, 0, 1), o.push(0.5, 0.5), l = 0, u = 3; l <= t; l++, u += 3) {
    var f = r + l / t * n;
    c.x = e * Math.cos(f), c.y = e * Math.sin(f), a.push(c.x, c.y, c.z), s.push(0, 0, 1), h.x = (a[u] / e + 1) / 2, h.y = (a[u + 1] / e + 1) / 2, o.push(h.x, h.y);
  }
  for (u = 1; u <= t; u++)
    i.push(u, u + 1, 0);
  this.setIndex(i), this.addAttribute("position", new Be(a, 3)), this.addAttribute("normal", new Be(s, 3)), this.addAttribute("uv", new Be(o, 2));
}
so.prototype = Object.create(Ge.prototype);
so.prototype.constructor = so;
var ai = /* @__PURE__ */ Object.freeze({
  WireframeGeometry: Ys,
  ParametricGeometry: Ru,
  ParametricBufferGeometry: Qs,
  TetrahedronGeometry: Ou,
  TetrahedronBufferGeometry: Ks,
  OctahedronGeometry: Bu,
  OctahedronBufferGeometry: Za,
  IcosahedronGeometry: Fu,
  IcosahedronBufferGeometry: $s,
  DodecahedronGeometry: ku,
  DodecahedronBufferGeometry: Zs,
  PolyhedronGeometry: Iu,
  PolyhedronBufferGeometry: fi,
  TubeGeometry: Nu,
  TubeBufferGeometry: Js,
  TorusKnotGeometry: Uu,
  TorusKnotBufferGeometry: eo,
  TorusGeometry: Gu,
  TorusBufferGeometry: to,
  TextGeometry: ju,
  TextBufferGeometry: ro,
  SphereGeometry: Bn,
  SphereBufferGeometry: ma,
  RingGeometry: qu,
  RingBufferGeometry: io,
  PlaneGeometry: wu,
  PlaneBufferGeometry: $a,
  LatheGeometry: Xu,
  LatheBufferGeometry: no,
  ShapeGeometry: es,
  ShapeBufferGeometry: ts,
  ExtrudeGeometry: Ja,
  ExtrudeBufferGeometry: bn,
  EdgesGeometry: ao,
  ConeGeometry: Yu,
  ConeBufferGeometry: Qu,
  CylinderGeometry: rs,
  CylinderBufferGeometry: zn,
  CircleGeometry: Ku,
  CircleBufferGeometry: so,
  BoxGeometry: ca,
  BoxBufferGeometry: Ka
});
function is(e) {
  ft.call(this), this.type = "ShadowMaterial", this.color = new je(0), this.transparent = !0, this.setValues(e);
}
is.prototype = Object.create(ft.prototype);
is.prototype.constructor = is;
is.prototype.isShadowMaterial = !0;
is.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.color.copy(e.color), this;
};
function oo(e) {
  Mi.call(this, e), this.type = "RawShaderMaterial";
}
oo.prototype = Object.create(Mi.prototype);
oo.prototype.constructor = oo;
oo.prototype.isRawShaderMaterial = !0;
function xn(e) {
  ft.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new je(16777215), this.roughness = 0.5, this.metalness = 0.5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
xn.prototype = Object.create(ft.prototype);
xn.prototype.constructor = xn;
xn.prototype.isMeshStandardMaterial = !0;
xn.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function ns(e) {
  xn.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = 0.5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e);
}
ns.prototype = Object.create(xn.prototype);
ns.prototype.constructor = ns;
ns.prototype.isMeshPhysicalMaterial = !0;
ns.prototype.copy = function(e) {
  return xn.prototype.copy.call(this, e), this.defines = { PHYSICAL: "" }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this;
};
function Yi(e) {
  ft.call(this), this.type = "MeshPhongMaterial", this.color = new je(16777215), this.specular = new je(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = bl, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
Yi.prototype = Object.create(ft.prototype);
Yi.prototype.constructor = Yi;
Yi.prototype.isMeshPhongMaterial = !0;
Yi.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function as(e) {
  Yi.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e);
}
as.prototype = Object.create(Yi.prototype);
as.prototype.constructor = as;
as.prototype.isMeshToonMaterial = !0;
as.prototype.copy = function(e) {
  return Yi.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this;
};
function ss(e) {
  ft.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
ss.prototype = Object.create(ft.prototype);
ss.prototype.constructor = ss;
ss.prototype.isMeshNormalMaterial = !0;
ss.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function os(e) {
  ft.call(this), this.type = "MeshLambertMaterial", this.color = new je(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = bl, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
os.prototype = Object.create(ft.prototype);
os.prototype.constructor = os;
os.prototype.isMeshLambertMaterial = !0;
os.prototype.copy = function(e) {
  return ft.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function us(e) {
  qt.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
}
us.prototype = Object.create(qt.prototype);
us.prototype.constructor = us;
us.prototype.isLineDashedMaterial = !0;
us.prototype.copy = function(e) {
  return qt.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
};
var lE = /* @__PURE__ */ Object.freeze({
  ShadowMaterial: is,
  SpriteMaterial: pa,
  RawShaderMaterial: oo,
  ShaderMaterial: Mi,
  PointsMaterial: Xi,
  MeshPhysicalMaterial: ns,
  MeshStandardMaterial: xn,
  MeshPhongMaterial: Yi,
  MeshToonMaterial: as,
  MeshNormalMaterial: ss,
  MeshLambertMaterial: os,
  MeshDepthMaterial: fa,
  MeshDistanceMaterial: da,
  MeshBasicMaterial: Er,
  LineDashedMaterial: us,
  LineBasicMaterial: qt,
  Material: ft
}), ls = {
  enabled: !1,
  files: {},
  add: function(e, t) {
    this.enabled !== !1 && (this.files[e] = t);
  },
  get: function(e) {
    if (this.enabled !== !1)
      return this.files[e];
  },
  remove: function(e) {
    delete this.files[e];
  },
  clear: function() {
    this.files = {};
  }
};
function Hd(e, t, r) {
  var n = this, i = !1, a = 0, s = 0, o = void 0;
  this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function(u) {
    s++, i === !1 && n.onStart !== void 0 && n.onStart(u, a, s), i = !0;
  }, this.itemEnd = function(u) {
    a++, n.onProgress !== void 0 && n.onProgress(u, a, s), a === s && (i = !1, n.onLoad !== void 0 && n.onLoad());
  }, this.itemError = function(u) {
    n.onError !== void 0 && n.onError(u);
  }, this.resolveURL = function(u) {
    return o ? o(u) : u;
  }, this.setURLModifier = function(u) {
    return o = u, this;
  };
}
var pi = new Hd(), Dn = {};
function tn(e) {
  this.manager = e !== void 0 ? e : pi;
}
Object.assign(tn.prototype, {
  load: function(e, t, r, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    var i = this, a = ls.get(e);
    if (a !== void 0)
      return i.manager.itemStart(e), setTimeout(function() {
        t && t(a), i.manager.itemEnd(e);
      }, 0), a;
    if (Dn[e] !== void 0) {
      Dn[e].push({
        onLoad: t,
        onProgress: r,
        onError: n
      });
      return;
    }
    var s = /^data:(.*?)(;base64)?,(.*)$/, o = e.match(s);
    if (o) {
      var u = o[1], l = !!o[2], c = o[3];
      c = window.decodeURIComponent(c), l && (c = window.atob(c));
      try {
        var h, f = (this.responseType || "").toLowerCase();
        switch (f) {
          case "arraybuffer":
          case "blob":
            for (var d = new Uint8Array(c.length), p = 0; p < c.length; p++)
              d[p] = c.charCodeAt(p);
            f === "blob" ? h = new Blob([d.buffer], { type: u }) : h = d.buffer;
            break;
          case "document":
            var _ = new DOMParser();
            h = _.parseFromString(c, u);
            break;
          case "json":
            h = JSON.parse(c);
            break;
          default:
            h = c;
            break;
        }
        window.setTimeout(function() {
          t && t(h), i.manager.itemEnd(e);
        }, 0);
      } catch (E) {
        window.setTimeout(function() {
          n && n(E), i.manager.itemEnd(e), i.manager.itemError(e);
        }, 0);
      }
    } else {
      Dn[e] = [], Dn[e].push({
        onLoad: t,
        onProgress: r,
        onError: n
      });
      var v = new XMLHttpRequest();
      v.open("GET", e, !0), v.addEventListener("load", function(E) {
        var M = this.response;
        ls.add(e, M);
        var C = Dn[e];
        if (delete Dn[e], this.status === 200 || this.status === 0) {
          this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received.");
          for (var R = 0, B = C.length; R < B; R++) {
            var k = C[R];
            k.onLoad && k.onLoad(M);
          }
          i.manager.itemEnd(e);
        } else {
          for (var R = 0, B = C.length; R < B; R++) {
            var k = C[R];
            k.onError && k.onError(E);
          }
          i.manager.itemEnd(e), i.manager.itemError(e);
        }
      }, !1), v.addEventListener("progress", function(E) {
        for (var M = Dn[e], C = 0, R = M.length; C < R; C++) {
          var B = M[C];
          B.onProgress && B.onProgress(E);
        }
      }, !1), v.addEventListener("error", function(E) {
        var M = Dn[e];
        delete Dn[e];
        for (var C = 0, R = M.length; C < R; C++) {
          var B = M[C];
          B.onError && B.onError(E);
        }
        i.manager.itemEnd(e), i.manager.itemError(e);
      }, !1), this.responseType !== void 0 && (v.responseType = this.responseType), this.withCredentials !== void 0 && (v.withCredentials = this.withCredentials), v.overrideMimeType && v.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (var x in this.requestHeader)
        v.setRequestHeader(x, this.requestHeader[x]);
      v.send(null);
    }
    return i.manager.itemStart(e), v;
  },
  setPath: function(e) {
    return this.path = e, this;
  },
  setResponseType: function(e) {
    return this.responseType = e, this;
  },
  setWithCredentials: function(e) {
    return this.withCredentials = e, this;
  },
  setMimeType: function(e) {
    return this.mimeType = e, this;
  },
  setRequestHeader: function(e) {
    return this.requestHeader = e, this;
  }
});
function ny(e) {
  this.manager = e !== void 0 ? e : pi, this._parser = null;
}
Object.assign(ny.prototype, {
  load: function(e, t, r, n) {
    var i = this, a = [], s = new Xs();
    s.image = a;
    var o = new tn(this.manager);
    o.setPath(this.path), o.setResponseType("arraybuffer");
    function u(f) {
      o.load(e[f], function(d) {
        var p = i._parser(d, !0);
        a[f] = {
          width: p.width,
          height: p.height,
          format: p.format,
          mipmaps: p.mipmaps
        }, l += 1, l === 6 && (p.mipmapCount === 1 && (s.minFilter = Vr), s.format = p.format, s.needsUpdate = !0, t && t(s));
      }, r, n);
    }
    if (Array.isArray(e))
      for (var l = 0, c = 0, h = e.length; c < h; ++c)
        u(c);
    else
      o.load(e, function(f) {
        var d = i._parser(f, !0);
        if (d.isCubemap)
          for (var p = d.mipmaps.length / d.mipmapCount, _ = 0; _ < p; _++) {
            a[_] = { mipmaps: [] };
            for (var v = 0; v < d.mipmapCount; v++)
              a[_].mipmaps.push(d.mipmaps[_ * d.mipmapCount + v]), a[_].format = d.format, a[_].width = d.width, a[_].height = d.height;
          }
        else
          s.image.width = d.width, s.image.height = d.height, s.mipmaps = d.mipmaps;
        d.mipmapCount === 1 && (s.minFilter = Vr), s.format = d.format, s.needsUpdate = !0, t && t(s);
      }, r, n);
    return s;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
function zd(e) {
  this.manager = e !== void 0 ? e : pi, this._parser = null;
}
Object.assign(zd.prototype, {
  load: function(e, t, r, n) {
    var i = this, a = new Xa(), s = new tn(this.manager);
    return s.setResponseType("arraybuffer"), s.load(e, function(o) {
      var u = i._parser(o);
      u && (u.image !== void 0 ? a.image = u.image : u.data !== void 0 && (a.image.width = u.width, a.image.height = u.height, a.image.data = u.data), a.wrapS = u.wrapS !== void 0 ? u.wrapS : Ei, a.wrapT = u.wrapT !== void 0 ? u.wrapT : Ei, a.magFilter = u.magFilter !== void 0 ? u.magFilter : Vr, a.minFilter = u.minFilter !== void 0 ? u.minFilter : xl, a.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1, u.format !== void 0 && (a.format = u.format), u.type !== void 0 && (a.type = u.type), u.mipmaps !== void 0 && (a.mipmaps = u.mipmaps), u.mipmapCount === 1 && (a.minFilter = Vr), a.needsUpdate = !0, t && t(a, u));
    }, r, n), a;
  }
});
function Al(e) {
  this.manager = e !== void 0 ? e : pi;
}
Object.assign(Al.prototype, {
  crossOrigin: "Anonymous",
  load: function(e, t, r, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    var i = this, a = ls.get(e);
    if (a !== void 0)
      return i.manager.itemStart(e), setTimeout(function() {
        t && t(a), i.manager.itemEnd(e);
      }, 0), a;
    var s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function o() {
      s.removeEventListener("load", o, !1), s.removeEventListener("error", u, !1), ls.add(e, this), t && t(this), i.manager.itemEnd(e);
    }
    function u(l) {
      s.removeEventListener("load", o, !1), s.removeEventListener("error", u, !1), n && n(l), i.manager.itemEnd(e), i.manager.itemError(e);
    }
    return s.addEventListener("load", o, !1), s.addEventListener("error", u, !1), e.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (s.crossOrigin = this.crossOrigin), i.manager.itemStart(e), s.src = e, s;
  },
  setCrossOrigin: function(e) {
    return this.crossOrigin = e, this;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
function Wd(e) {
  this.manager = e !== void 0 ? e : pi;
}
Object.assign(Wd.prototype, {
  crossOrigin: "Anonymous",
  load: function(e, t, r, n) {
    var i = new ha(), a = new Al(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    var s = 0;
    function o(l) {
      a.load(e[l], function(c) {
        i.images[l] = c, s++, s === 6 && (i.needsUpdate = !0, t && t(i));
      }, void 0, n);
    }
    for (var u = 0; u < e.length; ++u)
      o(u);
    return i;
  },
  setCrossOrigin: function(e) {
    return this.crossOrigin = e, this;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
function vh(e) {
  this.manager = e !== void 0 ? e : pi;
}
Object.assign(vh.prototype, {
  crossOrigin: "Anonymous",
  load: function(e, t, r, n) {
    var i = new ir(), a = new Al(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(s) {
      i.image = s;
      var o = e.search(/\.(jpg|jpeg)$/) > 0 || e.search(/^data\:image\/jpeg/) === 0;
      i.format = o ? Wa : yn, i.needsUpdate = !0, t !== void 0 && t(i);
    }, r, n), i;
  },
  setCrossOrigin: function(e) {
    return this.crossOrigin = e, this;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
function Ye() {
  this.type = "Curve", this.arcLengthDivisions = 200;
}
Object.assign(Ye.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function(e, t) {
    var r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function(e) {
    e === void 0 && (e = 5);
    for (var t = [], r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function(e) {
    e === void 0 && (e = 5);
    for (var t = [], r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  },
  // Get total curve arc length
  getLength: function() {
    var e = this.getLengths();
    return e[e.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function(e) {
    if (e === void 0 && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    var t = [], r, n = this.getPoint(0), i, a = 0;
    for (t.push(0), i = 1; i <= e; i++)
      r = this.getPoint(i / e), a += r.distanceTo(n), t.push(a), n = r;
    return this.cacheArcLengths = t, t;
  },
  updateArcLengths: function() {
    this.needsUpdate = !0, this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function(e, t) {
    var r = this.getLengths(), n = 0, i = r.length, a;
    t ? a = t : a = e * r[i - 1];
    for (var s = 0, o = i - 1, u; s <= o; )
      if (n = Math.floor(s + (o - s) / 2), u = r[n] - a, u < 0)
        s = n + 1;
      else if (u > 0)
        o = n - 1;
      else {
        o = n;
        break;
      }
    if (n = o, r[n] === a)
      return n / (i - 1);
    var l = r[n], c = r[n + 1], h = c - l, f = (a - l) / h, d = (n + f) / (i - 1);
    return d;
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function(e) {
    var t = 1e-4, r = e - t, n = e + t;
    r < 0 && (r = 0), n > 1 && (n = 1);
    var i = this.getPoint(r), a = this.getPoint(n), s = a.clone().sub(i);
    return s.normalize();
  },
  getTangentAt: function(e) {
    var t = this.getUtoTmapping(e);
    return this.getTangent(t);
  },
  computeFrenetFrames: function(e, t) {
    var r = new z(), n = [], i = [], a = [], s = new z(), o = new at(), u, l, c;
    for (u = 0; u <= e; u++)
      l = u / e, n[u] = this.getTangentAt(l), n[u].normalize();
    i[0] = new z(), a[0] = new z();
    var h = Number.MAX_VALUE, f = Math.abs(n[0].x), d = Math.abs(n[0].y), p = Math.abs(n[0].z);
    for (f <= h && (h = f, r.set(1, 0, 0)), d <= h && (h = d, r.set(0, 1, 0)), p <= h && r.set(0, 0, 1), s.crossVectors(n[0], r).normalize(), i[0].crossVectors(n[0], s), a[0].crossVectors(n[0], i[0]), u = 1; u <= e; u++)
      i[u] = i[u - 1].clone(), a[u] = a[u - 1].clone(), s.crossVectors(n[u - 1], n[u]), s.length() > Number.EPSILON && (s.normalize(), c = Math.acos(gt.clamp(n[u - 1].dot(n[u]), -1, 1)), i[u].applyMatrix4(o.makeRotationAxis(s, c))), a[u].crossVectors(n[u], i[u]);
    if (t === !0)
      for (c = Math.acos(gt.clamp(i[0].dot(i[e]), -1, 1)), c /= e, n[0].dot(s.crossVectors(i[0], i[e])) > 0 && (c = -c), u = 1; u <= e; u++)
        i[u].applyMatrix4(o.makeRotationAxis(n[u], c * u)), a[u].crossVectors(n[u], i[u]);
    return {
      tangents: n,
      normals: i,
      binormals: a
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  },
  toJSON: function() {
    var e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  },
  fromJSON: function(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
});
function Di(e, t, r, n, i, a, s, o) {
  Ye.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = r || 1, this.yRadius = n || 1, this.aStartAngle = i || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = o || 0;
}
Di.prototype = Object.create(Ye.prototype);
Di.prototype.constructor = Di;
Di.prototype.isEllipseCurve = !0;
Di.prototype.getPoint = function(e, t) {
  for (var r = t || new ue(), n = Math.PI * 2, i = this.aEndAngle - this.aStartAngle, a = Math.abs(i) < Number.EPSILON; i < 0; ) i += n;
  for (; i > n; ) i -= n;
  i < Number.EPSILON && (a ? i = 0 : i = n), this.aClockwise === !0 && !a && (i === n ? i = -n : i = i - n);
  var s = this.aStartAngle + e * i, o = this.aX + this.xRadius * Math.cos(s), u = this.aY + this.yRadius * Math.sin(s);
  if (this.aRotation !== 0) {
    var l = Math.cos(this.aRotation), c = Math.sin(this.aRotation), h = o - this.aX, f = u - this.aY;
    o = h * l - f * c + this.aX, u = h * c + f * l + this.aY;
  }
  return r.set(o, u);
};
Di.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
};
Di.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
};
Di.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
};
function uo(e, t, r, n, i, a) {
  Di.call(this, e, t, r, r, n, i, a), this.type = "ArcCurve";
}
uo.prototype = Object.create(Di.prototype);
uo.prototype.constructor = uo;
uo.prototype.isArcCurve = !0;
function jd() {
  var e = 0, t = 0, r = 0, n = 0;
  function i(a, s, o, u) {
    e = a, t = o, r = -3 * a + 3 * s - 2 * o - u, n = 2 * a - 2 * s + o + u;
  }
  return {
    initCatmullRom: function(a, s, o, u, l) {
      i(s, o, l * (o - a), l * (u - s));
    },
    initNonuniformCatmullRom: function(a, s, o, u, l, c, h) {
      var f = (s - a) / l - (o - a) / (l + c) + (o - s) / c, d = (o - s) / c - (u - s) / (c + h) + (u - o) / h;
      f *= c, d *= c, i(s, o, f, d);
    },
    calc: function(a) {
      var s = a * a, o = s * a;
      return e + t * a + r * s + n * o;
    }
  };
}
var Nl = new z(), Xh = new jd(), Yh = new jd(), Qh = new jd();
function Wr(e, t, r, n) {
  Ye.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = r || "centripetal", this.tension = n || 0.5;
}
Wr.prototype = Object.create(Ye.prototype);
Wr.prototype.constructor = Wr;
Wr.prototype.isCatmullRomCurve3 = !0;
Wr.prototype.getPoint = function(e, t) {
  var r = t || new z(), n = this.points, i = n.length, a = (i - (this.closed ? 0 : 1)) * e, s = Math.floor(a), o = a - s;
  this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / i) + 1) * i : o === 0 && s === i - 1 && (s = i - 2, o = 1);
  var u, l, c, h;
  if (this.closed || s > 0 ? u = n[(s - 1) % i] : (Nl.subVectors(n[0], n[1]).add(n[0]), u = Nl), l = n[s % i], c = n[(s + 1) % i], this.closed || s + 2 < i ? h = n[(s + 2) % i] : (Nl.subVectors(n[i - 1], n[i - 2]).add(n[i - 1]), h = Nl), this.curveType === "centripetal" || this.curveType === "chordal") {
    var f = this.curveType === "chordal" ? 0.5 : 0.25, d = Math.pow(u.distanceToSquared(l), f), p = Math.pow(l.distanceToSquared(c), f), _ = Math.pow(c.distanceToSquared(h), f);
    p < 1e-4 && (p = 1), d < 1e-4 && (d = p), _ < 1e-4 && (_ = p), Xh.initNonuniformCatmullRom(u.x, l.x, c.x, h.x, d, p, _), Yh.initNonuniformCatmullRom(u.y, l.y, c.y, h.y, d, p, _), Qh.initNonuniformCatmullRom(u.z, l.z, c.z, h.z, d, p, _);
  } else this.curveType === "catmullrom" && (Xh.initCatmullRom(u.x, l.x, c.x, h.x, this.tension), Yh.initCatmullRom(u.y, l.y, c.y, h.y, this.tension), Qh.initCatmullRom(u.z, l.z, c.z, h.z, this.tension));
  return r.set(
    Xh.calc(o),
    Yh.calc(o),
    Qh.calc(o)
  ), r;
};
Wr.prototype.copy = function(e) {
  Ye.prototype.copy.call(this, e), this.points = [];
  for (var t = 0, r = e.points.length; t < r; t++) {
    var n = e.points[t];
    this.points.push(n.clone());
  }
  return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
};
Wr.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  e.points = [];
  for (var t = 0, r = this.points.length; t < r; t++) {
    var n = this.points[t];
    e.points.push(n.toArray());
  }
  return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
};
Wr.prototype.fromJSON = function(e) {
  Ye.prototype.fromJSON.call(this, e), this.points = [];
  for (var t = 0, r = e.points.length; t < r; t++) {
    var n = e.points[t];
    this.points.push(new z().fromArray(n));
  }
  return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
};
function Ym(e, t, r, n, i) {
  var a = (n - t) * 0.5, s = (i - r) * 0.5, o = e * e, u = e * o;
  return (2 * r - 2 * n + a + s) * u + (-3 * r + 3 * n - 2 * a - s) * o + a * e + r;
}
function cE(e, t) {
  var r = 1 - e;
  return r * r * t;
}
function hE(e, t) {
  return 2 * (1 - e) * e * t;
}
function fE(e, t) {
  return e * e * t;
}
function uu(e, t, r, n) {
  return cE(e, t) + hE(e, r) + fE(e, n);
}
function dE(e, t) {
  var r = 1 - e;
  return r * r * r * t;
}
function pE(e, t) {
  var r = 1 - e;
  return 3 * r * r * e * t;
}
function mE(e, t) {
  return 3 * (1 - e) * e * e * t;
}
function vE(e, t) {
  return e * e * e * t;
}
function lu(e, t, r, n, i) {
  return dE(e, t) + pE(e, r) + mE(e, n) + vE(e, i);
}
function Qi(e, t, r, n) {
  Ye.call(this), this.type = "CubicBezierCurve", this.v0 = e || new ue(), this.v1 = t || new ue(), this.v2 = r || new ue(), this.v3 = n || new ue();
}
Qi.prototype = Object.create(Ye.prototype);
Qi.prototype.constructor = Qi;
Qi.prototype.isCubicBezierCurve = !0;
Qi.prototype.getPoint = function(e, t) {
  var r = t || new ue(), n = this.v0, i = this.v1, a = this.v2, s = this.v3;
  return r.set(
    lu(e, n.x, i.x, a.x, s.x),
    lu(e, n.y, i.y, a.y, s.y)
  ), r;
};
Qi.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
};
Qi.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
};
Qi.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
};
function An(e, t, r, n) {
  Ye.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new z(), this.v1 = t || new z(), this.v2 = r || new z(), this.v3 = n || new z();
}
An.prototype = Object.create(Ye.prototype);
An.prototype.constructor = An;
An.prototype.isCubicBezierCurve3 = !0;
An.prototype.getPoint = function(e, t) {
  var r = t || new z(), n = this.v0, i = this.v1, a = this.v2, s = this.v3;
  return r.set(
    lu(e, n.x, i.x, a.x, s.x),
    lu(e, n.y, i.y, a.y, s.y),
    lu(e, n.z, i.z, a.z, s.z)
  ), r;
};
An.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
};
An.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
};
An.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
};
function di(e, t) {
  Ye.call(this), this.type = "LineCurve", this.v1 = e || new ue(), this.v2 = t || new ue();
}
di.prototype = Object.create(Ye.prototype);
di.prototype.constructor = di;
di.prototype.isLineCurve = !0;
di.prototype.getPoint = function(e, t) {
  var r = t || new ue();
  return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
};
di.prototype.getPointAt = function(e, t) {
  return this.getPoint(e, t);
};
di.prototype.getTangent = function() {
  var e = this.v2.clone().sub(this.v1);
  return e.normalize();
};
di.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
di.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
di.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function Ki(e, t) {
  Ye.call(this), this.type = "LineCurve3", this.v1 = e || new z(), this.v2 = t || new z();
}
Ki.prototype = Object.create(Ye.prototype);
Ki.prototype.constructor = Ki;
Ki.prototype.isLineCurve3 = !0;
Ki.prototype.getPoint = function(e, t) {
  var r = t || new z();
  return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
};
Ki.prototype.getPointAt = function(e, t) {
  return this.getPoint(e, t);
};
Ki.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
Ki.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
Ki.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function $i(e, t, r) {
  Ye.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new ue(), this.v1 = t || new ue(), this.v2 = r || new ue();
}
$i.prototype = Object.create(Ye.prototype);
$i.prototype.constructor = $i;
$i.prototype.isQuadraticBezierCurve = !0;
$i.prototype.getPoint = function(e, t) {
  var r = t || new ue(), n = this.v0, i = this.v1, a = this.v2;
  return r.set(
    uu(e, n.x, i.x, a.x),
    uu(e, n.y, i.y, a.y)
  ), r;
};
$i.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
$i.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
$i.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function Tn(e, t, r) {
  Ye.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new z(), this.v1 = t || new z(), this.v2 = r || new z();
}
Tn.prototype = Object.create(Ye.prototype);
Tn.prototype.constructor = Tn;
Tn.prototype.isQuadraticBezierCurve3 = !0;
Tn.prototype.getPoint = function(e, t) {
  var r = t || new z(), n = this.v0, i = this.v1, a = this.v2;
  return r.set(
    uu(e, n.x, i.x, a.x),
    uu(e, n.y, i.y, a.y),
    uu(e, n.z, i.z, a.z)
  ), r;
};
Tn.prototype.copy = function(e) {
  return Ye.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
Tn.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
Tn.prototype.fromJSON = function(e) {
  return Ye.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function Zi(e) {
  Ye.call(this), this.type = "SplineCurve", this.points = e || [];
}
Zi.prototype = Object.create(Ye.prototype);
Zi.prototype.constructor = Zi;
Zi.prototype.isSplineCurve = !0;
Zi.prototype.getPoint = function(e, t) {
  var r = t || new ue(), n = this.points, i = (n.length - 1) * e, a = Math.floor(i), s = i - a, o = n[a === 0 ? a : a - 1], u = n[a], l = n[a > n.length - 2 ? n.length - 1 : a + 1], c = n[a > n.length - 3 ? n.length - 1 : a + 2];
  return r.set(
    Ym(s, o.x, u.x, l.x, c.x),
    Ym(s, o.y, u.y, l.y, c.y)
  ), r;
};
Zi.prototype.copy = function(e) {
  Ye.prototype.copy.call(this, e), this.points = [];
  for (var t = 0, r = e.points.length; t < r; t++) {
    var n = e.points[t];
    this.points.push(n.clone());
  }
  return this;
};
Zi.prototype.toJSON = function() {
  var e = Ye.prototype.toJSON.call(this);
  e.points = [];
  for (var t = 0, r = this.points.length; t < r; t++) {
    var n = this.points[t];
    e.points.push(n.toArray());
  }
  return e;
};
Zi.prototype.fromJSON = function(e) {
  Ye.prototype.fromJSON.call(this, e), this.points = [];
  for (var t = 0, r = e.points.length; t < r; t++) {
    var n = e.points[t];
    this.points.push(new ue().fromArray(n));
  }
  return this;
};
var ay = /* @__PURE__ */ Object.freeze({
  ArcCurve: uo,
  CatmullRomCurve3: Wr,
  CubicBezierCurve: Qi,
  CubicBezierCurve3: An,
  EllipseCurve: Di,
  LineCurve: di,
  LineCurve3: Ki,
  QuadraticBezierCurve: $i,
  QuadraticBezierCurve3: Tn,
  SplineCurve: Zi
});
function Fn() {
  Ye.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
}
Fn.prototype = Object.assign(Object.create(Ye.prototype), {
  constructor: Fn,
  add: function(e) {
    this.curves.push(e);
  },
  closePath: function() {
    var e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new di(t, e));
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function(e) {
    for (var t = e * this.getLength(), r = this.getCurveLengths(), n = 0; n < r.length; ) {
      if (r[n] >= t) {
        var i = r[n] - t, a = this.curves[n], s = a.getLength(), o = s === 0 ? 0 : 1 - i / s;
        return a.getPointAt(o);
      }
      n++;
    }
    return null;
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function() {
    var e = this.getCurveLengths();
    return e[e.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    for (var e = [], t = 0, r = 0, n = this.curves.length; r < n; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  },
  getSpacedPoints: function(e) {
    e === void 0 && (e = 40);
    for (var t = [], r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  },
  getPoints: function(e) {
    e = e || 12;
    for (var t = [], r, n = 0, i = this.curves; n < i.length; n++)
      for (var a = i[n], s = a && a.isEllipseCurve ? e * 2 : a && a.isLineCurve ? 1 : a && a.isSplineCurve ? e * a.points.length : e, o = a.getPoints(s), u = 0; u < o.length; u++) {
        var l = o[u];
        r && r.equals(l) || (t.push(l), r = l);
      }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  },
  copy: function(e) {
    Ye.prototype.copy.call(this, e), this.curves = [];
    for (var t = 0, r = e.curves.length; t < r; t++) {
      var n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  },
  toJSON: function() {
    var e = Ye.prototype.toJSON.call(this);
    e.autoClose = this.autoClose, e.curves = [];
    for (var t = 0, r = this.curves.length; t < r; t++) {
      var n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  },
  fromJSON: function(e) {
    Ye.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
    for (var t = 0, r = e.curves.length; t < r; t++) {
      var n = e.curves[t];
      this.curves.push(new ay[n.type]().fromJSON(n));
    }
    return this;
  }
});
function zi(e) {
  Fn.call(this), this.type = "Path", this.currentPoint = new ue(), e && this.setFromPoints(e);
}
zi.prototype = Object.assign(Object.create(Fn.prototype), {
  constructor: zi,
  setFromPoints: function(e) {
    this.moveTo(e[0].x, e[0].y);
    for (var t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
  },
  moveTo: function(e, t) {
    this.currentPoint.set(e, t);
  },
  lineTo: function(e, t) {
    var r = new di(this.currentPoint.clone(), new ue(e, t));
    this.curves.push(r), this.currentPoint.set(e, t);
  },
  quadraticCurveTo: function(e, t, r, n) {
    var i = new $i(
      this.currentPoint.clone(),
      new ue(e, t),
      new ue(r, n)
    );
    this.curves.push(i), this.currentPoint.set(r, n);
  },
  bezierCurveTo: function(e, t, r, n, i, a) {
    var s = new Qi(
      this.currentPoint.clone(),
      new ue(e, t),
      new ue(r, n),
      new ue(i, a)
    );
    this.curves.push(s), this.currentPoint.set(i, a);
  },
  splineThru: function(e) {
    var t = [this.currentPoint.clone()].concat(e), r = new Zi(t);
    this.curves.push(r), this.currentPoint.copy(e[e.length - 1]);
  },
  arc: function(e, t, r, n, i, a) {
    var s = this.currentPoint.x, o = this.currentPoint.y;
    this.absarc(
      e + s,
      t + o,
      r,
      n,
      i,
      a
    );
  },
  absarc: function(e, t, r, n, i, a) {
    this.absellipse(e, t, r, r, n, i, a);
  },
  ellipse: function(e, t, r, n, i, a, s, o) {
    var u = this.currentPoint.x, l = this.currentPoint.y;
    this.absellipse(e + u, t + l, r, n, i, a, s, o);
  },
  absellipse: function(e, t, r, n, i, a, s, o) {
    var u = new Di(e, t, r, n, i, a, s, o);
    if (this.curves.length > 0) {
      var l = u.getPoint(0);
      l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
    }
    this.curves.push(u);
    var c = u.getPoint(1);
    this.currentPoint.copy(c);
  },
  copy: function(e) {
    return Fn.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this;
  },
  toJSON: function() {
    var e = Fn.prototype.toJSON.call(this);
    return e.currentPoint = this.currentPoint.toArray(), e;
  },
  fromJSON: function(e) {
    return Fn.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this;
  }
});
function la(e) {
  zi.call(this, e), this.uuid = gt.generateUUID(), this.type = "Shape", this.holes = [];
}
la.prototype = Object.assign(Object.create(zi.prototype), {
  constructor: la,
  getPointsHoles: function(e) {
    for (var t = [], r = 0, n = this.holes.length; r < n; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  },
  copy: function(e) {
    zi.prototype.copy.call(this, e), this.holes = [];
    for (var t = 0, r = e.holes.length; t < r; t++) {
      var n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  },
  toJSON: function() {
    var e = zi.prototype.toJSON.call(this);
    e.uuid = this.uuid, e.holes = [];
    for (var t = 0, r = this.holes.length; t < r; t++) {
      var n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  },
  fromJSON: function(e) {
    zi.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
    for (var t = 0, r = e.holes.length; t < r; t++) {
      var n = e.holes[t];
      this.holes.push(new zi().fromJSON(n));
    }
    return this;
  }
});
function ur(e, t) {
  ke.call(this), this.type = "Light", this.color = new je(e), this.intensity = t !== void 0 ? t : 1, this.receiveShadow = void 0;
}
ur.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: ur,
  isLight: !0,
  copy: function(e) {
    return ke.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this;
  },
  toJSON: function(e) {
    var t = ke.prototype.toJSON.call(this, e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
});
function vc(e, t, r) {
  ur.call(this, e, r), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(ke.DefaultUp), this.updateMatrix(), this.groundColor = new je(t);
}
vc.prototype = Object.assign(Object.create(ur.prototype), {
  constructor: vc,
  isHemisphereLight: !0,
  copy: function(e) {
    return ur.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this;
  }
});
function vs(e) {
  this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new ue(512, 512), this.map = null, this.matrix = new at();
}
Object.assign(vs.prototype, {
  copy: function(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    var e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
});
function gc() {
  vs.call(this, new or(50, 1, 0.5, 500));
}
gc.prototype = Object.assign(Object.create(vs.prototype), {
  constructor: gc,
  isSpotLightShadow: !0,
  update: function(e) {
    var t = this.camera, r = gt.RAD2DEG * 2 * e.angle, n = this.mapSize.width / this.mapSize.height, i = e.distance || t.far;
    (r !== t.fov || n !== t.aspect || i !== t.far) && (t.fov = r, t.aspect = n, t.far = i, t.updateProjectionMatrix());
  }
});
function yc(e, t, r, n, i, a) {
  ur.call(this, e, t), this.type = "SpotLight", this.position.copy(ke.DefaultUp), this.updateMatrix(), this.target = new ke(), Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(s) {
      this.intensity = s / Math.PI;
    }
  }), this.distance = r !== void 0 ? r : 0, this.angle = n !== void 0 ? n : Math.PI / 3, this.penumbra = i !== void 0 ? i : 0, this.decay = a !== void 0 ? a : 1, this.shadow = new gc();
}
yc.prototype = Object.assign(Object.create(ur.prototype), {
  constructor: yc,
  isSpotLight: !0,
  copy: function(e) {
    return ur.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
});
function _c(e, t, r, n) {
  ur.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(i) {
      this.intensity = i / (4 * Math.PI);
    }
  }), this.distance = r !== void 0 ? r : 0, this.decay = n !== void 0 ? n : 1, this.shadow = new vs(new or(90, 1, 0.5, 500));
}
_c.prototype = Object.assign(Object.create(ur.prototype), {
  constructor: _c,
  isPointLight: !0,
  copy: function(e) {
    return ur.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
});
function bc() {
  vs.call(this, new Hs(-5, 5, 5, -5, 0.5, 500));
}
bc.prototype = Object.assign(Object.create(vs.prototype), {
  constructor: bc
});
function xc(e, t) {
  ur.call(this, e, t), this.type = "DirectionalLight", this.position.copy(ke.DefaultUp), this.updateMatrix(), this.target = new ke(), this.shadow = new bc();
}
xc.prototype = Object.assign(Object.create(ur.prototype), {
  constructor: xc,
  isDirectionalLight: !0,
  copy: function(e) {
    return ur.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
});
function Ac(e, t) {
  ur.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0;
}
Ac.prototype = Object.assign(Object.create(ur.prototype), {
  constructor: Ac,
  isAmbientLight: !0
});
function Tc(e, t, r, n) {
  ur.call(this, e, t), this.type = "RectAreaLight", this.width = r !== void 0 ? r : 10, this.height = n !== void 0 ? n : 10;
}
Tc.prototype = Object.assign(Object.create(ur.prototype), {
  constructor: Tc,
  isRectAreaLight: !0,
  copy: function(e) {
    return ur.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this;
  },
  toJSON: function(e) {
    var t = ur.prototype.toJSON.call(this, e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
});
function Ec(e, t, r, n) {
  Sr.call(this, e, t, r, n);
}
Ec.prototype = Object.assign(Object.create(Sr.prototype), {
  constructor: Ec,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: vu,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function wc(e, t, r) {
  Sr.call(this, e, t, r);
}
wc.prototype = Object.assign(Object.create(Sr.prototype), {
  constructor: wc,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: vu,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
  // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".
});
function Ci(e, t, r, n) {
  this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(r), this.sampleValues = t, this.valueSize = r;
}
Object.assign(Ci.prototype, {
  evaluate: function(e) {
    var t = this.parameterPositions, r = this._cachedIndex, n = t[r], i = t[r - 1];
    e: {
      t: {
        var a;
        r: {
          i: if (!(e < n)) {
            for (var s = r + 2; ; ) {
              if (n === void 0) {
                if (e < i) break i;
                return r = t.length, this._cachedIndex = r, this.afterEnd_(r - 1, e, i);
              }
              if (r === s) break;
              if (i = n, n = t[++r], e < n)
                break t;
            }
            a = t.length;
            break r;
          }
          if (!(e >= i)) {
            var o = t[1];
            e < o && (r = 2, i = o);
            for (var s = r - 2; ; ) {
              if (i === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, e, n);
              if (r === s) break;
              if (n = i, i = t[--r - 1], e >= i)
                break t;
            }
            a = r, r = 0;
            break r;
          }
          break e;
        }
        for (; r < a; ) {
          var u = r + a >>> 1;
          e < t[u] ? a = u : r = u + 1;
        }
        if (n = t[r], i = t[r - 1], i === void 0)
          return this._cachedIndex = 0, this.beforeStart_(0, e, n);
        if (n === void 0)
          return r = t.length, this._cachedIndex = r, this.afterEnd_(r - 1, i, e);
      }
      this._cachedIndex = r, this.intervalChanged_(r, i, n);
    }
    return this.interpolate_(r, i, e, n);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(e) {
    for (var t = this.resultBuffer, r = this.sampleValues, n = this.valueSize, i = e * n, a = 0; a !== n; ++a)
      t[a] = r[i + a];
    return t;
  },
  // Template methods for derived classes:
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Ci.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Ci.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Ci.prototype.copySampleValue_
});
function Sc(e, t, r, n) {
  Ci.call(this, e, t, r, n);
}
Sc.prototype = Object.assign(Object.create(Ci.prototype), {
  constructor: Sc,
  interpolate_: function(e, t, r, n) {
    for (var i = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, u = (r - t) / (n - t), l = o + s; o !== l; o += 4)
      _r.slerpFlat(i, 0, a, o - s, a, o, u);
    return i;
  }
});
function $u(e, t, r, n) {
  Sr.call(this, e, t, r, n);
}
$u.prototype = Object.assign(Object.create(Sr.prototype), {
  constructor: $u,
  ValueTypeName: "quaternion",
  // ValueBufferType is inherited
  DefaultInterpolation: ou,
  InterpolantFactoryMethodLinear: function(e) {
    return new Sc(this.times, this.values, this.getValueSize(), e);
  },
  InterpolantFactoryMethodSmooth: void 0
  // not yet implemented
});
function Cc(e, t, r, n) {
  Sr.call(this, e, t, r, n);
}
Cc.prototype = Object.assign(Object.create(Sr.prototype), {
  constructor: Cc,
  ValueTypeName: "color"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.
});
function lo(e, t, r, n) {
  Sr.call(this, e, t, r, n);
}
lo.prototype = Object.assign(Object.create(Sr.prototype), {
  constructor: lo,
  ValueTypeName: "number"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function Mc(e, t, r, n) {
  Ci.call(this, e, t, r, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
}
Mc.prototype = Object.assign(Object.create(Ci.prototype), {
  constructor: Mc,
  DefaultSettings_: {
    endingStart: ja,
    endingEnd: ja
  },
  intervalChanged_: function(e, t, r) {
    var n = this.parameterPositions, i = e - 2, a = e + 1, s = n[i], o = n[a];
    if (s === void 0)
      switch (this.getSettings_().endingStart) {
        case Ia:
          i = e, s = 2 * t - r;
          break;
        case gu:
          i = n.length - 2, s = t + n[i] - n[i + 1];
          break;
        default:
          i = e, s = r;
      }
    if (o === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ia:
          a = e, o = 2 * r - t;
          break;
        case gu:
          a = 1, o = r + n[1] - n[0];
          break;
        default:
          a = e - 1, o = t;
      }
    var u = (r - t) * 0.5, l = this.valueSize;
    this._weightPrev = u / (t - s), this._weightNext = u / (o - r), this._offsetPrev = i * l, this._offsetNext = a * l;
  },
  interpolate_: function(e, t, r, n) {
    for (var i = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, u = o - s, l = this._offsetPrev, c = this._offsetNext, h = this._weightPrev, f = this._weightNext, d = (r - t) / (n - t), p = d * d, _ = p * d, v = -h * _ + 2 * h * p - h * d, x = (1 + h) * _ + (-1.5 - 2 * h) * p + (-0.5 + h) * d + 1, E = (-1 - f) * _ + (1.5 + f) * p + 0.5 * d, M = f * _ - f * p, C = 0; C !== s; ++C)
      i[C] = v * a[l + C] + x * a[u + C] + E * a[o + C] + M * a[c + C];
    return i;
  }
});
function Zu(e, t, r, n) {
  Ci.call(this, e, t, r, n);
}
Zu.prototype = Object.assign(Object.create(Ci.prototype), {
  constructor: Zu,
  interpolate_: function(e, t, r, n) {
    for (var i = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, u = o - s, l = (r - t) / (n - t), c = 1 - l, h = 0; h !== s; ++h)
      i[h] = a[u + h] * c + a[o + h] * l;
    return i;
  }
});
function Dc(e, t, r, n) {
  Ci.call(this, e, t, r, n);
}
Dc.prototype = Object.assign(Object.create(Ci.prototype), {
  constructor: Dc,
  interpolate_: function(e) {
    return this.copySampleValue_(e - 1);
  }
});
var Gr = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(e, t, r) {
    return Gr.isTypedArray(e) ? new e.constructor(e.subarray(t, r !== void 0 ? r : e.length)) : e.slice(t, r);
  },
  // converts an array to a specific type
  convertArray: function(e, t, r) {
    return !e || // let 'undefined' and 'null' pass
    !r && e.constructor === t ? e : typeof t.BYTES_PER_ELEMENT == "number" ? new t(e) : Array.prototype.slice.call(e);
  },
  isTypedArray: function(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(e) {
    function t(a, s) {
      return e[a] - e[s];
    }
    for (var r = e.length, n = new Array(r), i = 0; i !== r; ++i) n[i] = i;
    return n.sort(t), n;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(e, t, r) {
    for (var n = e.length, i = new e.constructor(n), a = 0, s = 0; s !== n; ++a)
      for (var o = r[a] * t, u = 0; u !== t; ++u)
        i[s++] = e[o + u];
    return i;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(e, t, r, n) {
    for (var i = 1, a = e[0]; a !== void 0 && a[n] === void 0; )
      a = e[i++];
    if (a !== void 0) {
      var s = a[n];
      if (s !== void 0)
        if (Array.isArray(s))
          do
            s = a[n], s !== void 0 && (t.push(a.time), r.push.apply(r, s)), a = e[i++];
          while (a !== void 0);
        else if (s.toArray !== void 0)
          do
            s = a[n], s !== void 0 && (t.push(a.time), s.toArray(r, r.length)), a = e[i++];
          while (a !== void 0);
        else
          do
            s = a[n], s !== void 0 && (t.push(a.time), r.push(s)), a = e[i++];
          while (a !== void 0);
    }
  }
};
function Sr(e, t, r, n) {
  if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
  this.name = e, this.times = Gr.convertArray(t, this.TimeBufferType), this.values = Gr.convertArray(r, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation), this.validate(), this.optimize();
}
Object.assign(Sr, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  parse: function(e) {
    if (e.type === void 0)
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var t = Sr._getTrackTypeForValueTypeName(e.type);
    if (e.times === void 0) {
      var r = [], n = [];
      Gr.flattenJSON(e.keys, r, n, "value"), e.times = r, e.values = n;
    }
    return t.parse !== void 0 ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
  },
  toJSON: function(e) {
    var t = e.constructor, r;
    if (t.toJSON !== void 0)
      r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: Gr.convertArray(e.times, Array),
        values: Gr.convertArray(e.values, Array)
      };
      var n = e.getInterpolation();
      n !== e.DefaultInterpolation && (r.interpolation = n);
    }
    return r.type = e.ValueTypeName, r;
  },
  _getTrackTypeForValueTypeName: function(e) {
    switch (e.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return lo;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return co;
      case "color":
        return Cc;
      case "quaternion":
        return $u;
      case "bool":
      case "boolean":
        return wc;
      case "string":
        return Ec;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
  }
});
Object.assign(Sr.prototype, {
  constructor: Sr,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: ou,
  InterpolantFactoryMethodDiscrete: function(e) {
    return new Dc(this.times, this.values, this.getValueSize(), e);
  },
  InterpolantFactoryMethodLinear: function(e) {
    return new Zu(this.times, this.values, this.getValueSize(), e);
  },
  InterpolantFactoryMethodSmooth: function(e) {
    return new Mc(this.times, this.values, this.getValueSize(), e);
  },
  setInterpolation: function(e) {
    var t;
    switch (e) {
      case vu:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case ou:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Jl:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      var r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(r);
      console.warn("THREE.KeyframeTrack:", r);
      return;
    }
    this.createInterpolant = t;
  },
  getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return vu;
      case this.InterpolantFactoryMethodLinear:
        return ou;
      case this.InterpolantFactoryMethodSmooth:
        return Jl;
    }
  },
  getValueSize: function() {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function(e) {
    if (e !== 0)
      for (var t = this.times, r = 0, n = t.length; r !== n; ++r)
        t[r] += e;
    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function(e) {
    if (e !== 1)
      for (var t = this.times, r = 0, n = t.length; r !== n; ++r)
        t[r] *= e;
    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function(e, t) {
    for (var r = this.times, n = r.length, i = 0, a = n - 1; i !== n && r[i] < e; )
      ++i;
    for (; a !== -1 && r[a] > t; )
      --a;
    if (++a, i !== 0 || a !== n) {
      i >= a && (a = Math.max(a, 1), i = a - 1);
      var s = this.getValueSize();
      this.times = Gr.arraySlice(r, i, a), this.values = Gr.arraySlice(this.values, i * s, a * s);
    }
    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function() {
    var e = !0, t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    var r = this.times, n = this.values, i = r.length;
    i === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    for (var a = null, s = 0; s !== i; s++) {
      var o = r[s];
      if (typeof o == "number" && isNaN(o)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, o), e = !1;
        break;
      }
      if (a !== null && a > o) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, s, o, a), e = !1;
        break;
      }
      a = o;
    }
    if (n !== void 0 && Gr.isTypedArray(n))
      for (var s = 0, u = n.length; s !== u; ++s) {
        var l = n[s];
        if (isNaN(l)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, l), e = !1;
          break;
        }
      }
    return e;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function() {
    for (var e = this.times, t = this.values, r = this.getValueSize(), n = this.getInterpolation() === Jl, i = 1, a = e.length - 1, s = 1; s < a; ++s) {
      var o = !1, u = e[s], l = e[s + 1];
      if (u !== l && (s !== 1 || u !== u[0]))
        if (n)
          o = !0;
        else
          for (var c = s * r, h = c - r, f = c + r, d = 0; d !== r; ++d) {
            var p = t[c + d];
            if (p !== t[h + d] || p !== t[f + d]) {
              o = !0;
              break;
            }
          }
      if (o) {
        if (s !== i) {
          e[i] = e[s];
          for (var _ = s * r, v = i * r, d = 0; d !== r; ++d)
            t[v + d] = t[_ + d];
        }
        ++i;
      }
    }
    if (a > 0) {
      e[i] = e[a];
      for (var _ = a * r, v = i * r, d = 0; d !== r; ++d)
        t[v + d] = t[_ + d];
      ++i;
    }
    return i !== e.length && (this.times = Gr.arraySlice(e, 0, i), this.values = Gr.arraySlice(t, 0, i * r)), this;
  }
});
function co(e, t, r, n) {
  Sr.call(this, e, t, r, n);
}
co.prototype = Object.assign(Object.create(Sr.prototype), {
  constructor: co,
  ValueTypeName: "vector"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function Ii(e, t, r) {
  this.name = e, this.tracks = r, this.duration = t !== void 0 ? t : -1, this.uuid = gt.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize();
}
Object.assign(Ii, {
  parse: function(e) {
    for (var t = [], r = e.tracks, n = 1 / (e.fps || 1), i = 0, a = r.length; i !== a; ++i)
      t.push(Sr.parse(r[i]).scale(n));
    return new Ii(e.name, e.duration, t);
  },
  toJSON: function(e) {
    for (var t = [], r = e.tracks, n = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid
    }, i = 0, a = r.length; i !== a; ++i)
      t.push(Sr.toJSON(r[i]));
    return n;
  },
  CreateFromMorphTargetSequence: function(e, t, r, n) {
    for (var i = t.length, a = [], s = 0; s < i; s++) {
      var o = [], u = [];
      o.push(
        (s + i - 1) % i,
        s,
        (s + 1) % i
      ), u.push(0, 1, 0);
      var l = Gr.getKeyframeOrder(o);
      o = Gr.sortedArray(o, 1, l), u = Gr.sortedArray(u, 1, l), !n && o[0] === 0 && (o.push(i), u.push(u[0])), a.push(
        new lo(
          ".morphTargetInfluences[" + t[s].name + "]",
          o,
          u
        ).scale(1 / r)
      );
    }
    return new Ii(e, -1, a);
  },
  findByName: function(e, t) {
    var r = e;
    if (!Array.isArray(e)) {
      var n = e;
      r = n.geometry && n.geometry.animations || n.animations;
    }
    for (var i = 0; i < r.length; i++)
      if (r[i].name === t)
        return r[i];
    return null;
  },
  CreateClipsFromMorphTargetSequences: function(e, t, r) {
    for (var n = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, s = e.length; a < s; a++) {
      var o = e[a], u = o.name.match(i);
      if (u && u.length > 1) {
        var l = u[1], c = n[l];
        c || (n[l] = c = []), c.push(o);
      }
    }
    var h = [];
    for (var l in n)
      h.push(Ii.CreateFromMorphTargetSequence(l, n[l], t, r));
    return h;
  },
  // parse the animation.hierarchy format
  parseAnimation: function(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    for (var r = function(M, C, R, B, k) {
      if (R.length !== 0) {
        var F = [], I = [];
        Gr.flattenJSON(R, F, I, B), F.length !== 0 && k.push(new M(C, F, I));
      }
    }, n = [], i = e.name || "default", a = e.length || -1, s = e.fps || 30, o = e.hierarchy || [], u = 0; u < o.length; u++) {
      var l = o[u].keys;
      if (!(!l || l.length === 0))
        if (l[0].morphTargets) {
          for (var c = {}, h = 0; h < l.length; h++)
            if (l[h].morphTargets)
              for (var f = 0; f < l[h].morphTargets.length; f++)
                c[l[h].morphTargets[f]] = -1;
          for (var d in c) {
            for (var p = [], _ = [], f = 0; f !== l[h].morphTargets.length; ++f) {
              var v = l[h];
              p.push(v.time), _.push(v.morphTarget === d ? 1 : 0);
            }
            n.push(new lo(".morphTargetInfluence[" + d + "]", p, _));
          }
          a = c.length * s;
        } else {
          var x = ".bones[" + t[u].name + "]";
          r(
            co,
            x + ".position",
            l,
            "pos",
            n
          ), r(
            $u,
            x + ".quaternion",
            l,
            "rot",
            n
          ), r(
            co,
            x + ".scale",
            l,
            "scl",
            n
          );
        }
    }
    if (n.length === 0)
      return null;
    var E = new Ii(i, a, n);
    return E;
  }
});
Object.assign(Ii.prototype, {
  resetDuration: function() {
    for (var e = this.tracks, t = 0, r = 0, n = e.length; r !== n; ++r) {
      var i = this.tracks[r];
      t = Math.max(t, i.times[i.times.length - 1]);
    }
    this.duration = t;
  },
  trim: function() {
    for (var e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  },
  optimize: function() {
    for (var e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
});
function gh(e) {
  this.manager = e !== void 0 ? e : pi, this.textures = {};
}
Object.assign(gh.prototype, {
  load: function(e, t, r, n) {
    var i = this, a = new tn(i.manager);
    a.load(e, function(s) {
      t(i.parse(JSON.parse(s)));
    }, r, n);
  },
  setTextures: function(e) {
    this.textures = e;
  },
  parse: function(e) {
    var t = this.textures;
    function r(a) {
      return t[a] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", a), t[a];
    }
    var n = new lE[e.type]();
    if (e.uuid !== void 0 && (n.uuid = e.uuid), e.name !== void 0 && (n.name = e.name), e.color !== void 0 && n.color.setHex(e.color), e.roughness !== void 0 && (n.roughness = e.roughness), e.metalness !== void 0 && (n.metalness = e.metalness), e.emissive !== void 0 && n.emissive.setHex(e.emissive), e.specular !== void 0 && n.specular.setHex(e.specular), e.shininess !== void 0 && (n.shininess = e.shininess), e.clearCoat !== void 0 && (n.clearCoat = e.clearCoat), e.clearCoatRoughness !== void 0 && (n.clearCoatRoughness = e.clearCoatRoughness), e.uniforms !== void 0 && (n.uniforms = e.uniforms), e.vertexShader !== void 0 && (n.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (n.fragmentShader = e.fragmentShader), e.vertexColors !== void 0 && (n.vertexColors = e.vertexColors), e.fog !== void 0 && (n.fog = e.fog), e.flatShading !== void 0 && (n.flatShading = e.flatShading), e.blending !== void 0 && (n.blending = e.blending), e.side !== void 0 && (n.side = e.side), e.opacity !== void 0 && (n.opacity = e.opacity), e.transparent !== void 0 && (n.transparent = e.transparent), e.alphaTest !== void 0 && (n.alphaTest = e.alphaTest), e.depthTest !== void 0 && (n.depthTest = e.depthTest), e.depthWrite !== void 0 && (n.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (n.colorWrite = e.colorWrite), e.wireframe !== void 0 && (n.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (n.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (n.rotation = e.rotation), e.linewidth !== 1 && (n.linewidth = e.linewidth), e.dashSize !== void 0 && (n.dashSize = e.dashSize), e.gapSize !== void 0 && (n.gapSize = e.gapSize), e.scale !== void 0 && (n.scale = e.scale), e.polygonOffset !== void 0 && (n.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = e.polygonOffsetUnits), e.skinning !== void 0 && (n.skinning = e.skinning), e.morphTargets !== void 0 && (n.morphTargets = e.morphTargets), e.dithering !== void 0 && (n.dithering = e.dithering), e.visible !== void 0 && (n.visible = e.visible), e.userData !== void 0 && (n.userData = e.userData), e.shading !== void 0 && (n.flatShading = e.shading === 1), e.size !== void 0 && (n.size = e.size), e.sizeAttenuation !== void 0 && (n.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (n.map = r(e.map)), e.alphaMap !== void 0 && (n.alphaMap = r(e.alphaMap), n.transparent = !0), e.bumpMap !== void 0 && (n.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (n.bumpScale = e.bumpScale), e.normalMap !== void 0 && (n.normalMap = r(e.normalMap)), e.normalScale !== void 0) {
      var i = e.normalScale;
      Array.isArray(i) === !1 && (i = [i, i]), n.normalScale = new ue().fromArray(i);
    }
    return e.displacementMap !== void 0 && (n.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (n.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (n.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (n.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (n.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (n.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (n.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (n.specularMap = r(e.specularMap)), e.envMap !== void 0 && (n.envMap = r(e.envMap)), e.reflectivity !== void 0 && (n.reflectivity = e.reflectivity), e.lightMap !== void 0 && (n.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (n.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (n.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (n.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (n.gradientMap = r(e.gradientMap)), n;
  }
});
function qd(e) {
  this.manager = e !== void 0 ? e : pi;
}
Object.assign(qd.prototype, {
  load: function(e, t, r, n) {
    var i = this, a = new tn(i.manager);
    a.load(e, function(s) {
      t(i.parse(JSON.parse(s)));
    }, r, n);
  },
  parse: function(e) {
    var t = new Ge(), r = e.data.index;
    if (r !== void 0) {
      var n = new Qm[r.type](r.array);
      t.setIndex(new pt(n, 1));
    }
    var i = e.data.attributes;
    for (var a in i) {
      var s = i[a], n = new Qm[s.type](s.array);
      t.addAttribute(a, new pt(n, s.itemSize, s.normalized));
    }
    var o = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (o !== void 0)
      for (var u = 0, l = o.length; u !== l; ++u) {
        var c = o[u];
        t.addGroup(c.start, c.count, c.materialIndex);
      }
    var h = e.data.boundingSphere;
    if (h !== void 0) {
      var f = new z();
      h.center !== void 0 && f.fromArray(h.center), t.boundingSphere = new qi(f, h.radius);
    }
    return t;
  }
});
var Qm = {
  Int8Array,
  Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function ho() {
}
ho.Handlers = {
  handlers: [],
  add: function(e, t) {
    this.handlers.push(e, t);
  },
  get: function(e) {
    for (var t = this.handlers, r = 0, n = t.length; r < n; r += 2) {
      var i = t[r], a = t[r + 1];
      if (i.test(e))
        return a;
    }
    return null;
  }
};
Object.assign(ho.prototype, {
  crossOrigin: void 0,
  onLoadStart: function() {
  },
  onLoadProgress: function() {
  },
  onLoadComplete: function() {
  },
  initMaterials: function(e, t, r) {
    for (var n = [], i = 0; i < e.length; ++i)
      n[i] = this.createMaterial(e[i], t, r);
    return n;
  },
  createMaterial: function() {
    var e = {
      NoBlending: sc,
      NormalBlending: _l,
      AdditiveBlending: Sd,
      SubtractiveBlending: Cd,
      MultiplyBlending: Md,
      CustomBlending: Dd
    }, t = new je(), r = new vh(), n = new gh();
    return function(a, s, o) {
      var u = {};
      function l(d, p, _, v, x) {
        var E = s + d, M = ho.Handlers.get(E), C;
        M !== null ? C = M.load(E) : (r.setCrossOrigin(o), C = r.load(E)), p !== void 0 && (C.repeat.fromArray(p), p[0] !== 1 && (C.wrapS = On), p[1] !== 1 && (C.wrapT = On)), _ !== void 0 && C.offset.fromArray(_), v !== void 0 && (v[0] === "repeat" && (C.wrapS = On), v[0] === "mirror" && (C.wrapS = za), v[1] === "repeat" && (C.wrapT = On), v[1] === "mirror" && (C.wrapT = za)), x !== void 0 && (C.anisotropy = x);
        var R = gt.generateUUID();
        return u[R] = C, R;
      }
      var c = {
        uuid: gt.generateUUID(),
        type: "MeshLambertMaterial"
      };
      for (var h in a) {
        var f = a[h];
        switch (h) {
          case "DbgColor":
          case "DbgIndex":
          case "opticalDensity":
          case "illumination":
            break;
          case "DbgName":
            c.name = f;
            break;
          case "blending":
            c.blending = e[f];
            break;
          case "colorAmbient":
          case "mapAmbient":
            console.warn("THREE.Loader.createMaterial:", h, "is no longer supported.");
            break;
          case "colorDiffuse":
            c.color = t.fromArray(f).getHex();
            break;
          case "colorSpecular":
            c.specular = t.fromArray(f).getHex();
            break;
          case "colorEmissive":
            c.emissive = t.fromArray(f).getHex();
            break;
          case "specularCoef":
            c.shininess = f;
            break;
          case "shading":
            f.toLowerCase() === "basic" && (c.type = "MeshBasicMaterial"), f.toLowerCase() === "phong" && (c.type = "MeshPhongMaterial"), f.toLowerCase() === "standard" && (c.type = "MeshStandardMaterial");
            break;
          case "mapDiffuse":
            c.map = l(f, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
            break;
          case "mapDiffuseRepeat":
          case "mapDiffuseOffset":
          case "mapDiffuseWrap":
          case "mapDiffuseAnisotropy":
            break;
          case "mapEmissive":
            c.emissiveMap = l(f, a.mapEmissiveRepeat, a.mapEmissiveOffset, a.mapEmissiveWrap, a.mapEmissiveAnisotropy);
            break;
          case "mapEmissiveRepeat":
          case "mapEmissiveOffset":
          case "mapEmissiveWrap":
          case "mapEmissiveAnisotropy":
            break;
          case "mapLight":
            c.lightMap = l(f, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
            break;
          case "mapLightRepeat":
          case "mapLightOffset":
          case "mapLightWrap":
          case "mapLightAnisotropy":
            break;
          case "mapAO":
            c.aoMap = l(f, a.mapAORepeat, a.mapAOOffset, a.mapAOWrap, a.mapAOAnisotropy);
            break;
          case "mapAORepeat":
          case "mapAOOffset":
          case "mapAOWrap":
          case "mapAOAnisotropy":
            break;
          case "mapBump":
            c.bumpMap = l(f, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
            break;
          case "mapBumpScale":
            c.bumpScale = f;
            break;
          case "mapBumpRepeat":
          case "mapBumpOffset":
          case "mapBumpWrap":
          case "mapBumpAnisotropy":
            break;
          case "mapNormal":
            c.normalMap = l(f, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
            break;
          case "mapNormalFactor":
            c.normalScale = f;
            break;
          case "mapNormalRepeat":
          case "mapNormalOffset":
          case "mapNormalWrap":
          case "mapNormalAnisotropy":
            break;
          case "mapSpecular":
            c.specularMap = l(f, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
            break;
          case "mapSpecularRepeat":
          case "mapSpecularOffset":
          case "mapSpecularWrap":
          case "mapSpecularAnisotropy":
            break;
          case "mapMetalness":
            c.metalnessMap = l(f, a.mapMetalnessRepeat, a.mapMetalnessOffset, a.mapMetalnessWrap, a.mapMetalnessAnisotropy);
            break;
          case "mapMetalnessRepeat":
          case "mapMetalnessOffset":
          case "mapMetalnessWrap":
          case "mapMetalnessAnisotropy":
            break;
          case "mapRoughness":
            c.roughnessMap = l(f, a.mapRoughnessRepeat, a.mapRoughnessOffset, a.mapRoughnessWrap, a.mapRoughnessAnisotropy);
            break;
          case "mapRoughnessRepeat":
          case "mapRoughnessOffset":
          case "mapRoughnessWrap":
          case "mapRoughnessAnisotropy":
            break;
          case "mapAlpha":
            c.alphaMap = l(f, a.mapAlphaRepeat, a.mapAlphaOffset, a.mapAlphaWrap, a.mapAlphaAnisotropy);
            break;
          case "mapAlphaRepeat":
          case "mapAlphaOffset":
          case "mapAlphaWrap":
          case "mapAlphaAnisotropy":
            break;
          case "flipSided":
            c.side = Tr;
            break;
          case "doubleSided":
            c.side = Ro;
            break;
          case "transparency":
            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), c.opacity = f;
            break;
          case "depthTest":
          case "depthWrite":
          case "colorWrite":
          case "opacity":
          case "reflectivity":
          case "transparent":
          case "visible":
          case "wireframe":
            c[h] = f;
            break;
          case "vertexColors":
            f === !0 && (c.vertexColors = ds), f === "face" && (c.vertexColors = wd);
            break;
          default:
            console.error("THREE.Loader.createMaterial: Unsupported", h, f);
            break;
        }
      }
      return c.type === "MeshBasicMaterial" && delete c.emissive, c.type !== "MeshPhongMaterial" && delete c.specular, c.opacity < 1 && (c.transparent = !0), n.setTextures(u), n.parse(c);
    };
  }()
});
var Xd = {
  decodeText: function(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    for (var t = "", r = 0, n = e.length; r < n; r++)
      t += String.fromCharCode(e[r]);
    return decodeURIComponent(escape(t));
  },
  extractUrlBase: function(e) {
    var t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.substr(0, t + 1);
  }
};
function Yd(e) {
  typeof e == "boolean" && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = e !== void 0 ? e : pi, this.withCredentials = !1;
}
Object.assign(Yd.prototype, {
  load: function(e, t, r, n) {
    var i = this, a = this.texturePath && typeof this.texturePath == "string" ? this.texturePath : Xd.extractUrlBase(e), s = new tn(this.manager);
    s.setWithCredentials(this.withCredentials), s.load(e, function(o) {
      var u = JSON.parse(o), l = u.metadata;
      if (l !== void 0) {
        var c = l.type;
        if (c !== void 0 && c.toLowerCase() === "object") {
          console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead.");
          return;
        }
      }
      var h = i.parse(u, a);
      t(h.geometry, h.materials);
    }, r, n);
  },
  setTexturePath: function(e) {
    this.texturePath = e;
  },
  parse: /* @__PURE__ */ function() {
    function e(i, a) {
      function s(pe, Re) {
        return pe & 1 << Re;
      }
      var o, u, l, c, h, f, d, p, _, v, x, E, M, C, R, B, k, F, I, H, Q, ee, oe, de, he, fe, V, G = i.faces, se = i.vertices, re = i.normals, Ce = i.colors, K = i.scale, xe = 0;
      if (i.uvs !== void 0) {
        for (o = 0; o < i.uvs.length; o++)
          i.uvs[o].length && xe++;
        for (o = 0; o < xe; o++)
          a.faceVertexUvs[o] = [];
      }
      for (c = 0, h = se.length; c < h; )
        F = new z(), F.x = se[c++] * K, F.y = se[c++] * K, F.z = se[c++] * K, a.vertices.push(F);
      for (c = 0, h = G.length; c < h; )
        if (v = G[c++], x = s(v, 0), E = s(v, 1), M = s(v, 3), C = s(v, 4), R = s(v, 5), B = s(v, 6), k = s(v, 7), x) {
          if (H = new kn(), H.a = G[c], H.b = G[c + 1], H.c = G[c + 3], Q = new kn(), Q.a = G[c + 1], Q.b = G[c + 2], Q.c = G[c + 3], c += 4, E && (_ = G[c++], H.materialIndex = _, Q.materialIndex = _), l = a.faces.length, M)
            for (o = 0; o < xe; o++)
              for (de = i.uvs[o], a.faceVertexUvs[o][l] = [], a.faceVertexUvs[o][l + 1] = [], u = 0; u < 4; u++)
                p = G[c++], fe = de[p * 2], V = de[p * 2 + 1], he = new ue(fe, V), u !== 2 && a.faceVertexUvs[o][l].push(he), u !== 0 && a.faceVertexUvs[o][l + 1].push(he);
          if (C && (d = G[c++] * 3, H.normal.set(
            re[d++],
            re[d++],
            re[d]
          ), Q.normal.copy(H.normal)), R)
            for (o = 0; o < 4; o++)
              d = G[c++] * 3, oe = new z(
                re[d++],
                re[d++],
                re[d]
              ), o !== 2 && H.vertexNormals.push(oe), o !== 0 && Q.vertexNormals.push(oe);
          if (B && (f = G[c++], ee = Ce[f], H.color.setHex(ee), Q.color.setHex(ee)), k)
            for (o = 0; o < 4; o++)
              f = G[c++], ee = Ce[f], o !== 2 && H.vertexColors.push(new je(ee)), o !== 0 && Q.vertexColors.push(new je(ee));
          a.faces.push(H), a.faces.push(Q);
        } else {
          if (I = new kn(), I.a = G[c++], I.b = G[c++], I.c = G[c++], E && (_ = G[c++], I.materialIndex = _), l = a.faces.length, M)
            for (o = 0; o < xe; o++)
              for (de = i.uvs[o], a.faceVertexUvs[o][l] = [], u = 0; u < 3; u++)
                p = G[c++], fe = de[p * 2], V = de[p * 2 + 1], he = new ue(fe, V), a.faceVertexUvs[o][l].push(he);
          if (C && (d = G[c++] * 3, I.normal.set(
            re[d++],
            re[d++],
            re[d]
          )), R)
            for (o = 0; o < 3; o++)
              d = G[c++] * 3, oe = new z(
                re[d++],
                re[d++],
                re[d]
              ), I.vertexNormals.push(oe);
          if (B && (f = G[c++], I.color.setHex(Ce[f])), k)
            for (o = 0; o < 3; o++)
              f = G[c++], I.vertexColors.push(new je(Ce[f]));
          a.faces.push(I);
        }
    }
    function t(i, a) {
      var s = i.influencesPerVertex !== void 0 ? i.influencesPerVertex : 2;
      if (i.skinWeights)
        for (var o = 0, u = i.skinWeights.length; o < u; o += s) {
          var l = i.skinWeights[o], c = s > 1 ? i.skinWeights[o + 1] : 0, h = s > 2 ? i.skinWeights[o + 2] : 0, f = s > 3 ? i.skinWeights[o + 3] : 0;
          a.skinWeights.push(new kt(l, c, h, f));
        }
      if (i.skinIndices)
        for (var o = 0, u = i.skinIndices.length; o < u; o += s) {
          var d = i.skinIndices[o], p = s > 1 ? i.skinIndices[o + 1] : 0, _ = s > 2 ? i.skinIndices[o + 2] : 0, v = s > 3 ? i.skinIndices[o + 3] : 0;
          a.skinIndices.push(new kt(d, p, _, v));
        }
      a.bones = i.bones, a.bones && a.bones.length > 0 && (a.skinWeights.length !== a.skinIndices.length || a.skinIndices.length !== a.vertices.length) && console.warn("When skinning, number of vertices (" + a.vertices.length + "), skinIndices (" + a.skinIndices.length + "), and skinWeights (" + a.skinWeights.length + ") should match.");
    }
    function r(i, a) {
      var s = i.scale;
      if (i.morphTargets !== void 0)
        for (var o = 0, u = i.morphTargets.length; o < u; o++) {
          a.morphTargets[o] = {}, a.morphTargets[o].name = i.morphTargets[o].name, a.morphTargets[o].vertices = [];
          for (var l = a.morphTargets[o].vertices, c = i.morphTargets[o].vertices, h = 0, f = c.length; h < f; h += 3) {
            var d = new z();
            d.x = c[h] * s, d.y = c[h + 1] * s, d.z = c[h + 2] * s, l.push(d);
          }
        }
      if (i.morphColors !== void 0 && i.morphColors.length > 0) {
        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
        for (var p = a.faces, _ = i.morphColors[0].colors, o = 0, u = p.length; o < u; o++)
          p[o].color.fromArray(_, o * 3);
      }
    }
    function n(i, a) {
      var s = [], o = [];
      i.animation !== void 0 && o.push(i.animation), i.animations !== void 0 && (i.animations.length ? o = o.concat(i.animations) : o.push(i.animations));
      for (var u = 0; u < o.length; u++) {
        var l = Ii.parseAnimation(o[u], a.bones);
        l && s.push(l);
      }
      if (a.morphTargets) {
        var c = Ii.CreateClipsFromMorphTargetSequences(a.morphTargets, 10);
        s = s.concat(c);
      }
      s.length > 0 && (a.animations = s);
    }
    return function(a, s) {
      a.data !== void 0 && (a = a.data), a.scale !== void 0 ? a.scale = 1 / a.scale : a.scale = 1;
      var o = new tt();
      if (e(a, o), t(a, o), r(a, o), n(a, o), o.computeFaceNormals(), o.computeBoundingSphere(), a.materials === void 0 || a.materials.length === 0)
        return { geometry: o };
      var u = ho.prototype.initMaterials(a.materials, s, this.crossOrigin);
      return { geometry: o, materials: u };
    };
  }()
});
function sy(e) {
  this.manager = e !== void 0 ? e : pi, this.texturePath = "";
}
Object.assign(sy.prototype, {
  load: function(e, t, r, n) {
    this.texturePath === "" && (this.texturePath = e.substring(0, e.lastIndexOf("/") + 1));
    var i = this, a = new tn(i.manager);
    a.load(e, function(s) {
      var o = null;
      try {
        o = JSON.parse(s);
      } catch (l) {
        n !== void 0 && n(l), console.error("THREE:ObjectLoader: Can't parse " + e + ".", l.message);
        return;
      }
      var u = o.metadata;
      if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + e + ". Use THREE.JSONLoader instead.");
        return;
      }
      i.parse(o, t);
    }, r, n);
  },
  setTexturePath: function(e) {
    return this.texturePath = e, this;
  },
  setCrossOrigin: function(e) {
    return this.crossOrigin = e, this;
  },
  parse: function(e, t) {
    var r = this.parseShape(e.shapes), n = this.parseGeometries(e.geometries, r), i = this.parseImages(e.images, function() {
      t !== void 0 && t(o);
    }), a = this.parseTextures(e.textures, i), s = this.parseMaterials(e.materials, a), o = this.parseObject(e.object, n, s);
    return e.animations && (o.animations = this.parseAnimations(e.animations)), (e.images === void 0 || e.images.length === 0) && t !== void 0 && t(o), o;
  },
  parseShape: function(e) {
    var t = {};
    if (e !== void 0)
      for (var r = 0, n = e.length; r < n; r++) {
        var i = new la().fromJSON(e[r]);
        t[i.uuid] = i;
      }
    return t;
  },
  parseGeometries: function(e, t) {
    var r = {};
    if (e !== void 0)
      for (var n = new Yd(), i = new qd(), a = 0, s = e.length; a < s; a++) {
        var o, u = e[a];
        switch (u.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            o = new ai[u.type](
              u.width,
              u.height,
              u.widthSegments,
              u.heightSegments
            );
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            o = new ai[u.type](
              u.width,
              u.height,
              u.depth,
              u.widthSegments,
              u.heightSegments,
              u.depthSegments
            );
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            o = new ai[u.type](
              u.radius,
              u.segments,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            o = new ai[u.type](
              u.radiusTop,
              u.radiusBottom,
              u.height,
              u.radialSegments,
              u.heightSegments,
              u.openEnded,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            o = new ai[u.type](
              u.radius,
              u.height,
              u.radialSegments,
              u.heightSegments,
              u.openEnded,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            o = new ai[u.type](
              u.radius,
              u.widthSegments,
              u.heightSegments,
              u.phiStart,
              u.phiLength,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            o = new ai[u.type](
              u.radius,
              u.detail
            );
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            o = new ai[u.type](
              u.innerRadius,
              u.outerRadius,
              u.thetaSegments,
              u.phiSegments,
              u.thetaStart,
              u.thetaLength
            );
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            o = new ai[u.type](
              u.radius,
              u.tube,
              u.radialSegments,
              u.tubularSegments,
              u.arc
            );
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            o = new ai[u.type](
              u.radius,
              u.tube,
              u.tubularSegments,
              u.radialSegments,
              u.p,
              u.q
            );
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            o = new ai[u.type](
              u.points,
              u.segments,
              u.phiStart,
              u.phiLength
            );
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            o = new ai[u.type](
              u.vertices,
              u.indices,
              u.radius,
              u.details
            );
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            for (var f = [], l = 0, c = u.shapes.length; l < c; l++) {
              var h = t[u.shapes[l]];
              f.push(h);
            }
            o = new ai[u.type](
              f,
              u.curveSegments
            );
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            for (var f = [], l = 0, c = u.shapes.length; l < c; l++) {
              var h = t[u.shapes[l]];
              f.push(h);
            }
            var d = u.options.extrudePath;
            d !== void 0 && (u.options.extrudePath = new ay[d.type]().fromJSON(d)), o = new ai[u.type](
              f,
              u.options
            );
            break;
          case "BufferGeometry":
            o = i.parse(u);
            break;
          case "Geometry":
            o = n.parse(u, this.texturePath).geometry;
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + u.type + '"');
            continue;
        }
        o.uuid = u.uuid, u.name !== void 0 && (o.name = u.name), o.isBufferGeometry === !0 && u.userData !== void 0 && (o.userData = u.userData), r[u.uuid] = o;
      }
    return r;
  },
  parseMaterials: function(e, t) {
    var r = {};
    if (e !== void 0) {
      var n = new gh();
      n.setTextures(t);
      for (var i = 0, a = e.length; i < a; i++) {
        var s = e[i];
        if (s.type === "MultiMaterial") {
          for (var o = [], u = 0; u < s.materials.length; u++)
            o.push(n.parse(s.materials[u]));
          r[s.uuid] = o;
        } else
          r[s.uuid] = n.parse(s);
      }
    }
    return r;
  },
  parseAnimations: function(e) {
    for (var t = [], r = 0; r < e.length; r++) {
      var n = e[r], i = Ii.parse(n);
      n.uuid !== void 0 && (i.uuid = n.uuid), t.push(i);
    }
    return t;
  },
  parseImages: function(e, t) {
    var r = this, n = {};
    function i(h) {
      return r.manager.itemStart(h), s.load(h, function() {
        r.manager.itemEnd(h);
      }, void 0, function() {
        r.manager.itemEnd(h), r.manager.itemError(h);
      });
    }
    if (e !== void 0 && e.length > 0) {
      var a = new Hd(t), s = new Al(a);
      s.setCrossOrigin(this.crossOrigin);
      for (var o = 0, u = e.length; o < u; o++) {
        var l = e[o], c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : r.texturePath + l.url;
        n[l.uuid] = i(c);
      }
    }
    return n;
  },
  parseTextures: function(e, t) {
    function r(u, l) {
      return typeof u == "number" ? u : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", u), l[u]);
    }
    var n = {};
    if (e !== void 0)
      for (var i = 0, a = e.length; i < a; i++) {
        var s = e[i];
        s.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), t[s.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", s.image);
        var o = new ir(t[s.image]);
        o.needsUpdate = !0, o.uuid = s.uuid, s.name !== void 0 && (o.name = s.name), s.mapping !== void 0 && (o.mapping = r(s.mapping, gE)), s.offset !== void 0 && o.offset.fromArray(s.offset), s.repeat !== void 0 && o.repeat.fromArray(s.repeat), s.center !== void 0 && o.center.fromArray(s.center), s.rotation !== void 0 && (o.rotation = s.rotation), s.wrap !== void 0 && (o.wrapS = r(s.wrap[0], Km), o.wrapT = r(s.wrap[1], Km)), s.format !== void 0 && (o.format = s.format), s.minFilter !== void 0 && (o.minFilter = r(s.minFilter, $m)), s.magFilter !== void 0 && (o.magFilter = r(s.magFilter, $m)), s.anisotropy !== void 0 && (o.anisotropy = s.anisotropy), s.flipY !== void 0 && (o.flipY = s.flipY), n[s.uuid] = o;
      }
    return n;
  },
  parseObject: function(e, t, r) {
    var n;
    function i(p) {
      return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p];
    }
    function a(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          for (var _ = [], v = 0, x = p.length; v < x; v++) {
            var E = p[v];
            r[E] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", E), _.push(r[E]);
          }
          return _;
        }
        return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), r[p];
      }
    }
    switch (e.type) {
      case "Scene":
        n = new Cu(), e.background !== void 0 && Number.isInteger(e.background) && (n.background = new je(e.background)), e.fog !== void 0 && (e.fog.type === "Fog" ? n.fog = new js(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (n.fog = new Ws(e.fog.color, e.fog.density)));
        break;
      case "PerspectiveCamera":
        n = new or(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (n.focus = e.focus), e.zoom !== void 0 && (n.zoom = e.zoom), e.filmGauge !== void 0 && (n.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (n.filmOffset = e.filmOffset), e.view !== void 0 && (n.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        n = new Hs(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (n.zoom = e.zoom), e.view !== void 0 && (n.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        n = new Ac(e.color, e.intensity);
        break;
      case "DirectionalLight":
        n = new xc(e.color, e.intensity);
        break;
      case "PointLight":
        n = new _c(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        n = new Tc(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        n = new yc(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        n = new vc(e.color, e.groundColor, e.intensity);
        break;
      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
      case "Mesh":
        var s = i(e.geometry), o = a(e.material);
        s.bones && s.bones.length > 0 ? n = new hc(s, o) : n = new dr(s, o);
        break;
      case "LOD":
        n = new Du();
        break;
      case "Line":
        n = new hi(i(e.geometry), a(e.material), e.mode);
        break;
      case "LineLoop":
        n = new fc(i(e.geometry), a(e.material));
        break;
      case "LineSegments":
        n = new Yt(i(e.geometry), a(e.material));
        break;
      case "PointCloud":
      case "Points":
        n = new qs(i(e.geometry), a(e.material));
        break;
      case "Sprite":
        n = new Mu(a(e.material));
        break;
      case "Group":
        n = new dc();
        break;
      default:
        n = new ke();
    }
    if (n.uuid = e.uuid, e.name !== void 0 && (n.name = e.name), e.matrix !== void 0 ? (n.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (e.position !== void 0 && n.position.fromArray(e.position), e.rotation !== void 0 && n.rotation.fromArray(e.rotation), e.quaternion !== void 0 && n.quaternion.fromArray(e.quaternion), e.scale !== void 0 && n.scale.fromArray(e.scale)), e.castShadow !== void 0 && (n.castShadow = e.castShadow), e.receiveShadow !== void 0 && (n.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (n.shadow.bias = e.shadow.bias), e.shadow.radius !== void 0 && (n.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && n.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (n.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (n.visible = e.visible), e.frustumCulled !== void 0 && (n.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (n.renderOrder = e.renderOrder), e.userData !== void 0 && (n.userData = e.userData), e.children !== void 0)
      for (var u = e.children, l = 0; l < u.length; l++)
        n.add(this.parseObject(u[l], t, r));
    if (e.type === "LOD")
      for (var c = e.levels, h = 0; h < c.length; h++) {
        var f = c[h], d = n.getObjectByProperty("uuid", f.object);
        d !== void 0 && n.addLevel(d, f.distance);
      }
    return n;
  }
});
var gE = {
  UVMapping: sh,
  CubeReflectionMapping: oh,
  CubeRefractionMapping: uc,
  EquirectangularReflectionMapping: Od,
  EquirectangularRefractionMapping: lc,
  SphericalReflectionMapping: Bd,
  CubeUVReflectionMapping: uh,
  CubeUVRefractionMapping: lh
}, Km = {
  RepeatWrapping: On,
  ClampToEdgeWrapping: Ei,
  MirroredRepeatWrapping: za
}, $m = {
  NearestFilter: wi,
  NearestMipMapNearestFilter: ch,
  NearestMipMapLinearFilter: hh,
  LinearFilter: Vr,
  LinearMipMapNearestFilter: Fd,
  LinearMipMapLinearFilter: xl
};
function Nf(e) {
  typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = e !== void 0 ? e : pi, this.options = void 0;
}
Nf.prototype = {
  constructor: Nf,
  setOptions: function(t) {
    return this.options = t, this;
  },
  load: function(e, t, r, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    var i = this, a = ls.get(e);
    if (a !== void 0)
      return i.manager.itemStart(e), setTimeout(function() {
        t && t(a), i.manager.itemEnd(e);
      }, 0), a;
    fetch(e).then(function(s) {
      return s.blob();
    }).then(function(s) {
      return createImageBitmap(s, i.options);
    }).then(function(s) {
      ls.add(e, s), t && t(s), i.manager.itemEnd(e);
    }).catch(function(s) {
      n && n(s), i.manager.itemEnd(e), i.manager.itemError(e);
    });
  },
  setCrossOrigin: function() {
    return this;
  },
  setPath: function(e) {
    return this.path = e, this;
  }
};
function Qd() {
  this.type = "ShapePath", this.color = new je(), this.subPaths = [], this.currentPath = null;
}
Object.assign(Qd.prototype, {
  moveTo: function(e, t) {
    this.currentPath = new zi(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t);
  },
  lineTo: function(e, t) {
    this.currentPath.lineTo(e, t);
  },
  quadraticCurveTo: function(e, t, r, n) {
    this.currentPath.quadraticCurveTo(e, t, r, n);
  },
  bezierCurveTo: function(e, t, r, n, i, a) {
    this.currentPath.bezierCurveTo(e, t, r, n, i, a);
  },
  splineThru: function(e) {
    this.currentPath.splineThru(e);
  },
  toShapes: function(e, t) {
    function r(he) {
      for (var fe = [], V = 0, G = he.length; V < G; V++) {
        var se = he[V], re = new la();
        re.curves = se.curves, fe.push(re);
      }
      return fe;
    }
    function n(he, fe) {
      for (var V = fe.length, G = !1, se = V - 1, re = 0; re < V; se = re++) {
        var Ce = fe[se], K = fe[re], xe = K.x - Ce.x, pe = K.y - Ce.y;
        if (Math.abs(pe) > Number.EPSILON) {
          if (pe < 0 && (Ce = fe[re], xe = -xe, K = fe[se], pe = -pe), he.y < Ce.y || he.y > K.y) continue;
          if (he.y === Ce.y) {
            if (he.x === Ce.x) return !0;
          } else {
            var Re = pe * (he.x - Ce.x) - xe * (he.y - Ce.y);
            if (Re === 0) return !0;
            if (Re < 0) continue;
            G = !G;
          }
        } else {
          if (he.y !== Ce.y) continue;
          if (K.x <= he.x && he.x <= Ce.x || Ce.x <= he.x && he.x <= K.x) return !0;
        }
      }
      return G;
    }
    var i = Nn.isClockWise, a = this.subPaths;
    if (a.length === 0) return [];
    if (t === !0) return r(a);
    var s, o, u, l = [];
    if (a.length === 1)
      return o = a[0], u = new la(), u.curves = o.curves, l.push(u), l;
    var c = !i(a[0].getPoints());
    c = e ? !c : c;
    var h = [], f = [], d = [], p = 0, _;
    f[p] = void 0, d[p] = [];
    for (var v = 0, x = a.length; v < x; v++)
      o = a[v], _ = o.getPoints(), s = i(_), s = e ? !s : s, s ? (!c && f[p] && p++, f[p] = { s: new la(), p: _ }, f[p].s.curves = o.curves, c && p++, d[p] = []) : d[p].push({ h: o, p: _[0] });
    if (!f[0]) return r(a);
    if (f.length > 1) {
      for (var E = !1, M = [], C = 0, R = f.length; C < R; C++)
        h[C] = [];
      for (var C = 0, R = f.length; C < R; C++)
        for (var B = d[C], k = 0; k < B.length; k++) {
          for (var F = B[k], I = !0, H = 0; H < f.length; H++)
            n(F.p, f[H].p) && (C !== H && M.push({ froms: C, tos: H, hole: k }), I ? (I = !1, h[H].push(F)) : E = !0);
          I && h[C].push(F);
        }
      M.length > 0 && (E || (d = h));
    }
    for (var Q, v = 0, ee = f.length; v < ee; v++) {
      u = f[v].s, l.push(u), Q = d[v];
      for (var oe = 0, de = Q.length; oe < de; oe++)
        u.holes.push(Q[oe].h);
    }
    return l;
  }
});
function Kd(e) {
  this.type = "Font", this.data = e;
}
Object.assign(Kd.prototype, {
  isFont: !0,
  generateShapes: function(e, t, r) {
    t === void 0 && (t = 100), r === void 0 && (r = 4);
    for (var n = [], i = yE(e, t, r, this.data), a = 0, s = i.length; a < s; a++)
      Array.prototype.push.apply(n, i[a].toShapes());
    return n;
  }
});
function yE(e, t, r, n) {
  for (var i = Array.from ? Array.from(e) : String(e).split(""), a = t / n.resolution, s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * a, o = [], u = 0, l = 0, c = 0; c < i.length; c++) {
    var h = i[c];
    if (h === `
`)
      u = 0, l -= s;
    else {
      var f = _E(h, r, a, u, l, n);
      u += f.offsetX, o.push(f.path);
    }
  }
  return o;
}
function _E(e, t, r, n, i, a) {
  var s = a.glyphs[e] || a.glyphs["?"];
  if (s) {
    var o = new Qd(), u, l, c, h, f, d, p, _;
    if (s.o)
      for (var v = s._cachedOutline || (s._cachedOutline = s.o.split(" ")), x = 0, E = v.length; x < E; ) {
        var M = v[x++];
        switch (M) {
          case "m":
            u = v[x++] * r + n, l = v[x++] * r + i, o.moveTo(u, l);
            break;
          case "l":
            u = v[x++] * r + n, l = v[x++] * r + i, o.lineTo(u, l);
            break;
          case "q":
            c = v[x++] * r + n, h = v[x++] * r + i, f = v[x++] * r + n, d = v[x++] * r + i, o.quadraticCurveTo(f, d, c, h);
            break;
          case "b":
            c = v[x++] * r + n, h = v[x++] * r + i, f = v[x++] * r + n, d = v[x++] * r + i, p = v[x++] * r + n, _ = v[x++] * r + i, o.bezierCurveTo(f, d, p, _, c, h);
            break;
        }
      }
    return { offsetX: s.ha * r, path: o };
  }
}
function oy(e) {
  this.manager = e !== void 0 ? e : pi;
}
Object.assign(oy.prototype, {
  load: function(e, t, r, n) {
    var i = this, a = new tn(this.manager);
    a.setPath(this.path), a.load(e, function(s) {
      var o;
      try {
        o = JSON.parse(s);
      } catch {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), o = JSON.parse(s.substring(65, s.length - 2));
      }
      var u = i.parse(o);
      t && t(u);
    }, r, n);
  },
  parse: function(e) {
    return new Kd(e);
  },
  setPath: function(e) {
    return this.path = e, this;
  }
});
var Ul, yh = {
  getContext: function() {
    return Ul === void 0 && (Ul = new (window.AudioContext || window.webkitAudioContext)()), Ul;
  },
  setContext: function(e) {
    Ul = e;
  }
};
function $d(e) {
  this.manager = e !== void 0 ? e : pi;
}
Object.assign($d.prototype, {
  load: function(e, t, r, n) {
    var i = new tn(this.manager);
    i.setResponseType("arraybuffer"), i.load(e, function(a) {
      var s = yh.getContext();
      s.decodeAudioData(a, function(o) {
        t(o);
      });
    }, r, n);
  }
});
function uy() {
  this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new or(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new or(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
}
Object.assign(uy.prototype, {
  update: function() {
    var e, t, r, n, i, a, s, o, u = new at(), l = new at();
    return function(h) {
      var f = e !== this || t !== h.focus || r !== h.fov || n !== h.aspect * this.aspect || i !== h.near || a !== h.far || s !== h.zoom || o !== this.eyeSep;
      if (f) {
        e = this, t = h.focus, r = h.fov, n = h.aspect * this.aspect, i = h.near, a = h.far, s = h.zoom;
        var d = h.projectionMatrix.clone();
        o = this.eyeSep / 2;
        var p = o * i / t, _ = i * Math.tan(gt.DEG2RAD * r * 0.5) / s, v, x;
        l.elements[12] = -o, u.elements[12] = o, v = -_ * n + p, x = _ * n + p, d.elements[0] = 2 * i / (x - v), d.elements[8] = (x + v) / (x - v), this.cameraL.projectionMatrix.copy(d), v = -_ * n - p, x = _ * n - p, d.elements[0] = 2 * i / (x - v), d.elements[8] = (x + v) / (x - v), this.cameraR.projectionMatrix.copy(d);
      }
      this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(u);
    };
  }()
});
function Ju(e, t, r) {
  ke.call(this), this.type = "CubeCamera";
  var n = 90, i = 1, a = new or(n, i, e, t);
  a.up.set(0, -1, 0), a.lookAt(new z(1, 0, 0)), this.add(a);
  var s = new or(n, i, e, t);
  s.up.set(0, -1, 0), s.lookAt(new z(-1, 0, 0)), this.add(s);
  var o = new or(n, i, e, t);
  o.up.set(0, 0, 1), o.lookAt(new z(0, 1, 0)), this.add(o);
  var u = new or(n, i, e, t);
  u.up.set(0, 0, -1), u.lookAt(new z(0, -1, 0)), this.add(u);
  var l = new or(n, i, e, t);
  l.up.set(0, -1, 0), l.lookAt(new z(0, 0, 1)), this.add(l);
  var c = new or(n, i, e, t);
  c.up.set(0, -1, 0), c.lookAt(new z(0, 0, -1)), this.add(c);
  var h = { format: Wa, magFilter: Vr, minFilter: Vr };
  this.renderTarget = new Vs(r, r, h), this.renderTarget.texture.name = "CubeCamera", this.update = function(f, d) {
    this.parent === null && this.updateMatrixWorld();
    var p = this.renderTarget, _ = p.texture.generateMipmaps;
    p.texture.generateMipmaps = !1, p.activeCubeFace = 0, f.render(d, a, p), p.activeCubeFace = 1, f.render(d, s, p), p.activeCubeFace = 2, f.render(d, o, p), p.activeCubeFace = 3, f.render(d, u, p), p.activeCubeFace = 4, f.render(d, l, p), p.texture.generateMipmaps = _, p.activeCubeFace = 5, f.render(d, c, p), f.setRenderTarget(null);
  }, this.clear = function(f, d, p, _) {
    for (var v = this.renderTarget, x = 0; x < 6; x++)
      v.activeCubeFace = x, f.setRenderTarget(v), f.clear(d, p, _);
    f.setRenderTarget(null);
  };
}
Ju.prototype = Object.create(ke.prototype);
Ju.prototype.constructor = Ju;
function Uf() {
  ke.call(this), this.type = "AudioListener", this.context = yh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null;
}
Uf.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: Uf,
  getInput: function() {
    return this.gain;
  },
  removeFilter: function() {
    this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null);
  },
  getFilter: function() {
    return this.filter;
  },
  setFilter: function(e) {
    this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination);
  },
  getMasterVolume: function() {
    return this.gain.gain.value;
  },
  setMasterVolume: function(e) {
    this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01);
  },
  updateMatrixWorld: function() {
    var e = new z(), t = new _r(), r = new z(), n = new z();
    return function(a) {
      ke.prototype.updateMatrixWorld.call(this, a);
      var s = this.context.listener, o = this.up;
      this.matrixWorld.decompose(e, t, r), n.set(0, 0, -1).applyQuaternion(t), s.positionX ? (s.positionX.setValueAtTime(e.x, this.context.currentTime), s.positionY.setValueAtTime(e.y, this.context.currentTime), s.positionZ.setValueAtTime(e.z, this.context.currentTime), s.forwardX.setValueAtTime(n.x, this.context.currentTime), s.forwardY.setValueAtTime(n.y, this.context.currentTime), s.forwardZ.setValueAtTime(n.z, this.context.currentTime), s.upX.setValueAtTime(o.x, this.context.currentTime), s.upY.setValueAtTime(o.y, this.context.currentTime), s.upZ.setValueAtTime(o.z, this.context.currentTime)) : (s.setPosition(e.x, e.y, e.z), s.setOrientation(n.x, n.y, n.z, o.x, o.y, o.z));
    };
  }()
});
function fo(e) {
  ke.call(this), this.type = "Audio", this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [];
}
fo.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: fo,
  getOutput: function() {
    return this.gain;
  },
  setNodeSource: function(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  },
  setMediaElementSource: function(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  },
  setBuffer: function(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  },
  play: function() {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    var e = this.context.createBufferSource();
    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), e.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.connect();
  },
  pause: function() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
  },
  stop: function() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.source.stop(), this.offset = 0, this.isPlaying = !1, this;
  },
  connect: function() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (var e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this;
  },
  disconnect: function() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (var e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this;
  },
  getFilters: function() {
    return this.filters;
  },
  setFilters: function(e) {
    return e || (e = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this;
  },
  getFilter: function() {
    return this.getFilters()[0];
  },
  setFilter: function(e) {
    return this.setFilters(e ? [e] : []);
  },
  setPlaybackRate: function(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
  },
  getPlaybackRate: function() {
    return this.playbackRate;
  },
  onEnded: function() {
    this.isPlaying = !1;
  },
  getLoop: function() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  },
  setLoop: function(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  },
  getVolume: function() {
    return this.gain.gain.value;
  },
  setVolume: function(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
});
function Gf(e) {
  fo.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
}
Gf.prototype = Object.assign(Object.create(fo.prototype), {
  constructor: Gf,
  getOutput: function() {
    return this.panner;
  },
  getRefDistance: function() {
    return this.panner.refDistance;
  },
  setRefDistance: function(e) {
    this.panner.refDistance = e;
  },
  getRolloffFactor: function() {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function(e) {
    this.panner.rolloffFactor = e;
  },
  getDistanceModel: function() {
    return this.panner.distanceModel;
  },
  setDistanceModel: function(e) {
    this.panner.distanceModel = e;
  },
  getMaxDistance: function() {
    return this.panner.maxDistance;
  },
  setMaxDistance: function(e) {
    this.panner.maxDistance = e;
  },
  updateMatrixWorld: function() {
    var e = new z();
    return function(r) {
      ke.prototype.updateMatrixWorld.call(this, r), e.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(e.x, e.y, e.z);
    };
  }()
});
function Zd(e, t) {
  this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t !== void 0 ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
}
Object.assign(Zd.prototype, {
  getFrequencyData: function() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  },
  getAverageFrequency: function() {
    for (var e = 0, t = this.getFrequencyData(), r = 0; r < t.length; r++)
      e += t[r];
    return e / t.length;
  }
});
function Jd(e, t, r) {
  this.binding = e, this.valueSize = r;
  var n = Float64Array, i;
  switch (t) {
    case "quaternion":
      i = this._slerp;
      break;
    case "string":
    case "bool":
      n = Array, i = this._select;
      break;
    default:
      i = this._lerp;
  }
  this.buffer = new n(r * 4), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0;
}
Object.assign(Jd.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function(e, t) {
    var r = this.buffer, n = this.valueSize, i = e * n + n, a = this.cumulativeWeight;
    if (a === 0) {
      for (var s = 0; s !== n; ++s)
        r[i + s] = r[s];
      a = t;
    } else {
      a += t;
      var o = t / a;
      this._mixBufferRegion(r, i, 0, o, n);
    }
    this.cumulativeWeight = a;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function(e) {
    var t = this.valueSize, r = this.buffer, n = e * t + t, i = this.cumulativeWeight, a = this.binding;
    if (this.cumulativeWeight = 0, i < 1) {
      var s = t * 3;
      this._mixBufferRegion(
        r,
        n,
        s,
        1 - i,
        t
      );
    }
    for (var o = t, u = t + t; o !== u; ++o)
      if (r[o] !== r[o + t]) {
        a.setValue(r, n);
        break;
      }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function() {
    var e = this.binding, t = this.buffer, r = this.valueSize, n = r * 3;
    e.getValue(t, n);
    for (var i = r, a = n; i !== a; ++i)
      t[i] = t[n + i % r];
    this.cumulativeWeight = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function() {
    var e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  },
  // mix functions
  _select: function(e, t, r, n, i) {
    if (n >= 0.5)
      for (var a = 0; a !== i; ++a)
        e[t + a] = e[r + a];
  },
  _slerp: function(e, t, r, n) {
    _r.slerpFlat(e, t, e, t, e, r, n);
  },
  _lerp: function(e, t, r, n, i) {
    for (var a = 1 - n, s = 0; s !== i; ++s) {
      var o = t + s;
      e[o] = e[o] * a + e[r + s] * n;
    }
  }
});
var Kh = "\\[\\]\\.:\\/";
function ly(e, t, r) {
  var n = r || Hr.parseTrackName(t);
  this._targetGroup = e, this._bindings = e.subscribe_(t, n);
}
Object.assign(ly.prototype, {
  getValue: function(e, t) {
    this.bind();
    var r = this._targetGroup.nCachedObjects_, n = this._bindings[r];
    n !== void 0 && n.getValue(e, t);
  },
  setValue: function(e, t) {
    for (var r = this._bindings, n = this._targetGroup.nCachedObjects_, i = r.length; n !== i; ++n)
      r[n].setValue(e, t);
  },
  bind: function() {
    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  },
  unbind: function() {
    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
});
function Hr(e, t, r) {
  this.path = t, this.parsedPath = r || Hr.parseTrackName(t), this.node = Hr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e;
}
Object.assign(Hr, {
  Composite: ly,
  create: function(e, t, r) {
    return e && e.isAnimationObjectGroup ? new Hr.Composite(e, t, r) : new Hr(e, t, r);
  },
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param  {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function() {
    var e = new RegExp("[" + Kh + "]", "g");
    return function(r) {
      return r.replace(/\s/g, "_").replace(e, "");
    };
  }(),
  parseTrackName: function() {
    var e = "[^" + Kh + "]", t = "[^" + Kh.replace("\\.", "") + "]", r = /((?:WC+[\/:])*)/.source.replace("WC", e), n = /(WCOD+)?/.source.replace("WCOD", t), i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", e), a = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", e), s = new RegExp(
      "^" + r + n + i + a + "$"
    ), o = ["material", "materials", "bones"];
    return function(l) {
      var c = s.exec(l);
      if (!c)
        throw new Error("PropertyBinding: Cannot parse trackName: " + l);
      var h = {
        // directoryName: matches[ 1 ], // (tschw) currently unused
        nodeName: c[2],
        objectName: c[3],
        objectIndex: c[4],
        propertyName: c[5],
        // required
        propertyIndex: c[6]
      }, f = h.nodeName && h.nodeName.lastIndexOf(".");
      if (f !== void 0 && f !== -1) {
        var d = h.nodeName.substring(f + 1);
        o.indexOf(d) !== -1 && (h.nodeName = h.nodeName.substring(0, f), h.objectName = d);
      }
      if (h.propertyName === null || h.propertyName.length === 0)
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + l);
      return h;
    };
  }(),
  findNode: function(e, t) {
    if (!t || t === "" || t === "root" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      var r = e.skeleton.getBoneByName(t);
      if (r !== void 0)
        return r;
    }
    if (e.children) {
      var n = function(a) {
        for (var s = 0; s < a.length; s++) {
          var o = a[s];
          if (o.name === t || o.uuid === t)
            return o;
          var u = n(o.children);
          if (u) return u;
        }
        return null;
      }, i = n(e.children);
      if (i)
        return i;
    }
    return null;
  }
});
Object.assign(Hr.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function(t, r) {
      t[r] = this.node[this.propertyName];
    },
    function(t, r) {
      for (var n = this.resolvedProperty, i = 0, a = n.length; i !== a; ++i)
        t[r++] = n[i];
    },
    function(t, r) {
      t[r] = this.resolvedProperty[this.propertyIndex];
    },
    function(t, r) {
      this.resolvedProperty.toArray(t, r);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      // Direct
      function(t, r) {
        this.targetObject[this.propertyName] = t[r];
      },
      function(t, r) {
        this.targetObject[this.propertyName] = t[r], this.targetObject.needsUpdate = !0;
      },
      function(t, r) {
        this.targetObject[this.propertyName] = t[r], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // EntireArray
      function(t, r) {
        for (var n = this.resolvedProperty, i = 0, a = n.length; i !== a; ++i)
          n[i] = t[r++];
      },
      function(t, r) {
        for (var n = this.resolvedProperty, i = 0, a = n.length; i !== a; ++i)
          n[i] = t[r++];
        this.targetObject.needsUpdate = !0;
      },
      function(t, r) {
        for (var n = this.resolvedProperty, i = 0, a = n.length; i !== a; ++i)
          n[i] = t[r++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // ArrayElement
      function(t, r) {
        this.resolvedProperty[this.propertyIndex] = t[r];
      },
      function(t, r) {
        this.resolvedProperty[this.propertyIndex] = t[r], this.targetObject.needsUpdate = !0;
      },
      function(t, r) {
        this.resolvedProperty[this.propertyIndex] = t[r], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // HasToFromArray
      function(t, r) {
        this.resolvedProperty.fromArray(t, r);
      },
      function(t, r) {
        this.resolvedProperty.fromArray(t, r), this.targetObject.needsUpdate = !0;
      },
      function(t, r) {
        this.resolvedProperty.fromArray(t, r), this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ]
  ],
  getValue: function(t, r) {
    this.bind(), this.getValue(t, r);
  },
  setValue: function(t, r) {
    this.bind(), this.setValue(t, r);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function() {
    var e = this.node, t = this.parsedPath, r = t.objectName, n = t.propertyName, i = t.propertyIndex;
    if (e || (e = Hr.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (r) {
      var a = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (var s = 0; s < e.length; s++)
            if (e[s].name === a) {
              a = s;
              break;
            }
          break;
        default:
          if (e[r] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[r];
      }
      if (a !== void 0) {
        if (e[a] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[a];
      }
    }
    var o = e[n];
    if (o === void 0) {
      var u = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + n + " but it wasn't found.", e);
      return;
    }
    var l = this.Versioning.None;
    e.needsUpdate !== void 0 ? (l = this.Versioning.NeedsUpdate, this.targetObject = e) : e.matrixWorldNeedsUpdate !== void 0 && (l = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = e);
    var c = this.BindingType.Direct;
    if (i !== void 0) {
      if (n === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (e.geometry.isBufferGeometry) {
          if (!e.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          for (var s = 0; s < this.node.geometry.morphAttributes.position.length; s++)
            if (e.geometry.morphAttributes.position[s].name === i) {
              i = s;
              break;
            }
        } else {
          if (!e.geometry.morphTargets) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
            return;
          }
          for (var s = 0; s < this.node.geometry.morphTargets.length; s++)
            if (e.geometry.morphTargets[s].name === i) {
              i = s;
              break;
            }
        }
      }
      c = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = i;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l];
  },
  unbind: function() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Hr.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: Hr.prototype.getValue,
  _setValue_unbound: Hr.prototype.setValue
});
function cy() {
  this.uuid = gt.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
  var e = {};
  this._indicesByUUID = e;
  for (var t = 0, r = arguments.length; t !== r; ++t)
    e[arguments[t].uuid] = t;
  this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
  var n = this;
  this.stats = {
    objects: {
      get total() {
        return n._objects.length;
      },
      get inUse() {
        return this.total - n.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return n._bindings.length;
    }
  };
}
Object.assign(cy.prototype, {
  isAnimationObjectGroup: !0,
  add: function() {
    for (var e = this._objects, t = e.length, r = this.nCachedObjects_, n = this._indicesByUUID, i = this._paths, a = this._parsedPaths, s = this._bindings, o = s.length, u = void 0, l = 0, c = arguments.length; l !== c; ++l) {
      var h = arguments[l], f = h.uuid, d = n[f];
      if (d === void 0) {
        d = t++, n[f] = d, e.push(h);
        for (var p = 0, _ = o; p !== _; ++p)
          s[p].push(new Hr(h, i[p], a[p]));
      } else if (d < r) {
        u = e[d];
        var v = --r, x = e[v];
        n[x.uuid] = d, e[d] = x, n[f] = v, e[v] = h;
        for (var p = 0, _ = o; p !== _; ++p) {
          var E = s[p], M = E[v], C = E[d];
          E[d] = M, C === void 0 && (C = new Hr(h, i[p], a[p])), E[v] = C;
        }
      } else e[d] !== u && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = r;
  },
  remove: function() {
    for (var e = this._objects, t = this.nCachedObjects_, r = this._indicesByUUID, n = this._bindings, i = n.length, a = 0, s = arguments.length; a !== s; ++a) {
      var o = arguments[a], u = o.uuid, l = r[u];
      if (l !== void 0 && l >= t) {
        var c = t++, h = e[c];
        r[h.uuid] = l, e[l] = h, r[u] = c, e[c] = o;
        for (var f = 0, d = i; f !== d; ++f) {
          var p = n[f], _ = p[c], v = p[l];
          p[l] = _, p[c] = v;
        }
      }
    }
    this.nCachedObjects_ = t;
  },
  // remove & forget
  uncache: function() {
    for (var e = this._objects, t = e.length, r = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, a = i.length, s = 0, o = arguments.length; s !== o; ++s) {
      var u = arguments[s], l = u.uuid, c = n[l];
      if (c !== void 0)
        if (delete n[l], c < r) {
          var h = --r, f = e[h], d = --t, p = e[d];
          n[f.uuid] = c, e[c] = f, n[p.uuid] = h, e[h] = p, e.pop();
          for (var _ = 0, v = a; _ !== v; ++_) {
            var x = i[_], E = x[h], M = x[d];
            x[c] = E, x[h] = M, x.pop();
          }
        } else {
          var d = --t, p = e[d];
          n[p.uuid] = c, e[c] = p, e.pop();
          for (var _ = 0, v = a; _ !== v; ++_) {
            var x = i[_];
            x[c] = x[d], x.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function(e, t) {
    var r = this._bindingsIndicesByPath, n = r[e], i = this._bindings;
    if (n !== void 0) return i[n];
    var a = this._paths, s = this._parsedPaths, o = this._objects, u = o.length, l = this.nCachedObjects_, c = new Array(u);
    n = i.length, r[e] = n, a.push(e), s.push(t), i.push(c);
    for (var h = l, f = o.length; h !== f; ++h) {
      var d = o[h];
      c[h] = new Hr(d, e, t);
    }
    return c;
  },
  unsubscribe_: function(e) {
    var t = this._bindingsIndicesByPath, r = t[e];
    if (r !== void 0) {
      var n = this._paths, i = this._parsedPaths, a = this._bindings, s = a.length - 1, o = a[s], u = e[s];
      t[u] = r, a[r] = o, a.pop(), i[r] = i[s], i.pop(), n[r] = n[s], n.pop();
    }
  }
});
function hy(e, t, r) {
  this._mixer = e, this._clip = t, this._localRoot = r || null;
  for (var n = t.tracks, i = n.length, a = new Array(i), s = {
    endingStart: ja,
    endingEnd: ja
  }, o = 0; o !== i; ++o) {
    var u = n[o].createInterpolant(null);
    a[o] = u, u.settings = s;
  }
  this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = C0, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
}
Object.assign(hy.prototype, {
  // State & Scheduling
  play: function() {
    return this._mixer._activateAction(this), this;
  },
  stop: function() {
    return this._mixer._deactivateAction(this), this.reset();
  },
  reset: function() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  },
  isRunning: function() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  // return true when play has been called
  isScheduled: function() {
    return this._mixer._isActiveAction(this);
  },
  startAt: function(e) {
    return this._startTime = e, this;
  },
  setLoop: function(e, t) {
    return this.loop = e, this.repetitions = t, this;
  },
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight: function(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  },
  // return the weight considering fading and .enabled
  getEffectiveWeight: function() {
    return this._effectiveWeight;
  },
  fadeIn: function(e) {
    return this._scheduleFading(e, 0, 1);
  },
  fadeOut: function(e) {
    return this._scheduleFading(e, 1, 0);
  },
  crossFadeFrom: function(e, t, r) {
    if (e.fadeOut(t), this.fadeIn(t), r) {
      var n = this._clip.duration, i = e._clip.duration, a = i / n, s = n / i;
      e.warp(1, a, t), this.warp(s, 1, t);
    }
    return this;
  },
  crossFadeTo: function(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  },
  stopFading: function() {
    var e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  },
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale: function(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  },
  // return the time scale considering warping and .paused
  getEffectiveTimeScale: function() {
    return this._effectiveTimeScale;
  },
  setDuration: function(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  },
  syncWith: function(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  },
  halt: function(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  },
  warp: function(e, t, r) {
    var n = this._mixer, i = n.time, a = this._timeScaleInterpolant, s = this.timeScale;
    a === null && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
    var o = a.parameterPositions, u = a.sampleValues;
    return o[0] = i, o[1] = i + r, u[0] = e / s, u[1] = t / s, this;
  },
  stopWarping: function() {
    var e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  },
  // Object Accessors
  getMixer: function() {
    return this._mixer;
  },
  getClip: function() {
    return this._clip;
  },
  getRoot: function() {
    return this._localRoot || this._mixer._root;
  },
  // Interna
  _update: function(e, t, r, n) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    var i = this._startTime;
    if (i !== null) {
      var a = (e - i) * r;
      if (a < 0 || r === 0)
        return;
      this._startTime = null, t = r * a;
    }
    t *= this._updateTimeScale(e);
    var s = this._updateTime(t), o = this._updateWeight(e);
    if (o > 0)
      for (var u = this._interpolants, l = this._propertyBindings, c = 0, h = u.length; c !== h; ++c)
        u[c].evaluate(s), l[c].accumulate(n, o);
  },
  _updateWeight: function(e) {
    var t = 0;
    if (this.enabled) {
      t = this.weight;
      var r = this._weightInterpolant;
      if (r !== null) {
        var n = r.evaluate(e)[0];
        t *= n, e > r.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  },
  _updateTimeScale: function(e) {
    var t = 0;
    if (!this.paused) {
      t = this.timeScale;
      var r = this._timeScaleInterpolant;
      if (r !== null) {
        var n = r.evaluate(e)[0];
        t *= n, e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  },
  _updateTime: function(e) {
    var t = this.time + e;
    if (e === 0) return t;
    var r = this._clip.duration, n = this.loop, i = this._loopCount;
    if (n === S0) {
      i === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (t >= r)
          t = r;
        else if (t < 0)
          t = 0;
        else break e;
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      var a = n === M0;
      if (i === -1 && (e >= 0 ? (i = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), t >= r || t < 0) {
        var s = Math.floor(t / r);
        t -= r * s, i += Math.abs(s);
        var o = this.repetitions - i;
        if (o <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? r : 0, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (o === 1) {
            var u = e < 0;
            this._setEndings(u, !u, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: s
          });
        }
      }
      if (a && (i & 1) === 1)
        return this.time = t, r - t;
    }
    return this.time = t, t;
  },
  _setEndings: function(e, t, r) {
    var n = this._interpolantSettings;
    r ? (n.endingStart = Ia, n.endingEnd = Ia) : (e ? n.endingStart = this.zeroSlopeAtStart ? Ia : ja : n.endingStart = gu, t ? n.endingEnd = this.zeroSlopeAtEnd ? Ia : ja : n.endingEnd = gu);
  },
  _scheduleFading: function(e, t, r) {
    var n = this._mixer, i = n.time, a = this._weightInterpolant;
    a === null && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
    var s = a.parameterPositions, o = a.sampleValues;
    return s[0] = i, o[0] = t, s[1] = i + e, o[1] = r, this;
  }
});
function Vf(e) {
  this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
}
Vf.prototype = Object.assign(Object.create($n.prototype), {
  constructor: Vf,
  _bindAction: function(e, t) {
    var r = e._localRoot || this._root, n = e._clip.tracks, i = n.length, a = e._propertyBindings, s = e._interpolants, o = r.uuid, u = this._bindingsByRootAndName, l = u[o];
    l === void 0 && (l = {}, u[o] = l);
    for (var c = 0; c !== i; ++c) {
      var h = n[c], f = h.name, d = l[f];
      if (d !== void 0)
        a[c] = d;
      else {
        if (d = a[c], d !== void 0) {
          d._cacheIndex === null && (++d.referenceCount, this._addInactiveBinding(d, o, f));
          continue;
        }
        var p = t && t._propertyBindings[c].binding.parsedPath;
        d = new Jd(
          Hr.create(r, f, p),
          h.ValueTypeName,
          h.getValueSize()
        ), ++d.referenceCount, this._addInactiveBinding(d, o, f), a[c] = d;
      }
      s[c].resultBuffer = d.buffer;
    }
  },
  _activateAction: function(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        var t = (e._localRoot || this._root).uuid, r = e._clip.uuid, n = this._actionsByClip[r];
        this._bindAction(
          e,
          n && n.knownActions[0]
        ), this._addInactiveAction(e, r, t);
      }
      for (var i = e._propertyBindings, a = 0, s = i.length; a !== s; ++a) {
        var o = i[a];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  },
  _deactivateAction: function(e) {
    if (this._isActiveAction(e)) {
      for (var t = e._propertyBindings, r = 0, n = t.length; r !== n; ++r) {
        var i = t[r];
        --i.useCount === 0 && (i.restoreOriginalState(), this._takeBackBinding(i));
      }
      this._takeBackAction(e);
    }
  },
  // Memory manager
  _initMemoryManager: function() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    var e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function(e) {
    var t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  },
  _addInactiveAction: function(e, t, r) {
    var n = this._actions, i = this._actionsByClip, a = i[t];
    if (a === void 0)
      a = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, i[t] = a;
    else {
      var s = a.knownActions;
      e._byClipCacheIndex = s.length, s.push(e);
    }
    e._cacheIndex = n.length, n.push(e), a.actionByRoot[r] = e;
  },
  _removeInactiveAction: function(e) {
    var t = this._actions, r = t[t.length - 1], n = e._cacheIndex;
    r._cacheIndex = n, t[n] = r, t.pop(), e._cacheIndex = null;
    var i = e._clip.uuid, a = this._actionsByClip, s = a[i], o = s.knownActions, u = o[o.length - 1], l = e._byClipCacheIndex;
    u._byClipCacheIndex = l, o[l] = u, o.pop(), e._byClipCacheIndex = null;
    var c = s.actionByRoot, h = (e._localRoot || this._root).uuid;
    delete c[h], o.length === 0 && delete a[i], this._removeInactiveBindingsForAction(e);
  },
  _removeInactiveBindingsForAction: function(e) {
    for (var t = e._propertyBindings, r = 0, n = t.length; r !== n; ++r) {
      var i = t[r];
      --i.referenceCount === 0 && this._removeInactiveBinding(i);
    }
  },
  _lendAction: function(e) {
    var t = this._actions, r = e._cacheIndex, n = this._nActiveActions++, i = t[n];
    e._cacheIndex = n, t[n] = e, i._cacheIndex = r, t[r] = i;
  },
  _takeBackAction: function(e) {
    var t = this._actions, r = e._cacheIndex, n = --this._nActiveActions, i = t[n];
    e._cacheIndex = n, t[n] = e, i._cacheIndex = r, t[r] = i;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function(e, t, r) {
    var n = this._bindingsByRootAndName, i = n[t], a = this._bindings;
    i === void 0 && (i = {}, n[t] = i), i[r] = e, e._cacheIndex = a.length, a.push(e);
  },
  _removeInactiveBinding: function(e) {
    var t = this._bindings, r = e.binding, n = r.rootNode.uuid, i = r.path, a = this._bindingsByRootAndName, s = a[n], o = t[t.length - 1], u = e._cacheIndex;
    o._cacheIndex = u, t[u] = o, t.pop(), delete s[i];
    e: {
      for (var l in s) break e;
      delete a[n];
    }
  },
  _lendBinding: function(e) {
    var t = this._bindings, r = e._cacheIndex, n = this._nActiveBindings++, i = t[n];
    e._cacheIndex = n, t[n] = e, i._cacheIndex = r, t[r] = i;
  },
  _takeBackBinding: function(e) {
    var t = this._bindings, r = e._cacheIndex, n = --this._nActiveBindings, i = t[n];
    e._cacheIndex = n, t[n] = e, i._cacheIndex = r, t[r] = i;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function() {
    var e = this._controlInterpolants, t = this._nActiveControlInterpolants++, r = e[t];
    return r === void 0 && (r = new Zu(
      new Float32Array(2),
      new Float32Array(2),
      1,
      this._controlInterpolantsResultBuffer
    ), r.__cacheIndex = t, e[t] = r), r;
  },
  _takeBackControlInterpolant: function(e) {
    var t = this._controlInterpolants, r = e.__cacheIndex, n = --this._nActiveControlInterpolants, i = t[n];
    e.__cacheIndex = n, t[n] = e, i.__cacheIndex = r, t[r] = i;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function(e, t) {
    var r = t || this._root, n = r.uuid, i = typeof e == "string" ? Ii.findByName(r, e) : e, a = i !== null ? i.uuid : e, s = this._actionsByClip[a], o = null;
    if (s !== void 0) {
      var u = s.actionByRoot[n];
      if (u !== void 0)
        return u;
      o = s.knownActions[0], i === null && (i = o._clip);
    }
    if (i === null) return null;
    var l = new hy(this, i, t);
    return this._bindAction(l, o), this._addInactiveAction(l, a, n), l;
  },
  // get an existing action
  existingAction: function(e, t) {
    var r = t || this._root, n = r.uuid, i = typeof e == "string" ? Ii.findByName(r, e) : e, a = i ? i.uuid : e, s = this._actionsByClip[a];
    return s !== void 0 && s.actionByRoot[n] || null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function() {
    var e = this._actions, t = this._nActiveActions, r = this._bindings, n = this._nActiveBindings;
    this._nActiveActions = 0, this._nActiveBindings = 0;
    for (var i = 0; i !== t; ++i)
      e[i].reset();
    for (var i = 0; i !== n; ++i)
      r[i].useCount = 0;
    return this;
  },
  // advance the time and update apply the animation
  update: function(e) {
    e *= this.timeScale;
    for (var t = this._actions, r = this._nActiveActions, n = this.time += e, i = Math.sign(e), a = this._accuIndex ^= 1, s = 0; s !== r; ++s) {
      var o = t[s];
      o._update(n, e, i, a);
    }
    for (var u = this._bindings, l = this._nActiveBindings, s = 0; s !== l; ++s)
      u[s].apply(a);
    return this;
  },
  // return this mixer's root target object
  getRoot: function() {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function(e) {
    var t = this._actions, r = e.uuid, n = this._actionsByClip, i = n[r];
    if (i !== void 0) {
      for (var a = i.knownActions, s = 0, o = a.length; s !== o; ++s) {
        var u = a[s];
        this._deactivateAction(u);
        var l = u._cacheIndex, c = t[t.length - 1];
        u._cacheIndex = null, u._byClipCacheIndex = null, c._cacheIndex = l, t[l] = c, t.pop(), this._removeInactiveBindingsForAction(u);
      }
      delete n[r];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function(e) {
    var t = e.uuid, r = this._actionsByClip;
    for (var n in r) {
      var i = r[n].actionByRoot, a = i[t];
      a !== void 0 && (this._deactivateAction(a), this._removeInactiveAction(a));
    }
    var s = this._bindingsByRootAndName, o = s[t];
    if (o !== void 0)
      for (var u in o) {
        var l = o[u];
        l.restoreOriginalState(), this._removeInactiveBinding(l);
      }
  },
  // remove a targeted clip from the cache
  uncacheAction: function(e, t) {
    var r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
});
function Pc(e) {
  typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e;
}
Pc.prototype.clone = function() {
  return new Pc(this.value.clone === void 0 ? this.value : this.value.clone());
};
function Hf() {
  Ge.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
}
Hf.prototype = Object.assign(Object.create(Ge.prototype), {
  constructor: Hf,
  isInstancedBufferGeometry: !0,
  copy: function(e) {
    return Ge.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function ep(e, t, r, n) {
  this.data = e, this.itemSize = t, this.offset = r, this.normalized = n === !0;
}
Object.defineProperties(ep.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  }
});
Object.assign(ep.prototype, {
  isInterleavedBufferAttribute: !0,
  setX: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset] = t, this;
  },
  setY: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  },
  setZ: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  },
  setW: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  },
  getX: function(e) {
    return this.data.array[e * this.data.stride + this.offset];
  },
  getY: function(e) {
    return this.data.array[e * this.data.stride + this.offset + 1];
  },
  getZ: function(e) {
    return this.data.array[e * this.data.stride + this.offset + 2];
  },
  getW: function(e) {
    return this.data.array[e * this.data.stride + this.offset + 3];
  },
  setXY: function(e, t, r) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this;
  },
  setXYZ: function(e, t, r, n) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = n, this;
  },
  setXYZW: function(e, t, r, n, i) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = n, this.data.array[e + 3] = i, this;
  }
});
function po(e, t) {
  this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
Object.defineProperty(po.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
Object.assign(po.prototype, {
  isInterleavedBuffer: !0,
  onUploadCallback: function() {
  },
  setArray: function(e) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    return this.count = e !== void 0 ? e.length / this.stride : 0, this.array = e, this;
  },
  setDynamic: function(e) {
    return this.dynamic = e, this;
  },
  copy: function(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this;
  },
  copyAt: function(e, t, r) {
    e *= this.stride, r *= t.stride;
    for (var n = 0, i = this.stride; n < i; n++)
      this.array[e + n] = t.array[r + n];
    return this;
  },
  set: function(e, t) {
    return t === void 0 && (t = 0), this.array.set(e, t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  onUpload: function(e) {
    return this.onUploadCallback = e, this;
  }
});
function zf(e, t, r) {
  po.call(this, e, t), this.meshPerAttribute = r || 1;
}
zf.prototype = Object.assign(Object.create(po.prototype), {
  constructor: zf,
  isInstancedInterleavedBuffer: !0,
  copy: function(e) {
    return po.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
});
function Wf(e, t, r) {
  pt.call(this, e, t), this.meshPerAttribute = r || 1;
}
Wf.prototype = Object.assign(Object.create(pt.prototype), {
  constructor: Wf,
  isInstancedBufferAttribute: !0,
  copy: function(e) {
    return pt.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
});
function fy(e, t, r, n) {
  this.ray = new ms(e, t), this.near = r || 0, this.far = n || 1 / 0, this.params = {
    Mesh: {},
    Line: {},
    LOD: {},
    Points: { threshold: 1 },
    Sprite: {}
  }, Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
      }
    }
  });
}
function Zm(e, t) {
  return e.distance - t.distance;
}
function jf(e, t, r, n) {
  if (e.visible !== !1 && (e.raycast(t, r), n === !0))
    for (var i = e.children, a = 0, s = i.length; a < s; a++)
      jf(i[a], t, r, !0);
}
Object.assign(fy.prototype, {
  linePrecision: 1,
  set: function(e, t) {
    this.ray.set(e, t);
  },
  setFromCamera: function(e, t) {
    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
  },
  intersectObject: function(e, t, r) {
    var n = r || [];
    return jf(e, this, n, t), n.sort(Zm), n;
  },
  intersectObjects: function(e, t, r) {
    var n = r || [];
    if (Array.isArray(e) === !1)
      return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
    for (var i = 0, a = e.length; i < a; i++)
      jf(e[i], this, n, t);
    return n.sort(Zm), n;
  }
});
function dy(e) {
  this.autoStart = e !== void 0 ? e : !0, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
}
Object.assign(dy.prototype, {
  start: function() {
    this.startTime = (typeof performance > "u" ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  },
  stop: function() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  },
  getElapsedTime: function() {
    return this.getDelta(), this.elapsedTime;
  },
  getDelta: function() {
    var e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      var t = (typeof performance > "u" ? Date : performance).now();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
});
function py(e, t, r) {
  return this.radius = e !== void 0 ? e : 1, this.phi = t !== void 0 ? t : 0, this.theta = r !== void 0 ? r : 0, this;
}
Object.assign(py.prototype, {
  set: function(e, t, r) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  },
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe: function() {
    var e = 1e-6;
    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this;
  },
  setFromVector3: function(e) {
    return this.radius = e.length(), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e.x, e.z), this.phi = Math.acos(gt.clamp(e.y / this.radius, -1, 1))), this;
  }
});
function my(e, t, r) {
  return this.radius = e !== void 0 ? e : 1, this.theta = t !== void 0 ? t : 0, this.y = r !== void 0 ? r : 0, this;
}
Object.assign(my.prototype, {
  set: function(e, t, r) {
    return this.radius = e, this.theta = t, this.y = r, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  },
  setFromVector3: function(e) {
    return this.radius = Math.sqrt(e.x * e.x + e.z * e.z), this.theta = Math.atan2(e.x, e.z), this.y = e.y, this;
  }
});
function tp(e, t) {
  this.min = e !== void 0 ? e : new ue(1 / 0, 1 / 0), this.max = t !== void 0 ? t : new ue(-1 / 0, -1 / 0);
}
Object.assign(tp.prototype, {
  set: function(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  },
  setFromPoints: function(e) {
    this.makeEmpty();
    for (var t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  },
  setFromCenterAndSize: function() {
    var e = new ue();
    return function(r, n) {
      var i = e.copy(n).multiplyScalar(0.5);
      return this.min.copy(r).sub(i), this.max.copy(r).add(i), this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  },
  makeEmpty: function() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new ue()), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), e = new ue()), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  },
  expandByPoint: function(e) {
    return this.min.min(e), this.max.max(e), this;
  },
  expandByVector: function(e) {
    return this.min.sub(e), this.max.add(e), this;
  },
  expandByScalar: function(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  },
  containsPoint: function(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  },
  containsBox: function(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  },
  getParameter: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new ue()), t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  },
  intersectsBox: function(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  },
  clampPoint: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new ue()), t.copy(e).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var e = new ue();
    return function(r) {
      var n = e.copy(r).clamp(this.min, this.max);
      return n.sub(r).length();
    };
  }(),
  intersect: function(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  },
  union: function(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  },
  translate: function(e) {
    return this.min.add(e), this.max.add(e), this;
  },
  equals: function(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
});
function el(e) {
  ke.call(this), this.material = e, this.render = function() {
  };
}
el.prototype = Object.create(ke.prototype);
el.prototype.constructor = el;
el.prototype.isImmediateRenderObject = !0;
function tl(e, t, r, n) {
  this.object = e, this.size = t !== void 0 ? t : 1;
  var i = r !== void 0 ? r : 16711680, a = n !== void 0 ? n : 1, s = 0, o = this.object.geometry;
  o && o.isGeometry ? s = o.faces.length * 3 : o && o.isBufferGeometry && (s = o.attributes.normal.count);
  var u = new Ge(), l = new Be(s * 2 * 3, 3);
  u.addAttribute("position", l), Yt.call(this, u, new qt({ color: i, linewidth: a })), this.matrixAutoUpdate = !1, this.update();
}
tl.prototype = Object.create(Yt.prototype);
tl.prototype.constructor = tl;
tl.prototype.update = function() {
  var e = new z(), t = new z(), r = new wr();
  return function() {
    var i = ["a", "b", "c"];
    this.object.updateMatrixWorld(!0), r.getNormalMatrix(this.object.matrixWorld);
    var a = this.object.matrixWorld, s = this.geometry.attributes.position, o = this.object.geometry;
    if (o && o.isGeometry)
      for (var u = o.vertices, l = o.faces, c = 0, h = 0, f = l.length; h < f; h++)
        for (var d = l[h], p = 0, _ = d.vertexNormals.length; p < _; p++) {
          var v = u[d[i[p]]], x = d.vertexNormals[p];
          e.copy(v).applyMatrix4(a), t.copy(x).applyMatrix3(r).normalize().multiplyScalar(this.size).add(e), s.setXYZ(c, e.x, e.y, e.z), c = c + 1, s.setXYZ(c, t.x, t.y, t.z), c = c + 1;
        }
    else if (o && o.isBufferGeometry)
      for (var E = o.attributes.position, M = o.attributes.normal, c = 0, p = 0, _ = E.count; p < _; p++)
        e.set(E.getX(p), E.getY(p), E.getZ(p)).applyMatrix4(a), t.set(M.getX(p), M.getY(p), M.getZ(p)), t.applyMatrix3(r).normalize().multiplyScalar(this.size).add(e), s.setXYZ(c, e.x, e.y, e.z), c = c + 1, s.setXYZ(c, t.x, t.y, t.z), c = c + 1;
    s.needsUpdate = !0;
  };
}();
function mo(e, t) {
  ke.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
  for (var r = new Ge(), n = [
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    -1,
    1
  ], i = 0, a = 1, s = 32; i < s; i++, a++) {
    var o = i / s * Math.PI * 2, u = a / s * Math.PI * 2;
    n.push(
      Math.cos(o),
      Math.sin(o),
      1,
      Math.cos(u),
      Math.sin(u),
      1
    );
  }
  r.addAttribute("position", new Be(n, 3));
  var l = new qt({ fog: !1 });
  this.cone = new Yt(r, l), this.add(this.cone), this.update();
}
mo.prototype = Object.create(ke.prototype);
mo.prototype.constructor = mo;
mo.prototype.dispose = function() {
  this.cone.geometry.dispose(), this.cone.material.dispose();
};
mo.prototype.update = function() {
  var e = new z(), t = new z();
  return function() {
    this.light.updateMatrixWorld();
    var n = this.light.distance ? this.light.distance : 1e3, i = n * Math.tan(this.light.angle);
    this.cone.scale.set(i, i, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  };
}();
function vy(e) {
  var t = [];
  e && e.isBone && t.push(e);
  for (var r = 0; r < e.children.length; r++)
    t.push.apply(t, vy(e.children[r]));
  return t;
}
function vo(e) {
  for (var t = vy(e), r = new Ge(), n = [], i = [], a = new je(0, 0, 1), s = new je(0, 1, 0), o = 0; o < t.length; o++) {
    var u = t[o];
    u.parent && u.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), i.push(a.r, a.g, a.b), i.push(s.r, s.g, s.b));
  }
  r.addAttribute("position", new Be(n, 3)), r.addAttribute("color", new Be(i, 3));
  var l = new qt({ vertexColors: ds, depthTest: !1, depthWrite: !1, transparent: !0 });
  Yt.call(this, r, l), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
}
vo.prototype = Object.create(Yt.prototype);
vo.prototype.constructor = vo;
vo.prototype.updateMatrixWorld = function() {
  var e = new z(), t = new at(), r = new at();
  return function(i) {
    var a = this.bones, s = this.geometry, o = s.getAttribute("position");
    r.getInverse(this.root.matrixWorld);
    for (var u = 0, l = 0; u < a.length; u++) {
      var c = a[u];
      c.parent && c.parent.isBone && (t.multiplyMatrices(r, c.matrixWorld), e.setFromMatrixPosition(t), o.setXYZ(l, e.x, e.y, e.z), t.multiplyMatrices(r, c.parent.matrixWorld), e.setFromMatrixPosition(t), o.setXYZ(l + 1, e.x, e.y, e.z), l += 2);
    }
    s.getAttribute("position").needsUpdate = !0, ke.prototype.updateMatrixWorld.call(this, i);
  };
}();
function go(e, t, r) {
  this.light = e, this.light.updateMatrixWorld(), this.color = r;
  var n = new ma(t, 4, 2), i = new Er({ wireframe: !0, fog: !1 });
  dr.call(this, n, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
}
go.prototype = Object.create(dr.prototype);
go.prototype.constructor = go;
go.prototype.dispose = function() {
  this.geometry.dispose(), this.material.dispose();
};
go.prototype.update = function() {
  this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
};
function yo(e, t) {
  ke.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
  var r = new qt({ fog: !1 }), n = new Ge();
  n.addAttribute("position", new pt(new Float32Array(5 * 3), 3)), this.line = new hi(n, r), this.add(this.line), this.update();
}
yo.prototype = Object.create(ke.prototype);
yo.prototype.constructor = yo;
yo.prototype.dispose = function() {
  this.children[0].geometry.dispose(), this.children[0].material.dispose();
};
yo.prototype.update = function() {
  var e = this.light.width * 0.5, t = this.light.height * 0.5, r = this.line.geometry.attributes.position, n = r.array;
  n[0] = e, n[1] = -t, n[2] = 0, n[3] = e, n[4] = t, n[5] = 0, n[6] = -e, n[7] = t, n[8] = 0, n[9] = -e, n[10] = -t, n[11] = 0, n[12] = e, n[13] = -t, n[14] = 0, r.needsUpdate = !0, this.color !== void 0 ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
};
function _o(e, t, r) {
  ke.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r;
  var n = new Za(t);
  n.rotateY(Math.PI * 0.5), this.material = new Er({ wireframe: !0, fog: !1 }), this.color === void 0 && (this.material.vertexColors = ds);
  var i = n.getAttribute("position"), a = new Float32Array(i.count * 3);
  n.addAttribute("color", new pt(a, 3)), this.add(new dr(n, this.material)), this.update();
}
_o.prototype = Object.create(ke.prototype);
_o.prototype.constructor = _o;
_o.prototype.dispose = function() {
  this.children[0].geometry.dispose(), this.children[0].material.dispose();
};
_o.prototype.update = function() {
  var e = new z(), t = new je(), r = new je();
  return function() {
    var i = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      var a = i.geometry.getAttribute("color");
      t.copy(this.light.color), r.copy(this.light.groundColor);
      for (var s = 0, o = a.count; s < o; s++) {
        var u = s < o / 2 ? t : r;
        a.setXYZ(s, u.r, u.g, u.b);
      }
      a.needsUpdate = !0;
    }
    i.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate());
  };
}();
function rl(e, t, r, n) {
  e = e || 10, t = t || 10, r = new je(r !== void 0 ? r : 4473924), n = new je(n !== void 0 ? n : 8947848);
  for (var i = t / 2, a = e / t, s = e / 2, o = [], u = [], l = 0, c = 0, h = -s; l <= t; l++, h += a) {
    o.push(-s, 0, h, s, 0, h), o.push(h, 0, -s, h, 0, s);
    var f = l === i ? r : n;
    f.toArray(u, c), c += 3, f.toArray(u, c), c += 3, f.toArray(u, c), c += 3, f.toArray(u, c), c += 3;
  }
  var d = new Ge();
  d.addAttribute("position", new Be(o, 3)), d.addAttribute("color", new Be(u, 3));
  var p = new qt({ vertexColors: ds });
  Yt.call(this, d, p);
}
rl.prototype = Object.create(Yt.prototype);
rl.prototype.constructor = rl;
function Lc(e, t, r, n, i, a) {
  e = e || 10, t = t || 16, r = r || 8, n = n || 64, i = new je(i !== void 0 ? i : 4473924), a = new je(a !== void 0 ? a : 8947848);
  var s = [], o = [], u, l, c, h, f, d, p;
  for (h = 0; h <= t; h++)
    c = h / t * (Math.PI * 2), u = Math.sin(c) * e, l = Math.cos(c) * e, s.push(0, 0, 0), s.push(u, 0, l), p = h & 1 ? i : a, o.push(p.r, p.g, p.b), o.push(p.r, p.g, p.b);
  for (h = 0; h <= r; h++)
    for (p = h & 1 ? i : a, d = e - e / r * h, f = 0; f < n; f++)
      c = f / n * (Math.PI * 2), u = Math.sin(c) * d, l = Math.cos(c) * d, s.push(u, 0, l), o.push(p.r, p.g, p.b), c = (f + 1) / n * (Math.PI * 2), u = Math.sin(c) * d, l = Math.cos(c) * d, s.push(u, 0, l), o.push(p.r, p.g, p.b);
  var _ = new Ge();
  _.addAttribute("position", new Be(s, 3)), _.addAttribute("color", new Be(o, 3));
  var v = new qt({ vertexColors: ds });
  Yt.call(this, _, v);
}
Lc.prototype = Object.create(Yt.prototype);
Lc.prototype.constructor = Lc;
function il(e, t, r, n) {
  this.object = e, this.size = t !== void 0 ? t : 1;
  var i = r !== void 0 ? r : 16776960, a = n !== void 0 ? n : 1, s = 0, o = this.object.geometry;
  o && o.isGeometry ? s = o.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
  var u = new Ge(), l = new Be(s * 2 * 3, 3);
  u.addAttribute("position", l), Yt.call(this, u, new qt({ color: i, linewidth: a })), this.matrixAutoUpdate = !1, this.update();
}
il.prototype = Object.create(Yt.prototype);
il.prototype.constructor = il;
il.prototype.update = function() {
  var e = new z(), t = new z(), r = new wr();
  return function() {
    this.object.updateMatrixWorld(!0), r.getNormalMatrix(this.object.matrixWorld);
    for (var i = this.object.matrixWorld, a = this.geometry.attributes.position, s = this.object.geometry, o = s.vertices, u = s.faces, l = 0, c = 0, h = u.length; c < h; c++) {
      var f = u[c], d = f.normal;
      e.copy(o[f.a]).add(o[f.b]).add(o[f.c]).divideScalar(3).applyMatrix4(i), t.copy(d).applyMatrix3(r).normalize().multiplyScalar(this.size).add(e), a.setXYZ(l, e.x, e.y, e.z), l = l + 1, a.setXYZ(l, t.x, t.y, t.z), l = l + 1;
    }
    a.needsUpdate = !0;
  };
}();
function bo(e, t, r) {
  ke.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, t === void 0 && (t = 1);
  var n = new Ge();
  n.addAttribute("position", new Be([
    -t,
    t,
    0,
    t,
    t,
    0,
    t,
    -t,
    0,
    -t,
    -t,
    0,
    -t,
    t,
    0
  ], 3));
  var i = new qt({ fog: !1 });
  this.lightPlane = new hi(n, i), this.add(this.lightPlane), n = new Ge(), n.addAttribute("position", new Be([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new hi(n, i), this.add(this.targetLine), this.update();
}
bo.prototype = Object.create(ke.prototype);
bo.prototype.constructor = bo;
bo.prototype.dispose = function() {
  this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
};
bo.prototype.update = function() {
  var e = new z(), t = new z(), r = new z();
  return function() {
    e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), r.subVectors(t, e), this.lightPlane.lookAt(r), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(r), this.targetLine.scale.z = r.length();
  };
}();
function nl(e) {
  var t = new Ge(), r = new qt({ color: 16777215, vertexColors: wd }), n = [], i = [], a = {}, s = new je(16755200), o = new je(16711680), u = new je(43775), l = new je(16777215), c = new je(3355443);
  h("n1", "n2", s), h("n2", "n4", s), h("n4", "n3", s), h("n3", "n1", s), h("f1", "f2", s), h("f2", "f4", s), h("f4", "f3", s), h("f3", "f1", s), h("n1", "f1", s), h("n2", "f2", s), h("n3", "f3", s), h("n4", "f4", s), h("p", "n1", o), h("p", "n2", o), h("p", "n3", o), h("p", "n4", o), h("u1", "u2", u), h("u2", "u3", u), h("u3", "u1", u), h("c", "t", l), h("p", "c", c), h("cn1", "cn2", c), h("cn3", "cn4", c), h("cf1", "cf2", c), h("cf3", "cf4", c);
  function h(d, p, _) {
    f(d, _), f(p, _);
  }
  function f(d, p) {
    n.push(0, 0, 0), i.push(p.r, p.g, p.b), a[d] === void 0 && (a[d] = []), a[d].push(n.length / 3 - 1);
  }
  t.addAttribute("position", new Be(n, 3)), t.addAttribute("color", new Be(i, 3)), Yt.call(this, t, r), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
}
nl.prototype = Object.create(Yt.prototype);
nl.prototype.constructor = nl;
nl.prototype.update = function() {
  var e, t, r = new z(), n = new _n();
  function i(a, s, o, u) {
    r.set(s, o, u).unproject(n);
    var l = t[a];
    if (l !== void 0)
      for (var c = e.getAttribute("position"), h = 0, f = l.length; h < f; h++)
        c.setXYZ(l[h], r.x, r.y, r.z);
  }
  return function() {
    e = this.geometry, t = this.pointMap;
    var s = 1, o = 1;
    n.projectionMatrix.copy(this.camera.projectionMatrix), i("c", 0, 0, -1), i("t", 0, 0, 1), i("n1", -s, -o, -1), i("n2", s, -o, -1), i("n3", -s, o, -1), i("n4", s, o, -1), i("f1", -s, -o, 1), i("f2", s, -o, 1), i("f3", -s, o, 1), i("f4", s, o, 1), i("u1", s * 0.7, o * 1.1, -1), i("u2", -s * 0.7, o * 1.1, -1), i("u3", 0, o * 2, -1), i("cf1", -s, 0, 1), i("cf2", s, 0, 1), i("cf3", 0, -o, 1), i("cf4", 0, o, 1), i("cn1", -s, 0, -1), i("cn2", s, 0, -1), i("cn3", 0, -o, -1), i("cn4", 0, o, -1), e.getAttribute("position").needsUpdate = !0;
  };
}();
function cs(e, t) {
  this.object = e, t === void 0 && (t = 16776960);
  var r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(8 * 3), i = new Ge();
  i.setIndex(new pt(r, 1)), i.addAttribute("position", new pt(n, 3)), Yt.call(this, i, new qt({ color: t })), this.matrixAutoUpdate = !1, this.update();
}
cs.prototype = Object.create(Yt.prototype);
cs.prototype.constructor = cs;
cs.prototype.update = function() {
  var e = new Hn();
  return function(r) {
    if (r !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && e.setFromObject(this.object), !e.isEmpty()) {
      var n = e.min, i = e.max, a = this.geometry.attributes.position, s = a.array;
      s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = n.x, s[4] = i.y, s[5] = i.z, s[6] = n.x, s[7] = n.y, s[8] = i.z, s[9] = i.x, s[10] = n.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = n.z, s[15] = n.x, s[16] = i.y, s[17] = n.z, s[18] = n.x, s[19] = n.y, s[20] = n.z, s[21] = i.x, s[22] = n.y, s[23] = n.z, a.needsUpdate = !0, this.geometry.computeBoundingSphere();
    }
  };
}();
cs.prototype.setFromObject = function(e) {
  return this.object = e, this.update(), this;
};
function al(e, t) {
  this.type = "Box3Helper", this.box = e;
  var r = t !== void 0 ? t : 16776960, n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], a = new Ge();
  a.setIndex(new pt(n, 1)), a.addAttribute("position", new Be(i, 3)), Yt.call(this, a, new qt({ color: r })), this.geometry.computeBoundingSphere();
}
al.prototype = Object.create(Yt.prototype);
al.prototype.constructor = al;
al.prototype.updateMatrixWorld = function(e) {
  var t = this.box;
  t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), ke.prototype.updateMatrixWorld.call(this, e));
};
function sl(e, t, r) {
  this.type = "PlaneHelper", this.plane = e, this.size = t === void 0 ? 1 : t;
  var n = r !== void 0 ? r : 16776960, i = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], a = new Ge();
  a.addAttribute("position", new Be(i, 3)), a.computeBoundingSphere(), hi.call(this, a, new qt({ color: n }));
  var s = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], o = new Ge();
  o.addAttribute("position", new Be(s, 3)), o.computeBoundingSphere(), this.add(new dr(o, new Er({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1 })));
}
sl.prototype = Object.create(hi.prototype);
sl.prototype.constructor = sl;
sl.prototype.updateMatrixWorld = function(e) {
  var t = -this.plane.constant;
  Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, t), this.children[0].material.side = t < 0 ? Tr : yl, this.lookAt(this.plane.normal), ke.prototype.updateMatrixWorld.call(this, e);
};
var Gl, $h;
function hs(e, t, r, n, i, a) {
  ke.call(this), n === void 0 && (n = 16776960), r === void 0 && (r = 1), i === void 0 && (i = 0.2 * r), a === void 0 && (a = 0.2 * i), Gl === void 0 && (Gl = new Ge(), Gl.addAttribute("position", new Be([0, 0, 0, 0, 1, 0], 3)), $h = new zn(0, 0.5, 1, 5, 1), $h.translate(0, -0.5, 0)), this.position.copy(t), this.line = new hi(Gl, new qt({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new dr($h, new Er({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, i, a);
}
hs.prototype = Object.create(ke.prototype);
hs.prototype.constructor = hs;
hs.prototype.setDirection = function() {
  var e = new z(), t;
  return function(n) {
    n.y > 0.99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -0.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t));
  };
}();
hs.prototype.setLength = function(e, t, r) {
  t === void 0 && (t = 0.2 * e), r === void 0 && (r = 0.2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix();
};
hs.prototype.setColor = function(e) {
  this.line.material.color.copy(e), this.cone.material.color.copy(e);
};
function ol(e) {
  e = e || 1;
  var t = [
    0,
    0,
    0,
    e,
    0,
    0,
    0,
    0,
    0,
    0,
    e,
    0,
    0,
    0,
    0,
    0,
    0,
    e
  ], r = [
    1,
    0,
    0,
    1,
    0.6,
    0,
    0,
    1,
    0,
    0.6,
    1,
    0,
    0,
    0,
    1,
    0,
    0.6,
    1
  ], n = new Ge();
  n.addAttribute("position", new Be(t, 3)), n.addAttribute("color", new Be(r, 3));
  var i = new qt({ vertexColors: ds });
  Yt.call(this, n, i);
}
ol.prototype = Object.create(Yt.prototype);
ol.prototype.constructor = ol;
function bE(e, t, r, n, i, a, s) {
  return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new kn(e, t, r, i, a, s);
}
var xE = 0, AE = 1;
function TE(e) {
  return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e;
}
function EE(e) {
  return e === void 0 && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
    return e.slice();
  }, e;
}
function wE(e, t) {
  return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new qs(e, t);
}
function SE(e) {
  return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Mu(e);
}
function CE(e, t) {
  return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new qs(e, t);
}
function ME(e) {
  return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Xi(e);
}
function DE(e) {
  return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Xi(e);
}
function PE(e) {
  return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Xi(e);
}
function LE(e, t, r) {
  return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new z(e, t, r);
}
function RE(e, t) {
  return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new pt(e, t).setDynamic(!0);
}
function IE(e, t) {
  return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new _u(e, t);
}
function OE(e, t) {
  return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new bu(e, t);
}
function BE(e, t) {
  return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new xu(e, t);
}
function FE(e, t) {
  return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Au(e, t);
}
function kE(e, t) {
  return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Ya(e, t);
}
function NE(e, t) {
  return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Tu(e, t);
}
function UE(e, t) {
  return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Qa(e, t);
}
function GE(e, t) {
  return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Be(e, t);
}
function VE(e, t) {
  return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Eu(e, t);
}
Ye.create = function(e, t) {
  return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Ye.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e;
};
Object.assign(Fn.prototype, {
  createPointsGeometry: function(e) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var t = this.getPoints(e);
    return this.createGeometry(t);
  },
  createSpacedPointsGeometry: function(e) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var t = this.getSpacedPoints(e);
    return this.createGeometry(t);
  },
  createGeometry: function(e) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    for (var t = new tt(), r = 0, n = e.length; r < n; r++) {
      var i = e[r];
      t.vertices.push(new z(i.x, i.y, i.z || 0));
    }
    return t;
  }
});
Object.assign(zi.prototype, {
  fromPoints: function(e) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e);
  }
});
function gy(e) {
  console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Wr.call(this, e), this.type = "catmullrom", this.closed = !0;
}
gy.prototype = Object.create(Wr.prototype);
function yy(e) {
  console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Wr.call(this, e), this.type = "catmullrom";
}
yy.prototype = Object.create(Wr.prototype);
function rp(e) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Wr.call(this, e), this.type = "catmullrom";
}
rp.prototype = Object.create(Wr.prototype);
Object.assign(rp.prototype, {
  initFromArray: function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
});
function HE(e) {
  return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new ol(e);
}
function zE(e, t) {
  return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new cs(e, t);
}
function WE(e, t) {
  return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Yt(new ao(e.geometry), new qt({ color: t !== void 0 ? t : 16777215 }));
}
rl.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
vo.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
function jE(e, t) {
  return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Yt(new Ys(e.geometry), new qt({ color: t !== void 0 ? t : 16777215 }));
}
Object.assign(ho.prototype, {
  extractUrlBase: function(e) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Xd.extractUrlBase(e);
  }
});
function qE(e) {
  return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new tn(e);
}
function XE(e) {
  return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new zd(e);
}
Object.assign(tp.prototype, {
  center: function(e) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e);
  },
  empty: function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(e) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
  },
  size: function(e) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e);
  }
});
Object.assign(Hn.prototype, {
  center: function(e) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e);
  },
  empty: function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(e) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
  },
  isIntersectionSphere: function(e) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e);
  },
  size: function(e) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e);
  }
});
Os.prototype.center = function(e) {
  return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e);
};
Object.assign(gt, {
  random16: function() {
    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
  },
  nearestPowerOfTwo: function(e) {
    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), gt.floorPowerOfTwo(e);
  },
  nextPowerOfTwo: function(e) {
    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), gt.ceilPowerOfTwo(e);
  }
});
Object.assign(wr.prototype, {
  flattenToArrayOffset: function(e, t) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t);
  },
  multiplyVector3: function(e) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBuffer: function(e) {
    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }
});
Object.assign(at.prototype, {
  extractPosition: function(e) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e);
  },
  flattenToArrayOffset: function(e, t) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t);
  },
  getPosition: /* @__PURE__ */ function() {
    var e;
    return function() {
      return e === void 0 && (e = new z()), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3);
    };
  }(),
  setRotationFromQuaternion: function(e) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e);
  },
  multiplyToArray: function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function(e) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  multiplyVector4: function(e) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function(e) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this);
  },
  crossVector: function(e) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  translate: function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBuffer: function(e) {
    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function(e, t, r, n, i, a) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, r, i, a);
  }
});
Vi.prototype.isIntersectionLine = function(e) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e);
};
_r.prototype.multiplyVector3 = function(e) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this);
};
Object.assign(ms.prototype, {
  isIntersectionBox: function(e) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
  },
  isIntersectionPlane: function(e) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e);
  },
  isIntersectionSphere: function(e) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e);
  }
});
Object.assign(Si.prototype, {
  area: function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  },
  barycoordFromPoint: function(e, t) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t);
  },
  midpoint: function(e) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e);
  },
  normal: function(e) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e);
  },
  plane: function(e) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e);
  }
});
Object.assign(Si, {
  barycoordFromPoint: function(e, t, r, n, i) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Si.getBarycoord(e, t, r, n, i);
  },
  normal: function(e, t, r, n) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Si.getNormal(e, t, r, n);
  }
});
Object.assign(la.prototype, {
  extractAllPoints: function(e) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e);
  },
  extrude: function(e) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ja(this, e);
  },
  makeGeometry: function(e) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new es(this, e);
  }
});
Object.assign(ue.prototype, {
  fromAttribute: function(e, t, r) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, r);
  },
  distanceToManhattan: function(e) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(z.prototype, {
  setEulerFromRotationMatrix: function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function(e) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e);
  },
  getScaleFromMatrix: function(e) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e);
  },
  getColumnFromMatrix: function(e, t) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e);
  },
  applyProjection: function(e) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e);
  },
  fromAttribute: function(e, t, r) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, r);
  },
  distanceToManhattan: function(e) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(kt.prototype, {
  fromAttribute: function(e, t, r) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, r);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(tt.prototype, {
  computeTangents: function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
});
Object.assign(ke.prototype, {
  getChildByName: function(e) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e);
  },
  renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function(e, t) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e);
  },
  getWorldRotation: function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }
});
Object.defineProperties(ke.prototype, {
  eulerOrder: {
    get: function() {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function(e) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Object.defineProperties(Du.prototype, {
  objects: {
    get: function() {
      return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
    }
  }
});
Object.defineProperty(Pu.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
Object.defineProperty(Ye.prototype, "__arcLengthDivisions", {
  get: function() {
    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
  },
  set: function(e) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e;
  }
});
or.prototype.setLens = function(e, t) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), t !== void 0 && (this.filmGauge = t), this.setFocalLength(e);
};
Object.defineProperties(ur.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e;
    }
  },
  shadowCameraLeft: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e;
    }
  },
  shadowCameraRight: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e;
    }
  },
  shadowCameraTop: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e;
    }
  },
  shadowCameraBottom: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e;
    }
  },
  shadowCameraNear: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e;
    }
  },
  shadowCameraFar: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(e) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(e) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e;
    }
  },
  shadowMapHeight: {
    set: function(e) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e;
    }
  }
});
Object.defineProperties(pt.prototype, {
  length: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  copyIndicesArray: function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }
});
Object.assign(Ge.prototype, {
  addIndex: function(e) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e);
  },
  addDrawCall: function(e, t, r) {
    r !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t);
  },
  clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  },
  computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }
});
Object.defineProperties(Ge.prototype, {
  drawcalls: {
    get: function() {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function() {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
});
Object.assign(bn.prototype, {
  getArrays: function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  },
  addShapeList: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  },
  addShape: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }
});
Object.defineProperties(Pc.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
    }
  }
});
Object.defineProperties(ft.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new je();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(e) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === Ed;
    }
  }
});
Object.defineProperties(Yi.prototype, {
  metal: {
    get: function() {
      return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(Mi.prototype, {
  derivatives: {
    get: function() {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function(e) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e;
    }
  }
});
Object.assign(mh.prototype, {
  animate: function(e) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e);
  },
  getCurrentRenderTarget: function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  },
  getMaxAnisotropy: function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  },
  resetGLState: function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  },
  supportsFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function(e) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e);
  },
  initMaterial: function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  }
});
Object.defineProperties(mh.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(K0.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(qa.prototype, {
  wrapS: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e;
    }
  },
  wrapT: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e;
    }
  },
  magFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e;
    }
  },
  minFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e;
    }
  },
  anisotropy: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e;
    }
  },
  offset: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e;
    }
  },
  repeat: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e;
    }
  },
  format: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e;
    }
  },
  type: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e;
    }
  },
  generateMipmaps: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e;
    }
  }
});
Object.defineProperties(Z0.prototype, {
  standing: {
    set: function() {
      console.warn("THREE.WebVRManager: .standing has been removed.");
    }
  }
});
fo.prototype.load = function(e) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  var t = this, r = new $d();
  return r.load(e, function(n) {
    t.setBuffer(n);
  }), this;
};
Zd.prototype.getData = function() {
  return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
};
Ju.prototype.updateCubeMap = function(e, t) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t);
};
var YE = {
  merge: function(e, t, r) {
    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
    var n;
    t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), n = t.matrix, t = t.geometry), e.merge(t, n, r);
  },
  center: function(e) {
    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center();
  }
}, QE = {
  crossOrigin: void 0,
  loadTexture: function(e, t, r, n) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var i = new vh();
    i.setCrossOrigin(this.crossOrigin);
    var a = i.load(e, r, void 0, n);
    return t && (a.mapping = t), a;
  },
  loadTextureCube: function(e, t, r, n) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var i = new Wd();
    i.setCrossOrigin(this.crossOrigin);
    var a = i.load(e, r, void 0, n);
    return t && (a.mapping = t), a;
  },
  loadCompressedTexture: function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  },
  loadCompressedTextureCube: function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  }
};
function KE() {
  console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e, t) {
    console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t);
  }, this.unprojectVector = function(e, t) {
    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t);
  }, this.pickingRay = function() {
    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
  };
}
function $E() {
  console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {
  }, this.render = function() {
  }, this.setClearColor = function() {
  }, this.setSize = function() {
  };
}
var ZE = {
  createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  },
  detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  },
  attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  }
};
function JE() {
  console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
}
const ew = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AddEquation: Pd,
  AddOperation: Zg,
  AdditiveBlending: Sd,
  AlphaFormat: u0,
  AlwaysDepth: jg,
  AmbientLight: Ac,
  AnimationClip: Ii,
  AnimationMixer: Vf,
  AnimationObjectGroup: cy,
  AnimationUtils: Gr,
  ArcCurve: uo,
  ArrayCamera: Su,
  ArrowHelper: hs,
  Audio: fo,
  AudioAnalyser: Zd,
  AudioContext: yh,
  AudioListener: Uf,
  AudioLoader: $d,
  AxesHelper: ol,
  AxisHelper: HE,
  BackSide: Tr,
  BasicDepthPacking: F0,
  BasicShadowMap: Sx,
  BinaryTextureLoader: XE,
  Bone: cc,
  BooleanKeyframeTrack: wc,
  BoundingBoxHelper: zE,
  Box2: tp,
  Box3: Hn,
  Box3Helper: al,
  BoxBufferGeometry: Ka,
  BoxGeometry: ca,
  BoxHelper: cs,
  BufferAttribute: pt,
  BufferGeometry: Ge,
  BufferGeometryLoader: qd,
  ByteType: r0,
  Cache: ls,
  Camera: _n,
  CameraHelper: nl,
  CanvasRenderer: $E,
  CanvasTexture: zs,
  CatmullRomCurve3: Wr,
  CineonToneMapping: t0,
  CircleBufferGeometry: so,
  CircleGeometry: Ku,
  ClampToEdgeWrapping: Ei,
  Clock: dy,
  ClosedSplineCurve3: gy,
  Color: je,
  ColorKeyframeTrack: Cc,
  CompressedTexture: Xs,
  CompressedTextureLoader: ny,
  ConeBufferGeometry: Qu,
  ConeGeometry: Yu,
  CubeCamera: Ju,
  CubeGeometry: ca,
  CubeReflectionMapping: oh,
  CubeRefractionMapping: uc,
  CubeTexture: ha,
  CubeTextureLoader: Wd,
  CubeUVReflectionMapping: uh,
  CubeUVRefractionMapping: lh,
  CubicBezierCurve: Qi,
  CubicBezierCurve3: An,
  CubicInterpolant: Mc,
  CullFaceBack: Ef,
  CullFaceFront: Lg,
  CullFaceFrontBack: Tx,
  CullFaceNone: Pg,
  Curve: Ye,
  CurvePath: Fn,
  CustomBlending: Dd,
  CylinderBufferGeometry: zn,
  CylinderGeometry: rs,
  Cylindrical: my,
  DataTexture: Xa,
  DataTextureLoader: zd,
  DefaultLoadingManager: pi,
  DepthFormat: ka,
  DepthStencilFormat: Gs,
  DepthTexture: Lu,
  DirectionalLight: xc,
  DirectionalLightHelper: bo,
  DirectionalLightShadow: bc,
  DiscreteInterpolant: Dc,
  DodecahedronBufferGeometry: Zs,
  DodecahedronGeometry: ku,
  DoubleSide: Ro,
  DstAlphaFactor: Ug,
  DstColorFactor: Vg,
  DynamicBufferAttribute: RE,
  EdgesGeometry: ao,
  EdgesHelper: WE,
  EllipseCurve: Di,
  EqualDepth: Xg,
  EquirectangularReflectionMapping: Od,
  EquirectangularRefractionMapping: lc,
  Euler: ps,
  EventDispatcher: $n,
  ExtrudeBufferGeometry: bn,
  ExtrudeGeometry: Ja,
  Face3: kn,
  Face4: bE,
  FaceColors: wd,
  FaceNormalsHelper: il,
  FileLoader: tn,
  FlatShading: Ed,
  Float32Attribute: GE,
  Float32BufferAttribute: Be,
  Float64Attribute: VE,
  Float64BufferAttribute: Eu,
  FloatType: Us,
  Fog: js,
  FogExp2: Ws,
  Font: Kd,
  FontLoader: oy,
  FrontFaceDirectionCCW: wx,
  FrontFaceDirectionCW: Ex,
  FrontSide: yl,
  Frustum: ph,
  GammaEncoding: Ud,
  Geometry: tt,
  GeometryUtils: YE,
  GreaterDepth: Qg,
  GreaterEqualDepth: Yg,
  GridHelper: rl,
  Group: dc,
  HalfFloatType: dh,
  HemisphereLight: vc,
  HemisphereLightHelper: _o,
  IcosahedronBufferGeometry: $s,
  IcosahedronGeometry: Fu,
  ImageBitmapLoader: Nf,
  ImageLoader: Al,
  ImageUtils: QE,
  ImmediateRenderObject: el,
  InstancedBufferAttribute: Wf,
  InstancedBufferGeometry: Hf,
  InstancedInterleavedBuffer: zf,
  Int16Attribute: FE,
  Int16BufferAttribute: Au,
  Int32Attribute: NE,
  Int32BufferAttribute: Tu,
  Int8Attribute: IE,
  Int8BufferAttribute: _u,
  IntType: n0,
  InterleavedBuffer: po,
  InterleavedBufferAttribute: ep,
  Interpolant: Ci,
  InterpolateDiscrete: vu,
  InterpolateLinear: ou,
  InterpolateSmooth: Jl,
  JSONLoader: Yd,
  KeyframeTrack: Sr,
  LOD: Du,
  LatheBufferGeometry: no,
  LatheGeometry: Xu,
  Layers: Vd,
  LensFlare: JE,
  LessDepth: qg,
  LessEqualDepth: oc,
  Light: ur,
  LightShadow: vs,
  Line: hi,
  Line3: Os,
  LineBasicMaterial: qt,
  LineCurve: di,
  LineCurve3: Ki,
  LineDashedMaterial: us,
  LineLoop: fc,
  LinePieces: AE,
  LineSegments: Yt,
  LineStrip: xE,
  LinearEncoding: yu,
  LinearFilter: Vr,
  LinearInterpolant: Zu,
  LinearMipMapLinearFilter: xl,
  LinearMipMapNearestFilter: Fd,
  LinearToneMapping: Id,
  Loader: ho,
  LoaderUtils: Xd,
  LoadingManager: Hd,
  LogLuvEncoding: Dx,
  LoopOnce: S0,
  LoopPingPong: M0,
  LoopRepeat: C0,
  LuminanceAlphaFormat: c0,
  LuminanceFormat: l0,
  MOUSE: Ax,
  Material: ft,
  MaterialLoader: gh,
  Math: gt,
  Matrix3: wr,
  Matrix4: at,
  MaxEquation: Sf,
  Mesh: dr,
  MeshBasicMaterial: Er,
  MeshDepthMaterial: fa,
  MeshDistanceMaterial: da,
  MeshFaceMaterial: TE,
  MeshLambertMaterial: os,
  MeshNormalMaterial: ss,
  MeshPhongMaterial: Yi,
  MeshPhysicalMaterial: ns,
  MeshStandardMaterial: xn,
  MeshToonMaterial: as,
  MinEquation: wf,
  MirroredRepeatWrapping: za,
  MixOperation: $g,
  MultiMaterial: EE,
  MultiplyBlending: Md,
  MultiplyOperation: bl,
  NearestFilter: wi,
  NearestMipMapLinearFilter: hh,
  NearestMipMapNearestFilter: ch,
  NeverDepth: Wg,
  NoBlending: sc,
  NoColors: ah,
  NoToneMapping: Zl,
  NormalBlending: _l,
  NotEqualDepth: Kg,
  NumberKeyframeTrack: lo,
  Object3D: ke,
  ObjectLoader: sy,
  OctahedronBufferGeometry: Za,
  OctahedronGeometry: Bu,
  OneFactor: Fg,
  OneMinusDstAlphaFactor: Gg,
  OneMinusDstColorFactor: Hg,
  OneMinusSrcAlphaFactor: Rd,
  OneMinusSrcColorFactor: Ng,
  OrthographicCamera: Hs,
  PCFShadowMap: Td,
  PCFSoftShadowMap: Rg,
  ParametricBufferGeometry: Qs,
  ParametricGeometry: Ru,
  Particle: SE,
  ParticleBasicMaterial: DE,
  ParticleSystem: CE,
  ParticleSystemMaterial: PE,
  Path: zi,
  PerspectiveCamera: or,
  Plane: Vi,
  PlaneBufferGeometry: $a,
  PlaneGeometry: wu,
  PlaneHelper: sl,
  PointCloud: wE,
  PointCloudMaterial: ME,
  PointLight: _c,
  PointLightHelper: go,
  Points: qs,
  PointsMaterial: Xi,
  PolarGridHelper: Lc,
  PolyhedronBufferGeometry: fi,
  PolyhedronGeometry: Iu,
  PositionalAudio: Gf,
  Projector: KE,
  PropertyBinding: Hr,
  PropertyMixer: Jd,
  QuadraticBezierCurve: $i,
  QuadraticBezierCurve3: Tn,
  Quaternion: _r,
  QuaternionKeyframeTrack: $u,
  QuaternionLinearInterpolant: Sc,
  REVISION: Dg,
  RGBADepthPacking: k0,
  RGBAFormat: yn,
  RGBA_ASTC_10x10_Format: T0,
  RGBA_ASTC_10x5_Format: b0,
  RGBA_ASTC_10x6_Format: x0,
  RGBA_ASTC_10x8_Format: A0,
  RGBA_ASTC_12x10_Format: E0,
  RGBA_ASTC_12x12_Format: w0,
  RGBA_ASTC_4x4_Format: f0,
  RGBA_ASTC_5x4_Format: d0,
  RGBA_ASTC_5x5_Format: p0,
  RGBA_ASTC_6x5_Format: m0,
  RGBA_ASTC_6x6_Format: v0,
  RGBA_ASTC_8x5_Format: g0,
  RGBA_ASTC_8x6_Format: y0,
  RGBA_ASTC_8x8_Format: _0,
  RGBA_PVRTC_2BPPV1_Format: Of,
  RGBA_PVRTC_4BPPV1_Format: If,
  RGBA_S3TC_DXT1_Format: Mf,
  RGBA_S3TC_DXT3_Format: Df,
  RGBA_S3TC_DXT5_Format: Pf,
  RGBDEncoding: B0,
  RGBEEncoding: R0,
  RGBEFormat: Mx,
  RGBFormat: Wa,
  RGBM16Encoding: O0,
  RGBM7Encoding: I0,
  RGB_ETC1_Format: h0,
  RGB_PVRTC_2BPPV1_Format: Rf,
  RGB_PVRTC_4BPPV1_Format: Lf,
  RGB_S3TC_DXT1_Format: Cf,
  RawShaderMaterial: oo,
  Ray: ms,
  Raycaster: fy,
  RectAreaLight: Tc,
  RectAreaLightHelper: yo,
  ReinhardToneMapping: Jg,
  RepeatWrapping: On,
  ReverseSubtractEquation: Og,
  RingBufferGeometry: io,
  RingGeometry: qu,
  Scene: Cu,
  SceneUtils: ZE,
  ShaderChunk: Ot,
  ShaderLib: Na,
  ShaderMaterial: Mi,
  ShadowMaterial: is,
  Shape: la,
  ShapeBufferGeometry: ts,
  ShapeGeometry: es,
  ShapePath: Qd,
  ShapeUtils: Nn,
  ShortType: i0,
  Skeleton: Pu,
  SkeletonHelper: vo,
  SkinnedMesh: hc,
  SmoothShading: Cx,
  Sphere: qi,
  SphereBufferGeometry: ma,
  SphereGeometry: Bn,
  Spherical: py,
  SphericalReflectionMapping: Bd,
  Spline: rp,
  SplineCurve: Zi,
  SplineCurve3: yy,
  SpotLight: yc,
  SpotLightHelper: mo,
  SpotLightShadow: gc,
  Sprite: Mu,
  SpriteMaterial: pa,
  SrcAlphaFactor: Ld,
  SrcAlphaSaturateFactor: zg,
  SrcColorFactor: kg,
  StereoCamera: uy,
  StringKeyframeTrack: Ec,
  SubtractEquation: Ig,
  SubtractiveBlending: Cd,
  TetrahedronBufferGeometry: Ks,
  TetrahedronGeometry: Ou,
  TextBufferGeometry: ro,
  TextGeometry: ju,
  Texture: ir,
  TextureLoader: vh,
  TorusBufferGeometry: to,
  TorusGeometry: Gu,
  TorusKnotBufferGeometry: eo,
  TorusKnotGeometry: Uu,
  Triangle: Si,
  TriangleFanDrawMode: P0,
  TriangleStripDrawMode: D0,
  TrianglesDrawMode: Nd,
  TubeBufferGeometry: Js,
  TubeGeometry: Nu,
  UVMapping: sh,
  Uint16Attribute: kE,
  Uint16BufferAttribute: Ya,
  Uint32Attribute: UE,
  Uint32BufferAttribute: Qa,
  Uint8Attribute: OE,
  Uint8BufferAttribute: bu,
  Uint8ClampedAttribute: BE,
  Uint8ClampedBufferAttribute: xu,
  Uncharted2ToneMapping: e0,
  Uniform: Pc,
  UniformsLib: Xe,
  UniformsUtils: si,
  UnsignedByteType: fh,
  UnsignedInt248Type: mu,
  UnsignedIntType: kd,
  UnsignedShort4444Type: a0,
  UnsignedShort5551Type: s0,
  UnsignedShort565Type: o0,
  UnsignedShortType: pu,
  Vector2: ue,
  Vector3: z,
  Vector4: kt,
  VectorKeyframeTrack: co,
  Vertex: LE,
  VertexColors: ds,
  VertexNormalsHelper: tl,
  VideoTexture: pc,
  WebGLRenderTarget: qa,
  WebGLRenderTargetCube: Vs,
  WebGLRenderer: mh,
  WebGLUtils: $0,
  WireframeGeometry: Ys,
  WireframeHelper: jE,
  WrapAroundEnding: gu,
  XHRLoader: qE,
  ZeroCurvatureEnding: ja,
  ZeroFactor: Bg,
  ZeroSlopeEnding: Ia,
  sRGBEncoding: L0
}, Symbol.toStringTag, { value: "Module" }));
var _y = { exports: {} };
/**
 * @license
 * webvr-polyfill
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function(e, t) {
  /**
   * @license
   * cardboard-vr-display
   * Copyright (c) 2015-2017 Google
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * @license
   * webvr-polyfill-dpdb 
   * Copyright (c) 2017 Google
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * @license
   * wglu-preserve-state
   * Copyright (c) 2016, Brandon Jones.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  /**
   * @license
   * nosleep.js
   * Copyright (c) 2017, Rich Tibbett
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  (function(r, n) {
    e.exports = n();
  })(Fa, function() {
    var r = typeof window < "u" ? window : typeof Fa < "u" ? Fa : typeof self < "u" ? self : {};
    function n(v) {
      return v && v.__esModule && Object.prototype.hasOwnProperty.call(v, "default") ? v.default : v;
    }
    function i(v, x) {
      return x = { exports: {} }, v(x, x.exports), x.exports;
    }
    var a = function() {
      return /Android/i.test(navigator.userAgent) || /iPhone|iPad|iPod/i.test(navigator.userAgent);
    }, s = function(x, E) {
      for (var M = 0, C = x.length; M < C; M++)
        E[M] = x[M];
    }, o = function(x, E) {
      for (var M in E)
        E.hasOwnProperty(M) && (x[M] = E[M]);
      return x;
    }, u = i(function(v, x) {
      /**
       * @license
       * cardboard-vr-display
       * Copyright (c) 2015-2017 Google
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * gl-preserve-state
       * Copyright (c) 2016, Brandon Jones.
       *
       * Permission is hereby granted, free of charge, to any person obtaining a copy
       * of this software and associated documentation files (the "Software"), to deal
       * in the Software without restriction, including without limitation the rights
       * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       * copies of the Software, and to permit persons to whom the Software is
       * furnished to do so, subject to the following conditions:
       *
       * The above copyright notice and this permission notice shall be included in
       * all copies or substantial portions of the Software.
       *
       * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       * THE SOFTWARE.
       */
      /**
       * @license
       * webvr-polyfill-dpdb
       * Copyright (c) 2015-2017 Google
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * nosleep.js
       * Copyright (c) 2017, Rich Tibbett
       *
       * Permission is hereby granted, free of charge, to any person obtaining a copy
       * of this software and associated documentation files (the "Software"), to deal
       * in the Software without restriction, including without limitation the rights
       * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       * copies of the Software, and to permit persons to whom the Software is
       * furnished to do so, subject to the following conditions:
       *
       * The above copyright notice and this permission notice shall be included in
       * all copies or substantial portions of the Software.
       *
       * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       * THE SOFTWARE.
       */
      (function(E, M) {
        v.exports = M();
      })(r, function() {
        var E = function(A, T) {
          if (!(A instanceof T))
            throw new TypeError("Cannot call a class as a function");
        }, M = /* @__PURE__ */ function() {
          function A(T, D) {
            for (var L = 0; L < D.length; L++) {
              var U = D[L];
              U.enumerable = U.enumerable || !1, U.configurable = !0, "value" in U && (U.writable = !0), Object.defineProperty(T, U.key, U);
            }
          }
          return function(T, D, L) {
            return D && A(T.prototype, D), L && A(T, L), T;
          };
        }(), C = /* @__PURE__ */ function() {
          function A(T, D) {
            var L = [], U = !0, Z = !1, ie = void 0;
            try {
              for (var ve = T[Symbol.iterator](), me; !(U = (me = ve.next()).done) && (L.push(me.value), !(D && L.length === D)); U = !0)
                ;
            } catch (ne) {
              Z = !0, ie = ne;
            } finally {
              try {
                !U && ve.return && ve.return();
              } finally {
                if (Z) throw ie;
              }
            }
            return L;
          }
          return function(T, D) {
            if (Array.isArray(T))
              return T;
            if (Symbol.iterator in Object(T))
              return A(T, D);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), R = 1e-3, B = 1, k = function(T, D) {
          return "data:" + T + "," + encodeURIComponent(D);
        }, F = function(T, D, L) {
          return T + (D - T) * L;
        }, I = function() {
          var A = /iPad|iPhone|iPod/.test(navigator.platform);
          return function() {
            return A;
          };
        }(), H = function() {
          var A = navigator.userAgent.indexOf("Version") !== -1 && navigator.userAgent.indexOf("Android") !== -1 && navigator.userAgent.indexOf("Chrome") !== -1;
          return function() {
            return A;
          };
        }(), Q = function() {
          var A = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          return function() {
            return A;
          };
        }(), ee = function() {
          var A = navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
          return function() {
            return A;
          };
        }(), oe = function() {
          var A = navigator.userAgent.match(/.*Chrome\/([0-9]+)/), T = A ? parseInt(A[1], 10) : null;
          return function() {
            return T;
          };
        }(), de = function() {
          var A = !1;
          return A = I() && Q() && navigator.userAgent.indexOf("13_4") !== -1, function() {
            return A;
          };
        }(), he = function() {
          var A = !1;
          if (oe() === 65) {
            var T = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
            if (T) {
              var D = T[1].split("."), L = C(D, 4);
              L[0], L[1];
              var U = L[2], Z = L[3];
              A = parseInt(U, 10) === 3325 && parseInt(Z, 10) < 148;
            }
          }
          return function() {
            return A;
          };
        }(), fe = function() {
          var A = navigator.userAgent.indexOf("R7 Build") !== -1;
          return function() {
            return A;
          };
        }(), V = function() {
          var T = window.orientation == 90 || window.orientation == -90;
          return fe() ? !T : T;
        }, G = function(T) {
          return !(isNaN(T) || T <= R || T > B);
        }, se = function() {
          return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
        }, re = function() {
          return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
        }, Ce = function(T) {
          if (H())
            return !1;
          if (T.requestFullscreen)
            T.requestFullscreen();
          else if (T.webkitRequestFullscreen)
            T.webkitRequestFullscreen();
          else if (T.mozRequestFullScreen)
            T.mozRequestFullScreen();
          else if (T.msRequestFullscreen)
            T.msRequestFullscreen();
          else
            return !1;
          return !0;
        }, K = function() {
          if (document.exitFullscreen)
            document.exitFullscreen();
          else if (document.webkitExitFullscreen)
            document.webkitExitFullscreen();
          else if (document.mozCancelFullScreen)
            document.mozCancelFullScreen();
          else if (document.msExitFullscreen)
            document.msExitFullscreen();
          else
            return !1;
          return !0;
        }, xe = function() {
          return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        }, pe = function(T, D, L, U) {
          var Z = T.createShader(T.VERTEX_SHADER);
          T.shaderSource(Z, D), T.compileShader(Z);
          var ie = T.createShader(T.FRAGMENT_SHADER);
          T.shaderSource(ie, L), T.compileShader(ie);
          var ve = T.createProgram();
          T.attachShader(ve, Z), T.attachShader(ve, ie);
          for (var me in U)
            T.bindAttribLocation(ve, U[me], me);
          return T.linkProgram(ve), T.deleteShader(Z), T.deleteShader(ie), ve;
        }, Re = function(T, D) {
          for (var L = {}, U = T.getProgramParameter(D, T.ACTIVE_UNIFORMS), Z = "", ie = 0; ie < U; ie++) {
            var ve = T.getActiveUniform(D, ie);
            Z = ve.name.replace("[0]", ""), L[Z] = T.getUniformLocation(D, Z);
          }
          return L;
        }, _e = function(T, D, L, U, Z, ie, ve) {
          var me = 1 / (D - L), ne = 1 / (U - Z), le = 1 / (ie - ve);
          return T[0] = -2 * me, T[1] = 0, T[2] = 0, T[3] = 0, T[4] = 0, T[5] = -2 * ne, T[6] = 0, T[7] = 0, T[8] = 0, T[9] = 0, T[10] = 2 * le, T[11] = 0, T[12] = (D + L) * me, T[13] = (Z + U) * ne, T[14] = (ve + ie) * le, T[15] = 1, T;
        }, Le = function() {
          var T = !1;
          return function(D) {
            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(D) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(D.substr(0, 4))) && (T = !0);
          }(navigator.userAgent || navigator.vendor || window.opera), T;
        }, He = function(T, D) {
          for (var L in D)
            D.hasOwnProperty(L) && (T[L] = D[L]);
          return T;
        }, dt = function(T) {
          if (I()) {
            var D = T.style.width, L = T.style.height;
            T.style.width = parseInt(D) + 1 + "px", T.style.height = parseInt(L) + "px", setTimeout(function() {
              T.style.width = D, T.style.height = L;
            }, 100);
          }
          window.canvas = T;
        }, Ee = function() {
          var A = Math.PI / 180, T = Math.PI * 0.25;
          function D(ne, le, be, Ve) {
            var qe = Math.tan(le ? le.upDegrees * A : T), it = Math.tan(le ? le.downDegrees * A : T), At = Math.tan(le ? le.leftDegrees * A : T), ot = Math.tan(le ? le.rightDegrees * A : T), ut = 2 / (At + ot), zt = 2 / (qe + it);
            return ne[0] = ut, ne[1] = 0, ne[2] = 0, ne[3] = 0, ne[4] = 0, ne[5] = zt, ne[6] = 0, ne[7] = 0, ne[8] = -((At - ot) * ut * 0.5), ne[9] = (qe - it) * zt * 0.5, ne[10] = Ve / (be - Ve), ne[11] = -1, ne[12] = 0, ne[13] = 0, ne[14] = Ve * be / (be - Ve), ne[15] = 0, ne;
          }
          function L(ne, le, be) {
            var Ve = le[0], qe = le[1], it = le[2], At = le[3], ot = Ve + Ve, ut = qe + qe, zt = it + it, nr = Ve * ot, yr = Ve * ut, tr = Ve * zt, Mr = qe * ut, qr = qe * zt, Xr = it * zt, Yr = At * ot, Dr = At * ut, bi = At * zt;
            return ne[0] = 1 - (Mr + Xr), ne[1] = yr + bi, ne[2] = tr - Dr, ne[3] = 0, ne[4] = yr - bi, ne[5] = 1 - (nr + Xr), ne[6] = qr + Yr, ne[7] = 0, ne[8] = tr + Dr, ne[9] = qr - Yr, ne[10] = 1 - (nr + Mr), ne[11] = 0, ne[12] = be[0], ne[13] = be[1], ne[14] = be[2], ne[15] = 1, ne;
          }
          function U(ne, le, be) {
            var Ve = be[0], qe = be[1], it = be[2], At, ot, ut, zt, nr, yr, tr, Mr, qr, Xr, Yr, Dr;
            return le === ne ? (ne[12] = le[0] * Ve + le[4] * qe + le[8] * it + le[12], ne[13] = le[1] * Ve + le[5] * qe + le[9] * it + le[13], ne[14] = le[2] * Ve + le[6] * qe + le[10] * it + le[14], ne[15] = le[3] * Ve + le[7] * qe + le[11] * it + le[15]) : (At = le[0], ot = le[1], ut = le[2], zt = le[3], nr = le[4], yr = le[5], tr = le[6], Mr = le[7], qr = le[8], Xr = le[9], Yr = le[10], Dr = le[11], ne[0] = At, ne[1] = ot, ne[2] = ut, ne[3] = zt, ne[4] = nr, ne[5] = yr, ne[6] = tr, ne[7] = Mr, ne[8] = qr, ne[9] = Xr, ne[10] = Yr, ne[11] = Dr, ne[12] = At * Ve + nr * qe + qr * it + le[12], ne[13] = ot * Ve + yr * qe + Xr * it + le[13], ne[14] = ut * Ve + tr * qe + Yr * it + le[14], ne[15] = zt * Ve + Mr * qe + Dr * it + le[15]), ne;
          }
          function Z(ne, le) {
            var be = le[0], Ve = le[1], qe = le[2], it = le[3], At = le[4], ot = le[5], ut = le[6], zt = le[7], nr = le[8], yr = le[9], tr = le[10], Mr = le[11], qr = le[12], Xr = le[13], Yr = le[14], Dr = le[15], bi = be * ot - Ve * At, ba = be * ut - qe * At, xa = be * zt - it * At, Cn = Ve * ut - qe * ot, Aa = Ve * zt - it * ot, Mn = qe * zt - it * ut, Ta = nr * Xr - yr * qr, Ea = nr * Yr - tr * qr, wa = nr * Dr - Mr * qr, Ui = yr * Yr - tr * Xr, Li = yr * Dr - Mr * Xr, un = tr * Dr - Mr * Yr, Wt = bi * un - ba * Li + xa * Ui + Cn * wa - Aa * Ea + Mn * Ta;
            return Wt ? (Wt = 1 / Wt, ne[0] = (ot * un - ut * Li + zt * Ui) * Wt, ne[1] = (qe * Li - Ve * un - it * Ui) * Wt, ne[2] = (Xr * Mn - Yr * Aa + Dr * Cn) * Wt, ne[3] = (tr * Aa - yr * Mn - Mr * Cn) * Wt, ne[4] = (ut * wa - At * un - zt * Ea) * Wt, ne[5] = (be * un - qe * wa + it * Ea) * Wt, ne[6] = (Yr * xa - qr * Mn - Dr * ba) * Wt, ne[7] = (nr * Mn - tr * xa + Mr * ba) * Wt, ne[8] = (At * Li - ot * wa + zt * Ta) * Wt, ne[9] = (Ve * wa - be * Li - it * Ta) * Wt, ne[10] = (qr * Aa - Xr * xa + Dr * bi) * Wt, ne[11] = (yr * xa - nr * Aa - Mr * bi) * Wt, ne[12] = (ot * Ea - At * Ui - ut * Ta) * Wt, ne[13] = (be * Ui - Ve * Ea + qe * Ta) * Wt, ne[14] = (Xr * ba - qr * Cn - Yr * bi) * Wt, ne[15] = (nr * Cn - yr * ba + tr * bi) * Wt, ne) : null;
          }
          var ie = new Float32Array([0, 0, 0, 1]), ve = new Float32Array([0, 0, 0]);
          function me(ne, le, be, Ve, qe, it) {
            D(ne, Ve || null, it.depthNear, it.depthFar);
            var At = be.orientation || ie, ot = be.position || ve;
            L(le, At, ot), qe && U(le, le, qe), Z(le, le);
          }
          return function(ne, le, be) {
            return !ne || !le ? !1 : (ne.pose = le, ne.timestamp = le.timestamp, me(ne.leftProjectionMatrix, ne.leftViewMatrix, le, be._getFieldOfView("left"), be._getEyeOffset("left"), be), me(ne.rightProjectionMatrix, ne.rightViewMatrix, le, be._getFieldOfView("right"), be._getEyeOffset("right"), be), !0);
          };
        }(), ct = function() {
          var T = window.self !== window.top, D = Bt(document.referrer), L = Bt(window.location.href);
          return T && D !== L;
        }, Bt = function(T) {
          var D, L = T.indexOf("://");
          L !== -1 ? D = L + 3 : D = 0;
          var U = T.indexOf("/", D);
          return U === -1 && (U = T.length), T.substring(0, U);
        }, Mt = function(T) {
          if (T.w > 1)
            return console.warn("getQuaternionAngle: w > 1"), 0;
          var D = 2 * Math.acos(T.w);
          return D;
        }, Ht = /* @__PURE__ */ function() {
          var A = {};
          return function(T, D) {
            A[T] === void 0 && (console.warn("webvr-polyfill: " + D), A[T] = !0);
          };
        }(), yt = function(T, D) {
          var L = D ? "Please use " + D + " instead." : "";
          Ht(T, T + " has been deprecated. This may not work on native WebVR displays. " + L);
        };
        function Gt(A, T, D) {
          if (!T) {
            D(A);
            return;
          }
          for (var L = [], U = null, Z = 0; Z < T.length; ++Z) {
            var ie = T[Z];
            switch (ie) {
              case A.TEXTURE_BINDING_2D:
              case A.TEXTURE_BINDING_CUBE_MAP:
                var ve = T[++Z];
                if (ve < A.TEXTURE0 || ve > A.TEXTURE31) {
                  console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit"), L.push(null, null);
                  break;
                }
                U || (U = A.getParameter(A.ACTIVE_TEXTURE)), A.activeTexture(ve), L.push(A.getParameter(ie), null);
                break;
              case A.ACTIVE_TEXTURE:
                U = A.getParameter(A.ACTIVE_TEXTURE), L.push(null);
                break;
              default:
                L.push(A.getParameter(ie));
                break;
            }
          }
          D(A);
          for (var Z = 0; Z < T.length; ++Z) {
            var ie = T[Z], me = L[Z];
            switch (ie) {
              case A.ACTIVE_TEXTURE:
                break;
              case A.ARRAY_BUFFER_BINDING:
                A.bindBuffer(A.ARRAY_BUFFER, me);
                break;
              case A.COLOR_CLEAR_VALUE:
                A.clearColor(me[0], me[1], me[2], me[3]);
                break;
              case A.COLOR_WRITEMASK:
                A.colorMask(me[0], me[1], me[2], me[3]);
                break;
              case A.CURRENT_PROGRAM:
                A.useProgram(me);
                break;
              case A.ELEMENT_ARRAY_BUFFER_BINDING:
                A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, me);
                break;
              case A.FRAMEBUFFER_BINDING:
                A.bindFramebuffer(A.FRAMEBUFFER, me);
                break;
              case A.RENDERBUFFER_BINDING:
                A.bindRenderbuffer(A.RENDERBUFFER, me);
                break;
              case A.TEXTURE_BINDING_2D:
                var ve = T[++Z];
                if (ve < A.TEXTURE0 || ve > A.TEXTURE31)
                  break;
                A.activeTexture(ve), A.bindTexture(A.TEXTURE_2D, me);
                break;
              case A.TEXTURE_BINDING_CUBE_MAP:
                var ve = T[++Z];
                if (ve < A.TEXTURE0 || ve > A.TEXTURE31)
                  break;
                A.activeTexture(ve), A.bindTexture(A.TEXTURE_CUBE_MAP, me);
                break;
              case A.VIEWPORT:
                A.viewport(me[0], me[1], me[2], me[3]);
                break;
              case A.BLEND:
              case A.CULL_FACE:
              case A.DEPTH_TEST:
              case A.SCISSOR_TEST:
              case A.STENCIL_TEST:
                me ? A.enable(ie) : A.disable(ie);
                break;
              default:
                console.log("No GL restore behavior for 0x" + ie.toString(16));
                break;
            }
            U && A.activeTexture(U);
          }
        }
        var Et = Gt, gi = ["attribute vec2 position;", "attribute vec3 texCoord;", "varying vec2 vTexCoord;", "uniform vec4 viewportOffsetScale[2];", "void main() {", "  vec4 viewport = viewportOffsetScale[int(texCoord.z)];", "  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;", "  gl_Position = vec4( position, 1.0, 1.0 );", "}"].join(`
`), xt = ["precision mediump float;", "uniform sampler2D diffuse;", "varying vec2 vTexCoord;", "void main() {", "  gl_FragColor = texture2D(diffuse, vTexCoord);", "}"].join(`
`);
        function cr(A, T, D, L) {
          this.gl = A, this.cardboardUI = T, this.bufferScale = D, this.dirtySubmitFrameBindings = L, this.ctxAttribs = A.getContextAttributes(), this.instanceExt = A.getExtension("ANGLE_instanced_arrays"), this.meshWidth = 20, this.meshHeight = 20, this.bufferWidth = A.drawingBufferWidth, this.bufferHeight = A.drawingBufferHeight, this.realBindFramebuffer = A.bindFramebuffer, this.realEnable = A.enable, this.realDisable = A.disable, this.realColorMask = A.colorMask, this.realClearColor = A.clearColor, this.realViewport = A.viewport, I() || (this.realCanvasWidth = Object.getOwnPropertyDescriptor(A.canvas.__proto__, "width"), this.realCanvasHeight = Object.getOwnPropertyDescriptor(A.canvas.__proto__, "height")), this.isPatched = !1, this.lastBoundFramebuffer = null, this.cullFace = !1, this.depthTest = !1, this.blend = !1, this.scissorTest = !1, this.stencilTest = !1, this.viewport = [0, 0, 0, 0], this.colorMask = [!0, !0, !0, !0], this.clearColor = [0, 0, 0, 0], this.attribs = {
            position: 0,
            texCoord: 1
          }, this.program = pe(A, gi, xt, this.attribs), this.uniforms = Re(A, this.program), this.viewportOffsetScale = new Float32Array(8), this.setTextureBounds(), this.vertexBuffer = A.createBuffer(), this.indexBuffer = A.createBuffer(), this.indexCount = 0, this.renderTarget = A.createTexture(), this.framebuffer = A.createFramebuffer(), this.depthStencilBuffer = null, this.depthBuffer = null, this.stencilBuffer = null, this.ctxAttribs.depth && this.ctxAttribs.stencil ? this.depthStencilBuffer = A.createRenderbuffer() : this.ctxAttribs.depth ? this.depthBuffer = A.createRenderbuffer() : this.ctxAttribs.stencil && (this.stencilBuffer = A.createRenderbuffer()), this.patch(), this.onResize();
        }
        cr.prototype.destroy = function() {
          var A = this.gl;
          this.unpatch(), A.deleteProgram(this.program), A.deleteBuffer(this.vertexBuffer), A.deleteBuffer(this.indexBuffer), A.deleteTexture(this.renderTarget), A.deleteFramebuffer(this.framebuffer), this.depthStencilBuffer && A.deleteRenderbuffer(this.depthStencilBuffer), this.depthBuffer && A.deleteRenderbuffer(this.depthBuffer), this.stencilBuffer && A.deleteRenderbuffer(this.stencilBuffer), this.cardboardUI && this.cardboardUI.destroy();
        }, cr.prototype.onResize = function() {
          var A = this.gl, T = this, D = [A.RENDERBUFFER_BINDING, A.TEXTURE_BINDING_2D, A.TEXTURE0];
          Et(A, D, function(L) {
            T.realBindFramebuffer.call(L, L.FRAMEBUFFER, null), T.scissorTest && T.realDisable.call(L, L.SCISSOR_TEST), T.realColorMask.call(L, !0, !0, !0, !0), T.realViewport.call(L, 0, 0, L.drawingBufferWidth, L.drawingBufferHeight), T.realClearColor.call(L, 0, 0, 0, 1), L.clear(L.COLOR_BUFFER_BIT), T.realBindFramebuffer.call(L, L.FRAMEBUFFER, T.framebuffer), L.bindTexture(L.TEXTURE_2D, T.renderTarget), L.texImage2D(L.TEXTURE_2D, 0, T.ctxAttribs.alpha ? L.RGBA : L.RGB, T.bufferWidth, T.bufferHeight, 0, T.ctxAttribs.alpha ? L.RGBA : L.RGB, L.UNSIGNED_BYTE, null), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_MAG_FILTER, L.LINEAR), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_MIN_FILTER, L.LINEAR), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_WRAP_S, L.CLAMP_TO_EDGE), L.texParameteri(L.TEXTURE_2D, L.TEXTURE_WRAP_T, L.CLAMP_TO_EDGE), L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, T.renderTarget, 0), T.ctxAttribs.depth && T.ctxAttribs.stencil ? (L.bindRenderbuffer(L.RENDERBUFFER, T.depthStencilBuffer), L.renderbufferStorage(L.RENDERBUFFER, L.DEPTH_STENCIL, T.bufferWidth, T.bufferHeight), L.framebufferRenderbuffer(L.FRAMEBUFFER, L.DEPTH_STENCIL_ATTACHMENT, L.RENDERBUFFER, T.depthStencilBuffer)) : T.ctxAttribs.depth ? (L.bindRenderbuffer(L.RENDERBUFFER, T.depthBuffer), L.renderbufferStorage(L.RENDERBUFFER, L.DEPTH_COMPONENT16, T.bufferWidth, T.bufferHeight), L.framebufferRenderbuffer(L.FRAMEBUFFER, L.DEPTH_ATTACHMENT, L.RENDERBUFFER, T.depthBuffer)) : T.ctxAttribs.stencil && (L.bindRenderbuffer(L.RENDERBUFFER, T.stencilBuffer), L.renderbufferStorage(L.RENDERBUFFER, L.STENCIL_INDEX8, T.bufferWidth, T.bufferHeight), L.framebufferRenderbuffer(L.FRAMEBUFFER, L.STENCIL_ATTACHMENT, L.RENDERBUFFER, T.stencilBuffer)), !L.checkFramebufferStatus(L.FRAMEBUFFER) === L.FRAMEBUFFER_COMPLETE && console.error("Framebuffer incomplete!"), T.realBindFramebuffer.call(L, L.FRAMEBUFFER, T.lastBoundFramebuffer), T.scissorTest && T.realEnable.call(L, L.SCISSOR_TEST), T.realColorMask.apply(L, T.colorMask), T.realViewport.apply(L, T.viewport), T.realClearColor.apply(L, T.clearColor);
          }), this.cardboardUI && this.cardboardUI.onResize();
        }, cr.prototype.patch = function() {
          if (!this.isPatched) {
            var A = this, T = this.gl.canvas, D = this.gl;
            I() || (T.width = se() * this.bufferScale, T.height = re() * this.bufferScale, Object.defineProperty(T, "width", {
              configurable: !0,
              enumerable: !0,
              get: function() {
                return A.bufferWidth;
              },
              set: function(U) {
                A.bufferWidth = U, A.realCanvasWidth.set.call(T, U), A.onResize();
              }
            }), Object.defineProperty(T, "height", {
              configurable: !0,
              enumerable: !0,
              get: function() {
                return A.bufferHeight;
              },
              set: function(U) {
                A.bufferHeight = U, A.realCanvasHeight.set.call(T, U), A.onResize();
              }
            })), this.lastBoundFramebuffer = D.getParameter(D.FRAMEBUFFER_BINDING), this.lastBoundFramebuffer == null && (this.lastBoundFramebuffer = this.framebuffer, this.gl.bindFramebuffer(D.FRAMEBUFFER, this.framebuffer)), this.gl.bindFramebuffer = function(L, U) {
              A.lastBoundFramebuffer = U || A.framebuffer, A.realBindFramebuffer.call(D, L, A.lastBoundFramebuffer);
            }, this.cullFace = D.getParameter(D.CULL_FACE), this.depthTest = D.getParameter(D.DEPTH_TEST), this.blend = D.getParameter(D.BLEND), this.scissorTest = D.getParameter(D.SCISSOR_TEST), this.stencilTest = D.getParameter(D.STENCIL_TEST), D.enable = function(L) {
              switch (L) {
                case D.CULL_FACE:
                  A.cullFace = !0;
                  break;
                case D.DEPTH_TEST:
                  A.depthTest = !0;
                  break;
                case D.BLEND:
                  A.blend = !0;
                  break;
                case D.SCISSOR_TEST:
                  A.scissorTest = !0;
                  break;
                case D.STENCIL_TEST:
                  A.stencilTest = !0;
                  break;
              }
              A.realEnable.call(D, L);
            }, D.disable = function(L) {
              switch (L) {
                case D.CULL_FACE:
                  A.cullFace = !1;
                  break;
                case D.DEPTH_TEST:
                  A.depthTest = !1;
                  break;
                case D.BLEND:
                  A.blend = !1;
                  break;
                case D.SCISSOR_TEST:
                  A.scissorTest = !1;
                  break;
                case D.STENCIL_TEST:
                  A.stencilTest = !1;
                  break;
              }
              A.realDisable.call(D, L);
            }, this.colorMask = D.getParameter(D.COLOR_WRITEMASK), D.colorMask = function(L, U, Z, ie) {
              A.colorMask[0] = L, A.colorMask[1] = U, A.colorMask[2] = Z, A.colorMask[3] = ie, A.realColorMask.call(D, L, U, Z, ie);
            }, this.clearColor = D.getParameter(D.COLOR_CLEAR_VALUE), D.clearColor = function(L, U, Z, ie) {
              A.clearColor[0] = L, A.clearColor[1] = U, A.clearColor[2] = Z, A.clearColor[3] = ie, A.realClearColor.call(D, L, U, Z, ie);
            }, this.viewport = D.getParameter(D.VIEWPORT), D.viewport = function(L, U, Z, ie) {
              A.viewport[0] = L, A.viewport[1] = U, A.viewport[2] = Z, A.viewport[3] = ie, A.realViewport.call(D, L, U, Z, ie);
            }, this.isPatched = !0, dt(T);
          }
        }, cr.prototype.unpatch = function() {
          if (this.isPatched) {
            var A = this.gl, T = this.gl.canvas;
            I() || (Object.defineProperty(T, "width", this.realCanvasWidth), Object.defineProperty(T, "height", this.realCanvasHeight)), T.width = this.bufferWidth, T.height = this.bufferHeight, A.bindFramebuffer = this.realBindFramebuffer, A.enable = this.realEnable, A.disable = this.realDisable, A.colorMask = this.realColorMask, A.clearColor = this.realClearColor, A.viewport = this.realViewport, this.lastBoundFramebuffer == this.framebuffer && A.bindFramebuffer(A.FRAMEBUFFER, null), this.isPatched = !1, setTimeout(function() {
              dt(T);
            }, 1);
          }
        }, cr.prototype.setTextureBounds = function(A, T) {
          A || (A = [0, 0, 0.5, 1]), T || (T = [0.5, 0, 0.5, 1]), this.viewportOffsetScale[0] = A[0], this.viewportOffsetScale[1] = A[1], this.viewportOffsetScale[2] = A[2], this.viewportOffsetScale[3] = A[3], this.viewportOffsetScale[4] = T[0], this.viewportOffsetScale[5] = T[1], this.viewportOffsetScale[6] = T[2], this.viewportOffsetScale[7] = T[3];
        }, cr.prototype.submitFrame = function() {
          var A = this.gl, T = this, D = [];
          if (this.dirtySubmitFrameBindings || D.push(A.CURRENT_PROGRAM, A.ARRAY_BUFFER_BINDING, A.ELEMENT_ARRAY_BUFFER_BINDING, A.TEXTURE_BINDING_2D, A.TEXTURE0), Et(A, D, function(U) {
            T.realBindFramebuffer.call(U, U.FRAMEBUFFER, null);
            var Z = 0, ie = 0;
            T.instanceExt && (Z = U.getVertexAttrib(T.attribs.position, T.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE), ie = U.getVertexAttrib(T.attribs.texCoord, T.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)), T.cullFace && T.realDisable.call(U, U.CULL_FACE), T.depthTest && T.realDisable.call(U, U.DEPTH_TEST), T.blend && T.realDisable.call(U, U.BLEND), T.scissorTest && T.realDisable.call(U, U.SCISSOR_TEST), T.stencilTest && T.realDisable.call(U, U.STENCIL_TEST), T.realColorMask.call(U, !0, !0, !0, !0), T.realViewport.call(U, 0, 0, U.drawingBufferWidth, U.drawingBufferHeight), (T.ctxAttribs.alpha || I()) && (T.realClearColor.call(U, 0, 0, 0, 1), U.clear(U.COLOR_BUFFER_BIT)), U.useProgram(T.program), U.bindBuffer(U.ELEMENT_ARRAY_BUFFER, T.indexBuffer), U.bindBuffer(U.ARRAY_BUFFER, T.vertexBuffer), U.enableVertexAttribArray(T.attribs.position), U.enableVertexAttribArray(T.attribs.texCoord), U.vertexAttribPointer(T.attribs.position, 2, U.FLOAT, !1, 20, 0), U.vertexAttribPointer(T.attribs.texCoord, 3, U.FLOAT, !1, 20, 8), T.instanceExt && (Z != 0 && T.instanceExt.vertexAttribDivisorANGLE(T.attribs.position, 0), ie != 0 && T.instanceExt.vertexAttribDivisorANGLE(T.attribs.texCoord, 0)), U.activeTexture(U.TEXTURE0), U.uniform1i(T.uniforms.diffuse, 0), U.bindTexture(U.TEXTURE_2D, T.renderTarget), U.uniform4fv(T.uniforms.viewportOffsetScale, T.viewportOffsetScale), U.drawElements(U.TRIANGLES, T.indexCount, U.UNSIGNED_SHORT, 0), T.cardboardUI && T.cardboardUI.renderNoState(), T.realBindFramebuffer.call(T.gl, U.FRAMEBUFFER, T.framebuffer), T.ctxAttribs.preserveDrawingBuffer || (T.realClearColor.call(U, 0, 0, 0, 0), U.clear(U.COLOR_BUFFER_BIT)), T.dirtySubmitFrameBindings || T.realBindFramebuffer.call(U, U.FRAMEBUFFER, T.lastBoundFramebuffer), T.cullFace && T.realEnable.call(U, U.CULL_FACE), T.depthTest && T.realEnable.call(U, U.DEPTH_TEST), T.blend && T.realEnable.call(U, U.BLEND), T.scissorTest && T.realEnable.call(U, U.SCISSOR_TEST), T.stencilTest && T.realEnable.call(U, U.STENCIL_TEST), T.realColorMask.apply(U, T.colorMask), T.realViewport.apply(U, T.viewport), (T.ctxAttribs.alpha || !T.ctxAttribs.preserveDrawingBuffer) && T.realClearColor.apply(U, T.clearColor), T.instanceExt && (Z != 0 && T.instanceExt.vertexAttribDivisorANGLE(T.attribs.position, Z), ie != 0 && T.instanceExt.vertexAttribDivisorANGLE(T.attribs.texCoord, ie));
          }), I()) {
            var L = A.canvas;
            (L.width != T.bufferWidth || L.height != T.bufferHeight) && (T.bufferWidth = L.width, T.bufferHeight = L.height, T.onResize());
          }
        }, cr.prototype.updateDeviceInfo = function(A) {
          var T = this.gl, D = this, L = [T.ARRAY_BUFFER_BINDING, T.ELEMENT_ARRAY_BUFFER_BINDING];
          Et(T, L, function(U) {
            var Z = D.computeMeshVertices_(D.meshWidth, D.meshHeight, A);
            if (U.bindBuffer(U.ARRAY_BUFFER, D.vertexBuffer), U.bufferData(U.ARRAY_BUFFER, Z, U.STATIC_DRAW), !D.indexCount) {
              var ie = D.computeMeshIndices_(D.meshWidth, D.meshHeight);
              U.bindBuffer(U.ELEMENT_ARRAY_BUFFER, D.indexBuffer), U.bufferData(U.ELEMENT_ARRAY_BUFFER, ie, U.STATIC_DRAW), D.indexCount = ie.length;
            }
          });
        }, cr.prototype.computeMeshVertices_ = function(A, T, D) {
          for (var L = new Float32Array(2 * A * T * 5), U = D.getLeftEyeVisibleTanAngles(), Z = D.getLeftEyeNoLensTanAngles(), ie = D.getLeftEyeVisibleScreenRect(Z), ve = 0, me = 0; me < 2; me++) {
            for (var ne = 0; ne < T; ne++)
              for (var le = 0; le < A; le++, ve++) {
                var be = le / (A - 1), Ve = ne / (T - 1), qe = be, it = Ve, At = F(U[0], U[2], be), ot = F(U[3], U[1], Ve), ut = Math.sqrt(At * At + ot * ot), zt = D.distortion.distortInverse(ut), nr = At * zt / ut, yr = ot * zt / ut;
                be = (nr - Z[0]) / (Z[2] - Z[0]), Ve = (yr - Z[3]) / (Z[1] - Z[3]), be = (ie.x + be * ie.width - 0.5) * 2, Ve = (ie.y + Ve * ie.height - 0.5) * 2, L[ve * 5 + 0] = be, L[ve * 5 + 1] = Ve, L[ve * 5 + 2] = qe, L[ve * 5 + 3] = it, L[ve * 5 + 4] = me;
              }
            var tr = U[2] - U[0];
            U[0] = -(tr + U[0]), U[2] = tr - U[2], tr = Z[2] - Z[0], Z[0] = -(tr + Z[0]), Z[2] = tr - Z[2], ie.x = 1 - (ie.x + ie.width);
          }
          return L;
        }, cr.prototype.computeMeshIndices_ = function(A, T) {
          for (var D = new Uint16Array(2 * (A - 1) * (T - 1) * 6), L = A / 2, U = T / 2, Z = 0, ie = 0, ve = 0; ve < 2; ve++)
            for (var me = 0; me < T; me++)
              for (var ne = 0; ne < A; ne++, Z++)
                ne == 0 || me == 0 || (ne <= L == me <= U ? (D[ie++] = Z, D[ie++] = Z - A - 1, D[ie++] = Z - A, D[ie++] = Z - A - 1, D[ie++] = Z, D[ie++] = Z - 1) : (D[ie++] = Z - 1, D[ie++] = Z - A, D[ie++] = Z, D[ie++] = Z - A, D[ie++] = Z - 1, D[ie++] = Z - A - 1));
          return D;
        }, cr.prototype.getOwnPropertyDescriptor_ = function(A, T) {
          var D = Object.getOwnPropertyDescriptor(A, T);
          return (D.get === void 0 || D.set === void 0) && (D.configurable = !0, D.enumerable = !0, D.get = function() {
            return this.getAttribute(T);
          }, D.set = function(L) {
            this.setAttribute(T, L);
          }), D;
        };
        var Vt = ["attribute vec2 position;", "uniform mat4 projectionMat;", "void main() {", "  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );", "}"].join(`
`), yi = ["precision mediump float;", "uniform vec4 color;", "void main() {", "  gl_FragColor = color;", "}"].join(`
`), gr = Math.PI / 180, ar = 60, ae = 12, Pe = 20, Ie = 1, Ze = 0.75, Fe = 0.3125, st = 4, Ne = 28, mt = 1.5;
        function Rt(A) {
          this.gl = A, this.attribs = {
            position: 0
          }, this.program = pe(A, Vt, yi, this.attribs), this.uniforms = Re(A, this.program), this.vertexBuffer = A.createBuffer(), this.gearOffset = 0, this.gearVertexCount = 0, this.arrowOffset = 0, this.arrowVertexCount = 0, this.projMat = new Float32Array(16), this.listener = null, this.onResize();
        }
        Rt.prototype.destroy = function() {
          var A = this.gl;
          this.listener && A.canvas.removeEventListener("click", this.listener, !1), A.deleteProgram(this.program), A.deleteBuffer(this.vertexBuffer);
        }, Rt.prototype.listen = function(A, T) {
          var D = this.gl.canvas;
          this.listener = function(L) {
            var U = D.clientWidth / 2, Z = Ne * mt;
            L.clientX > U - Z && L.clientX < U + Z && L.clientY > D.clientHeight - Z ? A(L) : L.clientX < Z && L.clientY < Z && T(L);
          }, D.addEventListener("click", this.listener, !1);
        }, Rt.prototype.onResize = function() {
          var A = this.gl, T = this, D = [A.ARRAY_BUFFER_BINDING];
          Et(A, D, function(L) {
            var U = [], Z = L.drawingBufferWidth / 2, ie = Math.max(screen.width, screen.height) * window.devicePixelRatio, ve = L.drawingBufferWidth / ie, me = ve * window.devicePixelRatio, ne = st * me / 2, le = Ne * mt * me, be = Ne * me / 2, Ve = (Ne * mt - Ne) * me;
            U.push(Z - ne, le), U.push(Z - ne, L.drawingBufferHeight), U.push(Z + ne, le), U.push(Z + ne, L.drawingBufferHeight), T.gearOffset = U.length / 2;
            function qe(zt, nr) {
              var yr = (90 - zt) * gr, tr = Math.cos(yr), Mr = Math.sin(yr);
              U.push(Fe * tr * be + Z, Fe * Mr * be + be), U.push(nr * tr * be + Z, nr * Mr * be + be);
            }
            for (var it = 0; it <= 6; it++) {
              var At = it * ar;
              qe(At, Ie), qe(At + ae, Ie), qe(At + Pe, Ze), qe(At + (ar - Pe), Ze), qe(At + (ar - ae), Ie);
            }
            T.gearVertexCount = U.length / 2 - T.gearOffset, T.arrowOffset = U.length / 2;
            function ot(zt, nr) {
              U.push(Ve + zt, L.drawingBufferHeight - Ve - nr);
            }
            var ut = ne / Math.sin(45 * gr);
            ot(0, be), ot(be, 0), ot(be + ut, ut), ot(ut, be + ut), ot(ut, be - ut), ot(0, be), ot(be, be * 2), ot(be + ut, be * 2 - ut), ot(ut, be - ut), ot(0, be), ot(ut, be - ne), ot(Ne * me, be - ne), ot(ut, be + ne), ot(Ne * me, be + ne), T.arrowVertexCount = U.length / 2 - T.arrowOffset, L.bindBuffer(L.ARRAY_BUFFER, T.vertexBuffer), L.bufferData(L.ARRAY_BUFFER, new Float32Array(U), L.STATIC_DRAW);
          });
        }, Rt.prototype.render = function() {
          var A = this.gl, T = this, D = [A.CULL_FACE, A.DEPTH_TEST, A.BLEND, A.SCISSOR_TEST, A.STENCIL_TEST, A.COLOR_WRITEMASK, A.VIEWPORT, A.CURRENT_PROGRAM, A.ARRAY_BUFFER_BINDING];
          Et(A, D, function(L) {
            L.disable(L.CULL_FACE), L.disable(L.DEPTH_TEST), L.disable(L.BLEND), L.disable(L.SCISSOR_TEST), L.disable(L.STENCIL_TEST), L.colorMask(!0, !0, !0, !0), L.viewport(0, 0, L.drawingBufferWidth, L.drawingBufferHeight), T.renderNoState();
          });
        }, Rt.prototype.renderNoState = function() {
          var A = this.gl;
          A.useProgram(this.program), A.bindBuffer(A.ARRAY_BUFFER, this.vertexBuffer), A.enableVertexAttribArray(this.attribs.position), A.vertexAttribPointer(this.attribs.position, 2, A.FLOAT, !1, 8, 0), A.uniform4f(this.uniforms.color, 1, 1, 1, 1), _e(this.projMat, 0, A.drawingBufferWidth, 0, A.drawingBufferHeight, 0.1, 1024), A.uniformMatrix4fv(this.uniforms.projectionMat, !1, this.projMat), A.drawArrays(A.TRIANGLE_STRIP, 0, 4), A.drawArrays(A.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount), A.drawArrays(A.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
        };
        function ht(A) {
          this.coefficients = A;
        }
        ht.prototype.distortInverse = function(A) {
          for (var T = 0, D = 1, L = A - this.distort(T); Math.abs(D - T) > 1e-4; ) {
            var U = A - this.distort(D), Z = D - U * ((D - T) / (U - L));
            T = D, D = Z, L = U;
          }
          return D;
        }, ht.prototype.distort = function(A) {
          for (var T = A * A, D = 0, L = 0; L < this.coefficients.length; L++)
            D = T * (D + this.coefficients[L]);
          return (D + 1) * A;
        };
        var Ct = Math.PI / 180, Lt = 180 / Math.PI, wt = function(T, D, L) {
          this.x = T || 0, this.y = D || 0, this.z = L || 0;
        };
        wt.prototype = {
          constructor: wt,
          set: function(T, D, L) {
            return this.x = T, this.y = D, this.z = L, this;
          },
          copy: function(T) {
            return this.x = T.x, this.y = T.y, this.z = T.z, this;
          },
          length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
          },
          normalize: function() {
            var T = this.length();
            if (T !== 0) {
              var D = 1 / T;
              this.multiplyScalar(D);
            } else
              this.x = 0, this.y = 0, this.z = 0;
            return this;
          },
          multiplyScalar: function(T) {
            this.x *= T, this.y *= T, this.z *= T;
          },
          applyQuaternion: function(T) {
            var D = this.x, L = this.y, U = this.z, Z = T.x, ie = T.y, ve = T.z, me = T.w, ne = me * D + ie * U - ve * L, le = me * L + ve * D - Z * U, be = me * U + Z * L - ie * D, Ve = -Z * D - ie * L - ve * U;
            return this.x = ne * me + Ve * -Z + le * -ve - be * -ie, this.y = le * me + Ve * -ie + be * -Z - ne * -ve, this.z = be * me + Ve * -ve + ne * -ie - le * -Z, this;
          },
          dot: function(T) {
            return this.x * T.x + this.y * T.y + this.z * T.z;
          },
          crossVectors: function(T, D) {
            var L = T.x, U = T.y, Z = T.z, ie = D.x, ve = D.y, me = D.z;
            return this.x = U * me - Z * ve, this.y = Z * ie - L * me, this.z = L * ve - U * ie, this;
          }
        };
        var _t = function(T, D, L, U) {
          this.x = T || 0, this.y = D || 0, this.z = L || 0, this.w = U !== void 0 ? U : 1;
        };
        _t.prototype = {
          constructor: _t,
          set: function(T, D, L, U) {
            return this.x = T, this.y = D, this.z = L, this.w = U, this;
          },
          copy: function(T) {
            return this.x = T.x, this.y = T.y, this.z = T.z, this.w = T.w, this;
          },
          setFromEulerXYZ: function(T, D, L) {
            var U = Math.cos(T / 2), Z = Math.cos(D / 2), ie = Math.cos(L / 2), ve = Math.sin(T / 2), me = Math.sin(D / 2), ne = Math.sin(L / 2);
            return this.x = ve * Z * ie + U * me * ne, this.y = U * me * ie - ve * Z * ne, this.z = U * Z * ne + ve * me * ie, this.w = U * Z * ie - ve * me * ne, this;
          },
          setFromEulerYXZ: function(T, D, L) {
            var U = Math.cos(T / 2), Z = Math.cos(D / 2), ie = Math.cos(L / 2), ve = Math.sin(T / 2), me = Math.sin(D / 2), ne = Math.sin(L / 2);
            return this.x = ve * Z * ie + U * me * ne, this.y = U * me * ie - ve * Z * ne, this.z = U * Z * ne - ve * me * ie, this.w = U * Z * ie + ve * me * ne, this;
          },
          setFromAxisAngle: function(T, D) {
            var L = D / 2, U = Math.sin(L);
            return this.x = T.x * U, this.y = T.y * U, this.z = T.z * U, this.w = Math.cos(L), this;
          },
          multiply: function(T) {
            return this.multiplyQuaternions(this, T);
          },
          multiplyQuaternions: function(T, D) {
            var L = T.x, U = T.y, Z = T.z, ie = T.w, ve = D.x, me = D.y, ne = D.z, le = D.w;
            return this.x = L * le + ie * ve + U * ne - Z * me, this.y = U * le + ie * me + Z * ve - L * ne, this.z = Z * le + ie * ne + L * me - U * ve, this.w = ie * le - L * ve - U * me - Z * ne, this;
          },
          inverse: function() {
            return this.x *= -1, this.y *= -1, this.z *= -1, this.normalize(), this;
          },
          normalize: function() {
            var T = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            return T === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (T = 1 / T, this.x = this.x * T, this.y = this.y * T, this.z = this.z * T, this.w = this.w * T), this;
          },
          slerp: function(T, D) {
            if (D === 0) return this;
            if (D === 1) return this.copy(T);
            var L = this.x, U = this.y, Z = this.z, ie = this.w, ve = ie * T.w + L * T.x + U * T.y + Z * T.z;
            if (ve < 0 ? (this.w = -T.w, this.x = -T.x, this.y = -T.y, this.z = -T.z, ve = -ve) : this.copy(T), ve >= 1)
              return this.w = ie, this.x = L, this.y = U, this.z = Z, this;
            var me = Math.acos(ve), ne = Math.sqrt(1 - ve * ve);
            if (Math.abs(ne) < 1e-3)
              return this.w = 0.5 * (ie + this.w), this.x = 0.5 * (L + this.x), this.y = 0.5 * (U + this.y), this.z = 0.5 * (Z + this.z), this;
            var le = Math.sin((1 - D) * me) / ne, be = Math.sin(D * me) / ne;
            return this.w = ie * le + this.w * be, this.x = L * le + this.x * be, this.y = U * le + this.y * be, this.z = Z * le + this.z * be, this;
          },
          setFromUnitVectors: /* @__PURE__ */ function() {
            var A, T, D = 1e-6;
            return function(L, U) {
              return A === void 0 && (A = new wt()), T = L.dot(U) + 1, T < D ? (T = 0, Math.abs(L.x) > Math.abs(L.z) ? A.set(-L.y, L.x, 0) : A.set(0, -L.z, L.y)) : A.crossVectors(L, U), this.x = A.x, this.y = A.y, this.z = A.z, this.w = T, this.normalize(), this;
            };
          }()
        };
        function Fi(A) {
          this.width = A.width || se(), this.height = A.height || re(), this.widthMeters = A.widthMeters, this.heightMeters = A.heightMeters, this.bevelMeters = A.bevelMeters;
        }
        var ni = new Fi({
          widthMeters: 0.11,
          heightMeters: 0.062,
          bevelMeters: 4e-3
        }), ra = new Fi({
          widthMeters: 0.1038,
          heightMeters: 0.0584,
          bevelMeters: 4e-3
        }), xr = {
          CardboardV1: new an({
            id: "CardboardV1",
            label: "Cardboard I/O 2014",
            fov: 40,
            interLensDistance: 0.06,
            baselineLensDistance: 0.035,
            screenLensDistance: 0.042,
            distortionCoefficients: [0.441, 0.156],
            inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 1559834e-9]
          }),
          CardboardV2: new an({
            id: "CardboardV2",
            label: "Cardboard I/O 2015",
            fov: 60,
            interLensDistance: 0.064,
            baselineLensDistance: 0.035,
            screenLensDistance: 0.039,
            distortionCoefficients: [0.34, 0.55],
            inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 9177956e-9, -9904169e-10, 6183535e-11, -16981803e-13]
          })
        };
        function Xt(A, T) {
          this.viewer = xr.CardboardV2, this.updateDeviceParams(A), this.distortion = new ht(this.viewer.distortionCoefficients);
          for (var D = 0; D < T.length; D++) {
            var L = T[D];
            xr[L.id] = new an(L);
          }
        }
        Xt.prototype.updateDeviceParams = function(A) {
          this.device = this.determineDevice_(A) || this.device;
        }, Xt.prototype.getDevice = function() {
          return this.device;
        }, Xt.prototype.setViewer = function(A) {
          this.viewer = A, this.distortion = new ht(this.viewer.distortionCoefficients);
        }, Xt.prototype.determineDevice_ = function(A) {
          if (!A)
            return I() ? (console.warn("Using fallback iOS device measurements."), ra) : (console.warn("Using fallback Android device measurements."), ni);
          var T = 0.0254, D = T / A.xdpi, L = T / A.ydpi, U = se(), Z = re();
          return new Fi({
            widthMeters: D * U,
            heightMeters: L * Z,
            bevelMeters: A.bevelMm * 1e-3
          });
        }, Xt.prototype.getDistortedFieldOfViewLeftEye = function() {
          var A = this.viewer, T = this.device, D = this.distortion, L = A.screenLensDistance, U = (T.widthMeters - A.interLensDistance) / 2, Z = A.interLensDistance / 2, ie = A.baselineLensDistance - T.bevelMeters, ve = T.heightMeters - ie, me = Lt * Math.atan(D.distort(U / L)), ne = Lt * Math.atan(D.distort(Z / L)), le = Lt * Math.atan(D.distort(ie / L)), be = Lt * Math.atan(D.distort(ve / L));
          return {
            leftDegrees: Math.min(me, A.fov),
            rightDegrees: Math.min(ne, A.fov),
            downDegrees: Math.min(le, A.fov),
            upDegrees: Math.min(be, A.fov)
          };
        }, Xt.prototype.getLeftEyeVisibleTanAngles = function() {
          var A = this.viewer, T = this.device, D = this.distortion, L = Math.tan(-Ct * A.fov), U = Math.tan(Ct * A.fov), Z = Math.tan(Ct * A.fov), ie = Math.tan(-Ct * A.fov), ve = T.widthMeters / 4, me = T.heightMeters / 2, ne = A.baselineLensDistance - T.bevelMeters - me, le = A.interLensDistance / 2 - ve, be = -ne, Ve = A.screenLensDistance, qe = D.distort((le - ve) / Ve), it = D.distort((be + me) / Ve), At = D.distort((le + ve) / Ve), ot = D.distort((be - me) / Ve), ut = new Float32Array(4);
          return ut[0] = Math.max(L, qe), ut[1] = Math.min(U, it), ut[2] = Math.min(Z, At), ut[3] = Math.max(ie, ot), ut;
        }, Xt.prototype.getLeftEyeNoLensTanAngles = function() {
          var A = this.viewer, T = this.device, D = this.distortion, L = new Float32Array(4), U = D.distortInverse(Math.tan(-Ct * A.fov)), Z = D.distortInverse(Math.tan(Ct * A.fov)), ie = D.distortInverse(Math.tan(Ct * A.fov)), ve = D.distortInverse(Math.tan(-Ct * A.fov)), me = T.widthMeters / 4, ne = T.heightMeters / 2, le = A.baselineLensDistance - T.bevelMeters - ne, be = A.interLensDistance / 2 - me, Ve = -le, qe = A.screenLensDistance, it = (be - me) / qe, At = (Ve + ne) / qe, ot = (be + me) / qe, ut = (Ve - ne) / qe;
          return L[0] = Math.max(U, it), L[1] = Math.min(Z, At), L[2] = Math.min(ie, ot), L[3] = Math.max(ve, ut), L;
        }, Xt.prototype.getLeftEyeVisibleScreenRect = function(A) {
          var T = this.viewer, D = this.device, L = T.screenLensDistance, U = (D.widthMeters - T.interLensDistance) / 2, Z = T.baselineLensDistance - D.bevelMeters, ie = (A[0] * L + U) / D.widthMeters, ve = (A[1] * L + Z) / D.heightMeters, me = (A[2] * L + U) / D.widthMeters, ne = (A[3] * L + Z) / D.heightMeters;
          return {
            x: ie,
            y: ne,
            width: me - ie,
            height: ve - ne
          };
        }, Xt.prototype.getFieldOfViewLeftEye = function(A) {
          return A ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
        }, Xt.prototype.getFieldOfViewRightEye = function(A) {
          var T = this.getFieldOfViewLeftEye(A);
          return {
            leftDegrees: T.rightDegrees,
            rightDegrees: T.leftDegrees,
            upDegrees: T.upDegrees,
            downDegrees: T.downDegrees
          };
        }, Xt.prototype.getUndistortedFieldOfViewLeftEye = function() {
          var A = this.getUndistortedParams_();
          return {
            leftDegrees: Lt * Math.atan(A.outerDist),
            rightDegrees: Lt * Math.atan(A.innerDist),
            downDegrees: Lt * Math.atan(A.bottomDist),
            upDegrees: Lt * Math.atan(A.topDist)
          };
        }, Xt.prototype.getUndistortedViewportLeftEye = function() {
          var A = this.getUndistortedParams_(), T = this.viewer, D = this.device, L = T.screenLensDistance, U = D.widthMeters / L, Z = D.heightMeters / L, ie = D.width / U, ve = D.height / Z, me = Math.round((A.eyePosX - A.outerDist) * ie), ne = Math.round((A.eyePosY - A.bottomDist) * ve);
          return {
            x: me,
            y: ne,
            width: Math.round((A.eyePosX + A.innerDist) * ie) - me,
            height: Math.round((A.eyePosY + A.topDist) * ve) - ne
          };
        }, Xt.prototype.getUndistortedParams_ = function() {
          var A = this.viewer, T = this.device, D = this.distortion, L = A.screenLensDistance, U = A.interLensDistance / 2 / L, Z = T.widthMeters / L, ie = T.heightMeters / L, ve = Z / 2 - U, me = (A.baselineLensDistance - T.bevelMeters) / L, ne = A.fov, le = D.distortInverse(Math.tan(Ct * ne)), be = Math.min(ve, le), Ve = Math.min(U, le), qe = Math.min(me, le), it = Math.min(ie - me, le);
          return {
            outerDist: be,
            innerDist: Ve,
            topDist: it,
            bottomDist: qe,
            eyePosX: ve,
            eyePosY: me
          };
        };
        function an(A) {
          this.id = A.id, this.label = A.label, this.fov = A.fov, this.interLensDistance = A.interLensDistance, this.baselineLensDistance = A.baselineLensDistance, this.screenLensDistance = A.screenLensDistance, this.distortionCoefficients = A.distortionCoefficients, this.inverseCoefficients = A.inverseCoefficients;
        }
        Xt.Viewers = xr;
        var ia = 1, ki = "2019-11-09T17:36:14Z", zo = [{ type: "android", rules: [{ mdmh: "asus/*/Nexus 7/*" }, { ua: "Nexus 7" }], dpi: [320.8, 323], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "asus/*/ASUS_X00PD/*" }, { ua: "ASUS_X00PD" }], dpi: 245, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "asus/*/ASUS_X008D/*" }, { ua: "ASUS_X008D" }], dpi: 282, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "asus/*/ASUS_Z00AD/*" }, { ua: "ASUS_Z00AD" }], dpi: [403, 404.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel 2 XL/*" }, { ua: "Pixel 2 XL" }], dpi: 537.9, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel 3 XL/*" }, { ua: "Pixel 3 XL" }], dpi: [558.5, 553.8], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel XL/*" }, { ua: "Pixel XL" }], dpi: [537.9, 533], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel 3/*" }, { ua: "Pixel 3" }], dpi: 442.4, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel 2/*" }, { ua: "Pixel 2" }], dpi: 441, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "Google/*/Pixel/*" }, { ua: "Pixel" }], dpi: [432.6, 436.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC6435LVW/*" }, { ua: "HTC6435LVW" }], dpi: [449.7, 443.3], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC One XL/*" }, { ua: "HTC One XL" }], dpi: [315.3, 314.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "htc/*/Nexus 9/*" }, { ua: "Nexus 9" }], dpi: 289, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC One M9/*" }, { ua: "HTC One M9" }], dpi: [442.5, 443.3], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC One_M8/*" }, { ua: "HTC One_M8" }], dpi: [449.7, 447.4], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "HTC/*/HTC One/*" }, { ua: "HTC One" }], dpi: 472.8, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Huawei/*/Nexus 6P/*" }, { ua: "Nexus 6P" }], dpi: [515.1, 518], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Huawei/*/BLN-L24/*" }, { ua: "HONORBLN-L24" }], dpi: 480, bw: 4, ac: 500 }, { type: "android", rules: [{ mdmh: "Huawei/*/BKL-L09/*" }, { ua: "BKL-L09" }], dpi: 403, bw: 3.47, ac: 500 }, { type: "android", rules: [{ mdmh: "LENOVO/*/Lenovo PB2-690Y/*" }, { ua: "Lenovo PB2-690Y" }], dpi: [457.2, 454.713], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "LGE/*/Nexus 5X/*" }, { ua: "Nexus 5X" }], dpi: [422, 419.9], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/LGMS345/*" }, { ua: "LGMS345" }], dpi: [221.7, 219.1], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "LGE/*/LG-D800/*" }, { ua: "LG-D800" }], dpi: [422, 424.1], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "LGE/*/LG-D850/*" }, { ua: "LG-D850" }], dpi: [537.9, 541.9], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "LGE/*/VS985 4G/*" }, { ua: "VS985 4G" }], dpi: [537.9, 535.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/Nexus 5/*" }, { ua: "Nexus 5 B" }], dpi: [442.4, 444.8], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/Nexus 4/*" }, { ua: "Nexus 4" }], dpi: [319.8, 318.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/LG-P769/*" }, { ua: "LG-P769" }], dpi: [240.6, 247.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/LGMS323/*" }, { ua: "LGMS323" }], dpi: [206.6, 204.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "LGE/*/LGLS996/*" }, { ua: "LGLS996" }], dpi: [403.4, 401.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Micromax/*/4560MMX/*" }, { ua: "4560MMX" }], dpi: [240, 219.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Micromax/*/A250/*" }, { ua: "Micromax A250" }], dpi: [480, 446.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Micromax/*/Micromax AQ4501/*" }, { ua: "Micromax AQ4501" }], dpi: 240, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/G5/*" }, { ua: "Moto G (5) Plus" }], dpi: [403.4, 403], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/DROID RAZR/*" }, { ua: "DROID RAZR" }], dpi: [368.1, 256.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT830C/*" }, { ua: "XT830C" }], dpi: [254, 255.9], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1021/*" }, { ua: "XT1021" }], dpi: [254, 256.7], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1023/*" }, { ua: "XT1023" }], dpi: [254, 256.7], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1028/*" }, { ua: "XT1028" }], dpi: [326.6, 327.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1034/*" }, { ua: "XT1034" }], dpi: [326.6, 328.4], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1053/*" }, { ua: "XT1053" }], dpi: [315.3, 316.1], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1562/*" }, { ua: "XT1562" }], dpi: [403.4, 402.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/Nexus 6/*" }, { ua: "Nexus 6 B" }], dpi: [494.3, 489.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1063/*" }, { ua: "XT1063" }], dpi: [295, 296.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1064/*" }, { ua: "XT1064" }], dpi: [295, 295.6], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1092/*" }, { ua: "XT1092" }], dpi: [422, 424.1], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "motorola/*/XT1095/*" }, { ua: "XT1095" }], dpi: [422, 423.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "motorola/*/G4/*" }, { ua: "Moto G (4)" }], dpi: 401, bw: 4, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/A0001/*" }, { ua: "A0001" }], dpi: [403.4, 401], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE E1001/*" }, { ua: "ONE E1001" }], dpi: [442.4, 441.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE E1003/*" }, { ua: "ONE E1003" }], dpi: [442.4, 441.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE E1005/*" }, { ua: "ONE E1005" }], dpi: [442.4, 441.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE A2001/*" }, { ua: "ONE A2001" }], dpi: [391.9, 405.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE A2003/*" }, { ua: "ONE A2003" }], dpi: [391.9, 405.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE A2005/*" }, { ua: "ONE A2005" }], dpi: [391.9, 405.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A3000/*" }, { ua: "ONEPLUS A3000" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A3003/*" }, { ua: "ONEPLUS A3003" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A3010/*" }, { ua: "ONEPLUS A3010" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A5000/*" }, { ua: "ONEPLUS A5000 " }], dpi: [403.411, 399.737], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONE A5010/*" }, { ua: "ONEPLUS A5010" }], dpi: [403, 400], bw: 2, ac: 1e3 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A6000/*" }, { ua: "ONEPLUS A6000" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A6003/*" }, { ua: "ONEPLUS A6003" }], dpi: 401, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A6010/*" }, { ua: "ONEPLUS A6010" }], dpi: 401, bw: 2, ac: 500 }, { type: "android", rules: [{ mdmh: "OnePlus/*/ONEPLUS A6013/*" }, { ua: "ONEPLUS A6013" }], dpi: 401, bw: 2, ac: 500 }, { type: "android", rules: [{ mdmh: "OPPO/*/X909/*" }, { ua: "X909" }], dpi: [442.4, 444.1], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9082/*" }, { ua: "GT-I9082" }], dpi: [184.7, 185.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G360P/*" }, { ua: "SM-G360P" }], dpi: [196.7, 205.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/Nexus S/*" }, { ua: "Nexus S" }], dpi: [234.5, 229.8], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9300/*" }, { ua: "GT-I9300" }], dpi: [304.8, 303.9], bw: 5, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-T230NU/*" }, { ua: "SM-T230NU" }], dpi: 216, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SGH-T399/*" }, { ua: "SGH-T399" }], dpi: [217.7, 231.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SGH-M919/*" }, { ua: "SGH-M919" }], dpi: [440.8, 437.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N9005/*" }, { ua: "SM-N9005" }], dpi: [386.4, 387], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SAMSUNG-SM-N900A/*" }, { ua: "SAMSUNG-SM-N900A" }], dpi: [386.4, 387.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9500/*" }, { ua: "GT-I9500" }], dpi: [442.5, 443.3], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9505/*" }, { ua: "GT-I9505" }], dpi: 439.4, bw: 4, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G900F/*" }, { ua: "SM-G900F" }], dpi: [415.6, 431.6], bw: 5, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G900M/*" }, { ua: "SM-G900M" }], dpi: [415.6, 431.6], bw: 5, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G800F/*" }, { ua: "SM-G800F" }], dpi: 326.8, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G906S/*" }, { ua: "SM-G906S" }], dpi: [562.7, 572.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9300/*" }, { ua: "GT-I9300" }], dpi: [306.7, 304.8], bw: 5, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-T535/*" }, { ua: "SM-T535" }], dpi: [142.6, 136.4], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N920C/*" }, { ua: "SM-N920C" }], dpi: [515.1, 518.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N920P/*" }, { ua: "SM-N920P" }], dpi: [386.3655, 390.144], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N920W8/*" }, { ua: "SM-N920W8" }], dpi: [515.1, 518.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9300I/*" }, { ua: "GT-I9300I" }], dpi: [304.8, 305.8], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-I9195/*" }, { ua: "GT-I9195" }], dpi: [249.4, 256.7], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SPH-L520/*" }, { ua: "SPH-L520" }], dpi: [249.4, 255.9], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SAMSUNG-SGH-I717/*" }, { ua: "SAMSUNG-SGH-I717" }], dpi: 285.8, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SPH-D710/*" }, { ua: "SPH-D710" }], dpi: [217.7, 204.2], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/GT-N7100/*" }, { ua: "GT-N7100" }], dpi: 265.1, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SCH-I605/*" }, { ua: "SCH-I605" }], dpi: 265.1, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/Galaxy Nexus/*" }, { ua: "Galaxy Nexus" }], dpi: [315.3, 314.2], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N910H/*" }, { ua: "SM-N910H" }], dpi: [515.1, 518], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-N910C/*" }, { ua: "SM-N910C" }], dpi: [515.2, 520.2], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G130M/*" }, { ua: "SM-G130M" }], dpi: [165.9, 164.8], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G928I/*" }, { ua: "SM-G928I" }], dpi: [515.1, 518.4], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G920F/*" }, { ua: "SM-G920F" }], dpi: 580.6, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G920P/*" }, { ua: "SM-G920P" }], dpi: [522.5, 577], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G925F/*" }, { ua: "SM-G925F" }], dpi: 580.6, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G925V/*" }, { ua: "SM-G925V" }], dpi: [522.5, 576.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G930F/*" }, { ua: "SM-G930F" }], dpi: 576.6, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G935F/*" }, { ua: "SM-G935F" }], dpi: 533, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G950F/*" }, { ua: "SM-G950F" }], dpi: [562.707, 565.293], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G955U/*" }, { ua: "SM-G955U" }], dpi: [522.514, 525.762], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G955F/*" }, { ua: "SM-G955F" }], dpi: [522.514, 525.762], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960F/*" }, { ua: "SM-G960F" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G9600/*" }, { ua: "SM-G9600" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960T/*" }, { ua: "SM-G960T" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960N/*" }, { ua: "SM-G960N" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960U/*" }, { ua: "SM-G960U" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G9608/*" }, { ua: "SM-G9608" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960FD/*" }, { ua: "SM-G960FD" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G960W/*" }, { ua: "SM-G960W" }], dpi: [569.575, 571.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G965F/*" }, { ua: "SM-G965F" }], dpi: 529, bw: 2, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Sony/*/C6903/*" }, { ua: "C6903" }], dpi: [442.5, 443.3], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "Sony/*/D6653/*" }, { ua: "D6653" }], dpi: [428.6, 427.6], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Sony/*/E6653/*" }, { ua: "E6653" }], dpi: [428.6, 425.7], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Sony/*/E6853/*" }, { ua: "E6853" }], dpi: [403.4, 401.9], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Sony/*/SGP321/*" }, { ua: "SGP321" }], dpi: [224.7, 224.1], bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "TCT/*/ALCATEL ONE TOUCH Fierce/*" }, { ua: "ALCATEL ONE TOUCH Fierce" }], dpi: [240, 247.5], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "THL/*/thl 5000/*" }, { ua: "thl 5000" }], dpi: [480, 443.3], bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Fly/*/IQ4412/*" }, { ua: "IQ4412" }], dpi: 307.9, bw: 3, ac: 1e3 }, { type: "android", rules: [{ mdmh: "ZTE/*/ZTE Blade L2/*" }, { ua: "ZTE Blade L2" }], dpi: 240, bw: 3, ac: 500 }, { type: "android", rules: [{ mdmh: "BENEVE/*/VR518/*" }, { ua: "VR518" }], dpi: 480, bw: 3, ac: 500 }, { type: "ios", rules: [{ res: [640, 960] }], dpi: [325.1, 328.4], bw: 4, ac: 1e3 }, { type: "ios", rules: [{ res: [640, 1136] }], dpi: [317.1, 320.2], bw: 3, ac: 1e3 }, { type: "ios", rules: [{ res: [750, 1334] }], dpi: 326.4, bw: 4, ac: 1e3 }, { type: "ios", rules: [{ res: [1242, 2208] }], dpi: [453.6, 458.4], bw: 4, ac: 1e3 }, { type: "ios", rules: [{ res: [1125, 2001] }], dpi: [410.9, 415.4], bw: 4, ac: 1e3 }, { type: "ios", rules: [{ res: [1125, 2436] }], dpi: 458, bw: 4, ac: 1e3 }, { type: "android", rules: [{ mdmh: "Huawei/*/EML-L29/*" }, { ua: "EML-L29" }], dpi: 428, bw: 3.45, ac: 500 }, { type: "android", rules: [{ mdmh: "Nokia/*/Nokia 7.1/*" }, { ua: "Nokia 7.1" }], dpi: [432, 431.9], bw: 3, ac: 500 }, { type: "ios", rules: [{ res: [1242, 2688] }], dpi: 458, bw: 4, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G570M/*" }, { ua: "SM-G570M" }], dpi: 320, bw: 3.684, ac: 1e3 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G970F/*" }, { ua: "SM-G970F" }], dpi: 438, bw: 2.281, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G973F/*" }, { ua: "SM-G973F" }], dpi: 550, bw: 2.002, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G975F/*" }, { ua: "SM-G975F" }], dpi: 522, bw: 2.054, ac: 500 }, { type: "android", rules: [{ mdmh: "samsung/*/SM-G977F/*" }, { ua: "SM-G977F" }], dpi: 505, bw: 2.334, ac: 500 }, { type: "ios", rules: [{ res: [828, 1792] }], dpi: 326, bw: 5, ac: 500 }], _s = {
          format: ia,
          last_updated: ki,
          devices: zo
        };
        function _i(A, T) {
          if (this.dpdb = _s, this.recalculateDeviceParams_(), A) {
            this.onDeviceParamsUpdated = T;
            var D = new XMLHttpRequest(), L = this;
            D.open("GET", A, !0), D.addEventListener("load", function() {
              L.loading = !1, D.status >= 200 && D.status <= 299 ? (L.dpdb = JSON.parse(D.response), L.recalculateDeviceParams_()) : console.error("Error loading online DPDB!");
            }), D.send();
          }
        }
        _i.prototype.getDeviceParams = function() {
          return this.deviceParams;
        }, _i.prototype.recalculateDeviceParams_ = function() {
          var A = this.calcDeviceParams_();
          A ? (this.deviceParams = A, this.onDeviceParamsUpdated && this.onDeviceParamsUpdated(this.deviceParams)) : console.error("Failed to recalculate device parameters.");
        }, _i.prototype.calcDeviceParams_ = function() {
          var A = this.dpdb;
          if (!A)
            return console.error("DPDB not available."), null;
          if (A.format != 1)
            return console.error("DPDB has unexpected format version."), null;
          if (!A.devices || !A.devices.length)
            return console.error("DPDB does not have a devices section."), null;
          var T = navigator.userAgent || navigator.vendor || window.opera, D = se(), L = re();
          if (!A.devices)
            return console.error("DPDB has no devices section."), null;
          for (var U = 0; U < A.devices.length; U++) {
            var Z = A.devices[U];
            if (!Z.rules) {
              console.warn("Device[" + U + "] has no rules section.");
              continue;
            }
            if (Z.type != "ios" && Z.type != "android") {
              console.warn("Device[" + U + "] has invalid type.");
              continue;
            }
            if (I() == (Z.type == "ios")) {
              for (var ie = !1, ve = 0; ve < Z.rules.length; ve++) {
                var me = Z.rules[ve];
                if (this.ruleMatches_(me, T, D, L)) {
                  ie = !0;
                  break;
                }
              }
              if (ie) {
                var ne = Z.dpi[0] || Z.dpi, le = Z.dpi[1] || Z.dpi;
                return new Or({ xdpi: ne, ydpi: le, bevelMm: Z.bw });
              }
            }
          }
          return console.warn("No DPDB device match."), null;
        }, _i.prototype.ruleMatches_ = function(A, T, D, L) {
          if (!A.ua && !A.res || (A.ua && A.ua.substring(0, 2) === "SM" && (A.ua = A.ua.substring(0, 7)), A.ua && T.indexOf(A.ua) < 0)) return !1;
          if (A.res) {
            if (!A.res[0] || !A.res[1]) return !1;
            var U = A.res[0], Z = A.res[1];
            if (Math.min(D, L) != Math.min(U, Z) || Math.max(D, L) != Math.max(U, Z))
              return !1;
          }
          return !0;
        };
        function Or(A) {
          this.xdpi = A.xdpi, this.ydpi = A.ydpi, this.bevelMm = A.bevelMm;
        }
        function wn(A, T) {
          this.set(A, T);
        }
        wn.prototype.set = function(A, T) {
          this.sample = A, this.timestampS = T;
        }, wn.prototype.copy = function(A) {
          this.set(A.sample, A.timestampS);
        };
        function Ni(A, T) {
          this.kFilter = A, this.isDebug = T, this.currentAccelMeasurement = new wn(), this.currentGyroMeasurement = new wn(), this.previousGyroMeasurement = new wn(), I() ? this.filterQ = new _t(-1, 0, 0, 1) : this.filterQ = new _t(1, 0, 0, 1), this.previousFilterQ = new _t(), this.previousFilterQ.copy(this.filterQ), this.accelQ = new _t(), this.isOrientationInitialized = !1, this.estimatedGravity = new wt(), this.measuredGravity = new wt(), this.gyroIntegralQ = new _t();
        }
        Ni.prototype.addAccelMeasurement = function(A, T) {
          this.currentAccelMeasurement.set(A, T);
        }, Ni.prototype.addGyroMeasurement = function(A, T) {
          this.currentGyroMeasurement.set(A, T);
          var D = T - this.previousGyroMeasurement.timestampS;
          G(D) && this.run_(), this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
        }, Ni.prototype.run_ = function() {
          if (!this.isOrientationInitialized) {
            this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample), this.previousFilterQ.copy(this.accelQ), this.isOrientationInitialized = !0;
            return;
          }
          var A = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS, T = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, A);
          this.gyroIntegralQ.multiply(T), this.filterQ.copy(this.previousFilterQ), this.filterQ.multiply(T);
          var D = new _t();
          D.copy(this.filterQ), D.inverse(), this.estimatedGravity.set(0, 0, -1), this.estimatedGravity.applyQuaternion(D), this.estimatedGravity.normalize(), this.measuredGravity.copy(this.currentAccelMeasurement.sample), this.measuredGravity.normalize();
          var L = new _t();
          L.setFromUnitVectors(this.estimatedGravity, this.measuredGravity), L.inverse(), this.isDebug && console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)", Lt * Mt(L), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
          var U = new _t();
          U.copy(this.filterQ), U.multiply(L), this.filterQ.slerp(U, 1 - this.kFilter), this.previousFilterQ.copy(this.filterQ);
        }, Ni.prototype.getOrientation = function() {
          return this.filterQ;
        }, Ni.prototype.accelToQuaternion_ = function(A) {
          var T = new wt();
          T.copy(A), T.normalize();
          var D = new _t();
          return D.setFromUnitVectors(new wt(0, 0, -1), T), D.inverse(), D;
        }, Ni.prototype.gyroToQuaternionDelta_ = function(A, T) {
          var D = new _t(), L = new wt();
          return L.copy(A), L.normalize(), D.setFromAxisAngle(L, A.length() * T), D;
        };
        function Sn(A, T) {
          this.predictionTimeS = A, this.isDebug = T, this.previousQ = new _t(), this.previousTimestampS = null, this.deltaQ = new _t(), this.outQ = new _t();
        }
        Sn.prototype.getPrediction = function(A, T, D) {
          if (!this.previousTimestampS)
            return this.previousQ.copy(A), this.previousTimestampS = D, A;
          var L = new wt();
          L.copy(T), L.normalize();
          var U = T.length();
          if (U < Ct * 20)
            return this.isDebug && console.log("Moving slowly, at %s deg/s: no prediction", (Lt * U).toFixed(1)), this.outQ.copy(A), this.previousQ.copy(A), this.outQ;
          var Z = U * this.predictionTimeS;
          return this.deltaQ.setFromAxisAngle(L, Z), this.outQ.copy(this.previousQ), this.outQ.multiply(this.deltaQ), this.previousQ.copy(A), this.previousTimestampS = D, this.outQ;
        };
        function Zt(A, T, D, L) {
          this.yawOnly = D, this.accelerometer = new wt(), this.gyroscope = new wt(), this.filter = new Ni(A, L), this.posePredictor = new Sn(T, L), this.isFirefoxAndroid = ee(), this.isIOS = I();
          var U = oe();
          this.isDeviceMotionInRadians = !this.isIOS && U && U < 66, this.isWithoutDeviceMotion = he() || de(), this.filterToWorldQ = new _t(), I() ? this.filterToWorldQ.setFromAxisAngle(new wt(1, 0, 0), Math.PI / 2) : this.filterToWorldQ.setFromAxisAngle(new wt(1, 0, 0), -Math.PI / 2), this.inverseWorldToScreenQ = new _t(), this.worldToScreenQ = new _t(), this.originalPoseAdjustQ = new _t(), this.originalPoseAdjustQ.setFromAxisAngle(new wt(0, 0, 1), -window.orientation * Math.PI / 180), this.setScreenTransform_(), V() && this.filterToWorldQ.multiply(this.inverseWorldToScreenQ), this.resetQ = new _t(), this.orientationOut_ = new Float32Array(4), this.start();
        }
        Zt.prototype.getPosition = function() {
          return null;
        }, Zt.prototype.getOrientation = function() {
          var A = void 0;
          if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
            this.deviceOrientationFixQ = this.deviceOrientationFixQ || function() {
              var U = new _t().setFromAxisAngle(new wt(0, 0, -1), 0), Z = new _t();
              return window.orientation === -90 ? Z.setFromAxisAngle(new wt(0, 1, 0), Math.PI / -2) : Z.setFromAxisAngle(new wt(0, 1, 0), Math.PI / 2), U.multiply(Z);
            }(), this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function() {
              var U = new _t();
              return U.setFromAxisAngle(new wt(1, 0, 0), -Math.PI / 2), U;
            }(), A = this._deviceOrientationQ;
            var D = new _t();
            return D.copy(A), D.multiply(this.deviceOrientationFilterToWorldQ), D.multiply(this.resetQ), D.multiply(this.worldToScreenQ), D.multiplyQuaternions(this.deviceOrientationFixQ, D), this.yawOnly && (D.x = 0, D.z = 0, D.normalize()), this.orientationOut_[0] = D.x, this.orientationOut_[1] = D.y, this.orientationOut_[2] = D.z, this.orientationOut_[3] = D.w, this.orientationOut_;
          } else {
            var T = this.filter.getOrientation();
            A = this.posePredictor.getPrediction(T, this.gyroscope, this.previousTimestampS);
          }
          var D = new _t();
          return D.copy(this.filterToWorldQ), D.multiply(this.resetQ), D.multiply(A), D.multiply(this.worldToScreenQ), this.yawOnly && (D.x = 0, D.z = 0, D.normalize()), this.orientationOut_[0] = D.x, this.orientationOut_[1] = D.y, this.orientationOut_[2] = D.z, this.orientationOut_[3] = D.w, this.orientationOut_;
        }, Zt.prototype.resetPose = function() {
          this.resetQ.copy(this.filter.getOrientation()), this.resetQ.x = 0, this.resetQ.y = 0, this.resetQ.z *= -1, this.resetQ.normalize(), V() && this.resetQ.multiply(this.inverseWorldToScreenQ), this.resetQ.multiply(this.originalPoseAdjustQ);
        }, Zt.prototype.onDeviceOrientation_ = function(A) {
          this._deviceOrientationQ = this._deviceOrientationQ || new _t();
          var T = A.alpha, D = A.beta, L = A.gamma;
          T = (T || 0) * Math.PI / 180, D = (D || 0) * Math.PI / 180, L = (L || 0) * Math.PI / 180, this._deviceOrientationQ.setFromEulerYXZ(D, T, -L);
        }, Zt.prototype.onDeviceMotion_ = function(A) {
          this.updateDeviceMotion_(A);
        }, Zt.prototype.updateDeviceMotion_ = function(A) {
          var T = A.accelerationIncludingGravity, D = A.rotationRate, L = A.timeStamp / 1e3, U = L - this.previousTimestampS;
          if (U < 0) {
            Ht("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion"), this.previousTimestampS = L;
            return;
          } else if (U <= R || U > B) {
            Ht("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range."), this.previousTimestampS = L;
            return;
          }
          this.accelerometer.set(-T.x, -T.y, -T.z), D && (fe() ? this.gyroscope.set(-D.beta, D.alpha, D.gamma) : this.gyroscope.set(D.alpha, D.beta, D.gamma), this.isDeviceMotionInRadians || this.gyroscope.multiplyScalar(Math.PI / 180), this.filter.addGyroMeasurement(this.gyroscope, L)), this.filter.addAccelMeasurement(this.accelerometer, L), this.previousTimestampS = L;
        }, Zt.prototype.onOrientationChange_ = function(A) {
          this.setScreenTransform_();
        }, Zt.prototype.onMessage_ = function(A) {
          var T = A.data;
          if (!(!T || !T.type)) {
            var D = T.type.toLowerCase();
            D === "devicemotion" && this.updateDeviceMotion_(T.deviceMotionEvent);
          }
        }, Zt.prototype.setScreenTransform_ = function() {
          switch (this.worldToScreenQ.set(0, 0, 0, 1), window.orientation) {
            case 0:
              break;
            case 90:
              this.worldToScreenQ.setFromAxisAngle(new wt(0, 0, 1), -Math.PI / 2);
              break;
            case -90:
              this.worldToScreenQ.setFromAxisAngle(new wt(0, 0, 1), Math.PI / 2);
              break;
          }
          this.inverseWorldToScreenQ.copy(this.worldToScreenQ), this.inverseWorldToScreenQ.inverse();
        }, Zt.prototype.start = function() {
          this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this), this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this), this.onMessageCallback_ = this.onMessage_.bind(this), this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this), I() && ct() && window.addEventListener("message", this.onMessageCallback_), window.addEventListener("orientationchange", this.onOrientationChangeCallback_), this.isWithoutDeviceMotion ? window.addEventListener("deviceorientation", this.onDeviceOrientationCallback_) : window.addEventListener("devicemotion", this.onDeviceMotionCallback_);
        }, Zt.prototype.stop = function() {
          window.removeEventListener("devicemotion", this.onDeviceMotionCallback_), window.removeEventListener("deviceorientation", this.onDeviceOrientationCallback_), window.removeEventListener("orientationchange", this.onOrientationChangeCallback_), window.removeEventListener("message", this.onMessageCallback_);
        };
        var O = 60, W = new wt(1, 0, 0), J = new wt(0, 0, 1), ge = new _t();
        ge.setFromAxisAngle(W, -Math.PI / 2), ge.multiply(new _t().setFromAxisAngle(J, Math.PI / 2));
        var Me = function() {
          function A(T) {
            E(this, A), this.config = T, this.sensor = null, this.fusionSensor = null, this._out = new Float32Array(4), this.api = null, this.errors = [], this._sensorQ = new _t(), this._outQ = new _t(), this._onSensorRead = this._onSensorRead.bind(this), this._onSensorError = this._onSensorError.bind(this), this.init();
          }
          return M(A, [{
            key: "init",
            value: function() {
              var D = null;
              try {
                D = new RelativeOrientationSensor({
                  frequency: O,
                  referenceFrame: "screen"
                }), D.addEventListener("error", this._onSensorError);
              } catch (L) {
                this.errors.push(L), L.name === "SecurityError" ? (console.error("Cannot construct sensors due to the Feature Policy"), console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.'), this.useDeviceMotion()) : L.name === "ReferenceError" ? this.useDeviceMotion() : console.error(L);
              }
              D && (this.api = "sensor", this.sensor = D, this.sensor.addEventListener("reading", this._onSensorRead), this.sensor.start());
            }
          }, {
            key: "useDeviceMotion",
            value: function() {
              this.api = "devicemotion", this.fusionSensor = new Zt(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG), this.sensor && (this.sensor.removeEventListener("reading", this._onSensorRead), this.sensor.removeEventListener("error", this._onSensorError), this.sensor = null);
            }
          }, {
            key: "getOrientation",
            value: function() {
              if (this.fusionSensor)
                return this.fusionSensor.getOrientation();
              if (!this.sensor || !this.sensor.quaternion)
                return this._out[0] = this._out[1] = this._out[2] = 0, this._out[3] = 1, this._out;
              var D = this.sensor.quaternion;
              this._sensorQ.set(D[0], D[1], D[2], D[3]);
              var L = this._outQ;
              return L.copy(ge), L.multiply(this._sensorQ), this.config.YAW_ONLY && (L.x = L.z = 0, L.normalize()), this._out[0] = L.x, this._out[1] = L.y, this._out[2] = L.z, this._out[3] = L.w, this._out;
            }
          }, {
            key: "_onSensorError",
            value: function(D) {
              this.errors.push(D.error), D.error.name === "NotAllowedError" ? console.error("Permission to access sensor was denied") : D.error.name === "NotReadableError" ? console.error("Sensor could not be read") : console.error(D.error), this.useDeviceMotion();
            }
          }, {
            key: "_onSensorRead",
            value: function() {
            }
          }]), A;
        }(), We = "<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>";
        function Ke() {
          this.loadIcon_();
          var A = document.createElement("div"), ie = A.style;
          ie.position = "fixed", ie.top = 0, ie.right = 0, ie.bottom = 0, ie.left = 0, ie.backgroundColor = "gray", ie.fontFamily = "sans-serif", ie.zIndex = 1e6;
          var T = document.createElement("img");
          T.src = this.icon;
          var ie = T.style;
          ie.marginLeft = "25%", ie.marginTop = "25%", ie.width = "50%", A.appendChild(T);
          var D = document.createElement("div"), ie = D.style;
          ie.textAlign = "center", ie.fontSize = "16px", ie.lineHeight = "24px", ie.margin = "24px 25%", ie.width = "50%", D.innerHTML = "Place your phone into your Cardboard viewer.", A.appendChild(D);
          var L = document.createElement("div"), ie = L.style;
          ie.backgroundColor = "#CFD8DC", ie.position = "fixed", ie.bottom = 0, ie.width = "100%", ie.height = "48px", ie.padding = "14px 24px", ie.boxSizing = "border-box", ie.color = "#656A6B", A.appendChild(L);
          var U = document.createElement("div");
          U.style.float = "left", U.innerHTML = "No Cardboard viewer?";
          var Z = document.createElement("a");
          Z.href = "https://www.google.com/get/cardboard/get-cardboard/", Z.innerHTML = "get one", Z.target = "_blank";
          var ie = Z.style;
          ie.float = "right", ie.fontWeight = 600, ie.textTransform = "uppercase", ie.borderLeft = "1px solid gray", ie.paddingLeft = "24px", ie.textDecoration = "none", ie.color = "#656A6B", L.appendChild(U), L.appendChild(Z), this.overlay = A, this.text = D, this.hide();
        }
        Ke.prototype.show = function(A) {
          !A && !this.overlay.parentElement ? document.body.appendChild(this.overlay) : A && (this.overlay.parentElement && this.overlay.parentElement != A && this.overlay.parentElement.removeChild(this.overlay), A.appendChild(this.overlay)), this.overlay.style.display = "block";
          var T = this.overlay.querySelector("img"), D = T.style;
          V() ? (D.width = "20%", D.marginLeft = "40%", D.marginTop = "3%") : (D.width = "50%", D.marginLeft = "25%", D.marginTop = "25%");
        }, Ke.prototype.hide = function() {
          this.overlay.style.display = "none";
        }, Ke.prototype.showTemporarily = function(A, T) {
          this.show(T), this.timer = setTimeout(this.hide.bind(this), A);
        }, Ke.prototype.disableShowTemporarily = function() {
          clearTimeout(this.timer);
        }, Ke.prototype.update = function() {
          this.disableShowTemporarily(), !V() && Le() ? this.show() : this.hide();
        }, Ke.prototype.loadIcon_ = function() {
          this.icon = k("image/svg+xml", We);
        };
        var we = "CardboardV1", et = "WEBVR_CARDBOARD_VIEWER", nt = "webvr-polyfill-viewer-selector";
        function rt(A) {
          try {
            this.selectedKey = localStorage.getItem(et);
          } catch (T) {
            console.error("Failed to load viewer profile: %s", T);
          }
          this.selectedKey || (this.selectedKey = A || we), this.dialog = this.createDialog_(Xt.Viewers), this.root = null, this.onChangeCallbacks_ = [];
        }
        rt.prototype.show = function(A) {
          this.root = A, A.appendChild(this.dialog);
          var T = this.dialog.querySelector("#" + this.selectedKey);
          T.checked = !0, this.dialog.style.display = "block";
        }, rt.prototype.hide = function() {
          this.root && this.root.contains(this.dialog) && this.root.removeChild(this.dialog), this.dialog.style.display = "none";
        }, rt.prototype.getCurrentViewer = function() {
          return Xt.Viewers[this.selectedKey];
        }, rt.prototype.getSelectedKey_ = function() {
          var A = this.dialog.querySelector("input[name=field]:checked");
          return A ? A.id : null;
        }, rt.prototype.onChange = function(A) {
          this.onChangeCallbacks_.push(A);
        }, rt.prototype.fireOnChange_ = function(A) {
          for (var T = 0; T < this.onChangeCallbacks_.length; T++)
            this.onChangeCallbacks_[T](A);
        }, rt.prototype.onSave_ = function() {
          if (this.selectedKey = this.getSelectedKey_(), !this.selectedKey || !Xt.Viewers[this.selectedKey]) {
            console.error("ViewerSelector.onSave_: this should never happen!");
            return;
          }
          this.fireOnChange_(Xt.Viewers[this.selectedKey]);
          try {
            localStorage.setItem(et, this.selectedKey);
          } catch (A) {
            console.error("Failed to save viewer profile: %s", A);
          }
          this.hide();
        }, rt.prototype.createDialog_ = function(A) {
          var T = document.createElement("div");
          T.classList.add(nt), T.style.display = "none";
          var D = document.createElement("div"), Z = D.style;
          Z.position = "fixed", Z.left = 0, Z.top = 0, Z.width = "100%", Z.height = "100%", Z.background = "rgba(0, 0, 0, 0.3)", D.addEventListener("click", this.hide.bind(this));
          var L = 280, U = document.createElement("div"), Z = U.style;
          Z.boxSizing = "border-box", Z.position = "fixed", Z.top = "24px", Z.left = "50%", Z.marginLeft = -L / 2 + "px", Z.width = L + "px", Z.padding = "24px", Z.overflow = "hidden", Z.background = "#fafafa", Z.fontFamily = "'Roboto', sans-serif", Z.boxShadow = "0px 5px 20px #666", U.appendChild(this.createH1_("Select your viewer"));
          for (var ie in A)
            U.appendChild(this.createChoice_(ie, A[ie].label));
          return U.appendChild(this.createButton_("Save", this.onSave_.bind(this))), T.appendChild(D), T.appendChild(U), T;
        }, rt.prototype.createH1_ = function(A) {
          var T = document.createElement("h1"), D = T.style;
          return D.color = "black", D.fontSize = "20px", D.fontWeight = "bold", D.marginTop = 0, D.marginBottom = "24px", T.innerHTML = A, T;
        }, rt.prototype.createChoice_ = function(A, T) {
          var D = document.createElement("div");
          D.style.marginTop = "8px", D.style.color = "black";
          var L = document.createElement("input");
          L.style.fontSize = "30px", L.setAttribute("id", A), L.setAttribute("type", "radio"), L.setAttribute("value", A), L.setAttribute("name", "field");
          var U = document.createElement("label");
          return U.style.marginLeft = "4px", U.setAttribute("for", A), U.innerHTML = T, D.appendChild(L), D.appendChild(U), D;
        }, rt.prototype.createButton_ = function(A, T) {
          var D = document.createElement("button");
          D.innerHTML = A;
          var L = D.style;
          return L.float = "right", L.textTransform = "uppercase", L.color = "#1094f7", L.fontSize = "14px", L.letterSpacing = 0, L.border = 0, L.background = "none", L.marginTop = "16px", D.addEventListener("click", T), D;
        };
        var Tt = typeof window < "u" ? window : typeof r < "u" ? r : typeof self < "u" ? self : {};
        function Qe(A) {
          return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
        }
        function Dt(A, T) {
          return T = { exports: {} }, A(T, T.exports), T.exports;
        }
        var bt = Dt(function(A, T) {
          (function(L, U) {
            A.exports = U();
          })(Tt, function() {
            return function(D) {
              var L = {};
              function U(Z) {
                if (L[Z])
                  return L[Z].exports;
                var ie = L[Z] = {
                  i: Z,
                  l: !1,
                  exports: {}
                };
                return D[Z].call(ie.exports, ie, ie.exports, U), ie.l = !0, ie.exports;
              }
              return U.m = D, U.c = L, U.d = function(Z, ie, ve) {
                U.o(Z, ie) || Object.defineProperty(Z, ie, {
                  configurable: !1,
                  enumerable: !0,
                  get: ve
                });
              }, U.n = function(Z) {
                var ie = Z && Z.__esModule ? function() {
                  return Z.default;
                } : function() {
                  return Z;
                };
                return U.d(ie, "a", ie), ie;
              }, U.o = function(Z, ie) {
                return Object.prototype.hasOwnProperty.call(Z, ie);
              }, U.p = "", U(U.s = 0);
            }([
              function(D, L, U) {
                var Z = /* @__PURE__ */ function() {
                  function le(be, Ve) {
                    for (var qe = 0; qe < Ve.length; qe++) {
                      var it = Ve[qe];
                      it.enumerable = it.enumerable || !1, it.configurable = !0, "value" in it && (it.writable = !0), Object.defineProperty(be, it.key, it);
                    }
                  }
                  return function(be, Ve, qe) {
                    return Ve && le(be.prototype, Ve), qe && le(be, qe), be;
                  };
                }();
                function ie(le, be) {
                  if (!(le instanceof be))
                    throw new TypeError("Cannot call a class as a function");
                }
                var ve = U(1), me = typeof navigator < "u" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream, ne = function() {
                  function le() {
                    ie(this, le), me ? this.noSleepTimer = null : (this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("playsinline", ""), this.noSleepVideo.setAttribute("src", ve), this.noSleepVideo.addEventListener("timeupdate", (function(be) {
                      this.noSleepVideo.currentTime > 0.5 && (this.noSleepVideo.currentTime = Math.random());
                    }).bind(this)));
                  }
                  return Z(le, [{
                    key: "enable",
                    value: function() {
                      me ? (this.disable(), this.noSleepTimer = window.setInterval(function() {
                        window.location.href = "/", window.setTimeout(window.stop, 0);
                      }, 15e3)) : this.noSleepVideo.play();
                    }
                  }, {
                    key: "disable",
                    value: function() {
                      me ? this.noSleepTimer && (window.clearInterval(this.noSleepTimer), this.noSleepTimer = null) : this.noSleepVideo.pause();
                    }
                  }]), le;
                }();
                D.exports = ne;
              },
              function(D, L, U) {
                D.exports = "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA=";
              }
            ]);
          });
        }), Jt = Qe(bt), hr = 1e3, Nr = [0, 0, 0.5, 1], Cr = [0.5, 0, 0.5, 1], sn = window.requestAnimationFrame, na = window.cancelAnimationFrame;
        function aa() {
          this.leftProjectionMatrix = new Float32Array(16), this.leftViewMatrix = new Float32Array(16), this.rightProjectionMatrix = new Float32Array(16), this.rightViewMatrix = new Float32Array(16), this.pose = null;
        }
        function sa(A) {
          Object.defineProperties(this, {
            hasPosition: {
              writable: !1,
              enumerable: !0,
              value: A.hasPosition
            },
            hasExternalDisplay: {
              writable: !1,
              enumerable: !0,
              value: A.hasExternalDisplay
            },
            canPresent: {
              writable: !1,
              enumerable: !0,
              value: A.canPresent
            },
            maxLayers: {
              writable: !1,
              enumerable: !0,
              value: A.maxLayers
            },
            hasOrientation: {
              enumerable: !0,
              get: function() {
                return yt("VRDisplayCapabilities.prototype.hasOrientation", "VRDisplay.prototype.getFrameData"), A.hasOrientation;
              }
            }
          });
        }
        function It(A) {
          A = A || {};
          var T = "wakelock" in A ? A.wakelock : !0;
          this.isPolyfilled = !0, this.displayId = hr++, this.displayName = "", this.depthNear = 0.01, this.depthFar = 1e4, this.isPresenting = !1, Object.defineProperty(this, "isConnected", {
            get: function() {
              return yt("VRDisplay.prototype.isConnected", "VRDisplayCapabilities.prototype.hasExternalDisplay"), !1;
            }
          }), this.capabilities = new sa({
            hasPosition: !1,
            hasOrientation: !1,
            hasExternalDisplay: !1,
            canPresent: !1,
            maxLayers: 1
          }), this.stageParameters = null, this.waitingForPresent_ = !1, this.layer_ = null, this.originalParent_ = null, this.fullscreenElement_ = null, this.fullscreenWrapper_ = null, this.fullscreenElementCachedStyle_ = null, this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null, T && Le() && (this.wakelock_ = new Jt());
        }
        It.prototype.getFrameData = function(A) {
          return Ee(A, this._getPose(), this);
        }, It.prototype.getPose = function() {
          return yt("VRDisplay.prototype.getPose", "VRDisplay.prototype.getFrameData"), this._getPose();
        }, It.prototype.resetPose = function() {
          return yt("VRDisplay.prototype.resetPose"), this._resetPose();
        }, It.prototype.getImmediatePose = function() {
          return yt("VRDisplay.prototype.getImmediatePose", "VRDisplay.prototype.getFrameData"), this._getPose();
        }, It.prototype.requestAnimationFrame = function(A) {
          return sn(A);
        }, It.prototype.cancelAnimationFrame = function(A) {
          return na(A);
        }, It.prototype.wrapForFullscreen = function(A) {
          if (I())
            return A;
          if (!this.fullscreenWrapper_) {
            this.fullscreenWrapper_ = document.createElement("div");
            var T = ["height: " + Math.min(screen.height, screen.width) + "px !important", "top: 0 !important", "left: 0 !important", "right: 0 !important", "border: 0", "margin: 0", "padding: 0", "z-index: 999999 !important", "position: fixed"];
            this.fullscreenWrapper_.setAttribute("style", T.join("; ") + ";"), this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper");
          }
          if (this.fullscreenElement_ == A)
            return this.fullscreenWrapper_;
          if (this.fullscreenElement_ && (this.originalParent_ ? this.originalParent_.appendChild(this.fullscreenElement_) : this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_)), this.fullscreenElement_ = A, this.originalParent_ = A.parentElement, this.originalParent_ || document.body.appendChild(A), !this.fullscreenWrapper_.parentElement) {
            var D = this.fullscreenElement_.parentElement;
            D.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_), D.removeChild(this.fullscreenElement_);
          }
          this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild), this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
          var L = this;
          function U() {
            if (L.fullscreenElement_) {
              var Z = ["position: absolute", "top: 0", "left: 0", "width: " + Math.max(screen.width, screen.height) + "px", "height: " + Math.min(screen.height, screen.width) + "px", "border: 0", "margin: 0", "padding: 0"];
              L.fullscreenElement_.setAttribute("style", Z.join("; ") + ";");
            }
          }
          return U(), this.fullscreenWrapper_;
        }, It.prototype.removeFullscreenWrapper = function() {
          if (this.fullscreenElement_) {
            var A = this.fullscreenElement_;
            this.fullscreenElementCachedStyle_ ? A.setAttribute("style", this.fullscreenElementCachedStyle_) : A.removeAttribute("style"), this.fullscreenElement_ = null, this.fullscreenElementCachedStyle_ = null;
            var T = this.fullscreenWrapper_.parentElement;
            return this.fullscreenWrapper_.removeChild(A), this.originalParent_ === T ? T.insertBefore(A, this.fullscreenWrapper_) : this.originalParent_ && this.originalParent_.appendChild(A), T.removeChild(this.fullscreenWrapper_), A;
          }
        }, It.prototype.requestPresent = function(A) {
          var T = this.isPresenting, D = this;
          return A instanceof Array || (yt("VRDisplay.prototype.requestPresent with non-array argument", "an array of VRLayers as the first argument"), A = [A]), new Promise(function(L, U) {
            if (!D.capabilities.canPresent) {
              U(new Error("VRDisplay is not capable of presenting."));
              return;
            }
            if (A.length == 0 || A.length > D.capabilities.maxLayers) {
              U(new Error("Invalid number of layers."));
              return;
            }
            var Z = A[0];
            if (!Z.source) {
              L();
              return;
            }
            var ie = Z.leftBounds || Nr, ve = Z.rightBounds || Cr;
            if (T) {
              var me = D.layer_;
              me.source !== Z.source && (me.source = Z.source);
              for (var ne = 0; ne < 4; ne++)
                me.leftBounds[ne] = ie[ne], me.rightBounds[ne] = ve[ne];
              D.wrapForFullscreen(D.layer_.source), D.updatePresent_(), L();
              return;
            }
            if (D.layer_ = {
              predistorted: Z.predistorted,
              source: Z.source,
              leftBounds: ie.slice(0),
              rightBounds: ve.slice(0)
            }, D.waitingForPresent_ = !1, D.layer_ && D.layer_.source) {
              var le = D.wrapForFullscreen(D.layer_.source), be = function() {
                var it = xe();
                D.isPresenting = le === it, D.isPresenting ? (screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape-primary").catch(function(At) {
                  console.error("screen.orientation.lock() failed due to", At.message);
                }), D.waitingForPresent_ = !1, D.beginPresent_(), L()) : (screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), D.removeFullscreenWrapper(), D.disableWakeLock(), D.endPresent_(), D.removeFullscreenListeners_()), D.fireVRDisplayPresentChange_();
              }, Ve = function() {
                D.waitingForPresent_ && (D.removeFullscreenWrapper(), D.removeFullscreenListeners_(), D.disableWakeLock(), D.waitingForPresent_ = !1, D.isPresenting = !1, U(new Error("Unable to present.")));
              };
              D.addFullscreenListeners_(le, be, Ve), Ce(le) ? (D.enableWakeLock(), D.waitingForPresent_ = !0) : (I() || H()) && (D.enableWakeLock(), D.isPresenting = !0, D.beginPresent_(), D.fireVRDisplayPresentChange_(), L());
            }
            !D.waitingForPresent_ && !I() && (K(), U(new Error("Unable to present.")));
          });
        }, It.prototype.exitPresent = function() {
          var A = this.isPresenting, T = this;
          return this.isPresenting = !1, this.layer_ = null, this.disableWakeLock(), new Promise(function(D, L) {
            A ? (!K() && I() && (T.endPresent_(), T.fireVRDisplayPresentChange_()), H() && (T.removeFullscreenWrapper(), T.removeFullscreenListeners_(), T.endPresent_(), T.fireVRDisplayPresentChange_()), D()) : L(new Error("Was not presenting to VRDisplay."));
          });
        }, It.prototype.getLayers = function() {
          return this.layer_ ? [this.layer_] : [];
        }, It.prototype.fireVRDisplayPresentChange_ = function() {
          var A = new CustomEvent("vrdisplaypresentchange", { detail: { display: this } });
          window.dispatchEvent(A);
        }, It.prototype.fireVRDisplayConnect_ = function() {
          var A = new CustomEvent("vrdisplayconnect", { detail: { display: this } });
          window.dispatchEvent(A);
        }, It.prototype.addFullscreenListeners_ = function(A, T, D) {
          this.removeFullscreenListeners_(), this.fullscreenEventTarget_ = A, this.fullscreenChangeHandler_ = T, this.fullscreenErrorHandler_ = D, T && (document.fullscreenEnabled ? A.addEventListener("fullscreenchange", T, !1) : document.webkitFullscreenEnabled ? A.addEventListener("webkitfullscreenchange", T, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenchange", T, !1) : document.msFullscreenEnabled && A.addEventListener("msfullscreenchange", T, !1)), D && (document.fullscreenEnabled ? A.addEventListener("fullscreenerror", D, !1) : document.webkitFullscreenEnabled ? A.addEventListener("webkitfullscreenerror", D, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenerror", D, !1) : document.msFullscreenEnabled && A.addEventListener("msfullscreenerror", D, !1));
        }, It.prototype.removeFullscreenListeners_ = function() {
          if (this.fullscreenEventTarget_) {
            var A = this.fullscreenEventTarget_;
            if (this.fullscreenChangeHandler_) {
              var T = this.fullscreenChangeHandler_;
              A.removeEventListener("fullscreenchange", T, !1), A.removeEventListener("webkitfullscreenchange", T, !1), document.removeEventListener("mozfullscreenchange", T, !1), A.removeEventListener("msfullscreenchange", T, !1);
            }
            if (this.fullscreenErrorHandler_) {
              var D = this.fullscreenErrorHandler_;
              A.removeEventListener("fullscreenerror", D, !1), A.removeEventListener("webkitfullscreenerror", D, !1), document.removeEventListener("mozfullscreenerror", D, !1), A.removeEventListener("msfullscreenerror", D, !1);
            }
            this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null;
          }
        }, It.prototype.enableWakeLock = function() {
          this.wakelock_ && this.wakelock_.enable();
        }, It.prototype.disableWakeLock = function() {
          this.wakelock_ && this.wakelock_.disable();
        }, It.prototype.beginPresent_ = function() {
        }, It.prototype.endPresent_ = function() {
        }, It.prototype.submitFrame = function(A) {
        }, It.prototype.getEyeParameters = function(A) {
          return null;
        };
        var bs = {
          ADDITIONAL_VIEWERS: [],
          DEFAULT_VIEWER: "",
          MOBILE_WAKE_LOCK: !0,
          DEBUG: !1,
          DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
          K_FILTER: 0.98,
          PREDICTION_TIME_S: 0.04,
          CARDBOARD_UI_DISABLED: !1,
          ROTATE_INSTRUCTIONS_DISABLED: !1,
          YAW_ONLY: !1,
          BUFFER_SCALE: 0.5,
          DIRTY_SUBMIT_FRAME_BINDINGS: !1
        }, on = {
          LEFT: "left",
          RIGHT: "right"
        };
        function er(A) {
          var T = He({}, bs);
          A = He(T, A || {}), It.call(this, {
            wakelock: A.MOBILE_WAKE_LOCK
          }), this.config = A, this.displayName = "Cardboard VRDisplay", this.capabilities = new sa({
            hasPosition: !1,
            hasOrientation: !0,
            hasExternalDisplay: !1,
            canPresent: !0,
            maxLayers: 1
          }), this.stageParameters = null, this.bufferScale_ = this.config.BUFFER_SCALE, this.poseSensor_ = new Me(this.config), this.distorter_ = null, this.cardboardUI_ = null, this.dpdb_ = new _i(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this)), this.deviceInfo_ = new Xt(this.dpdb_.getDeviceParams(), A.ADDITIONAL_VIEWERS), this.viewerSelector_ = new rt(A.DEFAULT_VIEWER), this.viewerSelector_.onChange(this.onViewerChanged_.bind(this)), this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer()), this.config.ROTATE_INSTRUCTIONS_DISABLED || (this.rotateInstructions_ = new Ke()), I() && window.addEventListener("resize", this.onResize_.bind(this));
        }
        return er.prototype = Object.create(It.prototype), er.prototype._getPose = function() {
          return {
            position: null,
            orientation: this.poseSensor_.getOrientation(),
            linearVelocity: null,
            linearAcceleration: null,
            angularVelocity: null,
            angularAcceleration: null
          };
        }, er.prototype._resetPose = function() {
          this.poseSensor_.resetPose && this.poseSensor_.resetPose();
        }, er.prototype._getFieldOfView = function(A) {
          var T;
          if (A == on.LEFT)
            T = this.deviceInfo_.getFieldOfViewLeftEye();
          else if (A == on.RIGHT)
            T = this.deviceInfo_.getFieldOfViewRightEye();
          else
            return console.error("Invalid eye provided: %s", A), null;
          return T;
        }, er.prototype._getEyeOffset = function(A) {
          var T;
          if (A == on.LEFT)
            T = [-this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
          else if (A == on.RIGHT)
            T = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
          else
            return console.error("Invalid eye provided: %s", A), null;
          return T;
        }, er.prototype.getEyeParameters = function(A) {
          var T = this._getEyeOffset(A), D = this._getFieldOfView(A), L = {
            offset: T,
            renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
            renderHeight: this.deviceInfo_.device.height * this.bufferScale_
          };
          return Object.defineProperty(L, "fieldOfView", {
            enumerable: !0,
            get: function() {
              return yt("VRFieldOfView", "VRFrameData's projection matrices"), D;
            }
          }), L;
        }, er.prototype.onDeviceParamsUpdated_ = function(A) {
          this.config.DEBUG && console.log("DPDB reported that device params were updated."), this.deviceInfo_.updateDeviceParams(A), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_);
        }, er.prototype.updateBounds_ = function() {
          this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds) && this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
        }, er.prototype.beginPresent_ = function() {
          var A = this.layer_.source.getContext("webgl");
          A || (A = this.layer_.source.getContext("experimental-webgl")), A || (A = this.layer_.source.getContext("webgl2")), A && (this.layer_.predistorted ? this.config.CARDBOARD_UI_DISABLED || (A.canvas.width = se() * this.bufferScale_, A.canvas.height = re() * this.bufferScale_, this.cardboardUI_ = new Rt(A)) : (this.config.CARDBOARD_UI_DISABLED || (this.cardboardUI_ = new Rt(A)), this.distorter_ = new cr(A, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS), this.distorter_.updateDeviceInfo(this.deviceInfo_)), this.cardboardUI_ && this.cardboardUI_.listen((function(T) {
            this.viewerSelector_.show(this.layer_.source.parentElement), T.stopPropagation(), T.preventDefault();
          }).bind(this), (function(T) {
            this.exitPresent(), T.stopPropagation(), T.preventDefault();
          }).bind(this)), this.rotateInstructions_ && (V() && Le() ? this.rotateInstructions_.showTemporarily(3e3, this.layer_.source.parentElement) : this.rotateInstructions_.update()), this.orientationHandler = this.onOrientationChange_.bind(this), window.addEventListener("orientationchange", this.orientationHandler), this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this), window.addEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler), this.fireVRDisplayDeviceParamsChange_());
        }, er.prototype.endPresent_ = function() {
          this.distorter_ && (this.distorter_.destroy(), this.distorter_ = null), this.cardboardUI_ && (this.cardboardUI_.destroy(), this.cardboardUI_ = null), this.rotateInstructions_ && this.rotateInstructions_.hide(), this.viewerSelector_.hide(), window.removeEventListener("orientationchange", this.orientationHandler), window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
        }, er.prototype.updatePresent_ = function() {
          this.endPresent_(), this.beginPresent_();
        }, er.prototype.submitFrame = function(A) {
          if (this.distorter_)
            this.updateBounds_(), this.distorter_.submitFrame();
          else if (this.cardboardUI_ && this.layer_) {
            var T = this.layer_.source.getContext("webgl");
            T || (T = this.layer_.source.getContext("experimental-webgl")), T || (T = this.layer_.source.getContext("webgl2"));
            var D = T.canvas;
            (D.width != this.lastWidth || D.height != this.lastHeight) && this.cardboardUI_.onResize(), this.lastWidth = D.width, this.lastHeight = D.height, this.cardboardUI_.render();
          }
        }, er.prototype.onOrientationChange_ = function(A) {
          this.viewerSelector_.hide(), this.rotateInstructions_ && this.rotateInstructions_.update(), this.onResize_();
        }, er.prototype.onResize_ = function(A) {
          if (this.layer_) {
            var T = this.layer_.source.getContext("webgl");
            T || (T = this.layer_.source.getContext("experimental-webgl")), T || (T = this.layer_.source.getContext("webgl2"));
            var D = [
              "position: absolute",
              "top: 0",
              "left: 0",
              "width: 100vw",
              "height: 100vh",
              "border: 0",
              "margin: 0",
              "padding: 0px",
              "box-sizing: content-box"
            ];
            T.canvas.setAttribute("style", D.join("; ") + ";"), dt(T.canvas);
          }
        }, er.prototype.onViewerChanged_ = function(A) {
          this.deviceInfo_.setViewer(A), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_), this.fireVRDisplayDeviceParamsChange_();
        }, er.prototype.fireVRDisplayDeviceParamsChange_ = function() {
          var A = new CustomEvent("vrdisplaydeviceparamschange", {
            detail: {
              vrdisplay: this,
              deviceInfo: this.deviceInfo_
            }
          });
          window.dispatchEvent(A);
        }, er.VRFrameData = aa, er.VRDisplay = It, er;
      });
    }), l = n(u), c = "0.10.12", h = {
      ADDITIONAL_VIEWERS: [],
      DEFAULT_VIEWER: "",
      PROVIDE_MOBILE_VRDISPLAY: !0,
      MOBILE_WAKE_LOCK: !0,
      DEBUG: !1,
      DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
      K_FILTER: 0.98,
      PREDICTION_TIME_S: 0.04,
      CARDBOARD_UI_DISABLED: !1,
      ROTATE_INSTRUCTIONS_DISABLED: !1,
      YAW_ONLY: !1,
      BUFFER_SCALE: 0.5,
      DIRTY_SUBMIT_FRAME_BINDINGS: !1
    };
    function f(v) {
      this.config = o(o({}, h), v), this.polyfillDisplays = [], this.enabled = !1, this.hasNative = "getVRDisplays" in navigator, this.native = {}, this.native.getVRDisplays = navigator.getVRDisplays, this.native.VRFrameData = window.VRFrameData, this.native.VRDisplay = window.VRDisplay, (!this.hasNative || this.config.PROVIDE_MOBILE_VRDISPLAY && a()) && (this.enable(), this.getVRDisplays().then(function(x) {
        x && x[0] && x[0].fireVRDisplayConnect_ && x[0].fireVRDisplayConnect_();
      }));
    }
    f.prototype.getPolyfillDisplays = function() {
      if (this._polyfillDisplaysPopulated)
        return this.polyfillDisplays;
      if (a()) {
        var v = new l({
          ADDITIONAL_VIEWERS: this.config.ADDITIONAL_VIEWERS,
          DEFAULT_VIEWER: this.config.DEFAULT_VIEWER,
          MOBILE_WAKE_LOCK: this.config.MOBILE_WAKE_LOCK,
          DEBUG: this.config.DEBUG,
          DPDB_URL: this.config.DPDB_URL,
          CARDBOARD_UI_DISABLED: this.config.CARDBOARD_UI_DISABLED,
          K_FILTER: this.config.K_FILTER,
          PREDICTION_TIME_S: this.config.PREDICTION_TIME_S,
          ROTATE_INSTRUCTIONS_DISABLED: this.config.ROTATE_INSTRUCTIONS_DISABLED,
          YAW_ONLY: this.config.YAW_ONLY,
          BUFFER_SCALE: this.config.BUFFER_SCALE,
          DIRTY_SUBMIT_FRAME_BINDINGS: this.config.DIRTY_SUBMIT_FRAME_BINDINGS
        });
        this.polyfillDisplays.push(v);
      }
      return this._polyfillDisplaysPopulated = !0, this.polyfillDisplays;
    }, f.prototype.enable = function() {
      if (this.enabled = !0, this.hasNative && this.native.VRFrameData) {
        var v = this.native.VRFrameData, x = new this.native.VRFrameData(), E = this.native.VRDisplay.prototype.getFrameData;
        window.VRDisplay.prototype.getFrameData = function(M) {
          if (M instanceof v) {
            E.call(this, M);
            return;
          }
          E.call(this, x), M.pose = x.pose, s(x.leftProjectionMatrix, M.leftProjectionMatrix), s(x.rightProjectionMatrix, M.rightProjectionMatrix), s(x.leftViewMatrix, M.leftViewMatrix), s(x.rightViewMatrix, M.rightViewMatrix);
        };
      }
      navigator.getVRDisplays = this.getVRDisplays.bind(this), window.VRDisplay = l.VRDisplay, window.VRFrameData = l.VRFrameData;
    }, f.prototype.getVRDisplays = function() {
      var v = this;
      return this.config, this.hasNative ? this.native.getVRDisplays.call(navigator).then(function(x) {
        return x.length > 0 ? x : v.getPolyfillDisplays();
      }) : Promise.resolve(this.getPolyfillDisplays());
    }, f.version = c, f.VRFrameData = l.VRFrameData, f.VRDisplay = l.VRDisplay;
    var d = Object.freeze({
      default: f
    }), p = d && f || d;
    typeof r < "u" && r.window && (r.document || (r.document = r.window.document), r.navigator || (r.navigator = r.window.navigator));
    var _ = p;
    return _;
  });
})(_y);
var tw = _y.exports;
const Zh = /* @__PURE__ */ Qn(tw);
function by() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (by = function() {
    return !!e;
  })();
}
function xy(e, t, r) {
  if (by()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, t);
  var i = new (e.bind.apply(e, n))();
  return r && Ns(i, r.prototype), i;
}
function Bi() {
  return Bi = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Bi.apply(null, arguments);
}
const rw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get default() {
    return Bi;
  }
}, Symbol.toStringTag, { value: "Module" }));
function iw(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Ns(e, t);
}
function qf(e) {
  return qf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, qf(e);
}
function nw(e) {
  try {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  } catch {
    return typeof e == "function";
  }
}
function Xf(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Xf = function(n) {
    if (n === null || !nw(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (t !== void 0) {
      if (t.has(n)) return t.get(n);
      t.set(n, i);
    }
    function i() {
      return xy(n, arguments, qf(this).constructor);
    }
    return i.prototype = Object.create(n.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Ns(i, n);
  }, Xf(e);
}
var aw = function(t) {
  return t.toString(2).length;
}, sw = function(t) {
  return Math.ceil(aw(t) / 8);
}, Ay = function(t) {
  return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer;
}, ow = function(t) {
  return Ay(t);
}, $e = function(t) {
  return t instanceof Uint8Array ? t : (!Array.isArray(t) && !ow(t) && !(t instanceof ArrayBuffer) && (typeof t != "number" || typeof t == "number" && t !== t ? t = 0 : t = [t]), new Uint8Array(t && t.buffer || t, t && t.byteOffset || 0, t && t.byteLength || 0));
}, Br = j.BigInt || Number, Yf = [Br("0x1"), Br("0x100"), Br("0x10000"), Br("0x1000000"), Br("0x100000000"), Br("0x10000000000"), Br("0x1000000000000"), Br("0x100000000000000"), Br("0x10000000000000000")];
(function() {
  var e = new Uint16Array([65484]), t = new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
  return t[0] === 255 ? "big" : t[0] === 204 ? "little" : "unknown";
})();
var uw = function(t, r) {
  var n = r === void 0 ? {} : r, i = n.signed, a = i === void 0 ? !1 : i, s = n.le, o = s === void 0 ? !1 : s;
  t = $e(t);
  var u = o ? "reduce" : "reduceRight", l = t[u] ? t[u] : Array.prototype[u], c = l.call(t, function(f, d, p) {
    var _ = o ? p : Math.abs(p + 1 - t.length);
    return f + Br(d) * Yf[_];
  }, Br(0));
  if (a) {
    var h = Yf[t.length] / Br(2) - Br(1);
    c = Br(c), c > h && (c -= h, c -= h, c -= Br(2));
  }
  return Number(c);
}, lw = function(t, r) {
  var n = {}, i = n.le, a = i === void 0 ? !1 : i;
  (typeof t != "bigint" && typeof t != "number" || typeof t == "number" && t !== t) && (t = 0), t = Br(t);
  for (var s = sw(t), o = new Uint8Array(new ArrayBuffer(s)), u = 0; u < s; u++) {
    var l = a ? u : Math.abs(u + 1 - o.length);
    o[l] = Number(t / Yf[u] & Br(255)), t < 0 && (o[l] = Math.abs(~o[l]), o[l] -= u === 0 ? 1 : 2);
  }
  return o;
}, Ty = function(t, r) {
  if (typeof t != "string" && t && typeof t.toString == "function" && (t = t.toString()), typeof t != "string")
    return new Uint8Array();
  r || (t = unescape(encodeURIComponent(t)));
  for (var n = new Uint8Array(t.length), i = 0; i < t.length; i++)
    n[i] = t.charCodeAt(i);
  return n;
}, cw = function() {
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  if (r = r.filter(function(o) {
    return o && (o.byteLength || o.length) && typeof o != "string";
  }), r.length <= 1)
    return $e(r[0]);
  var i = r.reduce(function(o, u, l) {
    return o + (u.byteLength || u.length);
  }, 0), a = new Uint8Array(i), s = 0;
  return r.forEach(function(o) {
    o = $e(o), a.set(o, s), s += o.byteLength;
  }), a;
}, rr = function(t, r, n) {
  var i = n === void 0 ? {} : n, a = i.offset, s = a === void 0 ? 0 : a, o = i.mask, u = o === void 0 ? [] : o;
  t = $e(t), r = $e(r);
  var l = r.every ? r.every : Array.prototype.every;
  return r.length && t.length - s >= r.length && // ie 11 doesn't support every on uin8
  l.call(r, function(c, h) {
    var f = u[h] ? u[h] & t[s + h] : t[s + h];
    return c === f;
  });
}, Ua = {
  // to determine mime types
  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
  // to determine if a codec is audio or video
  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
  text: /^(stpp.ttml.im1t)/,
  // mux.js support regex
  muxerVideo: /^(avc0?1)/,
  muxerAudio: /^(mp4a)/,
  // match nothing as muxer does not support text right now.
  // there cannot never be a character before the start of a string
  // so this matches nothing.
  muxerText: /a^/
}, hw = ["video", "audio", "text"], Jm = ["Video", "Audio", "Text"], Ey = function(t) {
  return t && t.replace(/avc1\.(\d+)\.(\d+)/i, function(r, n, i) {
    var a = ("00" + Number(n).toString(16)).slice(-2), s = ("00" + Number(i).toString(16)).slice(-2);
    return "avc1." + a + "00" + s;
  });
}, cn = function(t) {
  t === void 0 && (t = "");
  var r = t.split(","), n = [];
  return r.forEach(function(i) {
    i = i.trim();
    var a;
    hw.forEach(function(s) {
      var o = Ua[s].exec(i.toLowerCase());
      if (!(!o || o.length <= 1)) {
        a = s;
        var u = i.substring(0, o[1].length), l = i.replace(u, "");
        n.push({
          type: u,
          details: l,
          mediaType: s
        });
      }
    }), a || n.push({
      type: i,
      details: "",
      mediaType: "unknown"
    });
  }), n;
}, fw = function(t, r) {
  if (!t.mediaGroups.AUDIO || !r)
    return null;
  var n = t.mediaGroups.AUDIO[r];
  if (!n)
    return null;
  for (var i in n) {
    var a = n[i];
    if (a.default && a.playlists)
      return cn(a.playlists[0].attributes.CODECS);
  }
  return null;
}, wy = function(t) {
  return t === void 0 && (t = ""), Ua.audio.test(t.trim().toLowerCase());
}, dw = function(t) {
  return t === void 0 && (t = ""), Ua.text.test(t.trim().toLowerCase());
}, ul = function(t) {
  if (!(!t || typeof t != "string")) {
    var r = t.toLowerCase().split(",").map(function(a) {
      return Ey(a.trim());
    }), n = "video";
    r.length === 1 && wy(r[0]) ? n = "audio" : r.length === 1 && dw(r[0]) && (n = "application");
    var i = "mp4";
    return r.every(function(a) {
      return Ua.mp4.test(a);
    }) ? i = "mp4" : r.every(function(a) {
      return Ua.webm.test(a);
    }) ? i = "webm" : r.every(function(a) {
      return Ua.ogg.test(a);
    }) && (i = "ogg"), n + "/" + i + ';codecs="' + t + '"';
  }
}, ec = function(t) {
  return t === void 0 && (t = ""), j.MediaSource && j.MediaSource.isTypeSupported && j.MediaSource.isTypeSupported(ul(t)) || !1;
}, Jh = function(t) {
  return t === void 0 && (t = ""), t.toLowerCase().split(",").every(function(r) {
    r = r.trim();
    for (var n = 0; n < Jm.length; n++) {
      var i = Jm[n];
      if (Ua["muxer" + i].test(r))
        return !0;
    }
    return !1;
  });
}, ev = "mp4a.40.2", pw = "avc1.4d400d", tv = function(t) {
  return typeof t == "string" ? Ty(t) : t;
}, mw = function(t) {
  return Array.isArray(t) ? t.map(function(r) {
    return tv(r);
  }) : [tv(t)];
}, vw = function e(t, r, n) {
  n === void 0 && (n = !1), r = mw(r), t = $e(t);
  var i = [];
  if (!r.length)
    return i;
  for (var a = 0; a < t.length; ) {
    var s = (t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3]) >>> 0, o = t.subarray(a + 4, a + 8);
    if (s === 0)
      break;
    var u = a + s;
    if (u > t.length) {
      if (n)
        break;
      u = t.length;
    }
    var l = t.subarray(a + 8, u);
    rr(o, r[0]) && (r.length === 1 ? i.push(l) : i.push.apply(i, e(l, r.slice(1), n))), a = u;
  }
  return i;
}, Vl = {
  EBML: $e([26, 69, 223, 163]),
  DocType: $e([66, 130]),
  Segment: $e([24, 83, 128, 103]),
  SegmentInfo: $e([21, 73, 169, 102]),
  Tracks: $e([22, 84, 174, 107]),
  Track: $e([174]),
  TrackNumber: $e([215]),
  DefaultDuration: $e([35, 227, 131]),
  TrackEntry: $e([174]),
  TrackType: $e([131]),
  FlagDefault: $e([136]),
  CodecID: $e([134]),
  CodecPrivate: $e([99, 162]),
  VideoTrack: $e([224]),
  AudioTrack: $e([225]),
  // Not used yet, but will be used for live webm/mkv
  // see https://www.matroska.org/technical/basics.html#block-structure
  // see https://www.matroska.org/technical/basics.html#simpleblock-structure
  Cluster: $e([31, 67, 182, 117]),
  Timestamp: $e([231]),
  TimestampScale: $e([42, 215, 177]),
  BlockGroup: $e([160]),
  BlockDuration: $e([155]),
  Block: $e([161]),
  SimpleBlock: $e([163])
}, Qf = [128, 64, 32, 16, 8, 4, 2, 1], gw = function(t) {
  for (var r = 1, n = 0; n < Qf.length && !(t & Qf[n]); n++)
    r++;
  return r;
}, Rc = function(t, r, n, i) {
  n === void 0 && (n = !0), i === void 0 && (i = !1);
  var a = gw(t[r]), s = t.subarray(r, r + a);
  return n && (s = Array.prototype.slice.call(t, r, r + a), s[0] ^= Qf[a - 1]), {
    length: a,
    value: uw(s, {
      signed: i
    }),
    bytes: s
  };
}, rv = function e(t) {
  return typeof t == "string" ? t.match(/.{1,2}/g).map(function(r) {
    return e(r);
  }) : typeof t == "number" ? lw(t) : t;
}, yw = function(t) {
  return Array.isArray(t) ? t.map(function(r) {
    return rv(r);
  }) : [rv(t)];
}, _w = function e(t, r, n) {
  if (n >= r.length)
    return r.length;
  var i = Rc(r, n, !1);
  if (rr(t.bytes, i.bytes))
    return n;
  var a = Rc(r, n + i.length);
  return e(t, r, n + a.length + a.value + i.length);
}, iv = function e(t, r) {
  r = yw(r), t = $e(t);
  var n = [];
  if (!r.length)
    return n;
  for (var i = 0; i < t.length; ) {
    var a = Rc(t, i, !1), s = Rc(t, i + a.length), o = i + a.length + s.length;
    s.value === 127 && (s.value = _w(a, t, o), s.value !== t.length && (s.value -= o));
    var u = o + s.value > t.length ? t.length : o + s.value, l = t.subarray(o, u);
    rr(r[0], a.bytes) && (r.length === 1 ? n.push(l) : n = n.concat(e(l, r.slice(1))));
    var c = a.length + s.length + l.length;
    i += c;
  }
  return n;
}, bw = $e([73, 68, 51]), xw = function(t, r) {
  r === void 0 && (r = 0), t = $e(t);
  var n = t[r + 5], i = t[r + 6] << 21 | t[r + 7] << 14 | t[r + 8] << 7 | t[r + 9], a = (n & 16) >> 4;
  return a ? i + 20 : i + 10;
}, iu = function e(t, r) {
  return r === void 0 && (r = 0), t = $e(t), t.length - r < 10 || !rr(t, bw, {
    offset: r
  }) ? r : (r += xw(t, r), e(t, r));
}, Aw = $e([0, 0, 0, 1]), Tw = $e([0, 0, 1]), Ew = $e([0, 0, 3]), ww = function(t) {
  for (var r = [], n = 1; n < t.length - 2; )
    rr(t.subarray(n, n + 3), Ew) && (r.push(n + 2), n++), n++;
  if (r.length === 0)
    return t;
  var i = t.length - r.length, a = new Uint8Array(i), s = 0;
  for (n = 0; n < i; s++, n++)
    s === r[0] && (s++, r.shift()), a[n] = t[s];
  return a;
}, Sy = function(t, r, n, i) {
  t = $e(t), n = [].concat(n);
  for (var a = 0, s, o = 0; a < t.length && (o < i || s); ) {
    var u = void 0;
    if (rr(t.subarray(a), Aw) ? u = 4 : rr(t.subarray(a), Tw) && (u = 3), !u) {
      a++;
      continue;
    }
    if (o++, s)
      return ww(t.subarray(s, a));
    var l = void 0;
    r === "h264" ? l = t[a + u] & 31 : r === "h265" && (l = t[a + u] >> 1 & 63), n.indexOf(l) !== -1 && (s = a + u), a += u + (r === "h264" ? 1 : 2);
  }
  return t.subarray(0, 0);
}, Sw = function(t, r, n) {
  return Sy(t, "h264", r, n);
}, Cw = function(t, r, n) {
  return Sy(t, "h265", r, n);
}, $r = {
  // "webm" string literal in hex
  webm: $e([119, 101, 98, 109]),
  // "matroska" string literal in hex
  matroska: $e([109, 97, 116, 114, 111, 115, 107, 97]),
  // "fLaC" string literal in hex
  flac: $e([102, 76, 97, 67]),
  // "OggS" string literal in hex
  ogg: $e([79, 103, 103, 83]),
  // ac-3 sync byte, also works for ec-3 as that is simply a codec
  // of ac-3
  ac3: $e([11, 119]),
  // "RIFF" string literal in hex used for wav and avi
  riff: $e([82, 73, 70, 70]),
  // "AVI" string literal in hex
  avi: $e([65, 86, 73]),
  // "WAVE" string literal in hex
  wav: $e([87, 65, 86, 69]),
  // "ftyp3g" string literal in hex
  "3gp": $e([102, 116, 121, 112, 51, 103]),
  // "ftyp" string literal in hex
  mp4: $e([102, 116, 121, 112]),
  // "styp" string literal in hex
  fmp4: $e([115, 116, 121, 112]),
  // "ftypqt" string literal in hex
  mov: $e([102, 116, 121, 112, 113, 116]),
  // moov string literal in hex
  moov: $e([109, 111, 111, 118]),
  // moof string literal in hex
  moof: $e([109, 111, 111, 102])
}, xo = {
  aac: function(t) {
    var r = iu(t);
    return rr(t, [255, 16], {
      offset: r,
      mask: [255, 22]
    });
  },
  mp3: function(t) {
    var r = iu(t);
    return rr(t, [255, 2], {
      offset: r,
      mask: [255, 6]
    });
  },
  webm: function(t) {
    var r = iv(t, [Vl.EBML, Vl.DocType])[0];
    return rr(r, $r.webm);
  },
  mkv: function(t) {
    var r = iv(t, [Vl.EBML, Vl.DocType])[0];
    return rr(r, $r.matroska);
  },
  mp4: function(t) {
    if (xo["3gp"](t) || xo.mov(t))
      return !1;
    if (rr(t, $r.mp4, {
      offset: 4
    }) || rr(t, $r.fmp4, {
      offset: 4
    }) || rr(t, $r.moof, {
      offset: 4
    }) || rr(t, $r.moov, {
      offset: 4
    }))
      return !0;
  },
  mov: function(t) {
    return rr(t, $r.mov, {
      offset: 4
    });
  },
  "3gp": function(t) {
    return rr(t, $r["3gp"], {
      offset: 4
    });
  },
  ac3: function(t) {
    var r = iu(t);
    return rr(t, $r.ac3, {
      offset: r
    });
  },
  ts: function(t) {
    if (t.length < 189 && t.length >= 1)
      return t[0] === 71;
    for (var r = 0; r + 188 < t.length && r < 188; ) {
      if (t[r] === 71 && t[r + 188] === 71)
        return !0;
      r += 1;
    }
    return !1;
  },
  flac: function(t) {
    var r = iu(t);
    return rr(t, $r.flac, {
      offset: r
    });
  },
  ogg: function(t) {
    return rr(t, $r.ogg);
  },
  avi: function(t) {
    return rr(t, $r.riff) && rr(t, $r.avi, {
      offset: 8
    });
  },
  wav: function(t) {
    return rr(t, $r.riff) && rr(t, $r.wav, {
      offset: 8
    });
  },
  h264: function(t) {
    return Sw(t, 7, 3).length;
  },
  h265: function(t) {
    return Cw(t, [32, 33], 3).length;
  }
}, Kf = Object.keys(xo).filter(function(e) {
  return e !== "ts" && e !== "h264" && e !== "h265";
}).concat(["ts", "h264", "h265"]);
Kf.forEach(function(e) {
  var t = xo[e];
  xo[e] = function(r) {
    return t($e(r));
  };
});
var Mw = xo, ip = function(t) {
  t = $e(t);
  for (var r = 0; r < Kf.length; r++) {
    var n = Kf[r];
    if (Mw[n](t))
      return n;
  }
  return "";
}, Dw = function(t) {
  return vw(t, ["moof"]).length > 0;
}, Pw = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i, Lw = /^application\/dash\+xml/i, Cy = function(t) {
  return Pw.test(t) ? "hls" : Lw.test(t) ? "dash" : t === "application/vnd.videojs.vhs+json" ? "vhs-json" : null;
}, My = { exports: {} };
(function(e, t) {
  (function(r) {
    var n = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, i = /^(?=([^\/?#]*))\1([^]*)$/, a = /(?:\/|^)\.(?=\/)/g, s = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = {
      // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
      // E.g
      // With opts.alwaysNormalize = false (default, spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
      // With opts.alwaysNormalize = true (not spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
      buildAbsoluteURL: function(u, l, c) {
        if (c = c || {}, u = u.trim(), l = l.trim(), !l) {
          if (!c.alwaysNormalize)
            return u;
          var h = o.parseURL(u);
          if (!h)
            throw new Error("Error trying to parse base URL.");
          return h.path = o.normalizePath(
            h.path
          ), o.buildURLFromParts(h);
        }
        var f = o.parseURL(l);
        if (!f)
          throw new Error("Error trying to parse relative URL.");
        if (f.scheme)
          return c.alwaysNormalize ? (f.path = o.normalizePath(f.path), o.buildURLFromParts(f)) : l;
        var d = o.parseURL(u);
        if (!d)
          throw new Error("Error trying to parse base URL.");
        if (!d.netLoc && d.path && d.path[0] !== "/") {
          var p = i.exec(d.path);
          d.netLoc = p[1], d.path = p[2];
        }
        d.netLoc && !d.path && (d.path = "/");
        var _ = {
          // 2c) Otherwise, the embedded URL inherits the scheme of
          // the base URL.
          scheme: d.scheme,
          netLoc: f.netLoc,
          path: null,
          params: f.params,
          query: f.query,
          fragment: f.fragment
        };
        if (!f.netLoc && (_.netLoc = d.netLoc, f.path[0] !== "/"))
          if (!f.path)
            _.path = d.path, f.params || (_.params = d.params, f.query || (_.query = d.query));
          else {
            var v = d.path, x = v.substring(0, v.lastIndexOf("/") + 1) + f.path;
            _.path = o.normalizePath(x);
          }
        return _.path === null && (_.path = c.alwaysNormalize ? o.normalizePath(f.path) : f.path), o.buildURLFromParts(_);
      },
      parseURL: function(u) {
        var l = n.exec(u);
        return l ? {
          scheme: l[1] || "",
          netLoc: l[2] || "",
          path: l[3] || "",
          params: l[4] || "",
          query: l[5] || "",
          fragment: l[6] || ""
        } : null;
      },
      normalizePath: function(u) {
        for (u = u.split("").reverse().join("").replace(a, ""); u.length !== (u = u.replace(s, "")).length; )
          ;
        return u.split("").reverse().join("");
      },
      buildURLFromParts: function(u) {
        return u.scheme + u.netLoc + u.path + u.params + u.query + u.fragment;
      }
    };
    e.exports = o;
  })();
})(My);
var Rw = My.exports;
const nv = /* @__PURE__ */ Qn(Rw);
var av = "http://example.com", _h = function(t, r) {
  if (/^[a-z]+:/i.test(r))
    return r;
  /^data:/.test(t) && (t = j.location && j.location.href || "");
  var n = typeof j.URL == "function", i = /^\/\//.test(t), a = !j.location && !/\/\//i.test(t);
  if (n ? t = new j.URL(t, j.location || av) : /\/\//i.test(t) || (t = nv.buildAbsoluteURL(j.location && j.location.href || "", t)), n) {
    var s = new URL(r, t);
    return a ? s.href.slice(av.length) : i ? s.href.slice(s.protocol.length) : s.href;
  }
  return nv.buildAbsoluteURL(t, r);
}, np = { exports: {} };
const Iw = /* @__PURE__ */ Cg(rw);
var Ow = Fw, Bw = Object.prototype.toString;
function Fw(e) {
  if (!e)
    return !1;
  var t = Bw.call(e);
  return t === "[object Function]" || typeof e == "function" && t !== "[object RegExp]" || typeof window < "u" && // IE8 and below
  (e === window.setTimeout || e === window.alert || e === window.confirm || e === window.prompt);
}
var kw = nh, Nw = function(t, r) {
  return r === void 0 && (r = !1), function(n, i, a) {
    if (n) {
      t(n);
      return;
    }
    if (i.statusCode >= 400 && i.statusCode <= 599) {
      var s = a;
      if (r)
        if (kw.TextDecoder) {
          var o = Uw(i.headers && i.headers["content-type"]);
          try {
            s = new TextDecoder(o).decode(a);
          } catch {
          }
        } else
          s = String.fromCharCode.apply(null, new Uint8Array(a));
      t({
        cause: s
      });
      return;
    }
    t(null, a);
  };
};
function Uw(e) {
  return e === void 0 && (e = ""), e.toLowerCase().split(";").reduce(function(t, r) {
    var n = r.split("="), i = n[0], a = n[1];
    return i.trim() === "charset" ? a.trim() : t;
  }, "utf-8");
}
var Gw = Nw, Dy = nh, Vw = Iw, Hw = Ow;
mn.httpHandler = Gw;
/**
 * @license
 * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
 * Copyright (c) 2014 David Bjrklund
 * Available under the MIT license
 * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
 */
var zw = function(t) {
  var r = {};
  return t && t.trim().split(`
`).forEach(function(n) {
    var i = n.indexOf(":"), a = n.slice(0, i).trim().toLowerCase(), s = n.slice(i + 1).trim();
    typeof r[a] > "u" ? r[a] = s : Array.isArray(r[a]) ? r[a].push(s) : r[a] = [r[a], s];
  }), r;
};
np.exports = mn;
np.exports.default = mn;
mn.XMLHttpRequest = Dy.XMLHttpRequest || Xw;
mn.XDomainRequest = "withCredentials" in new mn.XMLHttpRequest() ? mn.XMLHttpRequest : Dy.XDomainRequest;
Ww(["get", "put", "post", "patch", "head", "delete"], function(e) {
  mn[e === "delete" ? "del" : e] = function(t, r, n) {
    return r = Py(t, r, n), r.method = e.toUpperCase(), Ly(r);
  };
});
function Ww(e, t) {
  for (var r = 0; r < e.length; r++)
    t(e[r]);
}
function jw(e) {
  for (var t in e)
    if (e.hasOwnProperty(t)) return !1;
  return !0;
}
function Py(e, t, r) {
  var n = e;
  return Hw(t) ? (r = t, typeof e == "string" && (n = {
    uri: e
  })) : n = Vw({}, t, {
    uri: e
  }), n.callback = r, n;
}
function mn(e, t, r) {
  return t = Py(e, t, r), Ly(t);
}
function Ly(e) {
  if (typeof e.callback > "u")
    throw new Error("callback argument missing");
  var t = !1, r = function(M, C, R) {
    t || (t = !0, e.callback(M, C, R));
  };
  function n() {
    o.readyState === 4 && setTimeout(s, 0);
  }
  function i() {
    var E = void 0;
    if (o.response ? E = o.response : E = o.responseText || qw(o), _)
      try {
        E = JSON.parse(E);
      } catch {
      }
    return E;
  }
  function a(E) {
    return clearTimeout(v), E instanceof Error || (E = new Error("" + (E || "Unknown XMLHttpRequest Error"))), E.statusCode = 0, r(E, x);
  }
  function s() {
    if (!l) {
      var E;
      clearTimeout(v), e.useXDR && o.status === void 0 ? E = 200 : E = o.status === 1223 ? 204 : o.status;
      var M = x, C = null;
      return E !== 0 ? (M = {
        body: i(),
        statusCode: E,
        method: h,
        headers: {},
        url: c,
        rawRequest: o
      }, o.getAllResponseHeaders && (M.headers = zw(o.getAllResponseHeaders()))) : C = new Error("Internal XMLHttpRequest Error"), r(C, M, M.body);
    }
  }
  var o = e.xhr || null;
  o || (e.cors || e.useXDR ? o = new mn.XDomainRequest() : o = new mn.XMLHttpRequest());
  var u, l, c = o.url = e.uri || e.url, h = o.method = e.method || "GET", f = e.body || e.data, d = o.headers = e.headers || {}, p = !!e.sync, _ = !1, v, x = {
    body: void 0,
    headers: {},
    statusCode: 0,
    method: h,
    url: c,
    rawRequest: o
  };
  if ("json" in e && e.json !== !1 && (_ = !0, d.accept || d.Accept || (d.Accept = "application/json"), h !== "GET" && h !== "HEAD" && (d["content-type"] || d["Content-Type"] || (d["Content-Type"] = "application/json"), f = JSON.stringify(e.json === !0 ? f : e.json))), o.onreadystatechange = n, o.onload = s, o.onerror = a, o.onprogress = function() {
  }, o.onabort = function() {
    l = !0;
  }, o.ontimeout = a, o.open(h, c, !p, e.username, e.password), p || (o.withCredentials = !!e.withCredentials), !p && e.timeout > 0 && (v = setTimeout(function() {
    if (!l) {
      l = !0, o.abort("timeout");
      var E = new Error("XMLHttpRequest timeout");
      E.code = "ETIMEDOUT", a(E);
    }
  }, e.timeout)), o.setRequestHeader)
    for (u in d)
      d.hasOwnProperty(u) && o.setRequestHeader(u, d[u]);
  else if (e.headers && !jw(e.headers))
    throw new Error("Headers cannot be set on an XDomainRequest object");
  return "responseType" in e && (o.responseType = e.responseType), "beforeSend" in e && typeof e.beforeSend == "function" && e.beforeSend(o), o.send(f || null), o;
}
function qw(e) {
  try {
    if (e.responseType === "document")
      return e.responseXML;
    var t = e.responseXML && e.responseXML.documentElement.nodeName === "parsererror";
    if (e.responseType === "" && !t)
      return e.responseXML;
  } catch {
  }
  return null;
}
function Xw() {
}
var Yw = np.exports;
const Ry = /* @__PURE__ */ Qn(Yw);
var $f = { exports: {} };
(function(e, t) {
  function r(u) {
    if (u && typeof u == "object") {
      var l = u.which || u.keyCode || u.charCode;
      l && (u = l);
    }
    if (typeof u == "number") return s[u];
    var c = String(u), h = n[c.toLowerCase()];
    if (h) return h;
    var h = i[c.toLowerCase()];
    if (h) return h;
    if (c.length === 1) return c.charCodeAt(0);
  }
  r.isEventKey = function(l, c) {
    if (l && typeof l == "object") {
      var h = l.which || l.keyCode || l.charCode;
      if (h == null)
        return !1;
      if (typeof c == "string") {
        var f = n[c.toLowerCase()];
        if (f)
          return f === h;
        var f = i[c.toLowerCase()];
        if (f)
          return f === h;
      } else if (typeof c == "number")
        return c === h;
      return !1;
    }
  }, t = e.exports = r;
  var n = t.code = t.codes = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    "pause/break": 19,
    "caps lock": 20,
    esc: 27,
    space: 32,
    "page up": 33,
    "page down": 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    delete: 46,
    command: 91,
    "left command": 91,
    "right command": 93,
    "numpad *": 106,
    "numpad +": 107,
    "numpad -": 109,
    "numpad .": 110,
    "numpad /": 111,
    "num lock": 144,
    "scroll lock": 145,
    "my computer": 182,
    "my calculator": 183,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  }, i = t.aliases = {
    windows: 91,
    "": 16,
    "": 18,
    "": 17,
    "": 91,
    ctl: 17,
    control: 17,
    option: 18,
    pause: 19,
    break: 19,
    caps: 20,
    return: 13,
    escape: 27,
    spc: 32,
    spacebar: 32,
    pgup: 33,
    pgdn: 34,
    ins: 45,
    del: 46,
    cmd: 91
  };
  /*!
   * Programatically add the following
   */
  for (a = 97; a < 123; a++) n[String.fromCharCode(a)] = a - 32;
  for (var a = 48; a < 58; a++) n[a - 48] = a;
  for (a = 1; a < 13; a++) n["f" + a] = a + 111;
  for (a = 0; a < 10; a++) n["numpad " + a] = a + 96;
  var s = t.names = t.title = {};
  for (a in n) s[n[a]] = a;
  for (var o in i)
    n[o] = i[o];
})($f, $f.exports);
var Qw = $f.exports;
const lt = /* @__PURE__ */ Qn(Qw);
var ap = /* @__PURE__ */ function() {
  function e() {
    this.listeners = {};
  }
  var t = e.prototype;
  return t.on = function(n, i) {
    this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push(i);
  }, t.off = function(n, i) {
    if (!this.listeners[n])
      return !1;
    var a = this.listeners[n].indexOf(i);
    return this.listeners[n] = this.listeners[n].slice(0), this.listeners[n].splice(a, 1), a > -1;
  }, t.trigger = function(n) {
    var i = this.listeners[n];
    if (i)
      if (arguments.length === 2)
        for (var a = i.length, s = 0; s < a; ++s)
          i[s].call(this, arguments[1]);
      else
        for (var o = Array.prototype.slice.call(arguments, 1), u = i.length, l = 0; l < u; ++l)
          i[l].apply(this, o);
  }, t.dispose = function() {
    this.listeners = {};
  }, t.pipe = function(n) {
    this.on("data", function(i) {
      n.push(i);
    });
  }, e;
}(), Kw = function(t) {
  return j.atob ? j.atob(t) : Buffer.from(t, "base64").toString("binary");
};
function Iy(e) {
  for (var t = Kw(e), r = new Uint8Array(t.length), n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r;
}
/*! @name m3u8-parser @version 4.8.0 @license Apache-2.0 */
var $w = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    var n;
    return n = e.call(this) || this, n.buffer = "", n;
  }
  var r = t.prototype;
  return r.push = function(i) {
    var a;
    for (this.buffer += i, a = this.buffer.indexOf(`
`); a > -1; a = this.buffer.indexOf(`
`))
      this.trigger("data", this.buffer.substring(0, a)), this.buffer = this.buffer.substring(a + 1);
  }, t;
}(ap), Zw = "	", ef = function(t) {
  var r = /([0-9.]*)?@?([0-9.]*)?/.exec(t || ""), n = {};
  return r[1] && (n.length = parseInt(r[1], 10)), r[2] && (n.offset = parseInt(r[2], 10)), n;
}, Jw = function() {
  var t = "[^=]*", r = '"[^"]*"|[^,]*', n = "(?:" + t + ")=(?:" + r + ")";
  return new RegExp("(?:^|,)(" + n + ")");
}, Gi = function(t) {
  for (var r = t.split(Jw()), n = {}, i = r.length, a; i--; )
    r[i] !== "" && (a = /([^=]*)=(.*)/.exec(r[i]).slice(1), a[0] = a[0].replace(/^\s+|\s+$/g, ""), a[1] = a[1].replace(/^\s+|\s+$/g, ""), a[1] = a[1].replace(/^['"](.*)['"]$/g, "$1"), n[a[0]] = a[1]);
  return n;
}, eS = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    var n;
    return n = e.call(this) || this, n.customParsers = [], n.tagMappers = [], n;
  }
  var r = t.prototype;
  return r.push = function(i) {
    var a = this, s, o;
    if (i = i.trim(), i.length !== 0) {
      if (i[0] !== "#") {
        this.trigger("data", {
          type: "uri",
          uri: i
        });
        return;
      }
      var u = this.tagMappers.reduce(function(l, c) {
        var h = c(i);
        return h === i ? l : l.concat([h]);
      }, [i]);
      u.forEach(function(l) {
        for (var c = 0; c < a.customParsers.length; c++)
          if (a.customParsers[c].call(a, l))
            return;
        if (l.indexOf("#EXT") !== 0) {
          a.trigger("data", {
            type: "comment",
            text: l.slice(1)
          });
          return;
        }
        if (l = l.replace("\r", ""), s = /^#EXTM3U/.exec(l), s) {
          a.trigger("data", {
            type: "tag",
            tagType: "m3u"
          });
          return;
        }
        if (s = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "inf"
          }, s[1] && (o.duration = parseFloat(s[1])), s[2] && (o.title = s[2]), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "targetduration"
          }, s[1] && (o.duration = parseInt(s[1], 10)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "version"
          }, s[1] && (o.version = parseInt(s[1], 10)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "media-sequence"
          }, s[1] && (o.number = parseInt(s[1], 10)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "discontinuity-sequence"
          }, s[1] && (o.number = parseInt(s[1], 10)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "playlist-type"
          }, s[1] && (o.playlistType = s[1]), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(l), s) {
          o = Bi(ef(s[1]), {
            type: "tag",
            tagType: "byterange"
          }), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "allow-cache"
          }, s[1] && (o.allowed = !/NO/.test(s[1])), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-MAP:?(.*)$/.exec(l), s) {
          if (o = {
            type: "tag",
            tagType: "map"
          }, s[1]) {
            var h = Gi(s[1]);
            h.URI && (o.uri = h.URI), h.BYTERANGE && (o.byterange = ef(h.BYTERANGE));
          }
          a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-STREAM-INF:?(.*)$/.exec(l), s) {
          if (o = {
            type: "tag",
            tagType: "stream-inf"
          }, s[1]) {
            if (o.attributes = Gi(s[1]), o.attributes.RESOLUTION) {
              var f = o.attributes.RESOLUTION.split("x"), d = {};
              f[0] && (d.width = parseInt(f[0], 10)), f[1] && (d.height = parseInt(f[1], 10)), o.attributes.RESOLUTION = d;
            }
            o.attributes.BANDWIDTH && (o.attributes.BANDWIDTH = parseInt(o.attributes.BANDWIDTH, 10)), o.attributes["FRAME-RATE"] && (o.attributes["FRAME-RATE"] = parseFloat(o.attributes["FRAME-RATE"])), o.attributes["PROGRAM-ID"] && (o.attributes["PROGRAM-ID"] = parseInt(o.attributes["PROGRAM-ID"], 10));
          }
          a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-MEDIA:?(.*)$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "media"
          }, s[1] && (o.attributes = Gi(s[1])), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-ENDLIST/.exec(l), s) {
          a.trigger("data", {
            type: "tag",
            tagType: "endlist"
          });
          return;
        }
        if (s = /^#EXT-X-DISCONTINUITY/.exec(l), s) {
          a.trigger("data", {
            type: "tag",
            tagType: "discontinuity"
          });
          return;
        }
        if (s = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "program-date-time"
          }, s[1] && (o.dateTimeString = s[1], o.dateTimeObject = new Date(s[1])), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-KEY:?(.*)$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "key"
          }, s[1] && (o.attributes = Gi(s[1]), o.attributes.IV && (o.attributes.IV.substring(0, 2).toLowerCase() === "0x" && (o.attributes.IV = o.attributes.IV.substring(2)), o.attributes.IV = o.attributes.IV.match(/.{8}/g), o.attributes.IV[0] = parseInt(o.attributes.IV[0], 16), o.attributes.IV[1] = parseInt(o.attributes.IV[1], 16), o.attributes.IV[2] = parseInt(o.attributes.IV[2], 16), o.attributes.IV[3] = parseInt(o.attributes.IV[3], 16), o.attributes.IV = new Uint32Array(o.attributes.IV))), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-START:?(.*)$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "start"
          }, s[1] && (o.attributes = Gi(s[1]), o.attributes["TIME-OFFSET"] = parseFloat(o.attributes["TIME-OFFSET"]), o.attributes.PRECISE = /YES/.test(o.attributes.PRECISE)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "cue-out-cont"
          }, s[1] ? o.data = s[1] : o.data = "", a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "cue-out"
          }, s[1] ? o.data = s[1] : o.data = "", a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-CUE-IN:?(.*)?$/.exec(l), s) {
          o = {
            type: "tag",
            tagType: "cue-in"
          }, s[1] ? o.data = s[1] : o.data = "", a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-SKIP:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "skip"
          }, o.attributes = Gi(s[1]), o.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (o.attributes["SKIPPED-SEGMENTS"] = parseInt(o.attributes["SKIPPED-SEGMENTS"], 10)), o.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (o.attributes["RECENTLY-REMOVED-DATERANGES"] = o.attributes["RECENTLY-REMOVED-DATERANGES"].split(Zw)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-PART:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "part"
          }, o.attributes = Gi(s[1]), ["DURATION"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = parseFloat(o.attributes[p]));
          }), ["INDEPENDENT", "GAP"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = /YES/.test(o.attributes[p]));
          }), o.attributes.hasOwnProperty("BYTERANGE") && (o.attributes.byterange = ef(o.attributes.BYTERANGE)), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "server-control"
          }, o.attributes = Gi(s[1]), ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = parseFloat(o.attributes[p]));
          }), ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = /YES/.test(o.attributes[p]));
          }), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-PART-INF:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "part-inf"
          }, o.attributes = Gi(s[1]), ["PART-TARGET"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = parseFloat(o.attributes[p]));
          }), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "preload-hint"
          }, o.attributes = Gi(s[1]), ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(p) {
            if (o.attributes.hasOwnProperty(p)) {
              o.attributes[p] = parseInt(o.attributes[p], 10);
              var _ = p === "BYTERANGE-LENGTH" ? "length" : "offset";
              o.attributes.byterange = o.attributes.byterange || {}, o.attributes.byterange[_] = o.attributes[p], delete o.attributes[p];
            }
          }), a.trigger("data", o);
          return;
        }
        if (s = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(l), s && s[1]) {
          o = {
            type: "tag",
            tagType: "rendition-report"
          }, o.attributes = Gi(s[1]), ["LAST-MSN", "LAST-PART"].forEach(function(p) {
            o.attributes.hasOwnProperty(p) && (o.attributes[p] = parseInt(o.attributes[p], 10));
          }), a.trigger("data", o);
          return;
        }
        a.trigger("data", {
          type: "tag",
          data: l.slice(4)
        });
      });
    }
  }, r.addParser = function(i) {
    var a = this, s = i.expression, o = i.customType, u = i.dataParser, l = i.segment;
    typeof u != "function" && (u = function(h) {
      return h;
    }), this.customParsers.push(function(c) {
      var h = s.exec(c);
      if (h)
        return a.trigger("data", {
          type: "custom",
          data: u(c),
          customType: o,
          segment: l
        }), !0;
    });
  }, r.addTagMapper = function(i) {
    var a = i.expression, s = i.map, o = function(l) {
      return a.test(l) ? s(l) : l;
    };
    this.tagMappers.push(o);
  }, t;
}(ap), tS = function(t) {
  return t.toLowerCase().replace(/-(\w)/g, function(r) {
    return r[1].toUpperCase();
  });
}, As = function(t) {
  var r = {};
  return Object.keys(t).forEach(function(n) {
    r[tS(n)] = t[n];
  }), r;
}, tf = function(t) {
  var r = t.serverControl, n = t.targetDuration, i = t.partTargetDuration;
  if (r) {
    var a = "#EXT-X-SERVER-CONTROL", s = "holdBack", o = "partHoldBack", u = n && n * 3, l = i && i * 2;
    n && !r.hasOwnProperty(s) && (r[s] = u, this.trigger("info", {
      message: a + " defaulting HOLD-BACK to targetDuration * 3 (" + u + ")."
    })), u && r[s] < u && (this.trigger("warn", {
      message: a + " clamping HOLD-BACK (" + r[s] + ") to targetDuration * 3 (" + u + ")"
    }), r[s] = u), i && !r.hasOwnProperty(o) && (r[o] = i * 3, this.trigger("info", {
      message: a + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + r[o] + ")."
    })), i && r[o] < l && (this.trigger("warn", {
      message: a + " clamping PART-HOLD-BACK (" + r[o] + ") to partTargetDuration * 2 (" + l + ")."
    }), r[o] = l);
  }
}, rS = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    var n;
    n = e.call(this) || this, n.lineStream = new $w(), n.parseStream = new eS(), n.lineStream.pipe(n.parseStream);
    var i = ze(n), a = [], s = {}, o, u, l = !1, c = function() {
    }, h = {
      AUDIO: {},
      VIDEO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {}
    }, f = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", d = 0;
    n.manifest = {
      allowCache: !0,
      discontinuityStarts: [],
      segments: []
    };
    var p = 0, _ = 0;
    return n.on("end", function() {
      s.uri || !s.parts && !s.preloadHints || (!s.map && o && (s.map = o), !s.key && u && (s.key = u), !s.timeline && typeof d == "number" && (s.timeline = d), n.manifest.preloadSegment = s);
    }), n.parseStream.on("data", function(v) {
      var x, E;
      ({
        tag: function() {
          ({
            version: function() {
              v.version && (this.manifest.version = v.version);
            },
            "allow-cache": function() {
              this.manifest.allowCache = v.allowed, "allowed" in v || (this.trigger("info", {
                message: "defaulting allowCache to YES"
              }), this.manifest.allowCache = !0);
            },
            byterange: function() {
              var R = {};
              "length" in v && (s.byterange = R, R.length = v.length, "offset" in v || (v.offset = p)), "offset" in v && (s.byterange = R, R.offset = v.offset), p = R.offset + R.length;
            },
            endlist: function() {
              this.manifest.endList = !0;
            },
            inf: function() {
              "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", {
                message: "defaulting media sequence to zero"
              })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", {
                message: "defaulting discontinuity sequence to zero"
              })), v.duration > 0 && (s.duration = v.duration), v.duration === 0 && (s.duration = 0.01, this.trigger("info", {
                message: "updating zero segment duration to a small value"
              })), this.manifest.segments = a;
            },
            key: function() {
              if (!v.attributes) {
                this.trigger("warn", {
                  message: "ignoring key declaration without attribute list"
                });
                return;
              }
              if (v.attributes.METHOD === "NONE") {
                u = null;
                return;
              }
              if (!v.attributes.URI) {
                this.trigger("warn", {
                  message: "ignoring key declaration without URI"
                });
                return;
              }
              if (v.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.apple.fps.1_0"] = {
                  attributes: v.attributes
                };
                return;
              }
              if (v.attributes.KEYFORMAT === "com.microsoft.playready") {
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.microsoft.playready"] = {
                  uri: v.attributes.URI
                };
                return;
              }
              if (v.attributes.KEYFORMAT === f) {
                var R = ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"];
                if (R.indexOf(v.attributes.METHOD) === -1) {
                  this.trigger("warn", {
                    message: "invalid key method provided for Widevine"
                  });
                  return;
                }
                if (v.attributes.METHOD === "SAMPLE-AES-CENC" && this.trigger("warn", {
                  message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                }), v.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                  this.trigger("warn", {
                    message: "invalid key URI provided for Widevine"
                  });
                  return;
                }
                if (!(v.attributes.KEYID && v.attributes.KEYID.substring(0, 2) === "0x")) {
                  this.trigger("warn", {
                    message: "invalid key ID provided for Widevine"
                  });
                  return;
                }
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.widevine.alpha"] = {
                  attributes: {
                    schemeIdUri: v.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: v.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: Iy(v.attributes.URI.split(",")[1])
                };
                return;
              }
              v.attributes.METHOD || this.trigger("warn", {
                message: "defaulting key method to AES-128"
              }), u = {
                method: v.attributes.METHOD || "AES-128",
                uri: v.attributes.URI
              }, typeof v.attributes.IV < "u" && (u.iv = v.attributes.IV);
            },
            "media-sequence": function() {
              if (!isFinite(v.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid media sequence: " + v.number
                });
                return;
              }
              this.manifest.mediaSequence = v.number;
            },
            "discontinuity-sequence": function() {
              if (!isFinite(v.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid discontinuity sequence: " + v.number
                });
                return;
              }
              this.manifest.discontinuitySequence = v.number, d = v.number;
            },
            "playlist-type": function() {
              if (!/VOD|EVENT/.test(v.playlistType)) {
                this.trigger("warn", {
                  message: "ignoring unknown playlist type: " + v.playlist
                });
                return;
              }
              this.manifest.playlistType = v.playlistType;
            },
            map: function() {
              o = {}, v.uri && (o.uri = v.uri), v.byterange && (o.byterange = v.byterange), u && (o.key = u);
            },
            "stream-inf": function() {
              if (this.manifest.playlists = a, this.manifest.mediaGroups = this.manifest.mediaGroups || h, !v.attributes) {
                this.trigger("warn", {
                  message: "ignoring empty stream-inf attributes"
                });
                return;
              }
              s.attributes || (s.attributes = {}), Bi(s.attributes, v.attributes);
            },
            media: function() {
              if (this.manifest.mediaGroups = this.manifest.mediaGroups || h, !(v.attributes && v.attributes.TYPE && v.attributes["GROUP-ID"] && v.attributes.NAME)) {
                this.trigger("warn", {
                  message: "ignoring incomplete or missing media group"
                });
                return;
              }
              var R = this.manifest.mediaGroups[v.attributes.TYPE];
              R[v.attributes["GROUP-ID"]] = R[v.attributes["GROUP-ID"]] || {}, x = R[v.attributes["GROUP-ID"]], E = {
                default: /yes/i.test(v.attributes.DEFAULT)
              }, E.default ? E.autoselect = !0 : E.autoselect = /yes/i.test(v.attributes.AUTOSELECT), v.attributes.LANGUAGE && (E.language = v.attributes.LANGUAGE), v.attributes.URI && (E.uri = v.attributes.URI), v.attributes["INSTREAM-ID"] && (E.instreamId = v.attributes["INSTREAM-ID"]), v.attributes.CHARACTERISTICS && (E.characteristics = v.attributes.CHARACTERISTICS), v.attributes.FORCED && (E.forced = /yes/i.test(v.attributes.FORCED)), x[v.attributes.NAME] = E;
            },
            discontinuity: function() {
              d += 1, s.discontinuity = !0, this.manifest.discontinuityStarts.push(a.length);
            },
            "program-date-time": function() {
              typeof this.manifest.dateTimeString > "u" && (this.manifest.dateTimeString = v.dateTimeString, this.manifest.dateTimeObject = v.dateTimeObject), s.dateTimeString = v.dateTimeString, s.dateTimeObject = v.dateTimeObject;
            },
            targetduration: function() {
              if (!isFinite(v.duration) || v.duration < 0) {
                this.trigger("warn", {
                  message: "ignoring invalid target duration: " + v.duration
                });
                return;
              }
              this.manifest.targetDuration = v.duration, tf.call(this, this.manifest);
            },
            start: function() {
              if (!v.attributes || isNaN(v.attributes["TIME-OFFSET"])) {
                this.trigger("warn", {
                  message: "ignoring start declaration without appropriate attribute list"
                });
                return;
              }
              this.manifest.start = {
                timeOffset: v.attributes["TIME-OFFSET"],
                precise: v.attributes.PRECISE
              };
            },
            "cue-out": function() {
              s.cueOut = v.data;
            },
            "cue-out-cont": function() {
              s.cueOutCont = v.data;
            },
            "cue-in": function() {
              s.cueIn = v.data;
            },
            skip: function() {
              this.manifest.skip = As(v.attributes), this.warnOnMissingAttributes_("#EXT-X-SKIP", v.attributes, ["SKIPPED-SEGMENTS"]);
            },
            part: function() {
              var R = this;
              l = !0;
              var B = this.manifest.segments.length, k = As(v.attributes);
              s.parts = s.parts || [], s.parts.push(k), k.byterange && (k.byterange.hasOwnProperty("offset") || (k.byterange.offset = _), _ = k.byterange.offset + k.byterange.length);
              var F = s.parts.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PART #" + F + " for segment #" + B, v.attributes, ["URI", "DURATION"]), this.manifest.renditionReports && this.manifest.renditionReports.forEach(function(I, H) {
                I.hasOwnProperty("lastPart") || R.trigger("warn", {
                  message: "#EXT-X-RENDITION-REPORT #" + H + " lacks required attribute(s): LAST-PART"
                });
              });
            },
            "server-control": function() {
              var R = this.manifest.serverControl = As(v.attributes);
              R.hasOwnProperty("canBlockReload") || (R.canBlockReload = !1, this.trigger("info", {
                message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
              })), tf.call(this, this.manifest), R.canSkipDateranges && !R.hasOwnProperty("canSkipUntil") && this.trigger("warn", {
                message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
              });
            },
            "preload-hint": function() {
              var R = this.manifest.segments.length, B = As(v.attributes), k = B.type && B.type === "PART";
              s.preloadHints = s.preloadHints || [], s.preloadHints.push(B), B.byterange && (B.byterange.hasOwnProperty("offset") || (B.byterange.offset = k ? _ : 0, k && (_ = B.byterange.offset + B.byterange.length)));
              var F = s.preloadHints.length - 1;
              if (this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + F + " for segment #" + R, v.attributes, ["TYPE", "URI"]), !!B.type)
                for (var I = 0; I < s.preloadHints.length - 1; I++) {
                  var H = s.preloadHints[I];
                  H.type && H.type === B.type && this.trigger("warn", {
                    message: "#EXT-X-PRELOAD-HINT #" + F + " for segment #" + R + " has the same TYPE " + B.type + " as preload hint #" + I
                  });
                }
            },
            "rendition-report": function() {
              var R = As(v.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [], this.manifest.renditionReports.push(R);
              var B = this.manifest.renditionReports.length - 1, k = ["LAST-MSN", "URI"];
              l && k.push("LAST-PART"), this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + B, v.attributes, k);
            },
            "part-inf": function() {
              this.manifest.partInf = As(v.attributes), this.warnOnMissingAttributes_("#EXT-X-PART-INF", v.attributes, ["PART-TARGET"]), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), tf.call(this, this.manifest);
            }
          }[v.tagType] || c).call(i);
        },
        uri: function() {
          s.uri = v.uri, a.push(s), this.manifest.targetDuration && !("duration" in s) && (this.trigger("warn", {
            message: "defaulting segment duration to the target duration"
          }), s.duration = this.manifest.targetDuration), u && (s.key = u), s.timeline = d, o && (s.map = o), _ = 0, s = {};
        },
        comment: function() {
        },
        custom: function() {
          v.segment ? (s.custom = s.custom || {}, s.custom[v.customType] = v.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[v.customType] = v.data);
        }
      })[v.type].call(i);
    }), n;
  }
  var r = t.prototype;
  return r.warnOnMissingAttributes_ = function(i, a, s) {
    var o = [];
    s.forEach(function(u) {
      a.hasOwnProperty(u) || o.push(u);
    }), o.length && this.trigger("warn", {
      message: i + " lacks required attribute(s): " + o.join(", ")
    });
  }, r.push = function(i) {
    this.lineStream.push(i);
  }, r.end = function() {
    this.lineStream.push(`
`), this.trigger("end");
  }, r.addParser = function(i) {
    this.parseStream.addParser(i);
  }, r.addTagMapper = function(i) {
    this.parseStream.addTagMapper(i);
  }, t;
}(ap), iS = function(t, r, n) {
  r.forEach(function(i) {
    for (var a in t.mediaGroups[i])
      for (var s in t.mediaGroups[i][a]) {
        var o = t.mediaGroups[i][a][s];
        n(o, i, a, s);
      }
  });
}, _a = {}, Zn = {};
function nS(e, t, r) {
  if (r === void 0 && (r = Array.prototype), e && typeof r.find == "function")
    return r.find.call(e, t);
  for (var n = 0; n < e.length; n++)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      var i = e[n];
      if (t.call(void 0, i, n, e))
        return i;
    }
}
function sp(e, t) {
  return t === void 0 && (t = Object), t && typeof t.freeze == "function" ? t.freeze(e) : e;
}
function aS(e, t) {
  if (e === null || typeof e != "object")
    throw new TypeError("target is not an object");
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e;
}
var Oy = sp({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: "text/html",
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function(e) {
    return e === Oy.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: "application/xml",
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: "text/xml",
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: "image/svg+xml"
}), By = sp({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: "http://www.w3.org/1999/xhtml",
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function(e) {
    return e === By.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: "http://www.w3.org/2000/svg",
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: "http://www.w3.org/XML/1998/namespace",
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
Zn.assign = aS;
Zn.find = nS;
Zn.freeze = sp;
Zn.MIME_TYPE = Oy;
Zn.NAMESPACE = By;
var Fy = Zn, vn = Fy.find, ll = Fy.NAMESPACE;
function sS(e) {
  return e !== "";
}
function oS(e) {
  return e ? e.split(/[\t\n\f\r ]+/).filter(sS) : [];
}
function uS(e, t) {
  return e.hasOwnProperty(t) || (e[t] = !0), e;
}
function sv(e) {
  if (!e) return [];
  var t = oS(e);
  return Object.keys(t.reduce(uS, {}));
}
function lS(e) {
  return function(t) {
    return e && e.indexOf(t) !== -1;
  };
}
function Tl(e, t) {
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
}
function mi(e, t) {
  var r = e.prototype;
  if (!(r instanceof t)) {
    let n = function() {
    };
    n.prototype = t.prototype, n = new n(), Tl(r, n), e.prototype = r = n;
  }
  r.constructor != e && (typeof e != "function" && console.error("unknown Class:" + e), r.constructor = e);
}
var vi = {}, Wi = vi.ELEMENT_NODE = 1, Ao = vi.ATTRIBUTE_NODE = 2, Ic = vi.TEXT_NODE = 3, ky = vi.CDATA_SECTION_NODE = 4, Ny = vi.ENTITY_REFERENCE_NODE = 5, cS = vi.ENTITY_NODE = 6, Uy = vi.PROCESSING_INSTRUCTION_NODE = 7, Gy = vi.COMMENT_NODE = 8, Vy = vi.DOCUMENT_NODE = 9, Hy = vi.DOCUMENT_TYPE_NODE = 10, Wn = vi.DOCUMENT_FRAGMENT_NODE = 11, hS = vi.NOTATION_NODE = 12, jr = {}, Rr = {};
jr.INDEX_SIZE_ERR = (Rr[1] = "Index size error", 1);
jr.DOMSTRING_SIZE_ERR = (Rr[2] = "DOMString size error", 2);
var ui = jr.HIERARCHY_REQUEST_ERR = (Rr[3] = "Hierarchy request error", 3);
jr.WRONG_DOCUMENT_ERR = (Rr[4] = "Wrong document", 4);
jr.INVALID_CHARACTER_ERR = (Rr[5] = "Invalid character", 5);
jr.NO_DATA_ALLOWED_ERR = (Rr[6] = "No data allowed", 6);
jr.NO_MODIFICATION_ALLOWED_ERR = (Rr[7] = "No modification allowed", 7);
var zy = jr.NOT_FOUND_ERR = (Rr[8] = "Not found", 8);
jr.NOT_SUPPORTED_ERR = (Rr[9] = "Not supported", 9);
var ov = jr.INUSE_ATTRIBUTE_ERR = (Rr[10] = "Attribute in use", 10);
jr.INVALID_STATE_ERR = (Rr[11] = "Invalid state", 11);
jr.SYNTAX_ERR = (Rr[12] = "Syntax error", 12);
jr.INVALID_MODIFICATION_ERR = (Rr[13] = "Invalid modification", 13);
jr.NAMESPACE_ERR = (Rr[14] = "Invalid namespace", 14);
jr.INVALID_ACCESS_ERR = (Rr[15] = "Invalid access", 15);
function vr(e, t) {
  if (t instanceof Error)
    var r = t;
  else
    r = this, Error.call(this, Rr[e]), this.message = Rr[e], Error.captureStackTrace && Error.captureStackTrace(this, vr);
  return r.code = e, t && (this.message = this.message + ": " + t), r;
}
vr.prototype = Error.prototype;
Tl(jr, vr);
function Un() {
}
Un.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function(e) {
    return e >= 0 && e < this.length ? this[e] : null;
  },
  toString: function(e, t) {
    for (var r = [], n = 0; n < this.length; n++)
      Ps(this[n], r, e, t);
    return r.join("");
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function(e) {
    return Array.prototype.filter.call(this, e);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function(e) {
    return Array.prototype.indexOf.call(this, e);
  }
};
function To(e, t) {
  this._node = e, this._refresh = t, op(this);
}
function op(e) {
  var t = e._node._inc || e._node.ownerDocument._inc;
  if (e._inc !== t) {
    var r = e._refresh(e._node);
    if (t_(e, "length", r.length), !e.$$length || r.length < e.$$length)
      for (var n = r.length; n in e; n++)
        Object.prototype.hasOwnProperty.call(e, n) && delete e[n];
    Tl(r, e), e._inc = t;
  }
}
To.prototype.item = function(e) {
  return op(this), this[e] || null;
};
mi(To, Un);
function Oc() {
}
function Wy(e, t) {
  for (var r = e.length; r--; )
    if (e[r] === t)
      return r;
}
function uv(e, t, r, n) {
  if (n ? t[Wy(t, n)] = r : t[t.length++] = r, e) {
    r.ownerElement = e;
    var i = e.ownerDocument;
    i && (n && Xy(i, e, n), fS(i, e, r));
  }
}
function lv(e, t, r) {
  var n = Wy(t, r);
  if (n >= 0) {
    for (var i = t.length - 1; n < i; )
      t[n] = t[++n];
    if (t.length = i, e) {
      var a = e.ownerDocument;
      a && (Xy(a, e, r), r.ownerElement = null);
    }
  } else
    throw new vr(zy, new Error(e.tagName + "@" + r));
}
Oc.prototype = {
  length: 0,
  item: Un.prototype.item,
  getNamedItem: function(e) {
    for (var t = this.length; t--; ) {
      var r = this[t];
      if (r.nodeName == e)
        return r;
    }
  },
  setNamedItem: function(e) {
    var t = e.ownerElement;
    if (t && t != this._ownerElement)
      throw new vr(ov);
    var r = this.getNamedItem(e.nodeName);
    return uv(this._ownerElement, this, e, r), r;
  },
  /* returns Node */
  setNamedItemNS: function(e) {
    var t = e.ownerElement, r;
    if (t && t != this._ownerElement)
      throw new vr(ov);
    return r = this.getNamedItemNS(e.namespaceURI, e.localName), uv(this._ownerElement, this, e, r), r;
  },
  /* returns Node */
  removeNamedItem: function(e) {
    var t = this.getNamedItem(e);
    return lv(this._ownerElement, this, t), t;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  //for level2
  removeNamedItemNS: function(e, t) {
    var r = this.getNamedItemNS(e, t);
    return lv(this._ownerElement, this, r), r;
  },
  getNamedItemNS: function(e, t) {
    for (var r = this.length; r--; ) {
      var n = this[r];
      if (n.localName == t && n.namespaceURI == e)
        return n;
    }
    return null;
  }
};
function jy() {
}
jy.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function(e, t) {
    return !0;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function(e, t, r) {
    var n = new El();
    if (n.implementation = this, n.childNodes = new Un(), n.doctype = r || null, r && n.appendChild(r), t) {
      var i = n.createElementNS(e, t);
      n.appendChild(i);
    }
    return n;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function(e, t, r) {
    var n = new bh();
    return n.name = e, n.nodeName = e, n.publicId = t || "", n.systemId = r || "", n;
  }
};
function Nt() {
}
Nt.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function(e, t) {
    return Bc(this, e, t);
  },
  replaceChild: function(e, t) {
    Bc(this, e, t, Qy), t && this.removeChild(t);
  },
  removeChild: function(e) {
    return Yy(this, e);
  },
  appendChild: function(e) {
    return this.insertBefore(e, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(e) {
    return Zf(this.ownerDocument || this, this, e);
  },
  // Modified in DOM Level 2:
  normalize: function() {
    for (var e = this.firstChild; e; ) {
      var t = e.nextSibling;
      t && t.nodeType == Ic && e.nodeType == Ic ? (this.removeChild(t), e.appendData(t.data)) : (e.normalize(), e = t);
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function(e, t) {
    return this.ownerDocument.implementation.hasFeature(e, t);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function(e) {
    for (var t = this; t; ) {
      var r = t._nsMap;
      if (r) {
        for (var n in r)
          if (Object.prototype.hasOwnProperty.call(r, n) && r[n] === e)
            return n;
      }
      t = t.nodeType == Ao ? t.ownerDocument : t.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function(e) {
    for (var t = this; t; ) {
      var r = t._nsMap;
      if (r && Object.prototype.hasOwnProperty.call(r, e))
        return r[e];
      t = t.nodeType == Ao ? t.ownerDocument : t.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function(e) {
    var t = this.lookupPrefix(e);
    return t == null;
  }
};
function qy(e) {
  return e == "<" && "&lt;" || e == ">" && "&gt;" || e == "&" && "&amp;" || e == '"' && "&quot;" || "&#" + e.charCodeAt() + ";";
}
Tl(vi, Nt);
Tl(vi, Nt.prototype);
function cl(e, t) {
  if (t(e))
    return !0;
  if (e = e.firstChild)
    do
      if (cl(e, t))
        return !0;
    while (e = e.nextSibling);
}
function El() {
  this.ownerDocument = this;
}
function fS(e, t, r) {
  e && e._inc++;
  var n = r.namespaceURI;
  n === ll.XMLNS && (t._nsMap[r.prefix ? r.localName : ""] = r.value);
}
function Xy(e, t, r, n) {
  e && e._inc++;
  var i = r.namespaceURI;
  i === ll.XMLNS && delete t._nsMap[r.prefix ? r.localName : ""];
}
function up(e, t, r) {
  if (e && e._inc) {
    e._inc++;
    var n = t.childNodes;
    if (r)
      n[n.length++] = r;
    else {
      for (var i = t.firstChild, a = 0; i; )
        n[a++] = i, i = i.nextSibling;
      n.length = a, delete n[n.length];
    }
  }
}
function Yy(e, t) {
  var r = t.previousSibling, n = t.nextSibling;
  return r ? r.nextSibling = n : e.firstChild = n, n ? n.previousSibling = r : e.lastChild = r, t.parentNode = null, t.previousSibling = null, t.nextSibling = null, up(e.ownerDocument, e), t;
}
function dS(e) {
  return e && (e.nodeType === Nt.DOCUMENT_NODE || e.nodeType === Nt.DOCUMENT_FRAGMENT_NODE || e.nodeType === Nt.ELEMENT_NODE);
}
function pS(e) {
  return e && (gn(e) || lp(e) || jn(e) || e.nodeType === Nt.DOCUMENT_FRAGMENT_NODE || e.nodeType === Nt.COMMENT_NODE || e.nodeType === Nt.PROCESSING_INSTRUCTION_NODE);
}
function jn(e) {
  return e && e.nodeType === Nt.DOCUMENT_TYPE_NODE;
}
function gn(e) {
  return e && e.nodeType === Nt.ELEMENT_NODE;
}
function lp(e) {
  return e && e.nodeType === Nt.TEXT_NODE;
}
function cv(e, t) {
  var r = e.childNodes || [];
  if (vn(r, gn) || jn(t))
    return !1;
  var n = vn(r, jn);
  return !(t && n && r.indexOf(n) > r.indexOf(t));
}
function hv(e, t) {
  var r = e.childNodes || [];
  function n(a) {
    return gn(a) && a !== t;
  }
  if (vn(r, n))
    return !1;
  var i = vn(r, jn);
  return !(t && i && r.indexOf(i) > r.indexOf(t));
}
function mS(e, t, r) {
  if (!dS(e))
    throw new vr(ui, "Unexpected parent node type " + e.nodeType);
  if (r && r.parentNode !== e)
    throw new vr(zy, "child not in parent");
  if (
    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
    !pS(t) || // 5. If either `node` is a Text node and `parent` is a document,
    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
    // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
    jn(t) && e.nodeType !== Nt.DOCUMENT_NODE
  )
    throw new vr(
      ui,
      "Unexpected node type " + t.nodeType + " for parent node type " + e.nodeType
    );
}
function vS(e, t, r) {
  var n = e.childNodes || [], i = t.childNodes || [];
  if (t.nodeType === Nt.DOCUMENT_FRAGMENT_NODE) {
    var a = i.filter(gn);
    if (a.length > 1 || vn(i, lp))
      throw new vr(ui, "More than one element or text in fragment");
    if (a.length === 1 && !cv(e, r))
      throw new vr(ui, "Element in fragment can not be inserted before doctype");
  }
  if (gn(t) && !cv(e, r))
    throw new vr(ui, "Only one element can be added and only after doctype");
  if (jn(t)) {
    if (vn(n, jn))
      throw new vr(ui, "Only one doctype is allowed");
    var s = vn(n, gn);
    if (r && n.indexOf(s) < n.indexOf(r))
      throw new vr(ui, "Doctype can only be inserted before an element");
    if (!r && s)
      throw new vr(ui, "Doctype can not be appended since element is present");
  }
}
function Qy(e, t, r) {
  var n = e.childNodes || [], i = t.childNodes || [];
  if (t.nodeType === Nt.DOCUMENT_FRAGMENT_NODE) {
    var a = i.filter(gn);
    if (a.length > 1 || vn(i, lp))
      throw new vr(ui, "More than one element or text in fragment");
    if (a.length === 1 && !hv(e, r))
      throw new vr(ui, "Element in fragment can not be inserted before doctype");
  }
  if (gn(t) && !hv(e, r))
    throw new vr(ui, "Only one element can be added and only after doctype");
  if (jn(t)) {
    if (vn(n, function(u) {
      return jn(u) && u !== r;
    }))
      throw new vr(ui, "Only one doctype is allowed");
    var s = vn(n, gn);
    if (r && n.indexOf(s) < n.indexOf(r))
      throw new vr(ui, "Doctype can only be inserted before an element");
  }
}
function Bc(e, t, r, n) {
  mS(e, t, r), e.nodeType === Nt.DOCUMENT_NODE && (n || vS)(e, t, r);
  var i = t.parentNode;
  if (i && i.removeChild(t), t.nodeType === Wn) {
    var a = t.firstChild;
    if (a == null)
      return t;
    var s = t.lastChild;
  } else
    a = s = t;
  var o = r ? r.previousSibling : e.lastChild;
  a.previousSibling = o, s.nextSibling = r, o ? o.nextSibling = a : e.firstChild = a, r == null ? e.lastChild = s : r.previousSibling = s;
  do
    a.parentNode = e;
  while (a !== s && (a = a.nextSibling));
  return up(e.ownerDocument || e, e), t.nodeType == Wn && (t.firstChild = t.lastChild = null), t;
}
function gS(e, t) {
  return t.parentNode && t.parentNode.removeChild(t), t.parentNode = e, t.previousSibling = e.lastChild, t.nextSibling = null, t.previousSibling ? t.previousSibling.nextSibling = t : e.firstChild = t, e.lastChild = t, up(e.ownerDocument, e, t), t;
}
El.prototype = {
  //implementation : null,
  nodeName: "#document",
  nodeType: Vy,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(e, t) {
    if (e.nodeType == Wn) {
      for (var r = e.firstChild; r; ) {
        var n = r.nextSibling;
        this.insertBefore(r, t), r = n;
      }
      return e;
    }
    return Bc(this, e, t), e.ownerDocument = this, this.documentElement === null && e.nodeType === Wi && (this.documentElement = e), e;
  },
  removeChild: function(e) {
    return this.documentElement == e && (this.documentElement = null), Yy(this, e);
  },
  replaceChild: function(e, t) {
    Bc(this, e, t, Qy), e.ownerDocument = this, t && this.removeChild(t), gn(e) && (this.documentElement = e);
  },
  // Introduced in DOM Level 2:
  importNode: function(e, t) {
    return e_(this, e, t);
  },
  // Introduced in DOM Level 2:
  getElementById: function(e) {
    var t = null;
    return cl(this.documentElement, function(r) {
      if (r.nodeType == Wi && r.getAttribute("id") == e)
        return t = r, !0;
    }), t;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function(e) {
    var t = sv(e);
    return new To(this, function(r) {
      var n = [];
      return t.length > 0 && cl(r.documentElement, function(i) {
        if (i !== r && i.nodeType === Wi) {
          var a = i.getAttribute("class");
          if (a) {
            var s = e === a;
            if (!s) {
              var o = sv(a);
              s = t.every(lS(o));
            }
            s && n.push(i);
          }
        }
      }), n;
    });
  },
  //document factory method:
  createElement: function(e) {
    var t = new fs();
    t.ownerDocument = this, t.nodeName = e, t.tagName = e, t.localName = e, t.childNodes = new Un();
    var r = t.attributes = new Oc();
    return r._ownerElement = t, t;
  },
  createDocumentFragment: function() {
    var e = new xh();
    return e.ownerDocument = this, e.childNodes = new Un(), e;
  },
  createTextNode: function(e) {
    var t = new cp();
    return t.ownerDocument = this, t.appendData(e), t;
  },
  createComment: function(e) {
    var t = new hp();
    return t.ownerDocument = this, t.appendData(e), t;
  },
  createCDATASection: function(e) {
    var t = new fp();
    return t.ownerDocument = this, t.appendData(e), t;
  },
  createProcessingInstruction: function(e, t) {
    var r = new pp();
    return r.ownerDocument = this, r.tagName = r.nodeName = r.target = e, r.nodeValue = r.data = t, r;
  },
  createAttribute: function(e) {
    var t = new Fc();
    return t.ownerDocument = this, t.name = e, t.nodeName = e, t.localName = e, t.specified = !0, t;
  },
  createEntityReference: function(e) {
    var t = new dp();
    return t.ownerDocument = this, t.nodeName = e, t;
  },
  // Introduced in DOM Level 2:
  createElementNS: function(e, t) {
    var r = new fs(), n = t.split(":"), i = r.attributes = new Oc();
    return r.childNodes = new Un(), r.ownerDocument = this, r.nodeName = t, r.tagName = t, r.namespaceURI = e, n.length == 2 ? (r.prefix = n[0], r.localName = n[1]) : r.localName = t, i._ownerElement = r, r;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function(e, t) {
    var r = new Fc(), n = t.split(":");
    return r.ownerDocument = this, r.nodeName = t, r.name = t, r.namespaceURI = e, r.specified = !0, n.length == 2 ? (r.prefix = n[0], r.localName = n[1]) : r.localName = t, r;
  }
};
mi(El, Nt);
function fs() {
  this._nsMap = {};
}
fs.prototype = {
  nodeType: Wi,
  hasAttribute: function(e) {
    return this.getAttributeNode(e) != null;
  },
  getAttribute: function(e) {
    var t = this.getAttributeNode(e);
    return t && t.value || "";
  },
  getAttributeNode: function(e) {
    return this.attributes.getNamedItem(e);
  },
  setAttribute: function(e, t) {
    var r = this.ownerDocument.createAttribute(e);
    r.value = r.nodeValue = "" + t, this.setAttributeNode(r);
  },
  removeAttribute: function(e) {
    var t = this.getAttributeNode(e);
    t && this.removeAttributeNode(t);
  },
  //four real opeartion method
  appendChild: function(e) {
    return e.nodeType === Wn ? this.insertBefore(e, null) : gS(this, e);
  },
  setAttributeNode: function(e) {
    return this.attributes.setNamedItem(e);
  },
  setAttributeNodeNS: function(e) {
    return this.attributes.setNamedItemNS(e);
  },
  removeAttributeNode: function(e) {
    return this.attributes.removeNamedItem(e.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function(e, t) {
    var r = this.getAttributeNodeNS(e, t);
    r && this.removeAttributeNode(r);
  },
  hasAttributeNS: function(e, t) {
    return this.getAttributeNodeNS(e, t) != null;
  },
  getAttributeNS: function(e, t) {
    var r = this.getAttributeNodeNS(e, t);
    return r && r.value || "";
  },
  setAttributeNS: function(e, t, r) {
    var n = this.ownerDocument.createAttributeNS(e, t);
    n.value = n.nodeValue = "" + r, this.setAttributeNode(n);
  },
  getAttributeNodeNS: function(e, t) {
    return this.attributes.getNamedItemNS(e, t);
  },
  getElementsByTagName: function(e) {
    return new To(this, function(t) {
      var r = [];
      return cl(t, function(n) {
        n !== t && n.nodeType == Wi && (e === "*" || n.tagName == e) && r.push(n);
      }), r;
    });
  },
  getElementsByTagNameNS: function(e, t) {
    return new To(this, function(r) {
      var n = [];
      return cl(r, function(i) {
        i !== r && i.nodeType === Wi && (e === "*" || i.namespaceURI === e) && (t === "*" || i.localName == t) && n.push(i);
      }), n;
    });
  }
};
El.prototype.getElementsByTagName = fs.prototype.getElementsByTagName;
El.prototype.getElementsByTagNameNS = fs.prototype.getElementsByTagNameNS;
mi(fs, Nt);
function Fc() {
}
Fc.prototype.nodeType = Ao;
mi(Fc, Nt);
function wl() {
}
wl.prototype = {
  data: "",
  substringData: function(e, t) {
    return this.data.substring(e, e + t);
  },
  appendData: function(e) {
    e = this.data + e, this.nodeValue = this.data = e, this.length = e.length;
  },
  insertData: function(e, t) {
    this.replaceData(e, 0, t);
  },
  appendChild: function(e) {
    throw new Error(Rr[ui]);
  },
  deleteData: function(e, t) {
    this.replaceData(e, t, "");
  },
  replaceData: function(e, t, r) {
    var n = this.data.substring(0, e), i = this.data.substring(e + t);
    r = n + r + i, this.nodeValue = this.data = r, this.length = r.length;
  }
};
mi(wl, Nt);
function cp() {
}
cp.prototype = {
  nodeName: "#text",
  nodeType: Ic,
  splitText: function(e) {
    var t = this.data, r = t.substring(e);
    t = t.substring(0, e), this.data = this.nodeValue = t, this.length = t.length;
    var n = this.ownerDocument.createTextNode(r);
    return this.parentNode && this.parentNode.insertBefore(n, this.nextSibling), n;
  }
};
mi(cp, wl);
function hp() {
}
hp.prototype = {
  nodeName: "#comment",
  nodeType: Gy
};
mi(hp, wl);
function fp() {
}
fp.prototype = {
  nodeName: "#cdata-section",
  nodeType: ky
};
mi(fp, wl);
function bh() {
}
bh.prototype.nodeType = Hy;
mi(bh, Nt);
function Ky() {
}
Ky.prototype.nodeType = hS;
mi(Ky, Nt);
function $y() {
}
$y.prototype.nodeType = cS;
mi($y, Nt);
function dp() {
}
dp.prototype.nodeType = Ny;
mi(dp, Nt);
function xh() {
}
xh.prototype.nodeName = "#document-fragment";
xh.prototype.nodeType = Wn;
mi(xh, Nt);
function pp() {
}
pp.prototype.nodeType = Uy;
mi(pp, Nt);
function Zy() {
}
Zy.prototype.serializeToString = function(e, t, r) {
  return Jy.call(e, t, r);
};
Nt.prototype.toString = Jy;
function Jy(e, t) {
  var r = [], n = this.nodeType == 9 && this.documentElement || this, i = n.prefix, a = n.namespaceURI;
  if (a && i == null) {
    var i = n.lookupPrefix(a);
    if (i == null)
      var s = [
        { namespace: a, prefix: null }
        //{namespace:uri,prefix:''}
      ];
  }
  return Ps(this, r, e, t, s), r.join("");
}
function fv(e, t, r) {
  var n = e.prefix || "", i = e.namespaceURI;
  if (!i || n === "xml" && i === ll.XML || i === ll.XMLNS)
    return !1;
  for (var a = r.length; a--; ) {
    var s = r[a];
    if (s.prefix === n)
      return s.namespace !== i;
  }
  return !0;
}
function rf(e, t, r) {
  e.push(" ", t, '="', r.replace(/[<>&"\t\n\r]/g, qy), '"');
}
function Ps(e, t, r, n, i) {
  if (i || (i = []), n)
    if (e = n(e), e) {
      if (typeof e == "string") {
        t.push(e);
        return;
      }
    } else
      return;
  switch (e.nodeType) {
    case Wi:
      var a = e.attributes, s = a.length, x = e.firstChild, o = e.tagName;
      r = ll.isHTML(e.namespaceURI) || r;
      var u = o;
      if (!r && !e.prefix && e.namespaceURI) {
        for (var l, c = 0; c < a.length; c++)
          if (a.item(c).name === "xmlns") {
            l = a.item(c).value;
            break;
          }
        if (!l)
          for (var h = i.length - 1; h >= 0; h--) {
            var f = i[h];
            if (f.prefix === "" && f.namespace === e.namespaceURI) {
              l = f.namespace;
              break;
            }
          }
        if (l !== e.namespaceURI)
          for (var h = i.length - 1; h >= 0; h--) {
            var f = i[h];
            if (f.namespace === e.namespaceURI) {
              f.prefix && (u = f.prefix + ":" + o);
              break;
            }
          }
      }
      t.push("<", u);
      for (var d = 0; d < s; d++) {
        var p = a.item(d);
        p.prefix == "xmlns" ? i.push({ prefix: p.localName, namespace: p.value }) : p.nodeName == "xmlns" && i.push({ prefix: "", namespace: p.value });
      }
      for (var d = 0; d < s; d++) {
        var p = a.item(d);
        if (fv(p, r, i)) {
          var _ = p.prefix || "", v = p.namespaceURI;
          rf(t, _ ? "xmlns:" + _ : "xmlns", v), i.push({ prefix: _, namespace: v });
        }
        Ps(p, t, r, n, i);
      }
      if (o === u && fv(e, r, i)) {
        var _ = e.prefix || "", v = e.namespaceURI;
        rf(t, _ ? "xmlns:" + _ : "xmlns", v), i.push({ prefix: _, namespace: v });
      }
      if (x || r && !/^(?:meta|link|img|br|hr|input)$/i.test(o)) {
        if (t.push(">"), r && /^script$/i.test(o))
          for (; x; )
            x.data ? t.push(x.data) : Ps(x, t, r, n, i.slice()), x = x.nextSibling;
        else
          for (; x; )
            Ps(x, t, r, n, i.slice()), x = x.nextSibling;
        t.push("</", u, ">");
      } else
        t.push("/>");
      return;
    case Vy:
    case Wn:
      for (var x = e.firstChild; x; )
        Ps(x, t, r, n, i.slice()), x = x.nextSibling;
      return;
    case Ao:
      return rf(t, e.name, e.value);
    case Ic:
      return t.push(
        e.data.replace(/[<&>]/g, qy)
      );
    case ky:
      return t.push("<![CDATA[", e.data, "]]>");
    case Gy:
      return t.push("<!--", e.data, "-->");
    case Hy:
      var E = e.publicId, M = e.systemId;
      if (t.push("<!DOCTYPE ", e.name), E)
        t.push(" PUBLIC ", E), M && M != "." && t.push(" ", M), t.push(">");
      else if (M && M != ".")
        t.push(" SYSTEM ", M, ">");
      else {
        var C = e.internalSubset;
        C && t.push(" [", C, "]"), t.push(">");
      }
      return;
    case Uy:
      return t.push("<?", e.target, " ", e.data, "?>");
    case Ny:
      return t.push("&", e.nodeName, ";");
    default:
      t.push("??", e.nodeName);
  }
}
function e_(e, t, r) {
  var n;
  switch (t.nodeType) {
    case Wi:
      n = t.cloneNode(!1), n.ownerDocument = e;
    case Wn:
      break;
    case Ao:
      r = !0;
      break;
  }
  if (n || (n = t.cloneNode(!1)), n.ownerDocument = e, n.parentNode = null, r)
    for (var i = t.firstChild; i; )
      n.appendChild(e_(e, i, r)), i = i.nextSibling;
  return n;
}
function Zf(e, t, r) {
  var n = new t.constructor();
  for (var i in t)
    if (Object.prototype.hasOwnProperty.call(t, i)) {
      var a = t[i];
      typeof a != "object" && a != n[i] && (n[i] = a);
    }
  switch (t.childNodes && (n.childNodes = new Un()), n.ownerDocument = e, n.nodeType) {
    case Wi:
      var s = t.attributes, o = n.attributes = new Oc(), u = s.length;
      o._ownerElement = n;
      for (var l = 0; l < u; l++)
        n.setAttributeNode(Zf(e, s.item(l), !0));
      break;
    case Ao:
      r = !0;
  }
  if (r)
    for (var c = t.firstChild; c; )
      n.appendChild(Zf(e, c, r)), c = c.nextSibling;
  return n;
}
function t_(e, t, r) {
  e[t] = r;
}
try {
  if (Object.defineProperty) {
    let e = function(t) {
      switch (t.nodeType) {
        case Wi:
        case Wn:
          var r = [];
          for (t = t.firstChild; t; )
            t.nodeType !== 7 && t.nodeType !== 8 && r.push(e(t)), t = t.nextSibling;
          return r.join("");
        default:
          return t.nodeValue;
      }
    };
    Object.defineProperty(To.prototype, "length", {
      get: function() {
        return op(this), this.$$length;
      }
    }), Object.defineProperty(Nt.prototype, "textContent", {
      get: function() {
        return e(this);
      },
      set: function(t) {
        switch (this.nodeType) {
          case Wi:
          case Wn:
            for (; this.firstChild; )
              this.removeChild(this.firstChild);
            (t || String(t)) && this.appendChild(this.ownerDocument.createTextNode(t));
            break;
          default:
            this.data = t, this.value = t, this.nodeValue = t;
        }
      }
    }), t_ = function(t, r, n) {
      t["$$" + r] = n;
    };
  }
} catch {
}
_a.DocumentType = bh;
_a.DOMException = vr;
_a.DOMImplementation = jy;
_a.Element = fs;
_a.Node = Nt;
_a.NodeList = Un;
_a.XMLSerializer = Zy;
var Ah = {}, r_ = {};
(function(e) {
  var t = Zn.freeze;
  e.XML_ENTITIES = t({
    amp: "&",
    apos: "'",
    gt: ">",
    lt: "<",
    quot: '"'
  }), e.HTML_ENTITIES = t({
    Aacute: "",
    aacute: "",
    Abreve: "",
    abreve: "",
    ac: "",
    acd: "",
    acE: "",
    Acirc: "",
    acirc: "",
    acute: "",
    Acy: "",
    acy: "",
    AElig: "",
    aelig: "",
    af: "",
    Afr: "",
    afr: "",
    Agrave: "",
    agrave: "",
    alefsym: "",
    aleph: "",
    Alpha: "",
    alpha: "",
    Amacr: "",
    amacr: "",
    amalg: "",
    AMP: "&",
    amp: "&",
    And: "",
    and: "",
    andand: "",
    andd: "",
    andslope: "",
    andv: "",
    ang: "",
    ange: "",
    angle: "",
    angmsd: "",
    angmsdaa: "",
    angmsdab: "",
    angmsdac: "",
    angmsdad: "",
    angmsdae: "",
    angmsdaf: "",
    angmsdag: "",
    angmsdah: "",
    angrt: "",
    angrtvb: "",
    angrtvbd: "",
    angsph: "",
    angst: "",
    angzarr: "",
    Aogon: "",
    aogon: "",
    Aopf: "",
    aopf: "",
    ap: "",
    apacir: "",
    apE: "",
    ape: "",
    apid: "",
    apos: "'",
    ApplyFunction: "",
    approx: "",
    approxeq: "",
    Aring: "",
    aring: "",
    Ascr: "",
    ascr: "",
    Assign: "",
    ast: "*",
    asymp: "",
    asympeq: "",
    Atilde: "",
    atilde: "",
    Auml: "",
    auml: "",
    awconint: "",
    awint: "",
    backcong: "",
    backepsilon: "",
    backprime: "",
    backsim: "",
    backsimeq: "",
    Backslash: "",
    Barv: "",
    barvee: "",
    Barwed: "",
    barwed: "",
    barwedge: "",
    bbrk: "",
    bbrktbrk: "",
    bcong: "",
    Bcy: "",
    bcy: "",
    bdquo: "",
    becaus: "",
    Because: "",
    because: "",
    bemptyv: "",
    bepsi: "",
    bernou: "",
    Bernoullis: "",
    Beta: "",
    beta: "",
    beth: "",
    between: "",
    Bfr: "",
    bfr: "",
    bigcap: "",
    bigcirc: "",
    bigcup: "",
    bigodot: "",
    bigoplus: "",
    bigotimes: "",
    bigsqcup: "",
    bigstar: "",
    bigtriangledown: "",
    bigtriangleup: "",
    biguplus: "",
    bigvee: "",
    bigwedge: "",
    bkarow: "",
    blacklozenge: "",
    blacksquare: "",
    blacktriangle: "",
    blacktriangledown: "",
    blacktriangleleft: "",
    blacktriangleright: "",
    blank: "",
    blk12: "",
    blk14: "",
    blk34: "",
    block: "",
    bne: "=",
    bnequiv: "",
    bNot: "",
    bnot: "",
    Bopf: "",
    bopf: "",
    bot: "",
    bottom: "",
    bowtie: "",
    boxbox: "",
    boxDL: "",
    boxDl: "",
    boxdL: "",
    boxdl: "",
    boxDR: "",
    boxDr: "",
    boxdR: "",
    boxdr: "",
    boxH: "",
    boxh: "",
    boxHD: "",
    boxHd: "",
    boxhD: "",
    boxhd: "",
    boxHU: "",
    boxHu: "",
    boxhU: "",
    boxhu: "",
    boxminus: "",
    boxplus: "",
    boxtimes: "",
    boxUL: "",
    boxUl: "",
    boxuL: "",
    boxul: "",
    boxUR: "",
    boxUr: "",
    boxuR: "",
    boxur: "",
    boxV: "",
    boxv: "",
    boxVH: "",
    boxVh: "",
    boxvH: "",
    boxvh: "",
    boxVL: "",
    boxVl: "",
    boxvL: "",
    boxvl: "",
    boxVR: "",
    boxVr: "",
    boxvR: "",
    boxvr: "",
    bprime: "",
    Breve: "",
    breve: "",
    brvbar: "",
    Bscr: "",
    bscr: "",
    bsemi: "",
    bsim: "",
    bsime: "",
    bsol: "\\",
    bsolb: "",
    bsolhsub: "",
    bull: "",
    bullet: "",
    bump: "",
    bumpE: "",
    bumpe: "",
    Bumpeq: "",
    bumpeq: "",
    Cacute: "",
    cacute: "",
    Cap: "",
    cap: "",
    capand: "",
    capbrcup: "",
    capcap: "",
    capcup: "",
    capdot: "",
    CapitalDifferentialD: "",
    caps: "",
    caret: "",
    caron: "",
    Cayleys: "",
    ccaps: "",
    Ccaron: "",
    ccaron: "",
    Ccedil: "",
    ccedil: "",
    Ccirc: "",
    ccirc: "",
    Cconint: "",
    ccups: "",
    ccupssm: "",
    Cdot: "",
    cdot: "",
    cedil: "",
    Cedilla: "",
    cemptyv: "",
    cent: "",
    CenterDot: "",
    centerdot: "",
    Cfr: "",
    cfr: "",
    CHcy: "",
    chcy: "",
    check: "",
    checkmark: "",
    Chi: "",
    chi: "",
    cir: "",
    circ: "",
    circeq: "",
    circlearrowleft: "",
    circlearrowright: "",
    circledast: "",
    circledcirc: "",
    circleddash: "",
    CircleDot: "",
    circledR: "",
    circledS: "",
    CircleMinus: "",
    CirclePlus: "",
    CircleTimes: "",
    cirE: "",
    cire: "",
    cirfnint: "",
    cirmid: "",
    cirscir: "",
    ClockwiseContourIntegral: "",
    CloseCurlyDoubleQuote: "",
    CloseCurlyQuote: "",
    clubs: "",
    clubsuit: "",
    Colon: "",
    colon: ":",
    Colone: "",
    colone: "",
    coloneq: "",
    comma: ",",
    commat: "@",
    comp: "",
    compfn: "",
    complement: "",
    complexes: "",
    cong: "",
    congdot: "",
    Congruent: "",
    Conint: "",
    conint: "",
    ContourIntegral: "",
    Copf: "",
    copf: "",
    coprod: "",
    Coproduct: "",
    COPY: "",
    copy: "",
    copysr: "",
    CounterClockwiseContourIntegral: "",
    crarr: "",
    Cross: "",
    cross: "",
    Cscr: "",
    cscr: "",
    csub: "",
    csube: "",
    csup: "",
    csupe: "",
    ctdot: "",
    cudarrl: "",
    cudarrr: "",
    cuepr: "",
    cuesc: "",
    cularr: "",
    cularrp: "",
    Cup: "",
    cup: "",
    cupbrcap: "",
    CupCap: "",
    cupcap: "",
    cupcup: "",
    cupdot: "",
    cupor: "",
    cups: "",
    curarr: "",
    curarrm: "",
    curlyeqprec: "",
    curlyeqsucc: "",
    curlyvee: "",
    curlywedge: "",
    curren: "",
    curvearrowleft: "",
    curvearrowright: "",
    cuvee: "",
    cuwed: "",
    cwconint: "",
    cwint: "",
    cylcty: "",
    Dagger: "",
    dagger: "",
    daleth: "",
    Darr: "",
    dArr: "",
    darr: "",
    dash: "",
    Dashv: "",
    dashv: "",
    dbkarow: "",
    dblac: "",
    Dcaron: "",
    dcaron: "",
    Dcy: "",
    dcy: "",
    DD: "",
    dd: "",
    ddagger: "",
    ddarr: "",
    DDotrahd: "",
    ddotseq: "",
    deg: "",
    Del: "",
    Delta: "",
    delta: "",
    demptyv: "",
    dfisht: "",
    Dfr: "",
    dfr: "",
    dHar: "",
    dharl: "",
    dharr: "",
    DiacriticalAcute: "",
    DiacriticalDot: "",
    DiacriticalDoubleAcute: "",
    DiacriticalGrave: "`",
    DiacriticalTilde: "",
    diam: "",
    Diamond: "",
    diamond: "",
    diamondsuit: "",
    diams: "",
    die: "",
    DifferentialD: "",
    digamma: "",
    disin: "",
    div: "",
    divide: "",
    divideontimes: "",
    divonx: "",
    DJcy: "",
    djcy: "",
    dlcorn: "",
    dlcrop: "",
    dollar: "$",
    Dopf: "",
    dopf: "",
    Dot: "",
    dot: "",
    DotDot: "",
    doteq: "",
    doteqdot: "",
    DotEqual: "",
    dotminus: "",
    dotplus: "",
    dotsquare: "",
    doublebarwedge: "",
    DoubleContourIntegral: "",
    DoubleDot: "",
    DoubleDownArrow: "",
    DoubleLeftArrow: "",
    DoubleLeftRightArrow: "",
    DoubleLeftTee: "",
    DoubleLongLeftArrow: "",
    DoubleLongLeftRightArrow: "",
    DoubleLongRightArrow: "",
    DoubleRightArrow: "",
    DoubleRightTee: "",
    DoubleUpArrow: "",
    DoubleUpDownArrow: "",
    DoubleVerticalBar: "",
    DownArrow: "",
    Downarrow: "",
    downarrow: "",
    DownArrowBar: "",
    DownArrowUpArrow: "",
    DownBreve: "",
    downdownarrows: "",
    downharpoonleft: "",
    downharpoonright: "",
    DownLeftRightVector: "",
    DownLeftTeeVector: "",
    DownLeftVector: "",
    DownLeftVectorBar: "",
    DownRightTeeVector: "",
    DownRightVector: "",
    DownRightVectorBar: "",
    DownTee: "",
    DownTeeArrow: "",
    drbkarow: "",
    drcorn: "",
    drcrop: "",
    Dscr: "",
    dscr: "",
    DScy: "",
    dscy: "",
    dsol: "",
    Dstrok: "",
    dstrok: "",
    dtdot: "",
    dtri: "",
    dtrif: "",
    duarr: "",
    duhar: "",
    dwangle: "",
    DZcy: "",
    dzcy: "",
    dzigrarr: "",
    Eacute: "",
    eacute: "",
    easter: "",
    Ecaron: "",
    ecaron: "",
    ecir: "",
    Ecirc: "",
    ecirc: "",
    ecolon: "",
    Ecy: "",
    ecy: "",
    eDDot: "",
    Edot: "",
    eDot: "",
    edot: "",
    ee: "",
    efDot: "",
    Efr: "",
    efr: "",
    eg: "",
    Egrave: "",
    egrave: "",
    egs: "",
    egsdot: "",
    el: "",
    Element: "",
    elinters: "",
    ell: "",
    els: "",
    elsdot: "",
    Emacr: "",
    emacr: "",
    empty: "",
    emptyset: "",
    EmptySmallSquare: "",
    emptyv: "",
    EmptyVerySmallSquare: "",
    emsp: "",
    emsp13: "",
    emsp14: "",
    ENG: "",
    eng: "",
    ensp: "",
    Eogon: "",
    eogon: "",
    Eopf: "",
    eopf: "",
    epar: "",
    eparsl: "",
    eplus: "",
    epsi: "",
    Epsilon: "",
    epsilon: "",
    epsiv: "",
    eqcirc: "",
    eqcolon: "",
    eqsim: "",
    eqslantgtr: "",
    eqslantless: "",
    Equal: "",
    equals: "=",
    EqualTilde: "",
    equest: "",
    Equilibrium: "",
    equiv: "",
    equivDD: "",
    eqvparsl: "",
    erarr: "",
    erDot: "",
    Escr: "",
    escr: "",
    esdot: "",
    Esim: "",
    esim: "",
    Eta: "",
    eta: "",
    ETH: "",
    eth: "",
    Euml: "",
    euml: "",
    euro: "",
    excl: "!",
    exist: "",
    Exists: "",
    expectation: "",
    ExponentialE: "",
    exponentiale: "",
    fallingdotseq: "",
    Fcy: "",
    fcy: "",
    female: "",
    ffilig: "",
    fflig: "",
    ffllig: "",
    Ffr: "",
    ffr: "",
    filig: "",
    FilledSmallSquare: "",
    FilledVerySmallSquare: "",
    fjlig: "fj",
    flat: "",
    fllig: "",
    fltns: "",
    fnof: "",
    Fopf: "",
    fopf: "",
    ForAll: "",
    forall: "",
    fork: "",
    forkv: "",
    Fouriertrf: "",
    fpartint: "",
    frac12: "",
    frac13: "",
    frac14: "",
    frac15: "",
    frac16: "",
    frac18: "",
    frac23: "",
    frac25: "",
    frac34: "",
    frac35: "",
    frac38: "",
    frac45: "",
    frac56: "",
    frac58: "",
    frac78: "",
    frasl: "",
    frown: "",
    Fscr: "",
    fscr: "",
    gacute: "",
    Gamma: "",
    gamma: "",
    Gammad: "",
    gammad: "",
    gap: "",
    Gbreve: "",
    gbreve: "",
    Gcedil: "",
    Gcirc: "",
    gcirc: "",
    Gcy: "",
    gcy: "",
    Gdot: "",
    gdot: "",
    gE: "",
    ge: "",
    gEl: "",
    gel: "",
    geq: "",
    geqq: "",
    geqslant: "",
    ges: "",
    gescc: "",
    gesdot: "",
    gesdoto: "",
    gesdotol: "",
    gesl: "",
    gesles: "",
    Gfr: "",
    gfr: "",
    Gg: "",
    gg: "",
    ggg: "",
    gimel: "",
    GJcy: "",
    gjcy: "",
    gl: "",
    gla: "",
    glE: "",
    glj: "",
    gnap: "",
    gnapprox: "",
    gnE: "",
    gne: "",
    gneq: "",
    gneqq: "",
    gnsim: "",
    Gopf: "",
    gopf: "",
    grave: "`",
    GreaterEqual: "",
    GreaterEqualLess: "",
    GreaterFullEqual: "",
    GreaterGreater: "",
    GreaterLess: "",
    GreaterSlantEqual: "",
    GreaterTilde: "",
    Gscr: "",
    gscr: "",
    gsim: "",
    gsime: "",
    gsiml: "",
    Gt: "",
    GT: ">",
    gt: ">",
    gtcc: "",
    gtcir: "",
    gtdot: "",
    gtlPar: "",
    gtquest: "",
    gtrapprox: "",
    gtrarr: "",
    gtrdot: "",
    gtreqless: "",
    gtreqqless: "",
    gtrless: "",
    gtrsim: "",
    gvertneqq: "",
    gvnE: "",
    Hacek: "",
    hairsp: "",
    half: "",
    hamilt: "",
    HARDcy: "",
    hardcy: "",
    hArr: "",
    harr: "",
    harrcir: "",
    harrw: "",
    Hat: "^",
    hbar: "",
    Hcirc: "",
    hcirc: "",
    hearts: "",
    heartsuit: "",
    hellip: "",
    hercon: "",
    Hfr: "",
    hfr: "",
    HilbertSpace: "",
    hksearow: "",
    hkswarow: "",
    hoarr: "",
    homtht: "",
    hookleftarrow: "",
    hookrightarrow: "",
    Hopf: "",
    hopf: "",
    horbar: "",
    HorizontalLine: "",
    Hscr: "",
    hscr: "",
    hslash: "",
    Hstrok: "",
    hstrok: "",
    HumpDownHump: "",
    HumpEqual: "",
    hybull: "",
    hyphen: "",
    Iacute: "",
    iacute: "",
    ic: "",
    Icirc: "",
    icirc: "",
    Icy: "",
    icy: "",
    Idot: "",
    IEcy: "",
    iecy: "",
    iexcl: "",
    iff: "",
    Ifr: "",
    ifr: "",
    Igrave: "",
    igrave: "",
    ii: "",
    iiiint: "",
    iiint: "",
    iinfin: "",
    iiota: "",
    IJlig: "",
    ijlig: "",
    Im: "",
    Imacr: "",
    imacr: "",
    image: "",
    ImaginaryI: "",
    imagline: "",
    imagpart: "",
    imath: "",
    imof: "",
    imped: "",
    Implies: "",
    in: "",
    incare: "",
    infin: "",
    infintie: "",
    inodot: "",
    Int: "",
    int: "",
    intcal: "",
    integers: "",
    Integral: "",
    intercal: "",
    Intersection: "",
    intlarhk: "",
    intprod: "",
    InvisibleComma: "",
    InvisibleTimes: "",
    IOcy: "",
    iocy: "",
    Iogon: "",
    iogon: "",
    Iopf: "",
    iopf: "",
    Iota: "",
    iota: "",
    iprod: "",
    iquest: "",
    Iscr: "",
    iscr: "",
    isin: "",
    isindot: "",
    isinE: "",
    isins: "",
    isinsv: "",
    isinv: "",
    it: "",
    Itilde: "",
    itilde: "",
    Iukcy: "",
    iukcy: "",
    Iuml: "",
    iuml: "",
    Jcirc: "",
    jcirc: "",
    Jcy: "",
    jcy: "",
    Jfr: "",
    jfr: "",
    jmath: "",
    Jopf: "",
    jopf: "",
    Jscr: "",
    jscr: "",
    Jsercy: "",
    jsercy: "",
    Jukcy: "",
    jukcy: "",
    Kappa: "",
    kappa: "",
    kappav: "",
    Kcedil: "",
    kcedil: "",
    Kcy: "",
    kcy: "",
    Kfr: "",
    kfr: "",
    kgreen: "",
    KHcy: "",
    khcy: "",
    KJcy: "",
    kjcy: "",
    Kopf: "",
    kopf: "",
    Kscr: "",
    kscr: "",
    lAarr: "",
    Lacute: "",
    lacute: "",
    laemptyv: "",
    lagran: "",
    Lambda: "",
    lambda: "",
    Lang: "",
    lang: "",
    langd: "",
    langle: "",
    lap: "",
    Laplacetrf: "",
    laquo: "",
    Larr: "",
    lArr: "",
    larr: "",
    larrb: "",
    larrbfs: "",
    larrfs: "",
    larrhk: "",
    larrlp: "",
    larrpl: "",
    larrsim: "",
    larrtl: "",
    lat: "",
    lAtail: "",
    latail: "",
    late: "",
    lates: "",
    lBarr: "",
    lbarr: "",
    lbbrk: "",
    lbrace: "{",
    lbrack: "[",
    lbrke: "",
    lbrksld: "",
    lbrkslu: "",
    Lcaron: "",
    lcaron: "",
    Lcedil: "",
    lcedil: "",
    lceil: "",
    lcub: "{",
    Lcy: "",
    lcy: "",
    ldca: "",
    ldquo: "",
    ldquor: "",
    ldrdhar: "",
    ldrushar: "",
    ldsh: "",
    lE: "",
    le: "",
    LeftAngleBracket: "",
    LeftArrow: "",
    Leftarrow: "",
    leftarrow: "",
    LeftArrowBar: "",
    LeftArrowRightArrow: "",
    leftarrowtail: "",
    LeftCeiling: "",
    LeftDoubleBracket: "",
    LeftDownTeeVector: "",
    LeftDownVector: "",
    LeftDownVectorBar: "",
    LeftFloor: "",
    leftharpoondown: "",
    leftharpoonup: "",
    leftleftarrows: "",
    LeftRightArrow: "",
    Leftrightarrow: "",
    leftrightarrow: "",
    leftrightarrows: "",
    leftrightharpoons: "",
    leftrightsquigarrow: "",
    LeftRightVector: "",
    LeftTee: "",
    LeftTeeArrow: "",
    LeftTeeVector: "",
    leftthreetimes: "",
    LeftTriangle: "",
    LeftTriangleBar: "",
    LeftTriangleEqual: "",
    LeftUpDownVector: "",
    LeftUpTeeVector: "",
    LeftUpVector: "",
    LeftUpVectorBar: "",
    LeftVector: "",
    LeftVectorBar: "",
    lEg: "",
    leg: "",
    leq: "",
    leqq: "",
    leqslant: "",
    les: "",
    lescc: "",
    lesdot: "",
    lesdoto: "",
    lesdotor: "",
    lesg: "",
    lesges: "",
    lessapprox: "",
    lessdot: "",
    lesseqgtr: "",
    lesseqqgtr: "",
    LessEqualGreater: "",
    LessFullEqual: "",
    LessGreater: "",
    lessgtr: "",
    LessLess: "",
    lesssim: "",
    LessSlantEqual: "",
    LessTilde: "",
    lfisht: "",
    lfloor: "",
    Lfr: "",
    lfr: "",
    lg: "",
    lgE: "",
    lHar: "",
    lhard: "",
    lharu: "",
    lharul: "",
    lhblk: "",
    LJcy: "",
    ljcy: "",
    Ll: "",
    ll: "",
    llarr: "",
    llcorner: "",
    Lleftarrow: "",
    llhard: "",
    lltri: "",
    Lmidot: "",
    lmidot: "",
    lmoust: "",
    lmoustache: "",
    lnap: "",
    lnapprox: "",
    lnE: "",
    lne: "",
    lneq: "",
    lneqq: "",
    lnsim: "",
    loang: "",
    loarr: "",
    lobrk: "",
    LongLeftArrow: "",
    Longleftarrow: "",
    longleftarrow: "",
    LongLeftRightArrow: "",
    Longleftrightarrow: "",
    longleftrightarrow: "",
    longmapsto: "",
    LongRightArrow: "",
    Longrightarrow: "",
    longrightarrow: "",
    looparrowleft: "",
    looparrowright: "",
    lopar: "",
    Lopf: "",
    lopf: "",
    loplus: "",
    lotimes: "",
    lowast: "",
    lowbar: "_",
    LowerLeftArrow: "",
    LowerRightArrow: "",
    loz: "",
    lozenge: "",
    lozf: "",
    lpar: "(",
    lparlt: "",
    lrarr: "",
    lrcorner: "",
    lrhar: "",
    lrhard: "",
    lrm: "",
    lrtri: "",
    lsaquo: "",
    Lscr: "",
    lscr: "",
    Lsh: "",
    lsh: "",
    lsim: "",
    lsime: "",
    lsimg: "",
    lsqb: "[",
    lsquo: "",
    lsquor: "",
    Lstrok: "",
    lstrok: "",
    Lt: "",
    LT: "<",
    lt: "<",
    ltcc: "",
    ltcir: "",
    ltdot: "",
    lthree: "",
    ltimes: "",
    ltlarr: "",
    ltquest: "",
    ltri: "",
    ltrie: "",
    ltrif: "",
    ltrPar: "",
    lurdshar: "",
    luruhar: "",
    lvertneqq: "",
    lvnE: "",
    macr: "",
    male: "",
    malt: "",
    maltese: "",
    Map: "",
    map: "",
    mapsto: "",
    mapstodown: "",
    mapstoleft: "",
    mapstoup: "",
    marker: "",
    mcomma: "",
    Mcy: "",
    mcy: "",
    mdash: "",
    mDDot: "",
    measuredangle: "",
    MediumSpace: "",
    Mellintrf: "",
    Mfr: "",
    mfr: "",
    mho: "",
    micro: "",
    mid: "",
    midast: "*",
    midcir: "",
    middot: "",
    minus: "",
    minusb: "",
    minusd: "",
    minusdu: "",
    MinusPlus: "",
    mlcp: "",
    mldr: "",
    mnplus: "",
    models: "",
    Mopf: "",
    mopf: "",
    mp: "",
    Mscr: "",
    mscr: "",
    mstpos: "",
    Mu: "",
    mu: "",
    multimap: "",
    mumap: "",
    nabla: "",
    Nacute: "",
    nacute: "",
    nang: "",
    nap: "",
    napE: "",
    napid: "",
    napos: "",
    napprox: "",
    natur: "",
    natural: "",
    naturals: "",
    nbsp: "",
    nbump: "",
    nbumpe: "",
    ncap: "",
    Ncaron: "",
    ncaron: "",
    Ncedil: "",
    ncedil: "",
    ncong: "",
    ncongdot: "",
    ncup: "",
    Ncy: "",
    ncy: "",
    ndash: "",
    ne: "",
    nearhk: "",
    neArr: "",
    nearr: "",
    nearrow: "",
    nedot: "",
    NegativeMediumSpace: "",
    NegativeThickSpace: "",
    NegativeThinSpace: "",
    NegativeVeryThinSpace: "",
    nequiv: "",
    nesear: "",
    nesim: "",
    NestedGreaterGreater: "",
    NestedLessLess: "",
    NewLine: `
`,
    nexist: "",
    nexists: "",
    Nfr: "",
    nfr: "",
    ngE: "",
    nge: "",
    ngeq: "",
    ngeqq: "",
    ngeqslant: "",
    nges: "",
    nGg: "",
    ngsim: "",
    nGt: "",
    ngt: "",
    ngtr: "",
    nGtv: "",
    nhArr: "",
    nharr: "",
    nhpar: "",
    ni: "",
    nis: "",
    nisd: "",
    niv: "",
    NJcy: "",
    njcy: "",
    nlArr: "",
    nlarr: "",
    nldr: "",
    nlE: "",
    nle: "",
    nLeftarrow: "",
    nleftarrow: "",
    nLeftrightarrow: "",
    nleftrightarrow: "",
    nleq: "",
    nleqq: "",
    nleqslant: "",
    nles: "",
    nless: "",
    nLl: "",
    nlsim: "",
    nLt: "",
    nlt: "",
    nltri: "",
    nltrie: "",
    nLtv: "",
    nmid: "",
    NoBreak: "",
    NonBreakingSpace: "",
    Nopf: "",
    nopf: "",
    Not: "",
    not: "",
    NotCongruent: "",
    NotCupCap: "",
    NotDoubleVerticalBar: "",
    NotElement: "",
    NotEqual: "",
    NotEqualTilde: "",
    NotExists: "",
    NotGreater: "",
    NotGreaterEqual: "",
    NotGreaterFullEqual: "",
    NotGreaterGreater: "",
    NotGreaterLess: "",
    NotGreaterSlantEqual: "",
    NotGreaterTilde: "",
    NotHumpDownHump: "",
    NotHumpEqual: "",
    notin: "",
    notindot: "",
    notinE: "",
    notinva: "",
    notinvb: "",
    notinvc: "",
    NotLeftTriangle: "",
    NotLeftTriangleBar: "",
    NotLeftTriangleEqual: "",
    NotLess: "",
    NotLessEqual: "",
    NotLessGreater: "",
    NotLessLess: "",
    NotLessSlantEqual: "",
    NotLessTilde: "",
    NotNestedGreaterGreater: "",
    NotNestedLessLess: "",
    notni: "",
    notniva: "",
    notnivb: "",
    notnivc: "",
    NotPrecedes: "",
    NotPrecedesEqual: "",
    NotPrecedesSlantEqual: "",
    NotReverseElement: "",
    NotRightTriangle: "",
    NotRightTriangleBar: "",
    NotRightTriangleEqual: "",
    NotSquareSubset: "",
    NotSquareSubsetEqual: "",
    NotSquareSuperset: "",
    NotSquareSupersetEqual: "",
    NotSubset: "",
    NotSubsetEqual: "",
    NotSucceeds: "",
    NotSucceedsEqual: "",
    NotSucceedsSlantEqual: "",
    NotSucceedsTilde: "",
    NotSuperset: "",
    NotSupersetEqual: "",
    NotTilde: "",
    NotTildeEqual: "",
    NotTildeFullEqual: "",
    NotTildeTilde: "",
    NotVerticalBar: "",
    npar: "",
    nparallel: "",
    nparsl: "",
    npart: "",
    npolint: "",
    npr: "",
    nprcue: "",
    npre: "",
    nprec: "",
    npreceq: "",
    nrArr: "",
    nrarr: "",
    nrarrc: "",
    nrarrw: "",
    nRightarrow: "",
    nrightarrow: "",
    nrtri: "",
    nrtrie: "",
    nsc: "",
    nsccue: "",
    nsce: "",
    Nscr: "",
    nscr: "",
    nshortmid: "",
    nshortparallel: "",
    nsim: "",
    nsime: "",
    nsimeq: "",
    nsmid: "",
    nspar: "",
    nsqsube: "",
    nsqsupe: "",
    nsub: "",
    nsubE: "",
    nsube: "",
    nsubset: "",
    nsubseteq: "",
    nsubseteqq: "",
    nsucc: "",
    nsucceq: "",
    nsup: "",
    nsupE: "",
    nsupe: "",
    nsupset: "",
    nsupseteq: "",
    nsupseteqq: "",
    ntgl: "",
    Ntilde: "",
    ntilde: "",
    ntlg: "",
    ntriangleleft: "",
    ntrianglelefteq: "",
    ntriangleright: "",
    ntrianglerighteq: "",
    Nu: "",
    nu: "",
    num: "#",
    numero: "",
    numsp: "",
    nvap: "",
    nVDash: "",
    nVdash: "",
    nvDash: "",
    nvdash: "",
    nvge: "",
    nvgt: ">",
    nvHarr: "",
    nvinfin: "",
    nvlArr: "",
    nvle: "",
    nvlt: "<",
    nvltrie: "",
    nvrArr: "",
    nvrtrie: "",
    nvsim: "",
    nwarhk: "",
    nwArr: "",
    nwarr: "",
    nwarrow: "",
    nwnear: "",
    Oacute: "",
    oacute: "",
    oast: "",
    ocir: "",
    Ocirc: "",
    ocirc: "",
    Ocy: "",
    ocy: "",
    odash: "",
    Odblac: "",
    odblac: "",
    odiv: "",
    odot: "",
    odsold: "",
    OElig: "",
    oelig: "",
    ofcir: "",
    Ofr: "",
    ofr: "",
    ogon: "",
    Ograve: "",
    ograve: "",
    ogt: "",
    ohbar: "",
    ohm: "",
    oint: "",
    olarr: "",
    olcir: "",
    olcross: "",
    oline: "",
    olt: "",
    Omacr: "",
    omacr: "",
    Omega: "",
    omega: "",
    Omicron: "",
    omicron: "",
    omid: "",
    ominus: "",
    Oopf: "",
    oopf: "",
    opar: "",
    OpenCurlyDoubleQuote: "",
    OpenCurlyQuote: "",
    operp: "",
    oplus: "",
    Or: "",
    or: "",
    orarr: "",
    ord: "",
    order: "",
    orderof: "",
    ordf: "",
    ordm: "",
    origof: "",
    oror: "",
    orslope: "",
    orv: "",
    oS: "",
    Oscr: "",
    oscr: "",
    Oslash: "",
    oslash: "",
    osol: "",
    Otilde: "",
    otilde: "",
    Otimes: "",
    otimes: "",
    otimesas: "",
    Ouml: "",
    ouml: "",
    ovbar: "",
    OverBar: "",
    OverBrace: "",
    OverBracket: "",
    OverParenthesis: "",
    par: "",
    para: "",
    parallel: "",
    parsim: "",
    parsl: "",
    part: "",
    PartialD: "",
    Pcy: "",
    pcy: "",
    percnt: "%",
    period: ".",
    permil: "",
    perp: "",
    pertenk: "",
    Pfr: "",
    pfr: "",
    Phi: "",
    phi: "",
    phiv: "",
    phmmat: "",
    phone: "",
    Pi: "",
    pi: "",
    pitchfork: "",
    piv: "",
    planck: "",
    planckh: "",
    plankv: "",
    plus: "+",
    plusacir: "",
    plusb: "",
    pluscir: "",
    plusdo: "",
    plusdu: "",
    pluse: "",
    PlusMinus: "",
    plusmn: "",
    plussim: "",
    plustwo: "",
    pm: "",
    Poincareplane: "",
    pointint: "",
    Popf: "",
    popf: "",
    pound: "",
    Pr: "",
    pr: "",
    prap: "",
    prcue: "",
    prE: "",
    pre: "",
    prec: "",
    precapprox: "",
    preccurlyeq: "",
    Precedes: "",
    PrecedesEqual: "",
    PrecedesSlantEqual: "",
    PrecedesTilde: "",
    preceq: "",
    precnapprox: "",
    precneqq: "",
    precnsim: "",
    precsim: "",
    Prime: "",
    prime: "",
    primes: "",
    prnap: "",
    prnE: "",
    prnsim: "",
    prod: "",
    Product: "",
    profalar: "",
    profline: "",
    profsurf: "",
    prop: "",
    Proportion: "",
    Proportional: "",
    propto: "",
    prsim: "",
    prurel: "",
    Pscr: "",
    pscr: "",
    Psi: "",
    psi: "",
    puncsp: "",
    Qfr: "",
    qfr: "",
    qint: "",
    Qopf: "",
    qopf: "",
    qprime: "",
    Qscr: "",
    qscr: "",
    quaternions: "",
    quatint: "",
    quest: "?",
    questeq: "",
    QUOT: '"',
    quot: '"',
    rAarr: "",
    race: "",
    Racute: "",
    racute: "",
    radic: "",
    raemptyv: "",
    Rang: "",
    rang: "",
    rangd: "",
    range: "",
    rangle: "",
    raquo: "",
    Rarr: "",
    rArr: "",
    rarr: "",
    rarrap: "",
    rarrb: "",
    rarrbfs: "",
    rarrc: "",
    rarrfs: "",
    rarrhk: "",
    rarrlp: "",
    rarrpl: "",
    rarrsim: "",
    Rarrtl: "",
    rarrtl: "",
    rarrw: "",
    rAtail: "",
    ratail: "",
    ratio: "",
    rationals: "",
    RBarr: "",
    rBarr: "",
    rbarr: "",
    rbbrk: "",
    rbrace: "}",
    rbrack: "]",
    rbrke: "",
    rbrksld: "",
    rbrkslu: "",
    Rcaron: "",
    rcaron: "",
    Rcedil: "",
    rcedil: "",
    rceil: "",
    rcub: "}",
    Rcy: "",
    rcy: "",
    rdca: "",
    rdldhar: "",
    rdquo: "",
    rdquor: "",
    rdsh: "",
    Re: "",
    real: "",
    realine: "",
    realpart: "",
    reals: "",
    rect: "",
    REG: "",
    reg: "",
    ReverseElement: "",
    ReverseEquilibrium: "",
    ReverseUpEquilibrium: "",
    rfisht: "",
    rfloor: "",
    Rfr: "",
    rfr: "",
    rHar: "",
    rhard: "",
    rharu: "",
    rharul: "",
    Rho: "",
    rho: "",
    rhov: "",
    RightAngleBracket: "",
    RightArrow: "",
    Rightarrow: "",
    rightarrow: "",
    RightArrowBar: "",
    RightArrowLeftArrow: "",
    rightarrowtail: "",
    RightCeiling: "",
    RightDoubleBracket: "",
    RightDownTeeVector: "",
    RightDownVector: "",
    RightDownVectorBar: "",
    RightFloor: "",
    rightharpoondown: "",
    rightharpoonup: "",
    rightleftarrows: "",
    rightleftharpoons: "",
    rightrightarrows: "",
    rightsquigarrow: "",
    RightTee: "",
    RightTeeArrow: "",
    RightTeeVector: "",
    rightthreetimes: "",
    RightTriangle: "",
    RightTriangleBar: "",
    RightTriangleEqual: "",
    RightUpDownVector: "",
    RightUpTeeVector: "",
    RightUpVector: "",
    RightUpVectorBar: "",
    RightVector: "",
    RightVectorBar: "",
    ring: "",
    risingdotseq: "",
    rlarr: "",
    rlhar: "",
    rlm: "",
    rmoust: "",
    rmoustache: "",
    rnmid: "",
    roang: "",
    roarr: "",
    robrk: "",
    ropar: "",
    Ropf: "",
    ropf: "",
    roplus: "",
    rotimes: "",
    RoundImplies: "",
    rpar: ")",
    rpargt: "",
    rppolint: "",
    rrarr: "",
    Rrightarrow: "",
    rsaquo: "",
    Rscr: "",
    rscr: "",
    Rsh: "",
    rsh: "",
    rsqb: "]",
    rsquo: "",
    rsquor: "",
    rthree: "",
    rtimes: "",
    rtri: "",
    rtrie: "",
    rtrif: "",
    rtriltri: "",
    RuleDelayed: "",
    ruluhar: "",
    rx: "",
    Sacute: "",
    sacute: "",
    sbquo: "",
    Sc: "",
    sc: "",
    scap: "",
    Scaron: "",
    scaron: "",
    sccue: "",
    scE: "",
    sce: "",
    Scedil: "",
    scedil: "",
    Scirc: "",
    scirc: "",
    scnap: "",
    scnE: "",
    scnsim: "",
    scpolint: "",
    scsim: "",
    Scy: "",
    scy: "",
    sdot: "",
    sdotb: "",
    sdote: "",
    searhk: "",
    seArr: "",
    searr: "",
    searrow: "",
    sect: "",
    semi: ";",
    seswar: "",
    setminus: "",
    setmn: "",
    sext: "",
    Sfr: "",
    sfr: "",
    sfrown: "",
    sharp: "",
    SHCHcy: "",
    shchcy: "",
    SHcy: "",
    shcy: "",
    ShortDownArrow: "",
    ShortLeftArrow: "",
    shortmid: "",
    shortparallel: "",
    ShortRightArrow: "",
    ShortUpArrow: "",
    shy: "",
    Sigma: "",
    sigma: "",
    sigmaf: "",
    sigmav: "",
    sim: "",
    simdot: "",
    sime: "",
    simeq: "",
    simg: "",
    simgE: "",
    siml: "",
    simlE: "",
    simne: "",
    simplus: "",
    simrarr: "",
    slarr: "",
    SmallCircle: "",
    smallsetminus: "",
    smashp: "",
    smeparsl: "",
    smid: "",
    smile: "",
    smt: "",
    smte: "",
    smtes: "",
    SOFTcy: "",
    softcy: "",
    sol: "/",
    solb: "",
    solbar: "",
    Sopf: "",
    sopf: "",
    spades: "",
    spadesuit: "",
    spar: "",
    sqcap: "",
    sqcaps: "",
    sqcup: "",
    sqcups: "",
    Sqrt: "",
    sqsub: "",
    sqsube: "",
    sqsubset: "",
    sqsubseteq: "",
    sqsup: "",
    sqsupe: "",
    sqsupset: "",
    sqsupseteq: "",
    squ: "",
    Square: "",
    square: "",
    SquareIntersection: "",
    SquareSubset: "",
    SquareSubsetEqual: "",
    SquareSuperset: "",
    SquareSupersetEqual: "",
    SquareUnion: "",
    squarf: "",
    squf: "",
    srarr: "",
    Sscr: "",
    sscr: "",
    ssetmn: "",
    ssmile: "",
    sstarf: "",
    Star: "",
    star: "",
    starf: "",
    straightepsilon: "",
    straightphi: "",
    strns: "",
    Sub: "",
    sub: "",
    subdot: "",
    subE: "",
    sube: "",
    subedot: "",
    submult: "",
    subnE: "",
    subne: "",
    subplus: "",
    subrarr: "",
    Subset: "",
    subset: "",
    subseteq: "",
    subseteqq: "",
    SubsetEqual: "",
    subsetneq: "",
    subsetneqq: "",
    subsim: "",
    subsub: "",
    subsup: "",
    succ: "",
    succapprox: "",
    succcurlyeq: "",
    Succeeds: "",
    SucceedsEqual: "",
    SucceedsSlantEqual: "",
    SucceedsTilde: "",
    succeq: "",
    succnapprox: "",
    succneqq: "",
    succnsim: "",
    succsim: "",
    SuchThat: "",
    Sum: "",
    sum: "",
    sung: "",
    Sup: "",
    sup: "",
    sup1: "",
    sup2: "",
    sup3: "",
    supdot: "",
    supdsub: "",
    supE: "",
    supe: "",
    supedot: "",
    Superset: "",
    SupersetEqual: "",
    suphsol: "",
    suphsub: "",
    suplarr: "",
    supmult: "",
    supnE: "",
    supne: "",
    supplus: "",
    Supset: "",
    supset: "",
    supseteq: "",
    supseteqq: "",
    supsetneq: "",
    supsetneqq: "",
    supsim: "",
    supsub: "",
    supsup: "",
    swarhk: "",
    swArr: "",
    swarr: "",
    swarrow: "",
    swnwar: "",
    szlig: "",
    Tab: "	",
    target: "",
    Tau: "",
    tau: "",
    tbrk: "",
    Tcaron: "",
    tcaron: "",
    Tcedil: "",
    tcedil: "",
    Tcy: "",
    tcy: "",
    tdot: "",
    telrec: "",
    Tfr: "",
    tfr: "",
    there4: "",
    Therefore: "",
    therefore: "",
    Theta: "",
    theta: "",
    thetasym: "",
    thetav: "",
    thickapprox: "",
    thicksim: "",
    ThickSpace: "",
    thinsp: "",
    ThinSpace: "",
    thkap: "",
    thksim: "",
    THORN: "",
    thorn: "",
    Tilde: "",
    tilde: "",
    TildeEqual: "",
    TildeFullEqual: "",
    TildeTilde: "",
    times: "",
    timesb: "",
    timesbar: "",
    timesd: "",
    tint: "",
    toea: "",
    top: "",
    topbot: "",
    topcir: "",
    Topf: "",
    topf: "",
    topfork: "",
    tosa: "",
    tprime: "",
    TRADE: "",
    trade: "",
    triangle: "",
    triangledown: "",
    triangleleft: "",
    trianglelefteq: "",
    triangleq: "",
    triangleright: "",
    trianglerighteq: "",
    tridot: "",
    trie: "",
    triminus: "",
    TripleDot: "",
    triplus: "",
    trisb: "",
    tritime: "",
    trpezium: "",
    Tscr: "",
    tscr: "",
    TScy: "",
    tscy: "",
    TSHcy: "",
    tshcy: "",
    Tstrok: "",
    tstrok: "",
    twixt: "",
    twoheadleftarrow: "",
    twoheadrightarrow: "",
    Uacute: "",
    uacute: "",
    Uarr: "",
    uArr: "",
    uarr: "",
    Uarrocir: "",
    Ubrcy: "",
    ubrcy: "",
    Ubreve: "",
    ubreve: "",
    Ucirc: "",
    ucirc: "",
    Ucy: "",
    ucy: "",
    udarr: "",
    Udblac: "",
    udblac: "",
    udhar: "",
    ufisht: "",
    Ufr: "",
    ufr: "",
    Ugrave: "",
    ugrave: "",
    uHar: "",
    uharl: "",
    uharr: "",
    uhblk: "",
    ulcorn: "",
    ulcorner: "",
    ulcrop: "",
    ultri: "",
    Umacr: "",
    umacr: "",
    uml: "",
    UnderBar: "_",
    UnderBrace: "",
    UnderBracket: "",
    UnderParenthesis: "",
    Union: "",
    UnionPlus: "",
    Uogon: "",
    uogon: "",
    Uopf: "",
    uopf: "",
    UpArrow: "",
    Uparrow: "",
    uparrow: "",
    UpArrowBar: "",
    UpArrowDownArrow: "",
    UpDownArrow: "",
    Updownarrow: "",
    updownarrow: "",
    UpEquilibrium: "",
    upharpoonleft: "",
    upharpoonright: "",
    uplus: "",
    UpperLeftArrow: "",
    UpperRightArrow: "",
    Upsi: "",
    upsi: "",
    upsih: "",
    Upsilon: "",
    upsilon: "",
    UpTee: "",
    UpTeeArrow: "",
    upuparrows: "",
    urcorn: "",
    urcorner: "",
    urcrop: "",
    Uring: "",
    uring: "",
    urtri: "",
    Uscr: "",
    uscr: "",
    utdot: "",
    Utilde: "",
    utilde: "",
    utri: "",
    utrif: "",
    uuarr: "",
    Uuml: "",
    uuml: "",
    uwangle: "",
    vangrt: "",
    varepsilon: "",
    varkappa: "",
    varnothing: "",
    varphi: "",
    varpi: "",
    varpropto: "",
    vArr: "",
    varr: "",
    varrho: "",
    varsigma: "",
    varsubsetneq: "",
    varsubsetneqq: "",
    varsupsetneq: "",
    varsupsetneqq: "",
    vartheta: "",
    vartriangleleft: "",
    vartriangleright: "",
    Vbar: "",
    vBar: "",
    vBarv: "",
    Vcy: "",
    vcy: "",
    VDash: "",
    Vdash: "",
    vDash: "",
    vdash: "",
    Vdashl: "",
    Vee: "",
    vee: "",
    veebar: "",
    veeeq: "",
    vellip: "",
    Verbar: "",
    verbar: "|",
    Vert: "",
    vert: "|",
    VerticalBar: "",
    VerticalLine: "|",
    VerticalSeparator: "",
    VerticalTilde: "",
    VeryThinSpace: "",
    Vfr: "",
    vfr: "",
    vltri: "",
    vnsub: "",
    vnsup: "",
    Vopf: "",
    vopf: "",
    vprop: "",
    vrtri: "",
    Vscr: "",
    vscr: "",
    vsubnE: "",
    vsubne: "",
    vsupnE: "",
    vsupne: "",
    Vvdash: "",
    vzigzag: "",
    Wcirc: "",
    wcirc: "",
    wedbar: "",
    Wedge: "",
    wedge: "",
    wedgeq: "",
    weierp: "",
    Wfr: "",
    wfr: "",
    Wopf: "",
    wopf: "",
    wp: "",
    wr: "",
    wreath: "",
    Wscr: "",
    wscr: "",
    xcap: "",
    xcirc: "",
    xcup: "",
    xdtri: "",
    Xfr: "",
    xfr: "",
    xhArr: "",
    xharr: "",
    Xi: "",
    xi: "",
    xlArr: "",
    xlarr: "",
    xmap: "",
    xnis: "",
    xodot: "",
    Xopf: "",
    xopf: "",
    xoplus: "",
    xotime: "",
    xrArr: "",
    xrarr: "",
    Xscr: "",
    xscr: "",
    xsqcup: "",
    xuplus: "",
    xutri: "",
    xvee: "",
    xwedge: "",
    Yacute: "",
    yacute: "",
    YAcy: "",
    yacy: "",
    Ycirc: "",
    ycirc: "",
    Ycy: "",
    ycy: "",
    yen: "",
    Yfr: "",
    yfr: "",
    YIcy: "",
    yicy: "",
    Yopf: "",
    yopf: "",
    Yscr: "",
    yscr: "",
    YUcy: "",
    yucy: "",
    Yuml: "",
    yuml: "",
    Zacute: "",
    zacute: "",
    Zcaron: "",
    zcaron: "",
    Zcy: "",
    zcy: "",
    Zdot: "",
    zdot: "",
    zeetrf: "",
    ZeroWidthSpace: "",
    Zeta: "",
    zeta: "",
    Zfr: "",
    zfr: "",
    ZHcy: "",
    zhcy: "",
    zigrarr: "",
    Zopf: "",
    zopf: "",
    Zscr: "",
    zscr: "",
    zwj: "",
    zwnj: ""
  }), e.entityMap = e.HTML_ENTITIES;
})(r_);
var mp = {}, hl = Zn.NAMESPACE, Jf = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, dv = new RegExp("[\\-\\.0-9" + Jf.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), pv = new RegExp("^" + Jf.source + dv.source + "*(?::" + Jf.source + dv.source + "*)?$"), Xo = 0, oa = 1, Ts = 2, Yo = 3, Es = 4, ws = 5, Qo = 6, Hl = 7;
function Eo(e, t) {
  this.message = e, this.locator = t, Error.captureStackTrace && Error.captureStackTrace(this, Eo);
}
Eo.prototype = new Error();
Eo.prototype.name = Eo.name;
function i_() {
}
i_.prototype = {
  parse: function(e, t, r) {
    var n = this.domBuilder;
    n.startDocument(), n_(t, t = {}), yS(
      e,
      t,
      r,
      n,
      this.errorHandler
    ), n.endDocument();
  }
};
function yS(e, t, r, n, i) {
  function a(fe) {
    if (fe > 65535) {
      fe -= 65536;
      var V = 55296 + (fe >> 10), G = 56320 + (fe & 1023);
      return String.fromCharCode(V, G);
    } else
      return String.fromCharCode(fe);
  }
  function s(fe) {
    var V = fe.slice(1, -1);
    return Object.hasOwnProperty.call(r, V) ? r[V] : V.charAt(0) === "#" ? a(parseInt(V.substr(1).replace("x", "0x"))) : (i.error("entity not found:" + fe), fe);
  }
  function o(fe) {
    if (fe > _) {
      var V = e.substring(_, fe).replace(/&#?\w+;/g, s);
      f && u(_), n.characters(V, 0, fe - _), _ = fe;
    }
  }
  function u(fe, V) {
    for (; fe >= c && (V = h.exec(e)); )
      l = V.index, c = l + V[0].length, f.lineNumber++;
    f.columnNumber = fe - l + 1;
  }
  for (var l = 0, c = 0, h = /.*(?:\r\n?|\n)|.*$/g, f = n.locator, d = [{ currentNSMap: t }], p = {}, _ = 0; ; ) {
    try {
      var v = e.indexOf("<", _);
      if (v < 0) {
        if (!e.substr(_).match(/^\s*$/)) {
          var x = n.doc, E = x.createTextNode(e.substr(_));
          x.appendChild(E), n.currentElement = E;
        }
        return;
      }
      switch (v > _ && o(v), e.charAt(v + 1)) {
        case "/":
          var Q = e.indexOf(">", v + 3), M = e.substring(v + 2, Q).replace(/[ \t\n\r]+$/g, ""), C = d.pop();
          Q < 0 ? (M = e.substring(v + 2).replace(/[\s<].*/, ""), i.error("end tag name: " + M + " is not complete:" + C.tagName), Q = v + 1 + M.length) : M.match(/\s</) && (M = M.replace(/[\s<].*/, ""), i.error("end tag name: " + M + " maybe not complete"), Q = v + 1 + M.length);
          var R = C.localNSMap, B = C.tagName == M, k = B || C.tagName && C.tagName.toLowerCase() == M.toLowerCase();
          if (k) {
            if (n.endElement(C.uri, C.localName, M), R)
              for (var F in R)
                Object.prototype.hasOwnProperty.call(R, F) && n.endPrefixMapping(F);
            B || i.fatalError("end tag name: " + M + " is not match the current start tagName:" + C.tagName);
          } else
            d.push(C);
          Q++;
          break;
        case "?":
          f && u(v), Q = TS(e, v, n);
          break;
        case "!":
          f && u(v), Q = AS(e, v, n, i);
          break;
        default:
          f && u(v);
          var I = new a_(), H = d[d.length - 1].currentNSMap, Q = _S(e, v, I, H, s, i), ee = I.length;
          if (!I.closed && xS(e, Q, I.tagName, p) && (I.closed = !0, r.nbsp || i.warning("unclosed xml attribute")), f && ee) {
            for (var oe = mv(f, {}), de = 0; de < ee; de++) {
              var he = I[de];
              u(he.offset), he.locator = mv(f, {});
            }
            n.locator = oe, vv(I, n, H) && d.push(I), n.locator = f;
          } else
            vv(I, n, H) && d.push(I);
          hl.isHTML(I.uri) && !I.closed ? Q = bS(e, Q, I.tagName, s, n) : Q++;
      }
    } catch (fe) {
      if (fe instanceof Eo)
        throw fe;
      i.error("element parse error: " + fe), Q = -1;
    }
    Q > _ ? _ = Q : o(Math.max(v, _) + 1);
  }
}
function mv(e, t) {
  return t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber, t;
}
function _S(e, t, r, n, i, a) {
  function s(f, d, p) {
    r.attributeNames.hasOwnProperty(f) && a.fatalError("Attribute " + f + " redefined"), r.addValue(
      f,
      // @see https://www.w3.org/TR/xml/#AVNormalize
      // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
      // - recursive replacement of (DTD) entity references
      // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
      d.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, i),
      p
    );
  }
  for (var o, u, l = ++t, c = Xo; ; ) {
    var h = e.charAt(l);
    switch (h) {
      case "=":
        if (c === oa)
          o = e.slice(t, l), c = Yo;
        else if (c === Ts)
          c = Yo;
        else
          throw new Error("attribute equal must after attrName");
        break;
      case "'":
      case '"':
        if (c === Yo || c === oa)
          if (c === oa && (a.warning('attribute value must after "="'), o = e.slice(t, l)), t = l + 1, l = e.indexOf(h, t), l > 0)
            u = e.slice(t, l), s(o, u, t - 1), c = ws;
          else
            throw new Error("attribute value no end '" + h + "' match");
        else if (c == Es)
          u = e.slice(t, l), s(o, u, t), a.warning('attribute "' + o + '" missed start quot(' + h + ")!!"), t = l + 1, c = ws;
        else
          throw new Error('attribute value must after "="');
        break;
      case "/":
        switch (c) {
          case Xo:
            r.setTagName(e.slice(t, l));
          case ws:
          case Qo:
          case Hl:
            c = Hl, r.closed = !0;
          case Es:
          case oa:
            break;
          case Ts:
            r.closed = !0;
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        return a.error("unexpected end of input"), c == Xo && r.setTagName(e.slice(t, l)), l;
      case ">":
        switch (c) {
          case Xo:
            r.setTagName(e.slice(t, l));
          case ws:
          case Qo:
          case Hl:
            break;
          case Es:
          case oa:
            u = e.slice(t, l), u.slice(-1) === "/" && (r.closed = !0, u = u.slice(0, -1));
          case Ts:
            c === Ts && (u = o), c == Es ? (a.warning('attribute "' + u + '" missed quot(")!'), s(o, u, t)) : ((!hl.isHTML(n[""]) || !u.match(/^(?:disabled|checked|selected)$/i)) && a.warning('attribute "' + u + '" missed value!! "' + u + '" instead!!'), s(u, u, t));
            break;
          case Yo:
            throw new Error("attribute value missed!!");
        }
        return l;
      case "":
        h = " ";
      default:
        if (h <= " ")
          switch (c) {
            case Xo:
              r.setTagName(e.slice(t, l)), c = Qo;
              break;
            case oa:
              o = e.slice(t, l), c = Ts;
              break;
            case Es:
              var u = e.slice(t, l);
              a.warning('attribute "' + u + '" missed quot(")!!'), s(o, u, t);
            case ws:
              c = Qo;
              break;
          }
        else
          switch (c) {
            case Ts:
              r.tagName, (!hl.isHTML(n[""]) || !o.match(/^(?:disabled|checked|selected)$/i)) && a.warning('attribute "' + o + '" missed value!! "' + o + '" instead2!!'), s(o, o, t), t = l, c = oa;
              break;
            case ws:
              a.warning('attribute space is required"' + o + '"!!');
            case Qo:
              c = oa, t = l;
              break;
            case Yo:
              c = Es, t = l;
              break;
            case Hl:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
    }
    l++;
  }
}
function vv(e, t, r) {
  for (var n = e.tagName, i = null, h = e.length; h--; ) {
    var a = e[h], s = a.qName, o = a.value, f = s.indexOf(":");
    if (f > 0)
      var u = a.prefix = s.slice(0, f), l = s.slice(f + 1), c = u === "xmlns" && l;
    else
      l = s, u = null, c = s === "xmlns" && "";
    a.localName = l, c !== !1 && (i == null && (i = {}, n_(r, r = {})), r[c] = i[c] = o, a.uri = hl.XMLNS, t.startPrefixMapping(c, o));
  }
  for (var h = e.length; h--; ) {
    a = e[h];
    var u = a.prefix;
    u && (u === "xml" && (a.uri = hl.XML), u !== "xmlns" && (a.uri = r[u || ""]));
  }
  var f = n.indexOf(":");
  f > 0 ? (u = e.prefix = n.slice(0, f), l = e.localName = n.slice(f + 1)) : (u = null, l = e.localName = n);
  var d = e.uri = r[u || ""];
  if (t.startElement(d, l, n, e), e.closed) {
    if (t.endElement(d, l, n), i)
      for (u in i)
        Object.prototype.hasOwnProperty.call(i, u) && t.endPrefixMapping(u);
  } else
    return e.currentNSMap = r, e.localNSMap = i, !0;
}
function bS(e, t, r, n, i) {
  if (/^(?:script|textarea)$/i.test(r)) {
    var a = e.indexOf("</" + r + ">", t), s = e.substring(t + 1, a);
    if (/[&<]/.test(s))
      return /^script$/i.test(r) ? (i.characters(s, 0, s.length), a) : (s = s.replace(/&#?\w+;/g, n), i.characters(s, 0, s.length), a);
  }
  return t + 1;
}
function xS(e, t, r, n) {
  var i = n[r];
  return i == null && (i = e.lastIndexOf("</" + r + ">"), i < t && (i = e.lastIndexOf("</" + r)), n[r] = i), i < t;
}
function n_(e, t) {
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
}
function AS(e, t, r, n) {
  var i = e.charAt(t + 2);
  switch (i) {
    case "-":
      if (e.charAt(t + 3) === "-") {
        var a = e.indexOf("-->", t + 4);
        return a > t ? (r.comment(e, t + 4, a - t - 4), a + 3) : (n.error("Unclosed comment"), -1);
      } else
        return -1;
    default:
      if (e.substr(t + 3, 6) == "CDATA[") {
        var a = e.indexOf("]]>", t + 9);
        return r.startCDATA(), r.characters(e, t + 9, a - t - 9), r.endCDATA(), a + 3;
      }
      var s = ES(e, t), o = s.length;
      if (o > 1 && /!doctype/i.test(s[0][0])) {
        var u = s[1][0], l = !1, c = !1;
        o > 3 && (/^public$/i.test(s[2][0]) ? (l = s[3][0], c = o > 4 && s[4][0]) : /^system$/i.test(s[2][0]) && (c = s[3][0]));
        var h = s[o - 1];
        return r.startDTD(u, l, c), r.endDTD(), h.index + h[0].length;
      }
  }
  return -1;
}
function TS(e, t, r) {
  var n = e.indexOf("?>", t);
  if (n) {
    var i = e.substring(t, n).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    return i ? (i[0].length, r.processingInstruction(i[1], i[2]), n + 2) : -1;
  }
  return -1;
}
function a_() {
  this.attributeNames = {};
}
a_.prototype = {
  setTagName: function(e) {
    if (!pv.test(e))
      throw new Error("invalid tagName:" + e);
    this.tagName = e;
  },
  addValue: function(e, t, r) {
    if (!pv.test(e))
      throw new Error("invalid attribute:" + e);
    this.attributeNames[e] = this.length, this[this.length++] = { qName: e, value: t, offset: r };
  },
  length: 0,
  getLocalName: function(e) {
    return this[e].localName;
  },
  getLocator: function(e) {
    return this[e].locator;
  },
  getQName: function(e) {
    return this[e].qName;
  },
  getURI: function(e) {
    return this[e].uri;
  },
  getValue: function(e) {
    return this[e].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};
function ES(e, t) {
  var r, n = [], i = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  for (i.lastIndex = t, i.exec(e); r = i.exec(e); )
    if (n.push(r), r[1]) return n;
}
mp.XMLReader = i_;
mp.ParseError = Eo;
var wS = Zn, SS = _a, gv = r_, s_ = mp, CS = SS.DOMImplementation, yv = wS.NAMESPACE, MS = s_.ParseError, DS = s_.XMLReader;
function o_(e) {
  return e.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
}
function u_(e) {
  this.options = e || { locator: {} };
}
u_.prototype.parseFromString = function(e, t) {
  var r = this.options, n = new DS(), i = r.domBuilder || new Sl(), a = r.errorHandler, s = r.locator, o = r.xmlns || {}, u = /\/x?html?$/.test(t), l = u ? gv.HTML_ENTITIES : gv.XML_ENTITIES;
  s && i.setDocumentLocator(s), n.errorHandler = PS(a, i, s), n.domBuilder = r.domBuilder || i, u && (o[""] = yv.HTML), o.xml = o.xml || yv.XML;
  var c = r.normalizeLineEndings || o_;
  return e && typeof e == "string" ? n.parse(
    c(e),
    o,
    l
  ) : n.errorHandler.error("invalid doc source"), i.doc;
};
function PS(e, t, r) {
  if (!e) {
    if (t instanceof Sl)
      return t;
    e = t;
  }
  var n = {}, i = e instanceof Function;
  r = r || {};
  function a(s) {
    var o = e[s];
    !o && i && (o = e.length == 2 ? function(u) {
      e(s, u);
    } : e), n[s] = o && function(u) {
      o("[xmldom " + s + "]	" + u + ed(r));
    } || function() {
    };
  }
  return a("warning"), a("error"), a("fatalError"), n;
}
function Sl() {
  this.cdata = !1;
}
function Ss(e, t) {
  t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber;
}
Sl.prototype = {
  startDocument: function() {
    this.doc = new CS().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
  },
  startElement: function(e, t, r, n) {
    var i = this.doc, a = i.createElementNS(e, r || t), s = n.length;
    zl(this, a), this.currentElement = a, this.locator && Ss(this.locator, a);
    for (var o = 0; o < s; o++) {
      var e = n.getURI(o), u = n.getValue(o), r = n.getQName(o), l = i.createAttributeNS(e, r);
      this.locator && Ss(n.getLocator(o), l), l.value = l.nodeValue = u, a.setAttributeNode(l);
    }
  },
  endElement: function(e, t, r) {
    var n = this.currentElement;
    n.tagName, this.currentElement = n.parentNode;
  },
  startPrefixMapping: function(e, t) {
  },
  endPrefixMapping: function(e) {
  },
  processingInstruction: function(e, t) {
    var r = this.doc.createProcessingInstruction(e, t);
    this.locator && Ss(this.locator, r), zl(this, r);
  },
  ignorableWhitespace: function(e, t, r) {
  },
  characters: function(e, t, r) {
    if (e = _v.apply(this, arguments), e) {
      if (this.cdata)
        var n = this.doc.createCDATASection(e);
      else
        var n = this.doc.createTextNode(e);
      this.currentElement ? this.currentElement.appendChild(n) : /^\s*$/.test(e) && this.doc.appendChild(n), this.locator && Ss(this.locator, n);
    }
  },
  skippedEntity: function(e) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(e) {
    (this.locator = e) && (e.lineNumber = 0);
  },
  //LexicalHandler
  comment: function(e, t, r) {
    e = _v.apply(this, arguments);
    var n = this.doc.createComment(e);
    this.locator && Ss(this.locator, n), zl(this, n);
  },
  startCDATA: function() {
    this.cdata = !0;
  },
  endCDATA: function() {
    this.cdata = !1;
  },
  startDTD: function(e, t, r) {
    var n = this.doc.implementation;
    if (n && n.createDocumentType) {
      var i = n.createDocumentType(e, t, r);
      this.locator && Ss(this.locator, i), zl(this, i), this.doc.doctype = i;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function(e) {
    console.warn("[xmldom warning]	" + e, ed(this.locator));
  },
  error: function(e) {
    console.error("[xmldom error]	" + e, ed(this.locator));
  },
  fatalError: function(e) {
    throw new MS(e, this.locator);
  }
};
function ed(e) {
  if (e)
    return `
@` + (e.systemId || "") + "#[line:" + e.lineNumber + ",col:" + e.columnNumber + "]";
}
function _v(e, t, r) {
  return typeof e == "string" ? e.substr(t, r) : e.length >= t + r || t ? new java.lang.String(e, t, r) + "" : e;
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(e) {
  Sl.prototype[e] = function() {
    return null;
  };
});
function zl(e, t) {
  e.currentElement ? e.currentElement.appendChild(t) : e.doc.appendChild(t);
}
Ah.__DOMHandler = Sl;
Ah.normalizeLineEndings = o_;
Ah.DOMParser = u_;
var LS = Ah.DOMParser;
/*! @name mpd-parser @version 0.22.1 @license Apache-2.0 */
var bv = function(t) {
  return !!t && typeof t == "object";
}, ei = function e() {
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  return r.reduce(function(i, a) {
    return typeof a != "object" || Object.keys(a).forEach(function(s) {
      Array.isArray(i[s]) && Array.isArray(a[s]) ? i[s] = i[s].concat(a[s]) : bv(i[s]) && bv(a[s]) ? i[s] = e(i[s], a[s]) : i[s] = a[s];
    }), i;
  }, {});
}, l_ = function(t) {
  return Object.keys(t).map(function(r) {
    return t[r];
  });
}, RS = function(t, r) {
  for (var n = [], i = t; i < r; i++)
    n.push(i);
  return n;
}, Th = function(t) {
  return t.reduce(function(r, n) {
    return r.concat(n);
  }, []);
}, c_ = function(t) {
  if (!t.length)
    return [];
  for (var r = [], n = 0; n < t.length; n++)
    r.push(t[n]);
  return r;
}, IS = function(t, r) {
  return t.reduce(function(n, i, a) {
    return i[r] && n.push(a), n;
  }, []);
}, td = function(t, r) {
  for (var n = 0; n < t.length; n++)
    if (r(t[n]))
      return n;
  return -1;
}, OS = function(t, r) {
  return l_(t.reduce(function(n, i) {
    return i.forEach(function(a) {
      n[r(a)] = a;
    }), n;
  }, {}));
}, wo = {
  INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
  DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
  DASH_INVALID_XML: "DASH_INVALID_XML",
  NO_BASE_URL: "NO_BASE_URL",
  MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
  SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
  UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
}, fl = function(t) {
  var r = t.baseUrl, n = r === void 0 ? "" : r, i = t.source, a = i === void 0 ? "" : i, s = t.range, o = s === void 0 ? "" : s, u = t.indexRange, l = u === void 0 ? "" : u, c = {
    uri: a,
    resolvedUri: _h(n || "", a)
  };
  if (o || l) {
    var h = o || l, f = h.split("-"), d = j.BigInt ? j.BigInt(f[0]) : parseInt(f[0], 10), p = j.BigInt ? j.BigInt(f[1]) : parseInt(f[1], 10);
    d < Number.MAX_SAFE_INTEGER && typeof d == "bigint" && (d = Number(d)), p < Number.MAX_SAFE_INTEGER && typeof p == "bigint" && (p = Number(p));
    var _;
    typeof p == "bigint" || typeof d == "bigint" ? _ = j.BigInt(p) - j.BigInt(d) + j.BigInt(1) : _ = p - d + 1, typeof _ == "bigint" && _ < Number.MAX_SAFE_INTEGER && (_ = Number(_)), c.byterange = {
      length: _,
      offset: d
    };
  }
  return c;
}, BS = function(t) {
  var r;
  return typeof t.offset == "bigint" || typeof t.length == "bigint" ? r = j.BigInt(t.offset) + j.BigInt(t.length) - j.BigInt(1) : r = t.offset + t.length - 1, t.offset + "-" + r;
}, xv = function(t) {
  return t && typeof t != "number" && (t = parseInt(t, 10)), isNaN(t) ? null : t;
}, FS = {
  /**
   * Returns the entire range of available segments for a static MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  static: function(t) {
    var r = t.duration, n = t.timescale, i = n === void 0 ? 1 : n, a = t.sourceDuration, s = t.periodDuration, o = xv(t.endNumber), u = r / i;
    return typeof o == "number" ? {
      start: 0,
      end: o
    } : typeof s == "number" ? {
      start: 0,
      end: s / u
    } : {
      start: 0,
      end: a / u
    };
  },
  /**
   * Returns the current live window range of available segments for a dynamic MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  dynamic: function(t) {
    var r = t.NOW, n = t.clientOffset, i = t.availabilityStartTime, a = t.timescale, s = a === void 0 ? 1 : a, o = t.duration, u = t.periodStart, l = u === void 0 ? 0 : u, c = t.minimumUpdatePeriod, h = c === void 0 ? 0 : c, f = t.timeShiftBufferDepth, d = f === void 0 ? 1 / 0 : f, p = xv(t.endNumber), _ = (r + n) / 1e3, v = i + l, x = _ + h, E = x - v, M = Math.ceil(E * s / o), C = Math.floor((_ - v - d) * s / o), R = Math.floor((_ - v) * s / o);
    return {
      start: Math.max(0, C),
      end: typeof p == "number" ? p : Math.min(M, R)
    };
  }
}, kS = function(t) {
  return function(r) {
    var n = t.duration, i = t.timescale, a = i === void 0 ? 1 : i, s = t.periodStart, o = t.startNumber, u = o === void 0 ? 1 : o;
    return {
      number: u + r,
      duration: n / a,
      timeline: s,
      time: r * n
    };
  };
}, vp = function(t) {
  var r = t.type, n = t.duration, i = t.timescale, a = i === void 0 ? 1 : i, s = t.periodDuration, o = t.sourceDuration, u = FS[r](t), l = u.start, c = u.end, h = RS(l, c).map(kS(t));
  if (r === "static") {
    var f = h.length - 1, d = typeof s == "number" ? s : o;
    h[f].duration = d - n / a * f;
  }
  return h;
}, h_ = function(t) {
  var r = t.baseUrl, n = t.initialization, i = n === void 0 ? {} : n, a = t.sourceDuration, s = t.indexRange, o = s === void 0 ? "" : s, u = t.periodStart, l = t.presentationTime, c = t.number, h = c === void 0 ? 0 : c, f = t.duration;
  if (!r)
    throw new Error(wo.NO_BASE_URL);
  var d = fl({
    baseUrl: r,
    source: i.sourceURL,
    range: i.range
  }), p = fl({
    baseUrl: r,
    source: r,
    indexRange: o
  });
  if (p.map = d, f) {
    var _ = vp(t);
    _.length && (p.duration = _[0].duration, p.timeline = _[0].timeline);
  } else a && (p.duration = a, p.timeline = u);
  return p.presentationTime = l || u, p.number = h, [p];
}, gp = function(t, r, n) {
  var i = t.sidx.map ? t.sidx.map : null, a = t.sidx.duration, s = t.timeline || 0, o = t.sidx.byterange, u = o.offset + o.length, l = r.timescale, c = r.references.filter(function(I) {
    return I.referenceType !== 1;
  }), h = [], f = t.endList ? "static" : "dynamic", d = t.sidx.timeline, p = d, _ = t.mediaSequence || 0, v;
  typeof r.firstOffset == "bigint" ? v = j.BigInt(u) + r.firstOffset : v = u + r.firstOffset;
  for (var x = 0; x < c.length; x++) {
    var E = r.references[x], M = E.referencedSize, C = E.subsegmentDuration, R = void 0;
    typeof v == "bigint" ? R = v + j.BigInt(M) - j.BigInt(1) : R = v + M - 1;
    var B = v + "-" + R, k = {
      baseUrl: n,
      timescale: l,
      timeline: s,
      periodStart: d,
      presentationTime: p,
      number: _,
      duration: C,
      sourceDuration: a,
      indexRange: B,
      type: f
    }, F = h_(k)[0];
    i && (F.map = i), h.push(F), typeof v == "bigint" ? v += j.BigInt(M) : v += M, p += C / l, _++;
  }
  return t.segments = h, t;
}, NS = ["AUDIO", "SUBTITLES"], US = 1 / 60, f_ = function(t) {
  return OS(t, function(r) {
    var n = r.timeline;
    return n;
  }).sort(function(r, n) {
    return r.timeline > n.timeline ? 1 : -1;
  });
}, GS = function(t, r) {
  for (var n = 0; n < t.length; n++)
    if (t[n].attributes.NAME === r)
      return t[n];
  return null;
}, Av = function(t) {
  var r = [];
  return iS(t, NS, function(n, i, a, s) {
    r = r.concat(n.playlists || []);
  }), r;
}, Tv = function(t) {
  var r = t.playlist, n = t.mediaSequence;
  r.mediaSequence = n, r.segments.forEach(function(i, a) {
    i.number = r.mediaSequence + a;
  });
}, VS = function(t) {
  var r = t.oldPlaylists, n = t.newPlaylists, i = t.timelineStarts;
  n.forEach(function(a) {
    a.discontinuitySequence = td(i, function(c) {
      var h = c.timeline;
      return h === a.timeline;
    });
    var s = GS(r, a.attributes.NAME);
    if (s && !a.sidx) {
      var o = a.segments[0], u = td(s.segments, function(c) {
        return Math.abs(c.presentationTime - o.presentationTime) < US;
      });
      if (u === -1) {
        Tv({
          playlist: a,
          mediaSequence: s.mediaSequence + s.segments.length
        }), a.segments[0].discontinuity = !0, a.discontinuityStarts.unshift(0), (!s.segments.length && a.timeline > s.timeline || s.segments.length && a.timeline > s.segments[s.segments.length - 1].timeline) && a.discontinuitySequence--;
        return;
      }
      var l = s.segments[u];
      l.discontinuity && !o.discontinuity && (o.discontinuity = !0, a.discontinuityStarts.unshift(0), a.discontinuitySequence--), Tv({
        playlist: a,
        mediaSequence: s.segments[u].number
      });
    }
  });
}, HS = function(t) {
  var r = t.oldManifest, n = t.newManifest, i = r.playlists.concat(Av(r)), a = n.playlists.concat(Av(n));
  return n.timelineStarts = f_([r.timelineStarts, n.timelineStarts]), VS({
    oldPlaylists: i,
    newPlaylists: a,
    timelineStarts: n.timelineStarts
  }), n;
}, Eh = function(t) {
  return t && t.uri + "-" + BS(t.byterange);
}, nf = function(t) {
  var r = l_(t.reduce(function(n, i) {
    var a = i.attributes.id + (i.attributes.lang || "");
    if (!n[a])
      n[a] = i, n[a].attributes.timelineStarts = [];
    else {
      if (i.segments) {
        var s;
        i.segments[0] && (i.segments[0].discontinuity = !0), (s = n[a].segments).push.apply(s, i.segments);
      }
      i.attributes.contentProtection && (n[a].attributes.contentProtection = i.attributes.contentProtection);
    }
    return n[a].attributes.timelineStarts.push({
      // Although they represent the same number, it's important to have both to make it
      // compatible with HLS potentially having a similar attribute.
      start: i.attributes.periodStart,
      timeline: i.attributes.periodStart
    }), n;
  }, {}));
  return r.map(function(n) {
    return n.discontinuityStarts = IS(n.segments || [], "discontinuity"), n;
  });
}, yp = function(t, r) {
  var n = Eh(t.sidx), i = n && r[n] && r[n].sidx;
  return i && gp(t, i, t.sidx.resolvedUri), t;
}, zS = function(t, r) {
  if (r === void 0 && (r = {}), !Object.keys(r).length)
    return t;
  for (var n in t)
    t[n] = yp(t[n], r);
  return t;
}, WS = function(t, r) {
  var n, i = t.attributes, a = t.segments, s = t.sidx, o = t.mediaSequence, u = t.discontinuitySequence, l = t.discontinuityStarts, c = {
    attributes: (n = {
      NAME: i.id,
      BANDWIDTH: i.bandwidth,
      CODECS: i.codecs
    }, n["PROGRAM-ID"] = 1, n),
    uri: "",
    endList: i.type === "static",
    timeline: i.periodStart,
    resolvedUri: "",
    targetDuration: i.duration,
    discontinuitySequence: u,
    discontinuityStarts: l,
    timelineStarts: i.timelineStarts,
    mediaSequence: o,
    segments: a
  };
  return i.contentProtection && (c.contentProtection = i.contentProtection), s && (c.sidx = s), r && (c.attributes.AUDIO = "audio", c.attributes.SUBTITLES = "subs"), c;
}, jS = function(t) {
  var r, n = t.attributes, i = t.segments, a = t.mediaSequence, s = t.discontinuityStarts, o = t.discontinuitySequence;
  typeof i > "u" && (i = [{
    uri: n.baseUrl,
    timeline: n.periodStart,
    resolvedUri: n.baseUrl || "",
    duration: n.sourceDuration,
    number: 0
  }], n.duration = n.sourceDuration);
  var u = (r = {
    NAME: n.id,
    BANDWIDTH: n.bandwidth
  }, r["PROGRAM-ID"] = 1, r);
  return n.codecs && (u.CODECS = n.codecs), {
    attributes: u,
    uri: "",
    endList: n.type === "static",
    timeline: n.periodStart,
    resolvedUri: n.baseUrl || "",
    targetDuration: n.duration,
    timelineStarts: n.timelineStarts,
    discontinuityStarts: s,
    discontinuitySequence: o,
    mediaSequence: a,
    segments: i
  };
}, qS = function(t, r, n) {
  r === void 0 && (r = {}), n === void 0 && (n = !1);
  var i, a = t.reduce(function(o, u) {
    var l = u.attributes.role && u.attributes.role.value || "", c = u.attributes.lang || "", h = u.attributes.label || "main";
    if (c && !u.attributes.label) {
      var f = l ? " (" + l + ")" : "";
      h = "" + u.attributes.lang + f;
    }
    o[h] || (o[h] = {
      language: c,
      autoselect: !0,
      default: l === "main",
      playlists: [],
      uri: ""
    });
    var d = yp(WS(u, n), r);
    return o[h].playlists.push(d), typeof i > "u" && l === "main" && (i = u, i.default = !0), o;
  }, {});
  if (!i) {
    var s = Object.keys(a)[0];
    a[s].default = !0;
  }
  return a;
}, XS = function(t, r) {
  return r === void 0 && (r = {}), t.reduce(function(n, i) {
    var a = i.attributes.lang || "text";
    return n[a] || (n[a] = {
      language: a,
      default: !1,
      autoselect: !1,
      playlists: [],
      uri: ""
    }), n[a].playlists.push(yp(jS(i), r)), n;
  }, {});
}, YS = function(t) {
  return t.reduce(function(r, n) {
    return n && n.forEach(function(i) {
      var a = i.channel, s = i.language;
      r[s] = {
        autoselect: !1,
        default: !1,
        instreamId: a,
        language: s
      }, i.hasOwnProperty("aspectRatio") && (r[s].aspectRatio = i.aspectRatio), i.hasOwnProperty("easyReader") && (r[s].easyReader = i.easyReader), i.hasOwnProperty("3D") && (r[s]["3D"] = i["3D"]);
    }), r;
  }, {});
}, QS = function(t) {
  var r, n = t.attributes, i = t.segments, a = t.sidx, s = t.discontinuityStarts, o = {
    attributes: (r = {
      NAME: n.id,
      AUDIO: "audio",
      SUBTITLES: "subs",
      RESOLUTION: {
        width: n.width,
        height: n.height
      },
      CODECS: n.codecs,
      BANDWIDTH: n.bandwidth
    }, r["PROGRAM-ID"] = 1, r),
    uri: "",
    endList: n.type === "static",
    timeline: n.periodStart,
    resolvedUri: "",
    targetDuration: n.duration,
    discontinuityStarts: s,
    timelineStarts: n.timelineStarts,
    segments: i
  };
  return n.frameRate && (o.attributes["FRAME-RATE"] = n.frameRate), n.contentProtection && (o.contentProtection = n.contentProtection), a && (o.sidx = a), o;
}, KS = function(t) {
  var r = t.attributes;
  return r.mimeType === "video/mp4" || r.mimeType === "video/webm" || r.contentType === "video";
}, $S = function(t) {
  var r = t.attributes;
  return r.mimeType === "audio/mp4" || r.mimeType === "audio/webm" || r.contentType === "audio";
}, ZS = function(t) {
  var r = t.attributes;
  return r.mimeType === "text/vtt" || r.contentType === "text";
}, JS = function(t, r) {
  t.forEach(function(n) {
    n.mediaSequence = 0, n.discontinuitySequence = td(r, function(i) {
      var a = i.timeline;
      return a === n.timeline;
    }), n.segments && n.segments.forEach(function(i, a) {
      i.number = a;
    });
  });
}, Ev = function(t) {
  return t ? Object.keys(t).reduce(function(r, n) {
    var i = t[n];
    return r.concat(i.playlists);
  }, []) : [];
}, eC = function(t) {
  var r, n = t.dashPlaylists, i = t.locations, a = t.sidxMapping, s = a === void 0 ? {} : a, o = t.previousManifest;
  if (!n.length)
    return {};
  var u = n[0].attributes, l = u.sourceDuration, c = u.type, h = u.suggestedPresentationDelay, f = u.minimumUpdatePeriod, d = nf(n.filter(KS)).map(QS), p = nf(n.filter($S)), _ = nf(n.filter(ZS)), v = n.map(function(k) {
    return k.attributes.captionServices;
  }).filter(Boolean), x = {
    allowCache: !0,
    discontinuityStarts: [],
    segments: [],
    endList: !0,
    mediaGroups: (r = {
      AUDIO: {},
      VIDEO: {}
    }, r["CLOSED-CAPTIONS"] = {}, r.SUBTITLES = {}, r),
    uri: "",
    duration: l,
    playlists: zS(d, s)
  };
  f >= 0 && (x.minimumUpdatePeriod = f * 1e3), i && (x.locations = i), c === "dynamic" && (x.suggestedPresentationDelay = h);
  var E = x.playlists.length === 0, M = p.length ? qS(p, s, E) : null, C = _.length ? XS(_, s) : null, R = d.concat(Ev(M), Ev(C)), B = R.map(function(k) {
    var F = k.timelineStarts;
    return F;
  });
  return x.timelineStarts = f_(B), JS(R, x.timelineStarts), M && (x.mediaGroups.AUDIO.audio = M), C && (x.mediaGroups.SUBTITLES.subs = C), v.length && (x.mediaGroups["CLOSED-CAPTIONS"].cc = YS(v)), o ? HS({
    oldManifest: o,
    newManifest: x
  }) : x;
}, tC = function(t, r, n) {
  var i = t.NOW, a = t.clientOffset, s = t.availabilityStartTime, o = t.timescale, u = o === void 0 ? 1 : o, l = t.periodStart, c = l === void 0 ? 0 : l, h = t.minimumUpdatePeriod, f = h === void 0 ? 0 : h, d = (i + a) / 1e3, p = s + c, _ = d + f, v = _ - p;
  return Math.ceil((v * u - r) / n);
}, d_ = function(t, r) {
  for (var n = t.type, i = t.minimumUpdatePeriod, a = i === void 0 ? 0 : i, s = t.media, o = s === void 0 ? "" : s, u = t.sourceDuration, l = t.timescale, c = l === void 0 ? 1 : l, h = t.startNumber, f = h === void 0 ? 1 : h, d = t.periodStart, p = [], _ = -1, v = 0; v < r.length; v++) {
    var x = r[v], E = x.d, M = x.r || 0, C = x.t || 0;
    _ < 0 && (_ = C), C && C > _ && (_ = C);
    var R = void 0;
    if (M < 0) {
      var B = v + 1;
      B === r.length ? n === "dynamic" && a > 0 && o.indexOf("$Number$") > 0 ? R = tC(t, _, E) : R = (u * c - _) / E : R = (r[B].t - _) / E;
    } else
      R = M + 1;
    for (var k = f + p.length + R, F = f + p.length; F < k; )
      p.push({
        number: F,
        duration: E / c,
        time: _,
        timeline: d
      }), _ += E, F++;
  }
  return p;
}, rC = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g, iC = function(t) {
  return function(r, n, i, a) {
    if (r === "$$")
      return "$";
    if (typeof t[n] > "u")
      return r;
    var s = "" + t[n];
    return n === "RepresentationID" || (i ? a = parseInt(a, 10) : a = 1, s.length >= a) ? s : "" + new Array(a - s.length + 1).join("0") + s;
  };
}, wv = function(t, r) {
  return t.replace(rC, iC(r));
}, nC = function(t, r) {
  return !t.duration && !r ? [{
    number: t.startNumber || 1,
    duration: t.sourceDuration,
    time: 0,
    timeline: t.periodStart
  }] : t.duration ? vp(t) : d_(t, r);
}, aC = function(t, r) {
  var n = {
    RepresentationID: t.id,
    Bandwidth: t.bandwidth || 0
  }, i = t.initialization, a = i === void 0 ? {
    sourceURL: "",
    range: ""
  } : i, s = fl({
    baseUrl: t.baseUrl,
    source: wv(a.sourceURL, n),
    range: a.range
  }), o = nC(t, r);
  return o.map(function(u) {
    n.Number = u.number, n.Time = u.time;
    var l = wv(t.media || "", n), c = t.timescale || 1, h = t.presentationTimeOffset || 0, f = (
      // Even if the @t attribute is not specified for the segment, segment.time is
      // calculated in mpd-parser prior to this, so it's assumed to be available.
      t.periodStart + (u.time - h) / c
    ), d = {
      uri: l,
      timeline: u.timeline,
      duration: u.duration,
      resolvedUri: _h(t.baseUrl || "", l),
      map: s,
      number: u.number,
      presentationTime: f
    };
    return d;
  });
}, sC = function(t, r) {
  var n = t.baseUrl, i = t.initialization, a = i === void 0 ? {} : i, s = fl({
    baseUrl: n,
    source: a.sourceURL,
    range: a.range
  }), o = fl({
    baseUrl: n,
    source: r.media,
    range: r.mediaRange
  });
  return o.map = s, o;
}, oC = function(t, r) {
  var n = t.duration, i = t.segmentUrls, a = i === void 0 ? [] : i, s = t.periodStart;
  if (!n && !r || n && r)
    throw new Error(wo.SEGMENT_TIME_UNSPECIFIED);
  var o = a.map(function(c) {
    return sC(t, c);
  }), u;
  n && (u = vp(t)), r && (u = d_(t, r));
  var l = u.map(function(c, h) {
    if (o[h]) {
      var f = o[h], d = t.timescale || 1, p = t.presentationTimeOffset || 0;
      return f.timeline = c.timeline, f.duration = c.duration, f.number = c.number, f.presentationTime = s + (c.time - p) / d, f;
    }
  }).filter(function(c) {
    return c;
  });
  return l;
}, uC = function(t) {
  var r = t.attributes, n = t.segmentInfo, i, a;
  n.template ? (a = aC, i = ei(r, n.template)) : n.base ? (a = h_, i = ei(r, n.base)) : n.list && (a = oC, i = ei(r, n.list));
  var s = {
    attributes: r
  };
  if (!a)
    return s;
  var o = a(i, n.segmentTimeline);
  if (i.duration) {
    var u = i, l = u.duration, c = u.timescale, h = c === void 0 ? 1 : c;
    i.duration = l / h;
  } else o.length ? i.duration = o.reduce(function(f, d) {
    return Math.max(f, Math.ceil(d.duration));
  }, 0) : i.duration = 0;
  return s.attributes = i, s.segments = o, n.base && i.indexRange && (s.sidx = o[0], s.segments = []), s;
}, lC = function(t) {
  return t.map(uC);
}, pr = function(t, r) {
  return c_(t.childNodes).filter(function(n) {
    var i = n.tagName;
    return i === r;
  });
}, _p = function(t) {
  return t.textContent.trim();
}, cC = function(t) {
  return parseFloat(t.split("/").reduce(function(r, n) {
    return r / n;
  }));
}, Cs = function(t) {
  var r = 31536e3, n = 30 * 24 * 60 * 60, i = 24 * 60 * 60, a = 60 * 60, s = 60, o = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/, u = o.exec(t);
  if (!u)
    return 0;
  var l = u.slice(1), c = l[0], h = l[1], f = l[2], d = l[3], p = l[4], _ = l[5];
  return parseFloat(c || 0) * r + parseFloat(h || 0) * n + parseFloat(f || 0) * i + parseFloat(d || 0) * a + parseFloat(p || 0) * s + parseFloat(_ || 0);
}, hC = function(t) {
  var r = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
  return r.test(t) && (t += "Z"), Date.parse(t);
}, Sv = {
  /**
   * Specifies the duration of the entire Media Presentation. Format is a duration string
   * as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  mediaPresentationDuration: function(t) {
    return Cs(t);
  },
  /**
   * Specifies the Segment availability start time for all Segments referred to in this
   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability
   * time. Format is a date string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The date as seconds from unix epoch
   */
  availabilityStartTime: function(t) {
    return hC(t) / 1e3;
  },
  /**
   * Specifies the smallest period between potential changes to the MPD. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  minimumUpdatePeriod: function(t) {
    return Cs(t);
  },
  /**
   * Specifies the suggested presentation delay. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  suggestedPresentationDelay: function(t) {
    return Cs(t);
  },
  /**
   * specifices the type of mpd. Can be either "static" or "dynamic"
   *
   * @param {string} value
   *        value of attribute as a string
   *
   * @return {string}
   *         The type as a string
   */
  type: function(t) {
    return t;
  },
  /**
   * Specifies the duration of the smallest time shifting buffer for any Representation
   * in the MPD. Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  timeShiftBufferDepth: function(t) {
    return Cs(t);
  },
  /**
   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.
   * Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  start: function(t) {
    return Cs(t);
  },
  /**
   * Specifies the width of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed width
   */
  width: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the height of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed height
   */
  height: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the bitrate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed bandwidth
   */
  bandwidth: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the frame rate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed frame rate
   */
  frameRate: function(t) {
    return cC(t);
  },
  /**
   * Specifies the number of the first Media Segment in this Representation in the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  startNumber: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the timescale in units per seconds
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed timescale
   */
  timescale: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the presentationTimeOffset.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTimeOffset
   */
  presentationTimeOffset: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the constant approximate Segment duration
   * NOTE: The <Period> element also contains an @duration attribute. This duration
   *       specifies the duration of the Period. This attribute is currently not
   *       supported by the rest of the parser, however we still check for it to prevent
   *       errors.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  duration: function(t) {
    var r = parseInt(t, 10);
    return isNaN(r) ? Cs(t) : r;
  },
  /**
   * Specifies the Segment duration, in units of the value of the @timescale.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  d: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the MPD start time, in @timescale units, the first Segment in the series
   * starts relative to the beginning of the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed time
   */
  t: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the repeat count of the number of following contiguous Segments with the
   * same duration expressed by the value of @d
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  r: function(t) {
    return parseInt(t, 10);
  },
  /**
   * Default parser for all other attributes. Acts as a no-op and just returns the value
   * as a string
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {string}
   *         Unparsed value
   */
  DEFAULT: function(t) {
    return t;
  }
}, Ur = function(t) {
  return t && t.attributes ? c_(t.attributes).reduce(function(r, n) {
    var i = Sv[n.name] || Sv.DEFAULT;
    return r[n.name] = i(n.value), r;
  }, {}) : {};
}, fC = {
  "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
  "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
  "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
  "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
}, wh = function(t, r) {
  return r.length ? Th(t.map(function(n) {
    return r.map(function(i) {
      return _h(n, _p(i));
    });
  })) : t;
}, bp = function(t) {
  var r = pr(t, "SegmentTemplate")[0], n = pr(t, "SegmentList")[0], i = n && pr(n, "SegmentURL").map(function(f) {
    return ei({
      tag: "SegmentURL"
    }, Ur(f));
  }), a = pr(t, "SegmentBase")[0], s = n || r, o = s && pr(s, "SegmentTimeline")[0], u = n || a || r, l = u && pr(u, "Initialization")[0], c = r && Ur(r);
  c && l ? c.initialization = l && Ur(l) : c && c.initialization && (c.initialization = {
    sourceURL: c.initialization
  });
  var h = {
    template: c,
    segmentTimeline: o && pr(o, "S").map(function(f) {
      return Ur(f);
    }),
    list: n && ei(Ur(n), {
      segmentUrls: i,
      initialization: Ur(l)
    }),
    base: a && ei(Ur(a), {
      initialization: Ur(l)
    })
  };
  return Object.keys(h).forEach(function(f) {
    h[f] || delete h[f];
  }), h;
}, dC = function(t, r, n) {
  return function(i) {
    var a = pr(i, "BaseURL"), s = wh(r, a), o = ei(t, Ur(i)), u = bp(i);
    return s.map(function(l) {
      return {
        segmentInfo: ei(n, u),
        attributes: ei(o, {
          baseUrl: l
        })
      };
    });
  };
}, pC = function(t) {
  return t.reduce(function(r, n) {
    var i = Ur(n);
    i.schemeIdUri && (i.schemeIdUri = i.schemeIdUri.toLowerCase());
    var a = fC[i.schemeIdUri];
    if (a) {
      r[a] = {
        attributes: i
      };
      var s = pr(n, "cenc:pssh")[0];
      if (s) {
        var o = _p(s);
        r[a].pssh = o && Iy(o);
      }
    }
    return r;
  }, {});
}, mC = function(t) {
  if (t.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
    var r = typeof t.value != "string" ? [] : t.value.split(";");
    return r.map(function(i) {
      var a, s;
      if (s = i, /^CC\d=/.test(i)) {
        var o = i.split("=");
        a = o[0], s = o[1];
      } else /^CC\d$/.test(i) && (a = i);
      return {
        channel: a,
        language: s
      };
    });
  } else if (t.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
    var n = typeof t.value != "string" ? [] : t.value.split(";");
    return n.map(function(i) {
      var a = {
        // service or channel number 1-63
        channel: void 0,
        // language is a 3ALPHA per ISO 639.2/B
        // field is required
        language: void 0,
        // BIT 1/0 or ?
        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown
        aspectRatio: 1,
        // BIT 1/0
        // easy reader flag indicated the text is tailed to the needs of beginning readers
        // default 0, or off
        easyReader: 0,
        // BIT 1/0
        // If 3d metadata is present (CEA-708.1) then 1
        // default 0
        "3D": 0
      };
      if (/=/.test(i)) {
        var s = i.split("="), o = s[0], u = s[1], l = u === void 0 ? "" : u;
        a.channel = o, a.language = i, l.split(",").forEach(function(c) {
          var h = c.split(":"), f = h[0], d = h[1];
          f === "lang" ? a.language = d : f === "er" ? a.easyReader = Number(d) : f === "war" ? a.aspectRatio = Number(d) : f === "3D" && (a["3D"] = Number(d));
        });
      } else
        a.language = i;
      return a.channel && (a.channel = "SERVICE" + a.channel), a;
    });
  }
}, vC = function(t, r, n) {
  return function(i) {
    var a = Ur(i), s = wh(r, pr(i, "BaseURL")), o = pr(i, "Role")[0], u = {
      role: Ur(o)
    }, l = ei(t, a, u), c = pr(i, "Accessibility")[0], h = mC(Ur(c));
    h && (l = ei(l, {
      captionServices: h
    }));
    var f = pr(i, "Label")[0];
    if (f && f.childNodes.length) {
      var d = f.childNodes[0].nodeValue.trim();
      l = ei(l, {
        label: d
      });
    }
    var p = pC(pr(i, "ContentProtection"));
    Object.keys(p).length && (l = ei(l, {
      contentProtection: p
    }));
    var _ = bp(i), v = pr(i, "Representation"), x = ei(n, _);
    return Th(v.map(dC(l, s, x)));
  };
}, gC = function(t, r) {
  return function(n, i) {
    var a = wh(r, pr(n.node, "BaseURL")), s = ei(t, {
      periodStart: n.attributes.start
    });
    typeof n.attributes.duration == "number" && (s.periodDuration = n.attributes.duration);
    var o = pr(n.node, "AdaptationSet"), u = bp(n.node);
    return Th(o.map(vC(s, a, u)));
  };
}, yC = function(t) {
  var r = t.attributes, n = t.priorPeriodAttributes, i = t.mpdType;
  return typeof r.start == "number" ? r.start : n && typeof n.start == "number" && typeof n.duration == "number" ? n.start + n.duration : !n && i === "static" ? 0 : null;
}, _C = function(t, r) {
  r === void 0 && (r = {});
  var n = r, i = n.manifestUri, a = i === void 0 ? "" : i, s = n.NOW, o = s === void 0 ? Date.now() : s, u = n.clientOffset, l = u === void 0 ? 0 : u, c = pr(t, "Period");
  if (!c.length)
    throw new Error(wo.INVALID_NUMBER_OF_PERIOD);
  var h = pr(t, "Location"), f = Ur(t), d = wh([a], pr(t, "BaseURL"));
  f.type = f.type || "static", f.sourceDuration = f.mediaPresentationDuration || 0, f.NOW = o, f.clientOffset = l, h.length && (f.locations = h.map(_p));
  var p = [];
  return c.forEach(function(_, v) {
    var x = Ur(_), E = p[v - 1];
    x.start = yC({
      attributes: x,
      priorPeriodAttributes: E ? E.attributes : null,
      mpdType: f.type
    }), p.push({
      node: _,
      attributes: x
    });
  }), {
    locations: f.locations,
    representationInfo: Th(p.map(gC(f, d)))
  };
}, p_ = function(t) {
  if (t === "")
    throw new Error(wo.DASH_EMPTY_MANIFEST);
  var r = new LS(), n, i;
  try {
    n = r.parseFromString(t, "application/xml"), i = n && n.documentElement.tagName === "MPD" ? n.documentElement : null;
  } catch {
  }
  if (!i || i && i.getElementsByTagName("parsererror").length > 0)
    throw new Error(wo.DASH_INVALID_XML);
  return i;
}, bC = function(t) {
  var r = pr(t, "UTCTiming")[0];
  if (!r)
    return null;
  var n = Ur(r);
  switch (n.schemeIdUri) {
    case "urn:mpeg:dash:utc:http-head:2014":
    case "urn:mpeg:dash:utc:http-head:2012":
      n.method = "HEAD";
      break;
    case "urn:mpeg:dash:utc:http-xsdate:2014":
    case "urn:mpeg:dash:utc:http-iso:2014":
    case "urn:mpeg:dash:utc:http-xsdate:2012":
    case "urn:mpeg:dash:utc:http-iso:2012":
      n.method = "GET";
      break;
    case "urn:mpeg:dash:utc:direct:2014":
    case "urn:mpeg:dash:utc:direct:2012":
      n.method = "DIRECT", n.value = Date.parse(n.value);
      break;
    case "urn:mpeg:dash:utc:http-ntp:2014":
    case "urn:mpeg:dash:utc:ntp:2014":
    case "urn:mpeg:dash:utc:sntp:2014":
    default:
      throw new Error(wo.UNSUPPORTED_UTC_TIMING_SCHEME);
  }
  return n;
}, xC = function(t, r) {
  r === void 0 && (r = {});
  var n = _C(p_(t), r), i = lC(n.representationInfo);
  return eC({
    dashPlaylists: i,
    locations: n.locations,
    sidxMapping: r.sidxMapping,
    previousManifest: r.previousManifest
  });
}, AC = function(t) {
  return bC(p_(t));
}, m_ = Math.pow(2, 32), TC = function(e) {
  var t = new DataView(e.buffer, e.byteOffset, e.byteLength), r;
  return t.getBigUint64 ? (r = t.getBigUint64(0), r < Number.MAX_SAFE_INTEGER ? Number(r) : r) : t.getUint32(0) * m_ + t.getUint32(4);
}, EC = {
  getUint64: TC,
  MAX_UINT32: m_
}, Cv = EC.getUint64, wC = function(e) {
  var t = new DataView(e.buffer, e.byteOffset, e.byteLength), r = {
    version: e[0],
    flags: new Uint8Array(e.subarray(1, 4)),
    references: [],
    referenceId: t.getUint32(4),
    timescale: t.getUint32(8)
  }, n = 12;
  r.version === 0 ? (r.earliestPresentationTime = t.getUint32(n), r.firstOffset = t.getUint32(n + 4), n += 8) : (r.earliestPresentationTime = Cv(e.subarray(n)), r.firstOffset = Cv(e.subarray(n + 8)), n += 16), n += 2;
  var i = t.getUint16(n);
  for (n += 2; i > 0; n += 12, i--)
    r.references.push({
      referenceType: (e[n] & 128) >>> 7,
      referencedSize: t.getUint32(n) & 2147483647,
      subsegmentDuration: t.getUint32(n + 4),
      startsWithSap: !!(e[n + 8] & 128),
      sapType: (e[n + 8] & 112) >>> 4,
      sapDeltaTime: t.getUint32(n + 8) & 268435455
    });
  return r;
}, SC = wC;
const CC = /* @__PURE__ */ Qn(SC);
var xp = 9e4, Ap, Tp, Sh, Ep, v_, g_, y_;
Ap = function(e) {
  return e * xp;
};
Tp = function(e, t) {
  return e * t;
};
Sh = function(e) {
  return e / xp;
};
Ep = function(e, t) {
  return e / t;
};
v_ = function(e, t) {
  return Ap(Ep(e, t));
};
g_ = function(e, t) {
  return Tp(Sh(e), t);
};
y_ = function(e, t, r) {
  return Sh(r ? e : e - t);
};
var kc = {
  ONE_SECOND_IN_TS: xp,
  secondsToVideoTs: Ap,
  secondsToAudioTs: Tp,
  videoTsToSeconds: Sh,
  audioTsToSeconds: Ep,
  audioTsToVideoTs: v_,
  videoTsToAudioTs: g_,
  metadataTsToSeconds: y_
}, MC = DC;
function DC(e, t) {
  var r, n = null;
  try {
    r = JSON.parse(e, t);
  } catch (i) {
    n = i;
  }
  return [n, r];
}
const PC = /* @__PURE__ */ Qn(MC);
var __ = { exports: {} }, Mv = Mg, wp = Object.create || /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (arguments.length !== 1)
      throw new Error("Object.create shim only accepts one parameter.");
    return e.prototype = t, new e();
  };
}();
function Ti(e, t) {
  this.name = "ParsingError", this.code = e.code, this.message = t || e.message;
}
Ti.prototype = wp(Error.prototype);
Ti.prototype.constructor = Ti;
Ti.Errors = {
  BadSignature: {
    code: 0,
    message: "Malformed WebVTT signature."
  },
  BadTimeStamp: {
    code: 1,
    message: "Malformed time stamp."
  }
};
function Sp(e) {
  function t(n, i, a, s) {
    return (n | 0) * 3600 + (i | 0) * 60 + (a | 0) + (s | 0) / 1e3;
  }
  var r = e.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
  return r ? r[3] ? t(r[1], r[2], r[3].replace(":", ""), r[4]) : r[1] > 59 ? t(r[1], r[2], 0, r[4]) : t(0, r[1], r[2], r[4]) : null;
}
function cu() {
  this.values = wp(null);
}
cu.prototype = {
  // Only accept the first assignment to any key.
  set: function(e, t) {
    !this.get(e) && t !== "" && (this.values[e] = t);
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function(e, t, r) {
    return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t;
  },
  // Check whether we have a value for a key.
  has: function(e) {
    return e in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function(e, t, r) {
    for (var n = 0; n < r.length; ++n)
      if (t === r[n]) {
        this.set(e, t);
        break;
      }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function(e, t) {
    /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10));
  },
  // Accept a setting if its a valid percentage.
  percent: function(e, t) {
    return t.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (t = parseFloat(t), t >= 0 && t <= 100) ? (this.set(e, t), !0) : !1;
  }
};
function nu(e, t, r, n) {
  var i = n ? e.split(n) : [e];
  for (var a in i)
    if (typeof i[a] == "string") {
      var s = i[a].split(r);
      if (s.length === 2) {
        var o = s[0].trim(), u = s[1].trim();
        t(o, u);
      }
    }
}
function LC(e, t, r) {
  var n = e;
  function i() {
    var o = Sp(e);
    if (o === null)
      throw new Ti(
        Ti.Errors.BadTimeStamp,
        "Malformed timestamp: " + n
      );
    return e = e.replace(/^[^\sa-zA-Z-]+/, ""), o;
  }
  function a(o, u) {
    var l = new cu();
    nu(o, function(c, h) {
      switch (c) {
        case "region":
          for (var f = r.length - 1; f >= 0; f--)
            if (r[f].id === h) {
              l.set(c, r[f].region);
              break;
            }
          break;
        case "vertical":
          l.alt(c, h, ["rl", "lr"]);
          break;
        case "line":
          var d = h.split(","), p = d[0];
          l.integer(c, p), l.percent(c, p) && l.set("snapToLines", !1), l.alt(c, p, ["auto"]), d.length === 2 && l.alt("lineAlign", d[1], ["start", "center", "end"]);
          break;
        case "position":
          d = h.split(","), l.percent(c, d[0]), d.length === 2 && l.alt("positionAlign", d[1], ["start", "center", "end"]);
          break;
        case "size":
          l.percent(c, h);
          break;
        case "align":
          l.alt(c, h, ["start", "center", "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/), u.region = l.get("region", null), u.vertical = l.get("vertical", "");
    try {
      u.line = l.get("line", "auto");
    } catch {
    }
    u.lineAlign = l.get("lineAlign", "start"), u.snapToLines = l.get("snapToLines", !0), u.size = l.get("size", 100);
    try {
      u.align = l.get("align", "center");
    } catch {
      u.align = l.get("align", "middle");
    }
    try {
      u.position = l.get("position", "auto");
    } catch {
      u.position = l.get("position", {
        start: 0,
        left: 0,
        center: 50,
        middle: 50,
        end: 100,
        right: 100
      }, u.align);
    }
    u.positionAlign = l.get("positionAlign", {
      start: "start",
      left: "start",
      center: "center",
      middle: "center",
      end: "end",
      right: "end"
    }, u.align);
  }
  function s() {
    e = e.replace(/^\s+/, "");
  }
  if (s(), t.startTime = i(), s(), e.substr(0, 3) !== "-->")
    throw new Ti(
      Ti.Errors.BadTimeStamp,
      "Malformed time stamp (time stamps must be separated by '-->'): " + n
    );
  e = e.substr(3), s(), t.endTime = i(), s(), a(e, t);
}
var af = Mv.createElement && Mv.createElement("textarea"), RC = {
  c: "span",
  i: "i",
  b: "b",
  u: "u",
  ruby: "ruby",
  rt: "rt",
  v: "span",
  lang: "span"
}, Dv = {
  white: "rgba(255,255,255,1)",
  lime: "rgba(0,255,0,1)",
  cyan: "rgba(0,255,255,1)",
  red: "rgba(255,0,0,1)",
  yellow: "rgba(255,255,0,1)",
  magenta: "rgba(255,0,255,1)",
  blue: "rgba(0,0,255,1)",
  black: "rgba(0,0,0,1)"
}, IC = {
  v: "title",
  lang: "lang"
}, Pv = {
  rt: "ruby"
};
function b_(e, t) {
  function r() {
    if (!t)
      return null;
    function p(v) {
      return t = t.substr(v.length), v;
    }
    var _ = t.match(/^([^<]*)(<[^>]*>?)?/);
    return p(_[1] ? _[1] : _[2]);
  }
  function n(p) {
    return af.innerHTML = p, p = af.textContent, af.textContent = "", p;
  }
  function i(p, _) {
    return !Pv[_.localName] || Pv[_.localName] === p.localName;
  }
  function a(p, _) {
    var v = RC[p];
    if (!v)
      return null;
    var x = e.document.createElement(v), E = IC[p];
    return E && _ && (x[E] = _.trim()), x;
  }
  for (var s = e.document.createElement("div"), o = s, u, l = []; (u = r()) !== null; ) {
    if (u[0] === "<") {
      if (u[1] === "/") {
        l.length && l[l.length - 1] === u.substr(2).replace(">", "") && (l.pop(), o = o.parentNode);
        continue;
      }
      var c = Sp(u.substr(1, u.length - 2)), h;
      if (c) {
        h = e.document.createProcessingInstruction("timestamp", c), o.appendChild(h);
        continue;
      }
      var f = u.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
      if (!f || (h = a(f[1], f[3]), !h) || !i(o, h))
        continue;
      if (f[2]) {
        var d = f[2].split(".");
        d.forEach(function(p) {
          var _ = /^bg_/.test(p), v = _ ? p.slice(3) : p;
          if (Dv.hasOwnProperty(v)) {
            var x = _ ? "background-color" : "color", E = Dv[v];
            h.style[x] = E;
          }
        }), h.className = d.join(" ");
      }
      l.push(f[1]), o.appendChild(h), o = h;
      continue;
    }
    o.appendChild(e.document.createTextNode(n(u)));
  }
  return s;
}
var Lv = [
  [1470, 1470],
  [1472, 1472],
  [1475, 1475],
  [1478, 1478],
  [1488, 1514],
  [1520, 1524],
  [1544, 1544],
  [1547, 1547],
  [1549, 1549],
  [1563, 1563],
  [1566, 1610],
  [1645, 1647],
  [1649, 1749],
  [1765, 1766],
  [1774, 1775],
  [1786, 1805],
  [1807, 1808],
  [1810, 1839],
  [1869, 1957],
  [1969, 1969],
  [1984, 2026],
  [2036, 2037],
  [2042, 2042],
  [2048, 2069],
  [2074, 2074],
  [2084, 2084],
  [2088, 2088],
  [2096, 2110],
  [2112, 2136],
  [2142, 2142],
  [2208, 2208],
  [2210, 2220],
  [8207, 8207],
  [64285, 64285],
  [64287, 64296],
  [64298, 64310],
  [64312, 64316],
  [64318, 64318],
  [64320, 64321],
  [64323, 64324],
  [64326, 64449],
  [64467, 64829],
  [64848, 64911],
  [64914, 64967],
  [65008, 65020],
  [65136, 65140],
  [65142, 65276],
  [67584, 67589],
  [67592, 67592],
  [67594, 67637],
  [67639, 67640],
  [67644, 67644],
  [67647, 67669],
  [67671, 67679],
  [67840, 67867],
  [67872, 67897],
  [67903, 67903],
  [67968, 68023],
  [68030, 68031],
  [68096, 68096],
  [68112, 68115],
  [68117, 68119],
  [68121, 68147],
  [68160, 68167],
  [68176, 68184],
  [68192, 68223],
  [68352, 68405],
  [68416, 68437],
  [68440, 68466],
  [68472, 68479],
  [68608, 68680],
  [126464, 126467],
  [126469, 126495],
  [126497, 126498],
  [126500, 126500],
  [126503, 126503],
  [126505, 126514],
  [126516, 126519],
  [126521, 126521],
  [126523, 126523],
  [126530, 126530],
  [126535, 126535],
  [126537, 126537],
  [126539, 126539],
  [126541, 126543],
  [126545, 126546],
  [126548, 126548],
  [126551, 126551],
  [126553, 126553],
  [126555, 126555],
  [126557, 126557],
  [126559, 126559],
  [126561, 126562],
  [126564, 126564],
  [126567, 126570],
  [126572, 126578],
  [126580, 126583],
  [126585, 126588],
  [126590, 126590],
  [126592, 126601],
  [126603, 126619],
  [126625, 126627],
  [126629, 126633],
  [126635, 126651],
  [1114109, 1114109]
];
function OC(e) {
  for (var t = 0; t < Lv.length; t++) {
    var r = Lv[t];
    if (e >= r[0] && e <= r[1])
      return !0;
  }
  return !1;
}
function BC(e) {
  var t = [], r = "", n;
  if (!e || !e.childNodes)
    return "ltr";
  function i(o, u) {
    for (var l = u.childNodes.length - 1; l >= 0; l--)
      o.push(u.childNodes[l]);
  }
  function a(o) {
    if (!o || !o.length)
      return null;
    var u = o.pop(), l = u.textContent || u.innerText;
    if (l) {
      var c = l.match(/^.*(\n|\r)/);
      return c ? (o.length = 0, c[0]) : l;
    }
    if (u.tagName === "ruby")
      return a(o);
    if (u.childNodes)
      return i(o, u), a(o);
  }
  for (i(t, e); r = a(t); )
    for (var s = 0; s < r.length; s++)
      if (n = r.charCodeAt(s), OC(n))
        return "rtl";
  return "ltr";
}
function FC(e) {
  if (typeof e.line == "number" && (e.snapToLines || e.line >= 0 && e.line <= 100))
    return e.line;
  if (!e.track || !e.track.textTrackList || !e.track.textTrackList.mediaElement)
    return -1;
  for (var t = e.track, r = t.textTrackList, n = 0, i = 0; i < r.length && r[i] !== t; i++)
    r[i].mode === "showing" && n++;
  return ++n * -1;
}
function Ch() {
}
Ch.prototype.applyStyles = function(e, t) {
  t = t || this.div;
  for (var r in e)
    e.hasOwnProperty(r) && (t.style[r] = e[r]);
};
Ch.prototype.formatStyle = function(e, t) {
  return e === 0 ? 0 : e + t;
};
function Nc(e, t, r) {
  Ch.call(this), this.cue = t, this.cueDiv = b_(e, t.text);
  var n = {
    color: "rgba(255, 255, 255, 1)",
    backgroundColor: "rgba(0, 0, 0, 0.8)",
    position: "relative",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    display: "inline",
    writingMode: t.vertical === "" ? "horizontal-tb" : t.vertical === "lr" ? "vertical-lr" : "vertical-rl",
    unicodeBidi: "plaintext"
  };
  this.applyStyles(n, this.cueDiv), this.div = e.document.createElement("div"), n = {
    direction: BC(this.cueDiv),
    writingMode: t.vertical === "" ? "horizontal-tb" : t.vertical === "lr" ? "vertical-lr" : "vertical-rl",
    unicodeBidi: "plaintext",
    textAlign: t.align === "middle" ? "center" : t.align,
    font: r.font,
    whiteSpace: "pre-line",
    position: "absolute"
  }, this.applyStyles(n), this.div.appendChild(this.cueDiv);
  var i = 0;
  switch (t.positionAlign) {
    case "start":
    case "line-left":
      i = t.position;
      break;
    case "center":
      i = t.position - t.size / 2;
      break;
    case "end":
    case "line-right":
      i = t.position - t.size;
      break;
  }
  t.vertical === "" ? this.applyStyles({
    left: this.formatStyle(i, "%"),
    width: this.formatStyle(t.size, "%")
  }) : this.applyStyles({
    top: this.formatStyle(i, "%"),
    height: this.formatStyle(t.size, "%")
  }), this.move = function(a) {
    this.applyStyles({
      top: this.formatStyle(a.top, "px"),
      bottom: this.formatStyle(a.bottom, "px"),
      left: this.formatStyle(a.left, "px"),
      right: this.formatStyle(a.right, "px"),
      height: this.formatStyle(a.height, "px"),
      width: this.formatStyle(a.width, "px")
    });
  };
}
Nc.prototype = wp(Ch.prototype);
Nc.prototype.constructor = Nc;
function ti(e) {
  var t, r, n, i;
  if (e.div) {
    r = e.div.offsetHeight, n = e.div.offsetWidth, i = e.div.offsetTop;
    var a = (a = e.div.childNodes) && (a = a[0]) && a.getClientRects && a.getClientRects();
    e = e.div.getBoundingClientRect(), t = a ? Math.max(a[0] && a[0].height || 0, e.height / a.length) : 0;
  }
  this.left = e.left, this.right = e.right, this.top = e.top || i, this.height = e.height || r, this.bottom = e.bottom || i + (e.height || r), this.width = e.width || n, this.lineHeight = t !== void 0 ? t : e.lineHeight;
}
ti.prototype.move = function(e, t) {
  switch (t = t !== void 0 ? t : this.lineHeight, e) {
    case "+x":
      this.left += t, this.right += t;
      break;
    case "-x":
      this.left -= t, this.right -= t;
      break;
    case "+y":
      this.top += t, this.bottom += t;
      break;
    case "-y":
      this.top -= t, this.bottom -= t;
      break;
  }
};
ti.prototype.overlaps = function(e) {
  return this.left < e.right && this.right > e.left && this.top < e.bottom && this.bottom > e.top;
};
ti.prototype.overlapsAny = function(e) {
  for (var t = 0; t < e.length; t++)
    if (this.overlaps(e[t]))
      return !0;
  return !1;
};
ti.prototype.within = function(e) {
  return this.top >= e.top && this.bottom <= e.bottom && this.left >= e.left && this.right <= e.right;
};
ti.prototype.overlapsOppositeAxis = function(e, t) {
  switch (t) {
    case "+x":
      return this.left < e.left;
    case "-x":
      return this.right > e.right;
    case "+y":
      return this.top < e.top;
    case "-y":
      return this.bottom > e.bottom;
  }
};
ti.prototype.intersectPercentage = function(e) {
  var t = Math.max(0, Math.min(this.right, e.right) - Math.max(this.left, e.left)), r = Math.max(0, Math.min(this.bottom, e.bottom) - Math.max(this.top, e.top)), n = t * r;
  return n / (this.height * this.width);
};
ti.prototype.toCSSCompatValues = function(e) {
  return {
    top: this.top - e.top,
    bottom: e.bottom - this.bottom,
    left: this.left - e.left,
    right: e.right - this.right,
    height: this.height,
    width: this.width
  };
};
ti.getSimpleBoxPosition = function(e) {
  var t = e.div ? e.div.offsetHeight : e.tagName ? e.offsetHeight : 0, r = e.div ? e.div.offsetWidth : e.tagName ? e.offsetWidth : 0, n = e.div ? e.div.offsetTop : e.tagName ? e.offsetTop : 0;
  e = e.div ? e.div.getBoundingClientRect() : e.tagName ? e.getBoundingClientRect() : e;
  var i = {
    left: e.left,
    right: e.right,
    top: e.top || n,
    height: e.height || t,
    bottom: e.bottom || n + (e.height || t),
    width: e.width || r
  };
  return i;
};
function kC(e, t, r, n) {
  function i(v, x) {
    for (var E, M = new ti(v), C = 1, R = 0; R < x.length; R++) {
      for (; v.overlapsOppositeAxis(r, x[R]) || v.within(r) && v.overlapsAny(n); )
        v.move(x[R]);
      if (v.within(r))
        return v;
      var B = v.intersectPercentage(r);
      C > B && (E = new ti(v), C = B), v = new ti(M);
    }
    return E || M;
  }
  var a = new ti(t), s = t.cue, o = FC(s), u = [];
  if (s.snapToLines) {
    var l;
    switch (s.vertical) {
      case "":
        u = ["+y", "-y"], l = "height";
        break;
      case "rl":
        u = ["+x", "-x"], l = "width";
        break;
      case "lr":
        u = ["-x", "+x"], l = "width";
        break;
    }
    var c = a.lineHeight, h = c * Math.round(o), f = r[l] + c, d = u[0];
    Math.abs(h) > f && (h = h < 0 ? -1 : 1, h *= Math.ceil(f / c) * c), o < 0 && (h += s.vertical === "" ? r.height : r.width, u = u.reverse()), a.move(d, h);
  } else {
    var p = a.lineHeight / r.height * 100;
    switch (s.lineAlign) {
      case "center":
        o -= p / 2;
        break;
      case "end":
        o -= p;
        break;
    }
    switch (s.vertical) {
      case "":
        t.applyStyles({
          top: t.formatStyle(o, "%")
        });
        break;
      case "rl":
        t.applyStyles({
          left: t.formatStyle(o, "%")
        });
        break;
      case "lr":
        t.applyStyles({
          right: t.formatStyle(o, "%")
        });
        break;
    }
    u = ["+y", "-x", "+x", "-y"], a = new ti(t);
  }
  var _ = i(a, u);
  t.move(_.toCSSCompatValues(r));
}
function Oo() {
}
Oo.StringDecoder = function() {
  return {
    decode: function(e) {
      if (!e)
        return "";
      if (typeof e != "string")
        throw new Error("Error - expected string data.");
      return decodeURIComponent(encodeURIComponent(e));
    }
  };
};
Oo.convertCueToDOMTree = function(e, t) {
  return !e || !t ? null : b_(e, t);
};
var NC = 0.05, UC = "sans-serif", GC = "1.5%";
Oo.processCues = function(e, t, r) {
  if (!e || !t || !r)
    return null;
  for (; r.firstChild; )
    r.removeChild(r.firstChild);
  var n = e.document.createElement("div");
  n.style.position = "absolute", n.style.left = "0", n.style.right = "0", n.style.top = "0", n.style.bottom = "0", n.style.margin = GC, r.appendChild(n);
  function i(c) {
    for (var h = 0; h < c.length; h++)
      if (c[h].hasBeenReset || !c[h].displayState)
        return !0;
    return !1;
  }
  if (!i(t)) {
    for (var a = 0; a < t.length; a++)
      n.appendChild(t[a].displayState);
    return;
  }
  var s = [], o = ti.getSimpleBoxPosition(n), u = Math.round(o.height * NC * 100) / 100, l = {
    font: u + "px " + UC
  };
  (function() {
    for (var c, h, f = 0; f < t.length; f++)
      h = t[f], c = new Nc(e, h, l), n.appendChild(c.div), kC(e, c, o, s), h.displayState = c.div, s.push(ti.getSimpleBoxPosition(c));
  })();
};
Oo.Parser = function(e, t, r) {
  r || (r = t, t = {}), t || (t = {}), this.window = e, this.vttjs = t, this.state = "INITIAL", this.buffer = "", this.decoder = r || new TextDecoder("utf8"), this.regionList = [];
};
Oo.Parser.prototype = {
  // If the error is a ParsingError then report it to the consumer if
  // possible. If it's not a ParsingError then throw it like normal.
  reportOrThrowError: function(e) {
    if (e instanceof Ti)
      this.onparsingerror && this.onparsingerror(e);
    else
      throw e;
  },
  parse: function(e) {
    var t = this;
    e && (t.buffer += t.decoder.decode(e, { stream: !0 }));
    function r() {
      for (var c = t.buffer, h = 0; h < c.length && c[h] !== "\r" && c[h] !== `
`; )
        ++h;
      var f = c.substr(0, h);
      return c[h] === "\r" && ++h, c[h] === `
` && ++h, t.buffer = c.substr(h), f;
    }
    function n(c) {
      var h = new cu();
      if (nu(c, function(d, p) {
        switch (d) {
          case "id":
            h.set(d, p);
            break;
          case "width":
            h.percent(d, p);
            break;
          case "lines":
            h.integer(d, p);
            break;
          case "regionanchor":
          case "viewportanchor":
            var _ = p.split(",");
            if (_.length !== 2)
              break;
            var v = new cu();
            if (v.percent("x", _[0]), v.percent("y", _[1]), !v.has("x") || !v.has("y"))
              break;
            h.set(d + "X", v.get("x")), h.set(d + "Y", v.get("y"));
            break;
          case "scroll":
            h.alt(d, p, ["up"]);
            break;
        }
      }, /=/, /\s/), h.has("id")) {
        var f = new (t.vttjs.VTTRegion || t.window.VTTRegion)();
        f.width = h.get("width", 100), f.lines = h.get("lines", 3), f.regionAnchorX = h.get("regionanchorX", 0), f.regionAnchorY = h.get("regionanchorY", 100), f.viewportAnchorX = h.get("viewportanchorX", 0), f.viewportAnchorY = h.get("viewportanchorY", 100), f.scroll = h.get("scroll", ""), t.onregion && t.onregion(f), t.regionList.push({
          id: h.get("id"),
          region: f
        });
      }
    }
    function i(c) {
      var h = new cu();
      nu(c, function(f, d) {
        switch (f) {
          case "MPEGT":
            h.integer(f + "S", d);
            break;
          case "LOCA":
            h.set(f + "L", Sp(d));
            break;
        }
      }, /[^\d]:/, /,/), t.ontimestampmap && t.ontimestampmap({
        MPEGTS: h.get("MPEGTS"),
        LOCAL: h.get("LOCAL")
      });
    }
    function a(c) {
      c.match(/X-TIMESTAMP-MAP/) ? nu(c, function(h, f) {
        switch (h) {
          case "X-TIMESTAMP-MAP":
            i(f);
            break;
        }
      }, /=/) : nu(c, function(h, f) {
        switch (h) {
          case "Region":
            n(f);
            break;
        }
      }, /:/);
    }
    try {
      var s;
      if (t.state === "INITIAL") {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        s = r();
        var o = s.match(/^WEBVTT([ \t].*)?$/);
        if (!o || !o[0])
          throw new Ti(Ti.Errors.BadSignature);
        t.state = "HEADER";
      }
      for (var u = !1; t.buffer; ) {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        switch (u ? u = !1 : s = r(), t.state) {
          case "HEADER":
            /:/.test(s) ? a(s) : s || (t.state = "ID");
            continue;
          case "NOTE":
            s || (t.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(s)) {
              t.state = "NOTE";
              break;
            }
            if (!s)
              continue;
            t.cue = new (t.vttjs.VTTCue || t.window.VTTCue)(0, 0, "");
            try {
              t.cue.align = "center";
            } catch {
              t.cue.align = "middle";
            }
            if (t.state = "CUE", s.indexOf("-->") === -1) {
              t.cue.id = s;
              continue;
            }
          case "CUE":
            try {
              LC(s, t.cue, t.regionList);
            } catch (c) {
              t.reportOrThrowError(c), t.cue = null, t.state = "BADCUE";
              continue;
            }
            t.state = "CUETEXT";
            continue;
          case "CUETEXT":
            var l = s.indexOf("-->") !== -1;
            if (!s || l && (u = !0)) {
              t.oncue && t.oncue(t.cue), t.cue = null, t.state = "ID";
              continue;
            }
            t.cue.text && (t.cue.text += `
`), t.cue.text += s.replace(/\u2028/g, `
`).replace(/u2029/g, `
`);
            continue;
          case "BADCUE":
            s || (t.state = "ID");
            continue;
        }
      }
    } catch (c) {
      t.reportOrThrowError(c), t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  },
  flush: function() {
    var e = this;
    try {
      if (e.buffer += e.decoder.decode(), (e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL")
        throw new Ti(Ti.Errors.BadSignature);
    } catch (t) {
      e.reportOrThrowError(t);
    }
    return e.onflush && e.onflush(), this;
  }
};
var VC = Oo, HC = "auto", zC = {
  "": 1,
  lr: 1,
  rl: 1
}, WC = {
  start: 1,
  center: 1,
  end: 1,
  left: 1,
  right: 1,
  auto: 1,
  "line-left": 1,
  "line-right": 1
};
function jC(e) {
  if (typeof e != "string")
    return !1;
  var t = zC[e.toLowerCase()];
  return t ? e.toLowerCase() : !1;
}
function sf(e) {
  if (typeof e != "string")
    return !1;
  var t = WC[e.toLowerCase()];
  return t ? e.toLowerCase() : !1;
}
function x_(e, t, r) {
  this.hasBeenReset = !1;
  var n = "", i = !1, a = e, s = t, o = r, u = null, l = "", c = !0, h = "auto", f = "start", d = "auto", p = "auto", _ = 100, v = "center";
  Object.defineProperties(this, {
    id: {
      enumerable: !0,
      get: function() {
        return n;
      },
      set: function(x) {
        n = "" + x;
      }
    },
    pauseOnExit: {
      enumerable: !0,
      get: function() {
        return i;
      },
      set: function(x) {
        i = !!x;
      }
    },
    startTime: {
      enumerable: !0,
      get: function() {
        return a;
      },
      set: function(x) {
        if (typeof x != "number")
          throw new TypeError("Start time must be set to a number.");
        a = x, this.hasBeenReset = !0;
      }
    },
    endTime: {
      enumerable: !0,
      get: function() {
        return s;
      },
      set: function(x) {
        if (typeof x != "number")
          throw new TypeError("End time must be set to a number.");
        s = x, this.hasBeenReset = !0;
      }
    },
    text: {
      enumerable: !0,
      get: function() {
        return o;
      },
      set: function(x) {
        o = "" + x, this.hasBeenReset = !0;
      }
    },
    region: {
      enumerable: !0,
      get: function() {
        return u;
      },
      set: function(x) {
        u = x, this.hasBeenReset = !0;
      }
    },
    vertical: {
      enumerable: !0,
      get: function() {
        return l;
      },
      set: function(x) {
        var E = jC(x);
        if (E === !1)
          throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
        l = E, this.hasBeenReset = !0;
      }
    },
    snapToLines: {
      enumerable: !0,
      get: function() {
        return c;
      },
      set: function(x) {
        c = !!x, this.hasBeenReset = !0;
      }
    },
    line: {
      enumerable: !0,
      get: function() {
        return h;
      },
      set: function(x) {
        if (typeof x != "number" && x !== HC)
          throw new SyntaxError("Line: an invalid number or illegal string was specified.");
        h = x, this.hasBeenReset = !0;
      }
    },
    lineAlign: {
      enumerable: !0,
      get: function() {
        return f;
      },
      set: function(x) {
        var E = sf(x);
        E ? (f = E, this.hasBeenReset = !0) : console.warn("lineAlign: an invalid or illegal string was specified.");
      }
    },
    position: {
      enumerable: !0,
      get: function() {
        return d;
      },
      set: function(x) {
        if (x < 0 || x > 100)
          throw new Error("Position must be between 0 and 100.");
        d = x, this.hasBeenReset = !0;
      }
    },
    positionAlign: {
      enumerable: !0,
      get: function() {
        return p;
      },
      set: function(x) {
        var E = sf(x);
        E ? (p = E, this.hasBeenReset = !0) : console.warn("positionAlign: an invalid or illegal string was specified.");
      }
    },
    size: {
      enumerable: !0,
      get: function() {
        return _;
      },
      set: function(x) {
        if (x < 0 || x > 100)
          throw new Error("Size must be between 0 and 100.");
        _ = x, this.hasBeenReset = !0;
      }
    },
    align: {
      enumerable: !0,
      get: function() {
        return v;
      },
      set: function(x) {
        var E = sf(x);
        if (!E)
          throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
        v = E, this.hasBeenReset = !0;
      }
    }
  }), this.displayState = void 0;
}
x_.prototype.getCueAsHTML = function() {
  return WebVTT.convertCueToDOMTree(window, this.text);
};
var qC = x_, XC = {
  "": !0,
  up: !0
};
function YC(e) {
  if (typeof e != "string")
    return !1;
  var t = XC[e.toLowerCase()];
  return t ? e.toLowerCase() : !1;
}
function Ko(e) {
  return typeof e == "number" && e >= 0 && e <= 100;
}
function QC() {
  var e = 100, t = 3, r = 0, n = 100, i = 0, a = 100, s = "";
  Object.defineProperties(this, {
    width: {
      enumerable: !0,
      get: function() {
        return e;
      },
      set: function(o) {
        if (!Ko(o))
          throw new Error("Width must be between 0 and 100.");
        e = o;
      }
    },
    lines: {
      enumerable: !0,
      get: function() {
        return t;
      },
      set: function(o) {
        if (typeof o != "number")
          throw new TypeError("Lines must be set to a number.");
        t = o;
      }
    },
    regionAnchorY: {
      enumerable: !0,
      get: function() {
        return n;
      },
      set: function(o) {
        if (!Ko(o))
          throw new Error("RegionAnchorX must be between 0 and 100.");
        n = o;
      }
    },
    regionAnchorX: {
      enumerable: !0,
      get: function() {
        return r;
      },
      set: function(o) {
        if (!Ko(o))
          throw new Error("RegionAnchorY must be between 0 and 100.");
        r = o;
      }
    },
    viewportAnchorY: {
      enumerable: !0,
      get: function() {
        return a;
      },
      set: function(o) {
        if (!Ko(o))
          throw new Error("ViewportAnchorY must be between 0 and 100.");
        a = o;
      }
    },
    viewportAnchorX: {
      enumerable: !0,
      get: function() {
        return i;
      },
      set: function(o) {
        if (!Ko(o))
          throw new Error("ViewportAnchorX must be between 0 and 100.");
        i = o;
      }
    },
    scroll: {
      enumerable: !0,
      get: function() {
        return s;
      },
      set: function(o) {
        var u = YC(o);
        u === !1 ? console.warn("Scroll: an invalid or illegal string was specified.") : s = u;
      }
    }
  });
}
var KC = QC, qn = nh, gs = __.exports = {
  WebVTT: VC,
  VTTCue: qC,
  VTTRegion: KC
};
qn.vttjs = gs;
qn.WebVTT = gs.WebVTT;
var $C = gs.VTTCue, ZC = gs.VTTRegion, JC = qn.VTTCue, eM = qn.VTTRegion;
gs.shim = function() {
  qn.VTTCue = $C, qn.VTTRegion = ZC;
};
gs.restore = function() {
  qn.VTTCue = JC, qn.VTTRegion = eM;
};
qn.VTTCue || gs.shim();
var tM = __.exports;
const Rv = /* @__PURE__ */ Qn(tM);
/**
 * @license
 * Video.js 7.21.4 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
var A_ = "7.21.4", Rn = {}, va = function(t, r) {
  return Rn[t] = Rn[t] || [], r && (Rn[t] = Rn[t].concat(r)), Rn[t];
}, rM = function(t, r) {
  va(t, r);
}, T_ = function(t, r) {
  var n = va(t).indexOf(r);
  return n <= -1 ? !1 : (Rn[t] = Rn[t].slice(), Rn[t].splice(n, 1), !0);
}, iM = function(t, r) {
  va(
    t,
    [].concat(r).map(function(n) {
      var i = function a() {
        return T_(t, a), n.apply(void 0, arguments);
      };
      return i;
    })
  );
}, Uc = {
  prefixed: !0
}, tc = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror",
    "fullscreen"
  ],
  // WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror",
    "-webkit-full-screen"
  ],
  // Mozilla
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror",
    "-moz-full-screen"
  ],
  // Microsoft
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError",
    "-ms-fullscreen"
  ]
], Iv = tc[0], au;
for (var Wl = 0; Wl < tc.length; Wl++)
  if (tc[Wl][1] in Te) {
    au = tc[Wl];
    break;
  }
if (au) {
  for (var jl = 0; jl < au.length; jl++)
    Uc[Iv[jl]] = au[jl];
  Uc.prefixed = au[0] !== Iv[0];
}
var oi = [], nM = function(t, r) {
  return function(n, i, a) {
    var s = r.levels[i], o = new RegExp("^(" + s + ")$");
    if (n !== "log" && a.unshift(n.toUpperCase() + ":"), a.unshift(t + ":"), oi) {
      oi.push([].concat(a));
      var u = oi.length - 1e3;
      oi.splice(0, u > 0 ? u : 0);
    }
    if (j.console) {
      var l = j.console[n];
      !l && n === "debug" && (l = j.console.info || j.console.log), !(!l || !s || !o.test(n)) && l[Array.isArray(a) ? "apply" : "call"](j.console, a);
    }
  };
};
function E_(e) {
  var t = "info", r, n = function() {
    for (var a = arguments.length, s = new Array(a), o = 0; o < a; o++)
      s[o] = arguments[o];
    r("log", t, s);
  };
  return r = nM(e, n), n.createLogger = function(i) {
    return E_(e + ": " + i);
  }, n.levels = {
    DEFAULT: t,
    all: "debug|log|warn|error",
    debug: "debug|log|warn|error",
    error: "error",
    info: "log|warn|error",
    off: "",
    warn: "warn|error"
  }, n.level = function(i) {
    if (typeof i == "string") {
      if (!n.levels.hasOwnProperty(i))
        throw new Error('"' + i + '" in not a valid log level');
      t = i;
    }
    return t;
  }, n.history = function() {
    return oi ? [].concat(oi) : [];
  }, n.history.filter = function(i) {
    return (oi || []).filter(function(a) {
      return new RegExp(".*" + i + ".*").test(a[0]);
    });
  }, n.history.clear = function() {
    oi && (oi.length = 0);
  }, n.history.disable = function() {
    oi !== null && (oi.length = 0, oi = null);
  }, n.history.enable = function() {
    oi === null && (oi = []);
  }, n.error = function() {
    for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)
      a[s] = arguments[s];
    return r("error", t, a);
  }, n.warn = function() {
    for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)
      a[s] = arguments[s];
    return r("warn", t, a);
  }, n.debug = function() {
    for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)
      a[s] = arguments[s];
    return r("debug", t, a);
  }, n;
}
var vt = E_("VIDEOJS"), w_ = vt.createLogger, aM = Object.prototype.toString, S_ = function(t) {
  return Xn(t) ? Object.keys(t) : [];
};
function Bs(e, t) {
  S_(e).forEach(function(r) {
    return t(e[r], r);
  });
}
function sM(e, t, r) {
  return r === void 0 && (r = 0), S_(e).reduce(function(n, i) {
    return t(n, e[i], i);
  }, r);
}
function sr(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  return Object.assign ? Bi.apply(void 0, [e].concat(r)) : (r.forEach(function(i) {
    i && Bs(i, function(a, s) {
      e[s] = a;
    });
  }), e);
}
function Xn(e) {
  return !!e && typeof e == "object";
}
function dl(e) {
  return Xn(e) && aM.call(e) === "[object Object]" && e.constructor === Object;
}
function pl(e, t) {
  if (!e || !t)
    return "";
  if (typeof j.getComputedStyle == "function") {
    var r;
    try {
      r = j.getComputedStyle(e);
    } catch {
      return "";
    }
    return r ? r.getPropertyValue(t) || r[t] : "";
  }
  return "";
}
var Lr = j.navigator && j.navigator.userAgent || "", Ov = /AppleWebKit\/([\d.]+)/i.exec(Lr), oM = Ov ? parseFloat(Ov.pop()) : null, C_ = /iPod/i.test(Lr), uM = function() {
  var e = Lr.match(/OS (\d+)_/i);
  return e && e[1] ? e[1] : null;
}(), Jn = /Android/i.test(Lr), Cp = function() {
  var e = Lr.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
  if (!e)
    return null;
  var t = e[1] && parseFloat(e[1]), r = e[2] && parseFloat(e[2]);
  return t && r ? parseFloat(e[1] + "." + e[2]) : t || null;
}(), M_ = Jn && Cp < 5 && oM < 537, D_ = /Firefox/i.test(Lr), Cl = /Edg/i.test(Lr), ea = !Cl && (/Chrome/i.test(Lr) || /CriOS/i.test(Lr)), P_ = function() {
  var e = Lr.match(/(Chrome|CriOS)\/(\d+)/);
  return e && e[2] ? parseFloat(e[2]) : null;
}(), Ml = function() {
  var e = /MSIE\s(\d+)\.\d/.exec(Lr), t = e && parseFloat(e[1]);
  return !t && /Trident\/7.0/i.test(Lr) && /rv:11.0/.test(Lr) && (t = 11), t;
}(), Mp = /Safari/i.test(Lr) && !ea && !Jn && !Cl, L_ = /Windows/i.test(Lr), So = !!(Bo() && ("ontouchstart" in j || j.navigator.maxTouchPoints || j.DocumentTouch && j.document instanceof j.DocumentTouch)), Dp = /iPad/i.test(Lr) || Mp && So && !/iPhone/i.test(Lr), Pp = /iPhone/i.test(Lr) && !Dp, ci = Pp || Dp || C_, Mh = (Mp || ci) && !ea, lM = /* @__PURE__ */ Object.freeze({
  ANDROID_VERSION: Cp,
  CHROME_VERSION: P_,
  IOS_VERSION: uM,
  IE_VERSION: Ml,
  IS_ANDROID: Jn,
  IS_CHROME: ea,
  IS_EDGE: Cl,
  IS_FIREFOX: D_,
  IS_IPOD: C_,
  IS_ANY_SAFARI: Mh,
  __proto__: null,
  IS_IOS: ci,
  IS_IPAD: Dp,
  IS_IPHONE: Pp,
  IS_NATIVE_ANDROID: M_,
  IS_SAFARI: Mp,
  IS_WINDOWS: L_,
  TOUCH_ENABLED: So
});
function Bv(e) {
  return typeof e == "string" && !!e.trim();
}
function R_(e) {
  if (e.indexOf(" ") >= 0)
    throw new Error("class has illegal whitespace characters");
}
function cM(e) {
  return new RegExp("(^|\\s)" + e + "($|\\s)");
}
function Bo() {
  return Te === j.document;
}
function Fo(e) {
  return Xn(e) && e.nodeType === 1;
}
function I_() {
  try {
    return j.parent !== j.self;
  } catch {
    return !0;
  }
}
function O_(e) {
  return function(t, r) {
    if (!Bv(t))
      return Te[e](null);
    Bv(r) && (r = Te.querySelector(r));
    var n = Fo(r) ? r : Te;
    return n[e] && n[e](t);
  };
}
function St(e, t, r, n) {
  e === void 0 && (e = "div"), t === void 0 && (t = {}), r === void 0 && (r = {});
  var i = Te.createElement(e);
  return Object.getOwnPropertyNames(t).forEach(function(a) {
    var s = t[a];
    a.indexOf("aria-") !== -1 || a === "role" || a === "type" ? (vt.warn(
      `Setting attributes in the second argument of createEl()
has been deprecated. Use the third argument instead.
` + ("createEl(type, properties, attributes). Attempting to set " + a + " to " + s + ".")
    ), i.setAttribute(a, s)) : a === "textContent" ? ys(i, s) : (i[a] !== s || a === "tabIndex") && (i[a] = s);
  }), Object.getOwnPropertyNames(r).forEach(function(a) {
    i.setAttribute(a, r[a]);
  }), n && Rp(i, n), i;
}
function rn(e) {
  return e.tagName === "CX-TOOLTIP" ? e.children[0] : e;
}
function ys(e, t) {
  return typeof e.textContent > "u" ? e.innerText = t : e.textContent = t, e;
}
function rd(e, t) {
  t.firstChild ? t.insertBefore(e, t.firstChild) : t.appendChild(e);
}
function Ga(e, t) {
  const r = rn(e);
  return R_(t), r.classList ? r.classList.contains(t) : cM(t).test(r.className);
}
function Gn(e, t) {
  const r = rn(e);
  return r.classList ? r.classList.add(t) : Ga(r, t) || (r.className = (r.className + " " + t).trim()), r;
}
function Dl(e, t) {
  const r = rn(e);
  return r ? (r.classList ? r.classList.remove(t) : (R_(t), r.className = r.className.split(/\s+/).filter(function(n) {
    return n !== t;
  }).join(" ")), r) : (vt.warn("removeClass was called with an element that doesn't exist"), null);
}
function B_(e, t, r) {
  const n = rn(e);
  var i = Ga(n, t);
  if (typeof r == "function" && (r = r(n, t)), typeof r != "boolean" && (r = !i), r !== i)
    return r ? Gn(n, t) : Dl(n, t), n;
}
function F_(e, t) {
  const r = rn(e);
  Object.getOwnPropertyNames(t).forEach(function(n) {
    var i = t[n];
    i === null || typeof i > "u" || i === !1 ? r.removeAttribute(n) : r.setAttribute(n, i === !0 ? "" : i);
  });
}
function Ln(e) {
  var t = {}, r = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,";
  if (e && e.attributes && e.attributes.length > 0)
    for (var n = e.attributes, i = n.length - 1; i >= 0; i--) {
      var a = n[i].name, s = n[i].value;
      (typeof e[a] == "boolean" || r.indexOf("," + a + ",") !== -1) && (s = s !== null), t[a] = s;
    }
  return t;
}
function k_(e, t) {
  return rn(e).getAttribute(t);
}
function Co(e, t, r) {
  rn(e).setAttribute(t, r);
}
function Dh(e, t) {
  rn(e).removeAttribute(t);
}
function N_() {
  Te.body.focus(), Te.onselectstart = function() {
    return !1;
  };
}
function U_() {
  Te.onselectstart = function() {
    return !0;
  };
}
function Mo(e) {
  if (e && e.getBoundingClientRect && e.parentNode) {
    var t = e.getBoundingClientRect(), r = {};
    return ["bottom", "height", "left", "right", "top", "width"].forEach(function(n) {
      t[n] !== void 0 && (r[n] = t[n]);
    }), r.height || (r.height = parseFloat(pl(e, "height"))), r.width || (r.width = parseFloat(pl(e, "width"))), r;
  }
}
function ml(e) {
  if (!e || e && !e.offsetParent)
    return {
      height: 0,
      left: 0,
      top: 0,
      width: 0
    };
  for (var t = e.offsetWidth, r = e.offsetHeight, n = 0, i = 0; e.offsetParent && e !== Te[Uc.fullscreenElement]; )
    n += e.offsetLeft, i += e.offsetTop, e = e.offsetParent;
  return {
    height: r,
    left: n,
    top: i,
    width: t
  };
}
function Ph(e, t) {
  var r = {
    x: 0,
    y: 0
  };
  if (ci)
    for (var n = e; n && n.nodeName.toLowerCase() !== "html"; ) {
      var i = pl(n, "transform");
      if (/^matrix/.test(i)) {
        var a = i.slice(7, -1).split(/,\s/).map(Number);
        r.x += a[4], r.y += a[5];
      } else if (/^matrix3d/.test(i)) {
        var s = i.slice(9, -1).split(/,\s/).map(Number);
        r.x += s[12], r.y += s[13];
      }
      n = n.parentNode;
    }
  var o = {}, u = ml(t.target), l = ml(e), c = l.width, h = l.height, f = t.offsetY - (l.top - u.top), d = t.offsetX - (l.left - u.left);
  return t.changedTouches && (d = t.changedTouches[0].pageX - l.left, f = t.changedTouches[0].pageY + l.top, ci && (d -= r.x, f -= r.y)), o.y = 1 - Math.max(0, Math.min(1, f / h)), o.x = Math.max(0, Math.min(1, d / c)), o;
}
function G_(e) {
  return Xn(e) && e.nodeType === 3;
}
function Lp(e) {
  const t = rn(e);
  for (; t.firstChild; )
    t.removeChild(t.firstChild);
  return t;
}
function V_(e) {
  return typeof e == "function" && (e = e()), (Array.isArray(e) ? e : [e]).map(function(t) {
    if (typeof t == "function" && (t = t()), Fo(t) || G_(t))
      return t;
    if (typeof t == "string" && /\S/.test(t))
      return Te.createTextNode(t);
  }).filter(function(t) {
    return t;
  });
}
function Rp(e, t) {
  const r = rn(e);
  return V_(t).forEach(function(n) {
    return r.appendChild(n);
  }), r;
}
function H_(e, t) {
  const r = rn(e);
  return Rp(Lp(r), t);
}
function vl(e) {
  return e.button === void 0 && e.buttons === void 0 || e.button === 0 && e.buttons === void 0 || e.type === "mouseup" && e.button === 0 && e.buttons === 0 ? !0 : !(e.button !== 0 || e.buttons !== 1);
}
var ga = O_("querySelector"), z_ = O_("querySelectorAll"), W_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  addClass: Gn,
  createEl: St,
  hasClass: Ga,
  getAttribute: k_,
  isEl: Fo,
  getAttributes: Ln,
  isInFrame: I_,
  blockTextSelection: N_,
  isReal: Bo,
  getBoundingClientRect: Mo,
  prependTo: rd,
  findPosition: ml,
  removeClass: Dl,
  emptyEl: Lp,
  textContent: ys,
  appendContent: Rp,
  getPointerPosition: Ph,
  setAttributes: F_,
  $: ga,
  toggleClass: B_,
  $$: z_,
  removeAttribute: Dh,
  insertContent: H_,
  setAttribute: Co,
  isSingleLeftClick: vl,
  isTextNode: G_,
  unblockTextSelection: U_,
  normalizeContent: V_
}), j_ = !1, id, hM = function() {
  if (id.options.autoSetup !== !1) {
    var t = Array.prototype.slice.call(Te.getElementsByTagName("video")), r = Array.prototype.slice.call(
      Te.getElementsByTagName("audio")
    ), n = Array.prototype.slice.call(
      Te.getElementsByTagName("video-js")
    ), i = t.concat(r, n);
    if (i && i.length > 0)
      for (var a = 0, s = i.length; a < s; a++) {
        var o = i[a];
        if (o && o.getAttribute) {
          if (o.player === void 0) {
            var u = o.getAttribute("data-setup");
            u !== null && id(o);
          }
        } else {
          nd(1);
          break;
        }
      }
    else j_ || nd(1);
  }
};
function nd(e, t) {
  Bo() && (t && (id = t), j.setTimeout(hM, e));
}
function ad() {
  j_ = !0, j.removeEventListener("load", ad);
}
Bo() && (Te.readyState === "complete" ? ad() : j.addEventListener("load", ad));
var q_ = function(t) {
  var r = Te.createElement("style");
  return r.className = t, r;
}, X_ = function(t, r) {
  t.styleSheet ? t.styleSheet.cssText = r : t.textContent = r;
}, fM = 3, dM = fM;
function ta() {
  return dM++;
}
var Y_;
j.WeakMap || (Y_ = /* @__PURE__ */ function() {
  function e() {
    this.vdata = "vdata" + Math.floor(
      j.performance && j.performance.now() || Date.now()
    ), this.data = {};
  }
  var t = e.prototype;
  return t.set = function(n, i) {
    var a = n[this.vdata] || ta();
    return n[this.vdata] || (n[this.vdata] = a), this.data[a] = i, this;
  }, t.get = function(n) {
    var i = n[this.vdata];
    if (i)
      return this.data[i];
    vt("We have no data for this element", n);
  }, t.has = function(n) {
    var i = n[this.vdata];
    return i in this.data;
  }, t.delete = function(n) {
    var i = n[this.vdata];
    i && (delete this.data[i], delete n[this.vdata]);
  }, e;
}());
var ri = j.WeakMap ? /* @__PURE__ */ new WeakMap() : new Y_();
function Fv(e, t) {
  if (ri.has(e)) {
    var r = ri.get(e);
    r.handlers[t].length === 0 && (delete r.handlers[t], e.removeEventListener ? e.removeEventListener(t, r.dispatcher, !1) : e.detachEvent && e.detachEvent("on" + t, r.dispatcher)), Object.getOwnPropertyNames(r.handlers).length <= 0 && (delete r.handlers, delete r.dispatcher, delete r.disabled), Object.getOwnPropertyNames(r).length === 0 && ri.delete(e);
  }
}
function Ip(e, t, r, n) {
  r.forEach(function(i) {
    e(t, i, n);
  });
}
function Lh(e) {
  if (e.fixed_)
    return e;
  function t() {
    return !0;
  }
  function r() {
    return !1;
  }
  if (!e || !e.isPropagationStopped || !e.isImmediatePropagationStopped) {
    var n = e || j.event;
    e = {};
    for (var i in n)
      i !== "layerX" && i !== "layerY" && i !== "keyLocation" && i !== "webkitMovementX" && i !== "webkitMovementY" && i !== "path" && (i === "returnValue" && n.preventDefault || (e[i] = n[i]));
    if (e.target || (e.target = e.srcElement || Te), e.relatedTarget || (e.relatedTarget = e.fromElement === e.target ? e.toElement : e.fromElement), e.preventDefault = function() {
      n.preventDefault && n.preventDefault(), e.returnValue = !1, n.returnValue = !1, e.defaultPrevented = !0;
    }, e.defaultPrevented = !1, e.stopPropagation = function() {
      n.stopPropagation && n.stopPropagation(), e.cancelBubble = !0, n.cancelBubble = !0, e.isPropagationStopped = t;
    }, e.isPropagationStopped = r, e.stopImmediatePropagation = function() {
      n.stopImmediatePropagation && n.stopImmediatePropagation(), e.isImmediatePropagationStopped = t, e.stopPropagation();
    }, e.isImmediatePropagationStopped = r, e.clientX !== null && e.clientX !== void 0) {
      var a = Te.documentElement, s = Te.body;
      e.pageX = e.clientX + (a && a.scrollLeft || s && s.scrollLeft || 0) - (a && a.clientLeft || s && s.clientLeft || 0), e.pageY = e.clientY + (a && a.scrollTop || s && s.scrollTop || 0) - (a && a.clientTop || s && s.clientTop || 0);
    }
    e.which = e.charCode || e.keyCode, e.button !== null && e.button !== void 0 && (e.button = e.button & 1 ? 0 : e.button & 4 ? 1 : e.button & 2 ? 2 : 0);
  }
  return e.fixed_ = !0, e;
}
var ql, pM = function() {
  if (typeof ql != "boolean") {
    ql = !1;
    try {
      var t = Object.defineProperty({}, "passive", {
        get: function() {
          ql = !0;
        }
      });
      j.addEventListener("test", null, t), j.removeEventListener("test", null, t);
    } catch {
    }
  }
  return ql;
}, mM = ["touchstart", "touchmove"];
function Pi(e, t, r) {
  if (Array.isArray(t))
    return Ip(Pi, e, t, r);
  ri.has(e) || ri.set(e, {});
  var n = ri.get(e);
  if (n.handlers || (n.handlers = {}), n.handlers[t] || (n.handlers[t] = []), r.guid || (r.guid = ta()), n.handlers[t].push(r), n.dispatcher || (n.disabled = !1, n.dispatcher = function(a, s) {
    if (!n.disabled) {
      a = Lh(a);
      var o = n.handlers[a.type];
      if (o)
        for (var u = o.slice(0), l = 0, c = u.length; l < c && !a.isImmediatePropagationStopped(); l++)
          try {
            u[l].call(e, a, s);
          } catch (h) {
            vt.error(h);
          }
    }
  }), n.handlers[t].length === 1)
    if (e.addEventListener) {
      var i = !1;
      pM() && mM.indexOf(t) > -1 && (i = {
        passive: !0
      }), e.addEventListener(t, n.dispatcher, i);
    } else e.attachEvent && e.attachEvent("on" + t, n.dispatcher);
}
function zr(e, t, r) {
  if (ri.has(e)) {
    var n = ri.get(e);
    if (n.handlers) {
      if (Array.isArray(t))
        return Ip(zr, e, t, r);
      var i = function(l, c) {
        n.handlers[c] = [], Fv(l, c);
      };
      if (t === void 0) {
        for (var a in n.handlers)
          Object.prototype.hasOwnProperty.call(n.handlers || {}, a) && i(e, a);
        return;
      }
      var s = n.handlers[t];
      if (s) {
        if (!r) {
          i(e, t);
          return;
        }
        if (r.guid)
          for (var o = 0; o < s.length; o++)
            s[o].guid === r.guid && s.splice(o--, 1);
        Fv(e, t);
      }
    }
  }
}
function ko(e, t, r) {
  var n = ri.has(e) ? ri.get(e) : {}, i = e.parentNode || e.ownerDocument;
  if (typeof t == "string" ? t = {
    target: e,
    type: t
  } : t.target || (t.target = e), t = Lh(t), n.dispatcher && n.dispatcher.call(e, t, r), i && !t.isPropagationStopped() && t.bubbles === !0)
    ko.call(null, i, t, r);
  else if (!i && !t.defaultPrevented && t.target && t.target[t.type]) {
    ri.has(t.target) || ri.set(t.target, {});
    var a = ri.get(t.target);
    t.target[t.type] && (a.disabled = !0, typeof t.target[t.type] == "function" && t.target[t.type](), a.disabled = !1);
  }
  return !t.defaultPrevented;
}
function Rh(e, t, r) {
  if (Array.isArray(t))
    return Ip(Rh, e, t, r);
  var n = function i() {
    zr(e, t, i), r.apply(this, arguments);
  };
  n.guid = r.guid = r.guid || ta(), Pi(e, t, n);
}
function Q_(e, t, r) {
  var n = function i() {
    zr(e, t, i), r.apply(this, arguments);
  };
  n.guid = r.guid = r.guid || ta(), Pi(e, t, n);
}
var vM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  any: Q_,
  fixEvent: Lh,
  off: zr,
  on: Pi,
  one: Rh,
  trigger: ko
}), Ji = 30, $t = function(t, r, n) {
  r.guid || (r.guid = ta());
  var i = r.bind(t);
  return i.guid = n ? n + "_" + r.guid : r.guid, i;
}, Yn = function(t, r) {
  var n = j.performance.now(), i = function() {
    var s = j.performance.now();
    s - n >= r && (t.apply(void 0, arguments), n = s);
  };
  return i;
}, gM = function(t, r, n, i) {
  i === void 0 && (i = j);
  var a, s = function() {
    i.clearTimeout(a), a = null;
  }, o = function() {
    var l = this, c = arguments, h = function() {
      a = null, h = null, t.apply(l, c);
    };
    i.clearTimeout(a), a = i.setTimeout(h, r);
  };
  return o.cancel = s, o;
}, Ir = function() {
};
Ir.prototype.allowedEvents_ = {};
Ir.prototype.on = function(e, t) {
  var r = this.addEventListener;
  this.addEventListener = function() {
  }, Pi(this, e, t), this.addEventListener = r;
};
Ir.prototype.addEventListener = Ir.prototype.on;
Ir.prototype.off = function(e, t) {
  zr(this, e, t);
};
Ir.prototype.removeEventListener = Ir.prototype.off;
Ir.prototype.one = function(e, t) {
  var r = this.addEventListener;
  this.addEventListener = function() {
  }, Rh(this, e, t), this.addEventListener = r;
};
Ir.prototype.any = function(e, t) {
  var r = this.addEventListener;
  this.addEventListener = function() {
  }, Q_(this, e, t), this.addEventListener = r;
};
Ir.prototype.trigger = function(e) {
  var t = e.type || e;
  typeof e == "string" && (e = {
    type: t
  }), e = Lh(e), this.allowedEvents_[t] && this["on" + t] && this["on" + t](e), ko(this, e);
};
Ir.prototype.dispatchEvent = Ir.prototype.trigger;
var $o;
Ir.prototype.queueTrigger = function(e) {
  var t = this;
  $o || ($o = /* @__PURE__ */ new Map());
  var r = e.type || e, n = $o.get(this);
  n || (n = /* @__PURE__ */ new Map(), $o.set(this, n));
  var i = n.get(r);
  n.delete(r), j.clearTimeout(i);
  var a = j.setTimeout(function() {
    n.delete(r), n.size === 0 && (n = null, $o.delete(t)), t.trigger(e);
  }, 0);
  n.set(r, a);
};
var Ih = function(t) {
  return typeof t.name == "function" ? t.name() : typeof t.name == "string" ? t.name : t.name_ ? t.name_ : t.constructor && t.constructor.name ? t.constructor.name : typeof t;
}, Vn = function(t) {
  return t instanceof Ir || !!t.eventBusEl_ && ["on", "one", "off", "trigger"].every(function(r) {
    return typeof t[r] == "function";
  });
}, yM = function(t, r) {
  Vn(t) ? r() : (t.eventedCallbacks || (t.eventedCallbacks = []), t.eventedCallbacks.push(r));
}, sd = function(t) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof t == "string" && /\S/.test(t) || Array.isArray(t) && !!t.length
  );
}, Gc = function(t, r, n) {
  if (!t || !t.nodeName && !Vn(t))
    throw new Error(
      "Invalid target for " + Ih(r) + "#" + n + "; must be a DOM node or evented object."
    );
}, K_ = function(t, r, n) {
  if (!sd(t))
    throw new Error(
      "Invalid event type for " + Ih(r) + "#" + n + "; must be a non-empty string or array."
    );
}, $_ = function(t, r, n) {
  if (typeof t != "function")
    throw new Error(
      "Invalid listener for " + Ih(r) + "#" + n + "; must be a function."
    );
}, of = function(t, r, n) {
  var i = r.length < 3 || r[0] === t || r[0] === t.eventBusEl_, a, s, o;
  return i ? (a = t.eventBusEl_, r.length >= 3 && r.shift(), s = r[0], o = r[1]) : (a = r[0], s = r[1], o = r[2]), Gc(a, t, n), K_(s, t, n), $_(o, t, n), o = $t(t, o), {
    isTargetingSelf: i,
    listener: o,
    target: a,
    type: s
  };
}, Pa = function(t, r, n, i) {
  Gc(t, t, r), t.nodeName ? vM[r](t, n, i) : t[r](n, i);
}, _M = {
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once for the first event that is triggered
   * then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  any: function() {
    for (var t = this, r = arguments.length, n = new Array(r), i = 0; i < r; i++)
      n[i] = arguments[i];
    var a = of(this, n, "any"), s = a.isTargetingSelf, o = a.target, u = a.type, l = a.listener;
    if (s)
      Pa(o, "any", u, l);
    else {
      var c = function h() {
        t.off(o, u, h);
        for (var f = arguments.length, d = new Array(f), p = 0; p < f; p++)
          d[p] = arguments[p];
        l.apply(null, d);
      };
      c.guid = l.guid, Pa(o, "any", u, c);
    }
  },
  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function(t, r, n) {
    if (!t || sd(t))
      zr(this.eventBusEl_, t, r);
    else {
      var i = t, a = r;
      Gc(i, this, "off"), K_(a, this, "off"), $_(n, this, "off"), n = $t(this, n), this.off("dispose", n), i.nodeName ? (zr(i, a, n), zr(i, "dispose", n)) : Vn(i) && (i.off(a, n), i.off("dispose", n));
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function() {
    for (var t = this, r = arguments.length, n = new Array(r), i = 0; i < r; i++)
      n[i] = arguments[i];
    var a = of(this, n, "on"), s = a.isTargetingSelf, o = a.target, u = a.type, l = a.listener;
    if (Pa(o, "on", u, l), !s) {
      var c = function() {
        return t.off(o, u, l);
      };
      c.guid = l.guid;
      var h = function() {
        return t.off("dispose", c);
      };
      h.guid = l.guid, Pa(this, "on", "dispose", c), Pa(o, "on", "dispose", h);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will be called once per event and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function() {
    for (var t = this, r = arguments.length, n = new Array(r), i = 0; i < r; i++)
      n[i] = arguments[i];
    var a = of(this, n, "one"), s = a.isTargetingSelf, o = a.target, u = a.type, l = a.listener;
    if (s)
      Pa(o, "one", u, l);
    else {
      var c = function h() {
        t.off(o, u, h);
        for (var f = arguments.length, d = new Array(f), p = 0; p < f; p++)
          d[p] = arguments[p];
        l.apply(null, d);
      };
      c.guid = l.guid, Pa(o, "one", u, c);
    }
  },
  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @return {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function(t, r) {
    Gc(this.eventBusEl_, this, "trigger");
    var n = t && typeof t != "string" ? t.type : t;
    if (!sd(n)) {
      var i = "Invalid event type for " + Ih(this) + "#trigger; must be a non-empty string or object with a type key that has a non-empty value.";
      if (t)
        (this.log || vt).error(i);
      else
        throw new Error(i);
    }
    return ko(this.eventBusEl_, t, r);
  }
};
function Op(e, t) {
  t === void 0 && (t = {});
  var r = t, n = r.eventBusKey;
  if (n) {
    if (!e[n].nodeName)
      throw new Error(
        'The eventBusKey "' + n + '" does not refer to an element.'
      );
    e.eventBusEl_ = e[n];
  } else
    e.eventBusEl_ = St("span", {
      className: "vjs-event-bus"
    });
  return sr(e, _M), e.eventedCallbacks && e.eventedCallbacks.forEach(function(i) {
    i();
  }), e.on("dispose", function() {
    e.off(), [e, e.el_, e.eventBusEl_].forEach(function(i) {
      i && ri.has(i) && ri.delete(i);
    }), j.setTimeout(function() {
      e.eventBusEl_ = null;
    }, 0);
  }), e;
}
var bM = {
  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @return {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function(t) {
    var r = this;
    typeof t == "function" && (t = t());
    var n;
    return Bs(t, function(i, a) {
      r.state[a] !== i && (n = n || {}, n[a] = {
        from: r.state[a],
        to: i
      }), r.state[a] = i;
    }), n && Vn(this) && this.trigger({
      changes: n,
      type: "statechanged"
    }), n;
  },
  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {}
};
function Z_(e, t) {
  return sr(e, bM), e.state = sr({}, e.state, t), typeof e.handleStateChanged == "function" && Vn(e) && e.on("statechanged", e.handleStateChanged), e;
}
var rc = function(t) {
  return typeof t != "string" ? t : t.replace(/./, function(r) {
    return r.toLowerCase();
  });
}, mr = function(t) {
  return typeof t != "string" ? t : t.replace(/./, function(r) {
    return r.toUpperCase();
  });
}, xM = function(t, r) {
  return mr(t) === mr(r);
};
function Kt() {
  for (var e = {}, t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  return r.forEach(function(i) {
    i && Bs(i, function(a, s) {
      if (!dl(a)) {
        e[s] = a;
        return;
      }
      dl(e[s]) || (e[s] = {}), e[s] = Kt(e[s], a);
    });
  }), e;
}
var AM = /* @__PURE__ */ function() {
  function e() {
    this.map_ = {};
  }
  var t = e.prototype;
  return t.has = function(n) {
    return n in this.map_;
  }, t.delete = function(n) {
    var i = this.has(n);
    return delete this.map_[n], i;
  }, t.set = function(n, i) {
    return this.map_[n] = i, this;
  }, t.forEach = function(n, i) {
    for (var a in this.map_)
      n.call(i, this.map_[a], a, this);
  }, e;
}(), TM = j.Map ? j.Map : AM, EM = /* @__PURE__ */ function() {
  function e() {
    this.set_ = {};
  }
  var t = e.prototype;
  return t.has = function(n) {
    return n in this.set_;
  }, t.delete = function(n) {
    var i = this.has(n);
    return delete this.set_[n], i;
  }, t.add = function(n) {
    return this.set_[n] = 1, this;
  }, t.forEach = function(n, i) {
    for (var a in this.set_)
      n.call(i, a, a, this);
  }, e;
}(), uf = j.Set ? j.Set : EM, ye = /* @__PURE__ */ function() {
  function e(r, n, i) {
    var a = this;
    if (!r && this.play ? this.player_ = r = this : this.player_ = r, this.isDisposed_ = !1, this.parentComponent_ = null, this.options_ = Kt({}, this.options_), n = this.options_ = Kt(this.options_, n), this.id_ = n.id || n.el && n.el.id, !this.id_) {
      var s = r && r.id && r.id() || "no_player";
      this.id_ = s + "_component_" + ta();
    }
    this.name_ = n.name || null, n.el ? this.el_ = n.el : n.createEl !== !1 && (this.el_ = this.createEl()), n.className && this.el_ && n.className.split(" ").forEach(function(o) {
      return a.addClass(o);
    }), n.evented !== !1 && (Op(this, {
      eventBusKey: this.el_ ? "el_" : null
    }), this.handleLanguagechange = this.handleLanguagechange.bind(this), this.on(this.player_, "languagechange", this.handleLanguagechange)), Z_(this, this.constructor.defaultState), this.children_ = [], this.childIndex_ = {}, this.childNameIndex_ = {}, this.setTimeoutIds_ = new uf(), this.setIntervalIds_ = new uf(), this.rafIds_ = new uf(), this.namedRafs_ = new TM(), this.clearingTimersOnDispose_ = !1, n.initChildren !== !1 && this.initChildren(), this.ready(i), n.reportTouchActivity !== !1 && this.enableTouchActivity();
  }
  var t = e.prototype;
  return t.dispose = function(n) {
    if (n === void 0 && (n = {}), !this.isDisposed_) {
      if (this.readyQueue_ && (this.readyQueue_.length = 0), this.trigger({
        bubbles: !1,
        type: "dispose"
      }), this.isDisposed_ = !0, this.children_)
        for (var i = this.children_.length - 1; i >= 0; i--)
          this.children_[i].dispose && this.children_[i].dispose();
      this.children_ = null, this.childIndex_ = null, this.childNameIndex_ = null, this.parentComponent_ = null, this.el_ && (this.el_.parentNode && (n.restoreEl ? this.el_.parentNode.replaceChild(n.restoreEl, this.el_) : this.el_.parentNode.removeChild(this.el_)), this.el_ = null), this.player_ = null;
    }
  }, t.isDisposed = function() {
    return !!this.isDisposed_;
  }, t.player = function() {
    return this.player_;
  }, t.options = function(n) {
    return n ? (this.options_ = Kt(this.options_, n), this.options_) : this.options_;
  }, t.el = function() {
    return this.el_;
  }, t.createEl = function(n, i, a) {
    return St(n, i, a);
  }, t.localize = function(n, i, a) {
    a === void 0 && (a = n);
    var s = this.player_.language && this.player_.language(), o = this.player_.languages && this.player_.languages(), u = o && o[s], l = s && s.split("-")[0], c = o && o[l], h = a;
    return u && u[n] ? h = u[n] : c && c[n] && (h = c[n]), i && (h = h.replace(
      /\{(\d+)\}/g,
      function(f, d) {
        var p = i[d - 1], _ = p;
        return typeof p > "u" && (_ = f), _;
      }
    )), h;
  }, t.handleLanguagechange = function() {
  }, t.contentEl = function() {
    return this.contentEl_ || this.el_;
  }, t.id = function() {
    return this.id_;
  }, t.name = function() {
    return this.name_;
  }, t.children = function() {
    return this.children_;
  }, t.getChildById = function(n) {
    return this.childIndex_[n];
  }, t.getChild = function(n) {
    if (n)
      return this.childNameIndex_[n];
  }, t.getDescendant = function() {
    for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
      i[a] = arguments[a];
    i = i.reduce(function(u, l) {
      return u.concat(l);
    }, []);
    for (var s = this, o = 0; o < i.length; o++)
      if (s = s.getChild(i[o]), !s || !s.getChild)
        return;
    return s;
  }, t.addChild = function(n, i, a) {
    i === void 0 && (i = {}), a === void 0 && (a = this.children_.length);
    var s, o;
    if (typeof n == "string") {
      o = mr(n);
      var u = i.componentClass || o;
      i.name = o;
      var l = e.getComponent(u);
      if (!l)
        throw new Error("Component " + u + " does not exist");
      if (typeof l != "function")
        return null;
      s = new l(this.player_ || this, i);
    } else
      s = n;
    if (s.parentComponent_ && s.parentComponent_.removeChild(s), this.children_.splice(a, 0, s), s.parentComponent_ = this, typeof s.id == "function" && (this.childIndex_[s.id()] = s), o = o || s.name && mr(s.name()), o && (this.childNameIndex_[o] = s, this.childNameIndex_[rc(o)] = s), typeof s.el == "function" && s.el()) {
      var c = null;
      this.children_[a + 1] && (this.children_[a + 1].el_ ? c = this.children_[a + 1].el_ : Fo(this.children_[a + 1]) && (c = this.children_[a + 1])), this.contentEl().insertBefore(s.el(), c);
    }
    return s;
  }, t.removeChild = function(n) {
    if (typeof n == "string" && (n = this.getChild(n)), !(!n || !this.children_)) {
      for (var i = !1, a = this.children_.length - 1; a >= 0; a--)
        if (this.children_[a] === n) {
          i = !0, this.children_.splice(a, 1);
          break;
        }
      if (i) {
        n.parentComponent_ = null, this.childIndex_[n.id()] = null, this.childNameIndex_[mr(n.name())] = null, this.childNameIndex_[rc(n.name())] = null;
        var s = n.el();
        s && s.parentNode === this.contentEl() && this.contentEl().removeChild(n.el());
      }
    }
  }, t.initChildren = function() {
    var n = this, i = this.options_.children;
    if (i) {
      var a = this.options_, s = function(c) {
        var h = c.name, f = c.opts;
        if (a[h] !== void 0 && (f = a[h]), f !== !1) {
          f === !0 && (f = {}), f.playerOptions = n.options_.playerOptions;
          var d = n.addChild(h, f);
          d && (n[h] = d);
        }
      }, o, u = e.getComponent("Tech");
      Array.isArray(i) ? o = i : o = Object.keys(i), o.concat(
        Object.keys(this.options_).filter(function(l) {
          return !o.some(function(c) {
            return typeof c == "string" ? l === c : l === c.name;
          });
        })
      ).map(function(l) {
        var c, h;
        return typeof l == "string" ? (c = l, h = i[c] || n.options_[c] || {}) : (c = l.name, h = l), {
          name: c,
          opts: h
        };
      }).filter(function(l) {
        var c = e.getComponent(
          l.opts.componentClass || mr(l.name)
        );
        return c && !u.isTech(c);
      }).forEach(s);
    }
  }, t.buildCSSClass = function() {
    return "";
  }, t.ready = function(n, i) {
    if (i === void 0 && (i = !1), !!n) {
      if (!this.isReady_) {
        this.readyQueue_ = this.readyQueue_ || [], this.readyQueue_.push(n);
        return;
      }
      i ? n.call(this) : this.setTimeout(n, 1);
    }
  }, t.triggerReady = function() {
    this.isReady_ = !0, this.setTimeout(function() {
      var n = this.readyQueue_;
      this.readyQueue_ = [], n && n.length > 0 && n.forEach(function(i) {
        i.call(this);
      }, this), this.trigger("ready");
    }, 1);
  }, t.$ = function(n, i) {
    return ga(n, i || this.contentEl());
  }, t.$$ = function(n, i) {
    return z_(n, i || this.contentEl());
  }, t.hasClass = function(n) {
    return Ga(this.el_, n);
  }, t.addClass = function(n) {
    Gn(this.el_, n);
  }, t.removeClass = function(n) {
    Dl(this.el_, n);
  }, t.toggleClass = function(n, i) {
    B_(this.el_, n, i);
  }, t.show = function() {
    this.removeClass("vjs-hidden");
  }, t.hide = function() {
    this.addClass("vjs-hidden");
  }, t.lockShowing = function() {
    this.addClass("vjs-lock-showing");
  }, t.unlockShowing = function() {
    this.removeClass("vjs-lock-showing");
  }, t.getAttribute = function(n) {
    return k_(this.el_, n);
  }, t.setAttribute = function(n, i) {
    Co(this.el_, n, i);
  }, t.removeAttribute = function(n) {
    Dh(this.el_, n);
  }, t.width = function(n, i) {
    return this.dimension("width", n, i);
  }, t.height = function(n, i) {
    return this.dimension("height", n, i);
  }, t.dimensions = function(n, i) {
    this.width(n, !0), this.height(i);
  }, t.dimension = function(n, i, a) {
    if (i !== void 0) {
      (i === null || i !== i) && (i = 0), ("" + i).indexOf("%") !== -1 || ("" + i).indexOf("px") !== -1 ? this.el_.style[n] = i : i === "auto" ? this.el_.style[n] = "" : this.el_.style[n] = i + "px", a || this.trigger("componentresize");
      return;
    }
    if (!this.el_)
      return 0;
    var s = this.el_.style[n], o = s.indexOf("px");
    return parseInt(o !== -1 ? s.slice(0, o) : this.el_["offset" + mr(n)], 10);
  }, t.currentDimension = function(n) {
    var i = 0;
    if (n !== "width" && n !== "height")
      throw new Error("currentDimension only accepts width or height value");
    if (i = pl(this.el_, n), i = parseFloat(i), i === 0 || isNaN(i)) {
      var a = "offset" + mr(n);
      i = this.el_[a];
    }
    return i;
  }, t.currentDimensions = function() {
    return {
      height: this.currentDimension("height"),
      width: this.currentDimension("width")
    };
  }, t.currentWidth = function() {
    return this.currentDimension("width");
  }, t.currentHeight = function() {
    return this.currentDimension("height");
  }, t.focus = function() {
    this.el_.focus();
  }, t.blur = function() {
    this.el_.blur();
  }, t.handleKeyDown = function(n) {
    this.player_ && (lt.isEventKey(n, "Tab") || n.stopPropagation(), this.player_.handleKeyDown(n));
  }, t.handleKeyPress = function(n) {
    this.handleKeyDown(n);
  }, t.emitTapEvents = function() {
    var n = 0, i = null, a = 10, s = 200, o;
    this.on("touchstart", function(l) {
      l.touches.length === 1 && (i = {
        pageX: l.touches[0].pageX,
        pageY: l.touches[0].pageY
      }, n = j.performance.now(), o = !0);
    }), this.on("touchmove", function(l) {
      if (l.touches.length > 1)
        o = !1;
      else if (i) {
        var c = l.touches[0].pageX - i.pageX, h = l.touches[0].pageY - i.pageY, f = Math.sqrt(c * c + h * h);
        f > a && (o = !1);
      }
    });
    var u = function() {
      o = !1;
    };
    this.on("touchleave", u), this.on("touchcancel", u), this.on("touchend", function(l) {
      if (i = null, o === !0) {
        var c = j.performance.now() - n;
        c < s && (l.preventDefault(), this.trigger("tap"));
      }
    });
  }, t.enableTouchActivity = function() {
    if (!(!this.player() || !this.player().reportUserActivity)) {
      var n = $t(this.player(), this.player().reportUserActivity), i;
      this.on("touchstart", function() {
        n(), this.clearInterval(i), i = this.setInterval(n, 250);
      });
      var a = function(o) {
        n(), this.clearInterval(i);
      };
      this.on("touchmove", n), this.on("touchend", a), this.on("touchcancel", a);
    }
  }, t.setTimeout = function(n, i) {
    var a = this, s;
    return n = $t(this, n), this.clearTimersOnDispose_(), s = j.setTimeout(function() {
      a.setTimeoutIds_.has(s) && a.setTimeoutIds_.delete(s), n();
    }, i), this.setTimeoutIds_.add(s), s;
  }, t.clearTimeout = function(n) {
    return this.setTimeoutIds_.has(n) && (this.setTimeoutIds_.delete(n), j.clearTimeout(n)), n;
  }, t.setInterval = function(n, i) {
    n = $t(this, n), this.clearTimersOnDispose_();
    var a = j.setInterval(n, i);
    return this.setIntervalIds_.add(a), a;
  }, t.clearInterval = function(n) {
    return this.setIntervalIds_.has(n) && (this.setIntervalIds_.delete(n), j.clearInterval(n)), n;
  }, t.requestAnimationFrame = function(n) {
    var i = this;
    if (!this.supportsRaf_)
      return this.setTimeout(n, 1e3 / 60);
    this.clearTimersOnDispose_();
    var a;
    return n = $t(this, n), a = j.requestAnimationFrame(function() {
      i.rafIds_.has(a) && i.rafIds_.delete(a), n();
    }), this.rafIds_.add(a), a;
  }, t.requestNamedAnimationFrame = function(n, i) {
    var a = this;
    if (!this.namedRafs_.has(n)) {
      this.clearTimersOnDispose_(), i = $t(this, i);
      var s = this.requestAnimationFrame(function() {
        i(), a.namedRafs_.has(n) && a.namedRafs_.delete(n);
      });
      return this.namedRafs_.set(n, s), n;
    }
  }, t.cancelNamedAnimationFrame = function(n) {
    this.namedRafs_.has(n) && (this.cancelAnimationFrame(this.namedRafs_.get(n)), this.namedRafs_.delete(n));
  }, t.cancelAnimationFrame = function(n) {
    return this.supportsRaf_ ? (this.rafIds_.has(n) && (this.rafIds_.delete(n), j.cancelAnimationFrame(n)), n) : this.clearTimeout(n);
  }, t.clearTimersOnDispose_ = function() {
    var n = this;
    this.clearingTimersOnDispose_ || (this.clearingTimersOnDispose_ = !0, this.one("dispose", function() {
      [
        ["namedRafs_", "cancelNamedAnimationFrame"],
        ["rafIds_", "cancelAnimationFrame"],
        ["setTimeoutIds_", "clearTimeout"],
        ["setIntervalIds_", "clearInterval"]
      ].forEach(function(i) {
        var a = i[0], s = i[1];
        n[a].forEach(function(o, u) {
          return n[s](u);
        });
      }), n.clearingTimersOnDispose_ = !1;
    }));
  }, e.registerComponent = function(n, i) {
    if (typeof n != "string" || !n)
      throw new Error(
        'Illegal component name, "' + n + '"; must be a non-empty string.'
      );
    var a = e.getComponent("Tech"), s = a && a.isTech(i), o = e === i || e.prototype.isPrototypeOf(i.prototype);
    if (s || !o) {
      var u;
      throw s ? u = "techs must be registered using Tech.registerTech()" : u = "must be a Component subclass", new Error('Illegal component, "' + n + '"; ' + u + ".");
    }
    n = mr(n), e.components_ || (e.components_ = {});
    var l = e.getComponent("Player");
    if (n === "Player" && l && l.players) {
      var c = l.players, h = Object.keys(c);
      if (c && h.length > 0 && h.map(function(f) {
        return c[f];
      }).every(Boolean))
        throw new Error(
          "Can not register Player component after player has been created."
        );
    }
    return e.components_[n] = i, e.components_[rc(n)] = i, i;
  }, e.getComponent = function(n) {
    if (!(!n || !e.components_))
      return e.components_[n];
  }, e;
}();
ye.prototype.supportsRaf_ = typeof j.requestAnimationFrame == "function" && typeof j.cancelAnimationFrame == "function";
ye.registerComponent("Component", ye);
function wM(e, t, r) {
  if (typeof t != "number" || t < 0 || t > r)
    throw new Error(
      "Failed to execute '" + e + "' on 'TimeRanges': The index provided (" + t + ") is non-numeric or out of bounds (0-" + r + ")."
    );
}
function kv(e, t, r, n) {
  return wM(e, n, r.length - 1), r[n][t];
}
function lf(e) {
  var t;
  return e === void 0 || e.length === 0 ? t = {
    end: function() {
      throw new Error("This TimeRanges object is empty");
    },
    length: 0,
    start: function() {
      throw new Error("This TimeRanges object is empty");
    }
  } : t = {
    end: kv.bind(null, "end", 1, e),
    length: e.length,
    start: kv.bind(null, "start", 0, e)
  }, j.Symbol && j.Symbol.iterator && (t[j.Symbol.iterator] = function() {
    return (e || []).values();
  }), t;
}
function Va(e, t) {
  return Array.isArray(e) ? lf(e) : e === void 0 || t === void 0 ? lf() : lf([[e, t]]);
}
function J_(e, t) {
  var r = 0, n, i;
  if (!t)
    return 0;
  (!e || !e.length) && (e = Va(0, 0));
  for (var a = 0; a < e.length; a++)
    n = e.start(a), i = e.end(a), i > t && (i = t), r += i - n;
  return r / t;
}
function ii(e) {
  if (e instanceof ii)
    return e;
  typeof e == "number" ? this.code = e : typeof e == "string" ? this.message = e : Xn(e) && (typeof e.code == "number" && (this.code = e.code), sr(this, e)), this.message || (this.message = ii.defaultMessages[this.code] || "");
}
ii.prototype.code = 0;
ii.prototype.message = "";
ii.prototype.status = null;
ii.errorTypes = [
  "MEDIA_ERR_CUSTOM",
  "MEDIA_ERR_ABORTED",
  "MEDIA_ERR_NETWORK",
  "MEDIA_ERR_DECODE",
  "MEDIA_ERR_SRC_NOT_SUPPORTED",
  "MEDIA_ERR_ENCRYPTED"
];
ii.defaultMessages = {
  1: "You aborted the media playback",
  2: "A network error caused the media download to fail part-way.",
  3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
  4: "The media could not be loaded, either because the server or network failed, or because the format is not supported, or asset is still processing.",
  5: "The media is encrypted and we do not have the keys to decrypt it."
};
for (var Ms = 0; Ms < ii.errorTypes.length; Ms++)
  ii[ii.errorTypes[Ms]] = Ms, ii.prototype[ii.errorTypes[Ms]] = Ms;
function hu(e) {
  return e != null && typeof e.then == "function";
}
function fn(e) {
  hu(e) && e.then(null, function(t) {
  });
}
var od = function(t) {
  var r = [
    "kind",
    "label",
    "language",
    "id",
    "inBandMetadataTrackDispatchType",
    "mode",
    "src"
  ].reduce(
    function(n, i, a) {
      return t[i] && (n[i] = t[i]), n;
    },
    {
      cues: t.cues && Array.prototype.map.call(t.cues, function(n) {
        return {
          endTime: n.endTime,
          id: n.id,
          startTime: n.startTime,
          text: n.text
        };
      })
    }
  );
  return r;
}, SM = function(t) {
  var r = t.$$("track"), n = Array.prototype.map.call(r, function(a) {
    return a.track;
  }), i = Array.prototype.map.call(r, function(a) {
    var s = od(a.track);
    return a.src && (s.src = a.src), s;
  });
  return i.concat(
    Array.prototype.filter.call(t.textTracks(), function(a) {
      return n.indexOf(a) === -1;
    }).map(od)
  );
}, CM = function(t, r) {
  return t.forEach(function(n) {
    var i = r.addRemoteTextTrack(n).track;
    !n.src && n.cues && n.cues.forEach(function(a) {
      return i.addCue(a);
    });
  }), r.textTracks();
}, Nv = {
  jsonToTextTracks: CM,
  textTracksToJson: SM,
  trackToJson_: od
}, cf = "vjs-modal-dialog", No = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.handleKeyDown_ = function(s) {
      return a.handleKeyDown(s);
    }, a.close_ = function(s) {
      return a.close(s);
    }, a.opened_ = a.hasBeenOpened_ = a.hasBeenFilled_ = !1, a.closeable(!a.options_.uncloseable), a.content(a.options_.content), a.contentEl_ = St(
      "div",
      {
        className: cf + "-content"
      },
      {
        role: "document"
      }
    ), a.descEl_ = St("p", {
      className: cf + "-description vjs-control-text",
      id: a.el().getAttribute("aria-describedby")
    }), ys(a.descEl_, a.description()), a.el_.appendChild(a.descEl_), a.el_.appendChild(a.contentEl_), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: this.buildCSSClass(),
        tabIndex: -1
      },
      {
        "aria-describedby": this.id() + "_description",
        "aria-hidden": "true",
        "aria-label": this.label(),
        role: "dialog"
      }
    );
  }, r.dispose = function() {
    this.contentEl_ = null, this.descEl_ = null, this.previouslyActiveEl_ = null, e.prototype.dispose.call(this);
  }, r.buildCSSClass = function() {
    return cf + " vjs-hidden " + e.prototype.buildCSSClass.call(this);
  }, r.label = function() {
    return this.localize(this.options_.label || "Modal Window");
  }, r.description = function() {
    var i = this.options_.description || this.localize("This is a modal window.");
    return this.closeable() && (i += " " + this.localize(
      "This modal can be closed by pressing the Escape key or activating the close button."
    )), i;
  }, r.open = function() {
    if (!this.opened_) {
      var i = this.player();
      this.trigger("beforemodalopen"), this.opened_ = !0, (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) && this.fill(), this.wasPlaying_ = !i.paused(), this.options_.pauseOnOpen && this.wasPlaying_ && i.pause(), this.on("keydown", this.handleKeyDown_), this.hadControls_ = i.controls(), i.controls(!1), this.show(), this.conditionalFocus_(), this.el().setAttribute("aria-hidden", "false"), this.trigger("modalopen"), this.hasBeenOpened_ = !0;
    }
  }, r.opened = function(i) {
    return typeof i == "boolean" && this[i ? "open" : "close"](), this.opened_;
  }, r.close = function() {
    if (this.opened_) {
      var i = this.player();
      this.trigger("beforemodalclose"), this.opened_ = !1, this.wasPlaying_ && this.options_.pauseOnOpen && i.play(), this.off("keydown", this.handleKeyDown_), this.hadControls_ && i.controls(!0), this.hide(), this.el().setAttribute("aria-hidden", "true"), this.trigger("modalclose"), this.conditionalBlur_(), this.options_.temporary && this.dispose();
    }
  }, r.closeable = function(i) {
    if (typeof i == "boolean") {
      var a = this.closeable_ = !!i, s = this.getChild("closeButton");
      if (a && !s) {
        var o = this.contentEl_;
        this.contentEl_ = this.el_, s = this.addChild("closeButton", {
          controlText: "Close Modal Dialog"
        }), this.contentEl_ = o, this.on(s, "close", this.close_);
      }
      !a && s && (this.off(s, "close", this.close_), this.removeChild(s), s.dispose());
    }
    return this.closeable_;
  }, r.fill = function() {
    this.fillWith(this.content());
  }, r.fillWith = function(i) {
    var a = this.contentEl(), s = a.parentNode, o = a.nextSibling;
    this.trigger("beforemodalfill"), this.hasBeenFilled_ = !0, s.removeChild(a), this.empty(), H_(a, i), this.trigger("modalfill"), o ? s.insertBefore(a, o) : s.appendChild(a);
    var u = this.getChild("closeButton");
    u && s.appendChild(u.el_);
  }, r.empty = function() {
    this.trigger("beforemodalempty"), Lp(this.contentEl()), this.trigger("modalempty");
  }, r.content = function(i) {
    return typeof i < "u" && (this.content_ = i), this.content_;
  }, r.conditionalFocus_ = function() {
    var i = Te.activeElement, a = this.player_.el_;
    this.previouslyActiveEl_ = null, (a.contains(i) || a === i) && (this.previouslyActiveEl_ = i, this.focus());
  }, r.conditionalBlur_ = function() {
    this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(), this.previouslyActiveEl_ = null);
  }, r.handleKeyDown = function(i) {
    if (i.stopPropagation(), lt.isEventKey(i, "Escape") && this.closeable()) {
      i.preventDefault(), this.close();
      return;
    }
    if (lt.isEventKey(i, "Tab")) {
      for (var a = this.focusableEls_(), s = this.el_.querySelector(":focus"), o, u = 0; u < a.length; u++)
        if (s === a[u]) {
          o = u;
          break;
        }
      Te.activeElement === this.el_ && (o = 0), i.shiftKey && o === 0 ? (a[a.length - 1].focus(), i.preventDefault()) : !i.shiftKey && o === a.length - 1 && (a[0].focus(), i.preventDefault());
    }
  }, r.focusableEls_ = function() {
    var i = this.el_.querySelectorAll("*");
    return Array.prototype.filter.call(i, function(a) {
      return (a instanceof j.HTMLAnchorElement || a instanceof j.HTMLAreaElement) && a.hasAttribute("href") || (a instanceof j.HTMLInputElement || a instanceof j.HTMLSelectElement || a instanceof j.HTMLTextAreaElement || a instanceof j.HTMLButtonElement) && !a.hasAttribute("disabled") || a instanceof j.HTMLIFrameElement || a instanceof j.HTMLObjectElement || a instanceof j.HTMLEmbedElement || a.hasAttribute("tabindex") && a.getAttribute("tabindex") !== -1 || a.hasAttribute("contenteditable");
    });
  }, t;
}(ye);
No.prototype.options_ = {
  pauseOnOpen: !0,
  temporary: !0
};
ye.registerComponent("ModalDialog", No);
var Do = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var i;
    n === void 0 && (n = []), i = e.call(this) || this, i.tracks_ = [], Object.defineProperty(ze(i), "length", {
      get: function() {
        return this.tracks_.length;
      }
    });
    for (var a = 0; a < n.length; a++)
      i.addTrack(n[a]);
    return i;
  }
  var r = t.prototype;
  return r.addTrack = function(i) {
    var a = this, s = this.tracks_.length;
    "" + s in this || Object.defineProperty(this, s, {
      get: function() {
        return this.tracks_[s];
      }
    }), this.tracks_.indexOf(i) === -1 && (this.tracks_.push(i), this.trigger({
      target: this,
      track: i,
      type: "addtrack"
    })), i.labelchange_ = function() {
      a.trigger({
        target: a,
        track: i,
        type: "labelchange"
      });
    }, Vn(i) && i.addEventListener("labelchange", i.labelchange_);
  }, r.removeTrack = function(i) {
    for (var a, s = 0, o = this.length; s < o; s++)
      if (this[s] === i) {
        a = this[s], a.off && a.off(), this.tracks_.splice(s, 1);
        break;
      }
    a && this.trigger({
      target: this,
      track: a,
      type: "removetrack"
    });
  }, r.getTrackById = function(i) {
    for (var a = null, s = 0, o = this.length; s < o; s++) {
      var u = this[s];
      if (u.id === i) {
        a = u;
        break;
      }
    }
    return a;
  }, t;
}(Ir);
Do.prototype.allowedEvents_ = {
  addtrack: "addtrack",
  change: "change",
  labelchange: "labelchange",
  removetrack: "removetrack"
};
for (var MM in Do.prototype.allowedEvents_)
  Do.prototype["on" + MM] = null;
var hf = function(t, r) {
  for (var n = 0; n < t.length; n++)
    !Object.keys(t[n]).length || r.id === t[n].id || (t[n].enabled = !1);
}, DM = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var i;
    n === void 0 && (n = []);
    for (var a = n.length - 1; a >= 0; a--)
      if (n[a].enabled) {
        hf(n, n[a]);
        break;
      }
    return i = e.call(this, n) || this, i.changing_ = !1, i;
  }
  var r = t.prototype;
  return r.addTrack = function(i) {
    var a = this;
    i.enabled && hf(this, i), e.prototype.addTrack.call(this, i), i.addEventListener && (i.enabledChange_ = function() {
      a.changing_ || (a.changing_ = !0, hf(a, i), a.changing_ = !1, a.trigger("change"));
    }, i.addEventListener("enabledchange", i.enabledChange_));
  }, r.removeTrack = function(i) {
    e.prototype.removeTrack.call(this, i), i.removeEventListener && i.enabledChange_ && (i.removeEventListener("enabledchange", i.enabledChange_), i.enabledChange_ = null);
  }, t;
}(Do), ff = function(t, r) {
  for (var n = 0; n < t.length; n++)
    !Object.keys(t[n]).length || r.id === t[n].id || (t[n].selected = !1);
}, PM = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var i;
    n === void 0 && (n = []);
    for (var a = n.length - 1; a >= 0; a--)
      if (n[a].selected) {
        ff(n, n[a]);
        break;
      }
    return i = e.call(this, n) || this, i.changing_ = !1, Object.defineProperty(ze(i), "selectedIndex", {
      get: function() {
        for (var o = 0; o < this.length; o++)
          if (this[o].selected)
            return o;
        return -1;
      },
      set: function() {
      }
    }), i;
  }
  var r = t.prototype;
  return r.addTrack = function(i) {
    var a = this;
    i.selected && ff(this, i), e.prototype.addTrack.call(this, i), i.addEventListener && (i.selectedChange_ = function() {
      a.changing_ || (a.changing_ = !0, ff(a, i), a.changing_ = !1, a.trigger("change"));
    }, i.addEventListener("selectedchange", i.selectedChange_));
  }, r.removeTrack = function(i) {
    e.prototype.removeTrack.call(this, i), i.removeEventListener && i.selectedChange_ && (i.removeEventListener("selectedchange", i.selectedChange_), i.selectedChange_ = null);
  }, t;
}(Do), e1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.addTrack = function(i) {
    var a = this;
    e.prototype.addTrack.call(this, i), this.queueChange_ || (this.queueChange_ = function() {
      return a.queueTrigger("change");
    }), this.triggerSelectedlanguagechange || (this.triggerSelectedlanguagechange_ = function() {
      return a.trigger("selectedlanguagechange");
    }), i.addEventListener("modechange", this.queueChange_);
    var s = ["metadata", "chapters"];
    s.indexOf(i.kind) === -1 && i.addEventListener("modechange", this.triggerSelectedlanguagechange_);
  }, r.removeTrack = function(i) {
    e.prototype.removeTrack.call(this, i), i.removeEventListener && (this.queueChange_ && i.removeEventListener("modechange", this.queueChange_), this.selectedlanguagechange_ && i.removeEventListener(
      "modechange",
      this.triggerSelectedlanguagechange_
    ));
  }, t;
}(Do), LM = /* @__PURE__ */ function() {
  function e(r) {
    r === void 0 && (r = []), this.trackElements_ = [], Object.defineProperty(this, "length", {
      get: function() {
        return this.trackElements_.length;
      }
    });
    for (var n = 0, i = r.length; n < i; n++)
      this.addTrackElement_(r[n]);
  }
  var t = e.prototype;
  return t.addTrackElement_ = function(n) {
    var i = this.trackElements_.length;
    "" + i in this || Object.defineProperty(this, i, {
      get: function() {
        return this.trackElements_[i];
      }
    }), this.trackElements_.indexOf(n) === -1 && this.trackElements_.push(n);
  }, t.getTrackElementByTrack_ = function(n) {
    for (var i, a = 0, s = this.trackElements_.length; a < s; a++)
      if (n === this.trackElements_[a].track) {
        i = this.trackElements_[a];
        break;
      }
    return i;
  }, t.removeTrackElement_ = function(n) {
    for (var i = 0, a = this.trackElements_.length; i < a; i++)
      if (n === this.trackElements_[i]) {
        this.trackElements_[i].track && typeof this.trackElements_[i].track.off == "function" && this.trackElements_[i].track.off(), typeof this.trackElements_[i].off == "function" && this.trackElements_[i].off(), this.trackElements_.splice(i, 1);
        break;
      }
  }, e;
}(), Uv = /* @__PURE__ */ function() {
  function e(r) {
    e.prototype.setCues_.call(this, r), Object.defineProperty(this, "length", {
      get: function() {
        return this.length_;
      }
    });
  }
  var t = e.prototype;
  return t.setCues_ = function(n) {
    var i = this.length || 0, a = 0, s = n.length;
    this.cues_ = n, this.length_ = n.length;
    var o = function(l) {
      "" + l in this || Object.defineProperty(this, "" + l, {
        get: function() {
          return this.cues_[l];
        }
      });
    };
    if (i < s)
      for (a = i; a < s; a++)
        o.call(this, a);
  }, t.getCueById = function(n) {
    for (var i = null, a = 0, s = this.length; a < s; a++) {
      var o = this[a];
      if (o.id === n) {
        i = o;
        break;
      }
    }
    return i;
  }, e;
}(), RM = {
  alternative: "alternative",
  captions: "captions",
  commentary: "commentary",
  main: "main",
  sign: "sign",
  subtitles: "subtitles"
}, IM = {
  alternative: "alternative",
  commentary: "commentary",
  descriptions: "descriptions",
  main: "main",
  "main-desc": "main-desc",
  translation: "translation"
}, OM = {
  captions: "captions",
  chapters: "chapters",
  descriptions: "descriptions",
  metadata: "metadata",
  subtitles: "subtitles"
}, Gv = {
  disabled: "disabled",
  hidden: "hidden",
  showing: "showing"
}, Bp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(r) {
    var n;
    r === void 0 && (r = {}), n = e.call(this) || this;
    var i = {
      id: r.id || "vjs_track_" + ta(),
      kind: r.kind || "",
      language: r.language || ""
    }, a = r.label || "", s = function(l) {
      Object.defineProperty(ze(n), l, {
        get: function() {
          return i[l];
        },
        set: function() {
        }
      });
    };
    for (var o in i)
      s(o);
    return Object.defineProperty(ze(n), "label", {
      get: function() {
        return a;
      },
      set: function(l) {
        l !== a && (a = l, this.trigger("labelchange"));
      }
    }), n;
  }
  return t;
}(Ir), Fp = function(t) {
  var r = [
    "protocol",
    "hostname",
    "port",
    "pathname",
    "search",
    "hash",
    "host"
  ], n = Te.createElement("a");
  n.href = t;
  for (var i = {}, a = 0; a < r.length; a++)
    i[r[a]] = n[r[a]];
  return i.protocol === "http:" && (i.host = i.host.replace(/:80$/, "")), i.protocol === "https:" && (i.host = i.host.replace(/:443$/, "")), i.protocol || (i.protocol = j.location.protocol), i.host || (i.host = j.location.host), i;
}, t1 = function(t) {
  if (!t.match(/^https?:\/\//)) {
    var r = Te.createElement("a");
    r.href = t, t = r.href;
  }
  return t;
}, kp = function(t) {
  if (typeof t == "string") {
    var r = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/, n = r.exec(t);
    if (n)
      return n.pop().toLowerCase();
  }
  return "";
}, Oh = function(t, r) {
  r === void 0 && (r = j.location);
  var n = Fp(t), i = n.protocol === ":" ? r.protocol : n.protocol, a = i + n.host !== r.protocol + r.host;
  return a;
}, BM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getAbsoluteURL: t1,
  getFileExtension: kp,
  isCrossOrigin: Oh,
  parseUrl: Fp
}), Vv = function(t, r) {
  var n = new j.WebVTT.Parser(
    j,
    j.vttjs,
    j.WebVTT.StringDecoder()
  ), i = [];
  n.oncue = function(a) {
    r.addCue(a);
  }, n.onparsingerror = function(a) {
    i.push(a);
  }, n.onflush = function() {
    r.trigger({
      target: r,
      type: "loadeddata"
    });
  }, n.parse(t), i.length > 0 && (j.console && j.console.groupCollapsed && j.console.groupCollapsed(
    "Text Track parsing errors for " + r.src
  ), i.forEach(function(a) {
    return vt.error(a);
  }), j.console && j.console.groupEnd && j.console.groupEnd()), n.flush();
}, Hv = function(t, r) {
  var n = {
    uri: t
  }, i = Oh(t);
  i && (n.cors = i);
  var a = r.tech_.crossOrigin() === "use-credentials";
  a && (n.withCredentials = a), Ry(
    n,
    $t(this, function(s, o, u) {
      if (s)
        return vt.error(s, o);
      r.loaded_ = !0, typeof j.WebVTT != "function" ? r.tech_ && r.tech_.any(["vttjsloaded", "vttjserror"], function(l) {
        if (l.type === "vttjserror") {
          vt.error(
            "vttjs failed to load, stopping trying to process " + r.src
          );
          return;
        }
        return Vv(u, r);
      }) : Vv(u, r);
    })
  );
}, Pl = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var i;
    if (n === void 0 && (n = {}), !n.tech)
      throw new Error("A tech was not provided.");
    var a = Kt(n, {
      kind: OM[n.kind] || "subtitles",
      language: n.language || n.srclang || ""
    }), s = Gv[a.mode] || "disabled", o = a.default;
    (a.kind === "metadata" || a.kind === "chapters") && (s = "hidden"), i = e.call(this, a) || this, i.tech_ = a.tech, i.cues_ = [], i.activeCues_ = [], i.preload_ = i.tech_.preloadTextTracks !== !1;
    var u = new Uv(i.cues_), l = new Uv(i.activeCues_), c = !1;
    i.timeupdateHandler = $t(
      ze(i),
      function(f) {
        if (f === void 0 && (f = {}), !this.tech_.isDisposed()) {
          if (!this.tech_.isReady_) {
            f.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(
              this.timeupdateHandler
            ));
            return;
          }
          this.activeCues = this.activeCues, c && (this.trigger("cuechange"), c = !1), f.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(
            this.timeupdateHandler
          ));
        }
      }
    );
    var h = function() {
      i.stopTracking();
    };
    return i.tech_.one("dispose", h), s !== "disabled" && i.startTracking(), Object.defineProperties(ze(i), {
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} activeCues
       *         The list text track cues that are currently active for this TextTrack.
       * @instance
       */
      activeCues: {
        get: function() {
          if (!this.loaded_)
            return null;
          if (this.cues.length === 0)
            return l;
          for (var d = this.tech_.currentTime(), p = [], _ = 0, v = this.cues.length; _ < v; _++) {
            var x = this.cues[_];
            (x.startTime <= d && x.endTime >= d || x.startTime === x.endTime && x.startTime <= d && x.startTime + 0.5 >= d) && p.push(x);
          }
          if (c = !1, p.length !== this.activeCues_.length)
            c = !0;
          else
            for (var E = 0; E < p.length; E++)
              this.activeCues_.indexOf(p[E]) === -1 && (c = !0);
          return this.activeCues_ = p, l.setCues_(this.activeCues_), l;
        },
        // /!\ Keep this setter empty (see the timeupdate handler above)
        set: function() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} cues
       *         The text track cue list for this TextTrack.
       * @instance
       */
      cues: {
        get: function() {
          return this.loaded_ ? u : null;
        },
        set: function() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {boolean} default
       *         If this track was set to be on or off by default. Cannot be changed after
       *         creation.
       * @instance
       *
       * @readonly
       */
      default: {
        get: function() {
          return o;
        },
        set: function() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {string} mode
       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
       *         not be set if setting to an invalid mode.
       * @instance
       *
       * @fires TextTrack#modechange
       */
      mode: {
        get: function() {
          return s;
        },
        set: function(d) {
          Gv[d] && s !== d && (s = d, !this.preload_ && s !== "disabled" && this.cues.length === 0 && Hv(this.src, this), this.stopTracking(), s !== "disabled" && this.startTracking(), this.trigger("modechange"));
        }
      }
    }), a.src ? (i.src = a.src, i.preload_ || (i.loaded_ = !0), (i.preload_ || a.kind !== "subtitles" && a.kind !== "captions") && Hv(i.src, ze(i))) : i.loaded_ = !0, i;
  }
  var r = t.prototype;
  return r.startTracking = function() {
    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler), this.tech_.on("timeupdate", this.timeupdateHandler);
  }, r.stopTracking = function() {
    this.rvf_ && (this.tech_.cancelVideoFrameCallback(this.rvf_), this.rvf_ = void 0), this.tech_.off("timeupdate", this.timeupdateHandler);
  }, r.addCue = function(i) {
    var a = i;
    if (j.vttjs && !(i instanceof j.vttjs.VTTCue)) {
      a = new j.vttjs.VTTCue(
        i.startTime,
        i.endTime,
        i.text
      );
      for (var s in i)
        s in a || (a[s] = i[s]);
      a.id = i.id, a.originalCue_ = i;
    }
    for (var o = this.tech_.textTracks(), u = 0; u < o.length; u++)
      o[u] !== this && o[u].removeCue(a);
    this.cues_.push(a), this.cues.setCues_(this.cues_);
  }, r.removeCue = function(i) {
    for (var a = this.cues_.length; a--; ) {
      var s = this.cues_[a];
      if (s === i || s.originalCue_ && s.originalCue_ === i) {
        this.cues_.splice(a, 1), this.cues.setCues_(this.cues_);
        break;
      }
    }
  }, t;
}(Bp);
Pl.prototype.allowedEvents_ = {
  cuechange: "cuechange"
};
var r1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(r) {
    var n;
    r === void 0 && (r = {});
    var i = Kt(r, {
      kind: IM[r.kind] || ""
    });
    n = e.call(this, i) || this;
    var a = !1;
    return Object.defineProperty(ze(n), "enabled", {
      get: function() {
        return a;
      },
      set: function(o) {
        typeof o != "boolean" || o === a || (a = o, this.trigger("enabledchange"));
      }
    }), i.enabled && (n.enabled = i.enabled), n.loaded_ = !0, n;
  }
  return t;
}(Bp), i1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(r) {
    var n;
    r === void 0 && (r = {});
    var i = Kt(r, {
      kind: RM[r.kind] || ""
    });
    n = e.call(this, i) || this;
    var a = !1;
    return Object.defineProperty(ze(n), "selected", {
      get: function() {
        return a;
      },
      set: function(o) {
        typeof o != "boolean" || o === a || (a = o, this.trigger("selectedchange"));
      }
    }), i.selected && (n.selected = i.selected), n;
  }
  return t;
}(Bp), n1 = 0, FM = 1, a1 = 2, kM = 3, Uo = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(r) {
    var n;
    r === void 0 && (r = {}), n = e.call(this) || this;
    var i, a = new Pl(r);
    return n.kind = a.kind, n.src = a.src, n.srclang = a.language, n.label = a.label, n.default = a.default, Object.defineProperties(ze(n), {
      /**
       * @memberof HTMLTrackElement
       * @member {HTMLTrackElement~ReadyState} readyState
       *         The current ready state of the track element.
       * @instance
       */
      readyState: {
        get: function() {
          return i;
        }
      },
      /**
       * @memberof HTMLTrackElement
       * @member {TextTrack} track
       *         The underlying TextTrack object.
       * @instance
       *
       */
      track: {
        get: function() {
          return a;
        }
      }
    }), i = n1, a.addEventListener("loadeddata", function() {
      i = a1, n.trigger({
        target: ze(n),
        type: "load"
      });
    }), n;
  }
  return t;
}(Ir);
Uo.prototype.allowedEvents_ = {
  load: "load"
};
Uo.NONE = n1;
Uo.LOADING = FM;
Uo.LOADED = a1;
Uo.ERROR = kM;
var Oi = {
  audio: {
    ListClass: DM,
    TrackClass: r1,
    capitalName: "Audio"
  },
  text: {
    ListClass: e1,
    TrackClass: Pl,
    capitalName: "Text"
  },
  video: {
    ListClass: PM,
    TrackClass: i1,
    capitalName: "Video"
  }
};
Object.keys(Oi).forEach(function(e) {
  Oi[e].getterName = e + "Tracks", Oi[e].privateName = e + "Tracks_";
});
var Po = {
  remoteText: {
    ListClass: e1,
    TrackClass: Pl,
    capitalName: "RemoteText",
    getterName: "remoteTextTracks",
    privateName: "remoteTextTracks_"
  },
  remoteTextEl: {
    ListClass: LM,
    TrackClass: Uo,
    capitalName: "RemoteTextTrackEls",
    getterName: "remoteTextTrackEls",
    privateName: "remoteTextTrackEls_"
  }
}, Zr = Bi({}, Oi, Po);
Po.names = Object.keys(Po);
Oi.names = Object.keys(Oi);
Zr.names = [].concat(Po.names).concat(Oi.names);
function NM(e, t, r, n, i) {
  i === void 0 && (i = {});
  var a = e.textTracks();
  i.kind = t, r && (i.label = r), n && (i.language = n), i.tech = e;
  var s = new Zr.text.TrackClass(i);
  return a.addTrack(s), s;
}
var jt = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return n === void 0 && (n = {}), i === void 0 && (i = function() {
    }), n.reportTouchActivity = !1, a = e.call(this, null, n, i) || this, a.onDurationChange_ = function(s) {
      return a.onDurationChange(s);
    }, a.trackProgress_ = function(s) {
      return a.trackProgress(s);
    }, a.trackCurrentTime_ = function(s) {
      return a.trackCurrentTime(s);
    }, a.stopTrackingCurrentTime_ = function(s) {
      return a.stopTrackingCurrentTime(s);
    }, a.disposeSourceHandler_ = function(s) {
      return a.disposeSourceHandler(s);
    }, a.queuedHanders_ = /* @__PURE__ */ new Set(), a.hasStarted_ = !1, a.on("playing", function() {
      this.hasStarted_ = !0;
    }), a.on("loadstart", function() {
      this.hasStarted_ = !1;
    }), Zr.names.forEach(function(s) {
      var o = Zr[s];
      n && n[o.getterName] && (a[o.privateName] = n[o.getterName]);
    }), a.featuresProgressEvents || a.manualProgressOn(), a.featuresTimeupdateEvents || a.manualTimeUpdatesOn(), ["Text", "Audio", "Video"].forEach(function(s) {
      n["native" + s + "Tracks"] === !1 && (a["featuresNative" + s + "Tracks"] = !1);
    }), n.nativeCaptions === !1 || n.nativeTextTracks === !1 ? a.featuresNativeTextTracks = !1 : (n.nativeCaptions === !0 || n.nativeTextTracks === !0) && (a.featuresNativeTextTracks = !0), a.featuresNativeTextTracks || a.emulateTextTracks(), a.preloadTextTracks = n.preloadTextTracks !== !1, a.autoRemoteTextTracks_ = new Zr.text.ListClass(), a.initTrackListeners(), n.nativeControlsForTouch || a.emitTapEvents(), a.constructor && (a.name_ = a.constructor.name || "Unknown Tech"), a;
  }
  var r = t.prototype;
  return r.triggerSourceset = function(i) {
    var a = this;
    this.isReady_ || this.one("ready", function() {
      return a.setTimeout(function() {
        return a.triggerSourceset(i);
      }, 1);
    }), this.trigger({
      src: i,
      type: "sourceset"
    });
  }, r.manualProgressOn = function() {
    this.on("durationchange", this.onDurationChange_), this.manualProgress = !0, this.one("ready", this.trackProgress_);
  }, r.manualProgressOff = function() {
    this.manualProgress = !1, this.stopTrackingProgress(), this.off("durationchange", this.onDurationChange_);
  }, r.trackProgress = function(i) {
    this.stopTrackingProgress(), this.progressInterval = this.setInterval(
      $t(this, function() {
        var a = this.bufferedPercent();
        this.bufferedPercent_ !== a && this.trigger("progress"), this.bufferedPercent_ = a, a === 1 && this.stopTrackingProgress();
      }),
      500
    );
  }, r.onDurationChange = function(i) {
    this.duration_ = this.duration();
  }, r.buffered = function() {
    return Va(0, 0);
  }, r.bufferedPercent = function() {
    return J_(this.buffered(), this.duration_);
  }, r.stopTrackingProgress = function() {
    this.clearInterval(this.progressInterval);
  }, r.manualTimeUpdatesOn = function() {
    this.manualTimeUpdates = !0, this.on("play", this.trackCurrentTime_), this.on("pause", this.stopTrackingCurrentTime_);
  }, r.manualTimeUpdatesOff = function() {
    this.manualTimeUpdates = !1, this.stopTrackingCurrentTime(), this.off("play", this.trackCurrentTime_), this.off("pause", this.stopTrackingCurrentTime_);
  }, r.trackCurrentTime = function() {
    this.currentTimeInterval && this.stopTrackingCurrentTime(), this.currentTimeInterval = this.setInterval(function() {
      this.trigger({
        manuallyTriggered: !0,
        target: this,
        type: "timeupdate"
      });
    }, 250);
  }, r.stopTrackingCurrentTime = function() {
    this.clearInterval(this.currentTimeInterval), this.trigger({
      manuallyTriggered: !0,
      target: this,
      type: "timeupdate"
    });
  }, r.dispose = function() {
    this.clearTracks(Oi.names), this.manualProgress && this.manualProgressOff(), this.manualTimeUpdates && this.manualTimeUpdatesOff(), e.prototype.dispose.call(this);
  }, r.clearTracks = function(i) {
    var a = this;
    i = [].concat(i), i.forEach(function(s) {
      for (var o = a[s + "Tracks"]() || [], u = o.length; u--; ) {
        var l = o[u];
        s === "text" && a.removeRemoteTextTrack(l), o.removeTrack(l);
      }
    });
  }, r.cleanupAutoTextTracks = function() {
    for (var i = this.autoRemoteTextTracks_ || [], a = i.length; a--; ) {
      var s = i[a];
      this.removeRemoteTextTrack(s);
    }
  }, r.reset = function() {
  }, r.crossOrigin = function() {
  }, r.setCrossOrigin = function() {
  }, r.error = function(i) {
    return i !== void 0 && (this.error_ = new ii(i), this.trigger("error")), this.error_;
  }, r.played = function() {
    return this.hasStarted_ ? Va(0, 0) : Va();
  }, r.play = function() {
  }, r.setScrubbing = function() {
  }, r.scrubbing = function() {
  }, r.setCurrentTime = function() {
    this.manualTimeUpdates && this.trigger({
      manuallyTriggered: !0,
      target: this,
      type: "timeupdate"
    });
  }, r.initTrackListeners = function() {
    var i = this;
    Oi.names.forEach(function(a) {
      var s = Oi[a], o = function() {
        i.trigger(a + "trackchange");
      }, u = i[s.getterName]();
      u.addEventListener("removetrack", o), u.addEventListener("addtrack", o), i.on("dispose", function() {
        u.removeEventListener("removetrack", o), u.removeEventListener("addtrack", o);
      });
    });
  }, r.addWebVttScript_ = function() {
    var i = this;
    if (!j.WebVTT)
      if (Te.body.contains(this.el())) {
        if (!this.options_["vtt.js"] && dl(Rv) && Object.keys(Rv).length > 0) {
          this.trigger("vttjsloaded");
          return;
        }
        var a = Te.createElement("script");
        a.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js", a.onload = function() {
          i.trigger("vttjsloaded");
        }, a.onerror = function() {
          i.trigger("vttjserror");
        }, this.on("dispose", function() {
          a.onload = null, a.onerror = null;
        }), j.WebVTT = !0, this.el().parentNode.appendChild(a);
      } else
        this.ready(this.addWebVttScript_);
  }, r.emulateTextTracks = function() {
    var i = this, a = this.textTracks(), s = this.remoteTextTracks(), o = function(f) {
      return a.addTrack(f.track);
    }, u = function(f) {
      return a.removeTrack(f.track);
    };
    s.on("addtrack", o), s.on("removetrack", u), this.addWebVttScript_();
    var l = function() {
      return i.trigger("texttrackchange");
    }, c = function() {
      l();
      for (var f = 0; f < a.length; f++) {
        var d = a[f];
        d.removeEventListener("cuechange", l), d.mode === "showing" && d.addEventListener("cuechange", l);
      }
    };
    c(), a.addEventListener("change", c), a.addEventListener("addtrack", c), a.addEventListener("removetrack", c), this.on("dispose", function() {
      s.off("addtrack", o), s.off("removetrack", u), a.removeEventListener("change", c), a.removeEventListener("addtrack", c), a.removeEventListener("removetrack", c);
      for (var h = 0; h < a.length; h++) {
        var f = a[h];
        f.removeEventListener("cuechange", l);
      }
    });
  }, r.addTextTrack = function(i, a, s) {
    if (!i)
      throw new Error("TextTrack kind is required but was not provided");
    return NM(this, i, a, s);
  }, r.createRemoteTextTrack = function(i) {
    var a = Kt(i, {
      tech: this
    });
    return new Po.remoteTextEl.TrackClass(a);
  }, r.addRemoteTextTrack = function(i, a) {
    var s = this;
    i === void 0 && (i = {});
    var o = this.createRemoteTextTrack(i);
    return a !== !0 && a !== !1 && (vt.warn(
      'Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js'
    ), a = !0), this.remoteTextTrackEls().addTrackElement_(o), this.remoteTextTracks().addTrack(o.track), a !== !0 && this.ready(function() {
      return s.autoRemoteTextTracks_.addTrack(o.track);
    }), o;
  }, r.removeRemoteTextTrack = function(i) {
    var a = this.remoteTextTrackEls().getTrackElementByTrack_(i);
    this.remoteTextTrackEls().removeTrackElement_(a), this.remoteTextTracks().removeTrack(i), this.autoRemoteTextTracks_.removeTrack(i);
  }, r.getVideoPlaybackQuality = function() {
    return {};
  }, r.requestPictureInPicture = function() {
    var i = this.options_.Promise || j.Promise;
    if (i)
      return i.reject();
  }, r.disablePictureInPicture = function() {
    return !0;
  }, r.setDisablePictureInPicture = function() {
  }, r.requestVideoFrameCallback = function(i) {
    var a = this, s = ta();
    return !this.isReady_ || this.paused() ? (this.queuedHanders_.add(s), this.one("playing", function() {
      a.queuedHanders_.has(s) && (a.queuedHanders_.delete(s), i());
    })) : this.requestNamedAnimationFrame(s, i), s;
  }, r.cancelVideoFrameCallback = function(i) {
    this.queuedHanders_.has(i) ? this.queuedHanders_.delete(i) : this.cancelNamedAnimationFrame(i);
  }, r.setPoster = function() {
  }, r.playsinline = function() {
  }, r.setPlaysinline = function() {
  }, r.overrideNativeAudioTracks = function() {
  }, r.overrideNativeVideoTracks = function() {
  }, r.canPlayType = function() {
    return "";
  }, t.canPlayType = function() {
    return "";
  }, t.canPlaySource = function(i, a) {
    return t.canPlayType(i.type);
  }, t.isTech = function(i) {
    return i.prototype instanceof t || i instanceof t || i === t;
  }, t.registerTech = function(i, a) {
    if (t.techs_ || (t.techs_ = {}), !t.isTech(a))
      throw new Error("Tech " + i + " must be a Tech");
    if (!t.canPlayType)
      throw new Error("Techs must have a static canPlayType method on them");
    if (!t.canPlaySource)
      throw new Error("Techs must have a static canPlaySource method on them");
    return i = mr(i), t.techs_[i] = a, t.techs_[rc(i)] = a, i !== "Tech" && t.defaultTechOrder_.push(i), a;
  }, t.getTech = function(i) {
    if (i) {
      if (t.techs_ && t.techs_[i])
        return t.techs_[i];
      if (i = mr(i), j && j.videojs && j.videojs[i])
        return vt.warn(
          "The " + i + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)"
        ), j.videojs[i];
    }
  }, t;
}(ye);
Zr.names.forEach(function(e) {
  var t = Zr[e];
  jt.prototype[t.getterName] = function() {
    return this[t.privateName] = this[t.privateName] || new t.ListClass(), this[t.privateName];
  };
});
jt.prototype.featuresVolumeControl = !0;
jt.prototype.featuresMuteControl = !0;
jt.prototype.featuresFullscreenResize = !1;
jt.prototype.featuresPlaybackRate = !1;
jt.prototype.featuresProgressEvents = !1;
jt.prototype.featuresSourceset = !1;
jt.prototype.featuresTimeupdateEvents = !1;
jt.prototype.featuresNativeTextTracks = !1;
jt.prototype.featuresVideoFrameCallback = !1;
jt.withSourceHandlers = function(e) {
  e.registerSourceHandler = function(r, n) {
    var i = e.sourceHandlers;
    i || (i = e.sourceHandlers = []), n === void 0 && (n = i.length), i.splice(n, 0, r);
  }, e.canPlayType = function(r) {
    for (var n = e.sourceHandlers || [], i, a = 0; a < n.length; a++)
      if (i = n[a].canPlayType(r), i)
        return i;
    return "";
  }, e.selectSourceHandler = function(r, n) {
    for (var i = e.sourceHandlers || [], a, s = 0; s < i.length; s++)
      if (a = i[s].canHandleSource(r, n), a)
        return i[s];
    return null;
  }, e.canPlaySource = function(r, n) {
    var i = e.selectSourceHandler(r, n);
    return i ? i.canHandleSource(r, n) : "";
  };
  var t = ["seekable", "seeking", "duration"];
  t.forEach(function(r) {
    var n = this[r];
    typeof n == "function" && (this[r] = function() {
      return this.sourceHandler_ && this.sourceHandler_[r] ? this.sourceHandler_[r].apply(
        this.sourceHandler_,
        arguments
      ) : n.apply(this, arguments);
    });
  }, e.prototype), e.prototype.setSource = function(r) {
    var n = e.selectSourceHandler(r, this.options_);
    n || (e.nativeSourceHandler ? n = e.nativeSourceHandler : vt.error("No source handler found for the current source.")), this.disposeSourceHandler(), this.off("dispose", this.disposeSourceHandler_), n !== e.nativeSourceHandler && (this.currentSource_ = r), this.sourceHandler_ = n.handleSource(r, this, this.options_), this.one("dispose", this.disposeSourceHandler_);
  }, e.prototype.disposeSourceHandler = function() {
    this.currentSource_ && (this.clearTracks(["audio", "video"]), this.currentSource_ = null), this.cleanupAutoTextTracks(), this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(), this.sourceHandler_ = null);
  };
};
ye.registerComponent("Tech", jt);
jt.registerTech("Tech", jt);
jt.defaultTechOrder_ = [];
var Ha = {}, ud = {}, Vc = {};
function UM(e, t) {
  Ha[e] = Ha[e] || [], Ha[e].push(t);
}
function GM(e, t, r) {
  e.setTimeout(function() {
    return La(t, Ha[t.type], r, e);
  }, 1);
}
function VM(e, t) {
  e.forEach(function(r) {
    return r.setTech && r.setTech(t);
  });
}
function HM(e, t, r) {
  return e.reduceRight(Np(r), t[r]());
}
function zM(e, t, r, n) {
  return t[r](e.reduce(Np(r), n));
}
function zv(e, t, r, n) {
  n === void 0 && (n = null);
  var i = "call" + mr(r), a = e.reduce(Np(i), n), s = a === Vc, o = s ? null : t[r](a);
  return qM(e, r, o, s), o;
}
var WM = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  ended: 1,
  muted: 1,
  paused: 1,
  played: 1,
  seekable: 1,
  volume: 1
}, jM = {
  setCurrentTime: 1,
  setMuted: 1,
  setVolume: 1
}, Wv = {
  pause: 1,
  play: 1
};
function Np(e) {
  return function(t, r) {
    return t === Vc ? Vc : r[e] ? r[e](t) : t;
  };
}
function qM(e, t, r, n) {
  for (var i = e.length - 1; i >= 0; i--) {
    var a = e[i];
    a[t] && a[t](n, r);
  }
}
function XM(e) {
  ud[e.id()] = null;
}
function YM(e, t) {
  var r = ud[e.id()], n = null;
  if (r == null)
    return n = t(e), ud[e.id()] = [[t, n]], n;
  for (var i = 0; i < r.length; i++) {
    var a = r[i], s = a[0], o = a[1];
    s === t && (n = o);
  }
  return n === null && (n = t(e), r.push([t, n])), n;
}
function La(e, t, r, n, i, a) {
  e === void 0 && (e = {}), t === void 0 && (t = []), i === void 0 && (i = []), a === void 0 && (a = !1);
  var s = t, o = s[0], u = s.slice(1);
  if (typeof o == "string")
    La(e, Ha[o], r, n, i, a);
  else if (o) {
    var l = YM(n, o);
    if (!l.setSource)
      return i.push(l), La(e, u, r, n, i, a);
    l.setSource(sr({}, e), function(c, h) {
      if (c)
        return La(e, u, r, n, i, a);
      i.push(l), La(
        h,
        e.type === h.type ? u : Ha[h.type],
        r,
        n,
        i,
        a
      );
    });
  } else u.length ? La(e, u, r, n, i, a) : a ? r(e, i) : La(e, Ha["*"], r, n, i, !0);
}
var QM = {
  aac: "audio/aac",
  caf: "audio/x-caf",
  m4a: "audio/mp4",
  flac: "audio/flac",
  m4v: "video/mp4",
  m3u8: "application/x-mpegURL",
  mov: "video/mp4",
  jpg: "image/jpeg",
  ogv: "video/ogg",
  gif: "image/gif",
  opus: "video/ogg",
  jpeg: "image/jpeg",
  mp4: "video/mp4",
  mkv: "video/x-matroska",
  mp3: "audio/mpeg",
  mpd: "application/dash+xml",
  oga: "audio/ogg",
  png: "image/png",
  svg: "image/svg+xml",
  wav: "audio/wav",
  webp: "image/webp"
}, Hc = function(t) {
  t === void 0 && (t = "");
  var r = kp(t), n = QM[r.toLowerCase()];
  return n || "";
}, KM = function(t, r) {
  if (!r)
    return "";
  if (t.cache_.source.src === r && t.cache_.source.type)
    return t.cache_.source.type;
  var n = t.cache_.sources.filter(function(o) {
    return o.src === r;
  });
  if (n.length)
    return n[0].type;
  for (var i = t.$$("source"), a = 0; a < i.length; a++) {
    var s = i[a];
    if (s.type && s.src && s.src === r)
      return s.type;
  }
  return Hc(r);
}, $M = function e(t) {
  if (Array.isArray(t)) {
    var r = [];
    t.forEach(function(n) {
      n = e(n), Array.isArray(n) ? r = r.concat(n) : Xn(n) && r.push(n);
    }), t = r;
  } else typeof t == "string" && t.trim() ? t = [
    jv({
      src: t
    })
  ] : Xn(t) && typeof t.src == "string" && t.src && t.src.trim() ? t = [jv(t)] : t = [];
  return t;
};
function jv(e) {
  if (!e.type) {
    var t = Hc(e.src);
    t && (e.type = t);
  }
  return e;
}
var ZM = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(r, n, i) {
    var a, s = Kt(
      {
        createEl: !1
      },
      n
    );
    if (a = e.call(this, r, s, i) || this, !n.playerOptions.sources || n.playerOptions.sources.length === 0)
      for (var o = 0, u = n.playerOptions.techOrder; o < u.length; o++) {
        var l = mr(u[o]), c = jt.getTech(l);
        if (l || (c = ye.getComponent(l)), c && c.isSupported()) {
          r.loadTech_(l);
          break;
        }
      }
    else
      r.src(n.playerOptions.sources);
    return a;
  }
  return t;
}(ye);
ye.registerComponent("MediaLoader", ZM);
var Bh = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.options_.controlText && a.controlText(a.options_.controlText), a.handleMouseOver_ = function(s) {
      return a.handleMouseOver(s);
    }, a.handleMouseOut_ = function(s) {
      return a.handleMouseOut(s);
    }, a.handleClick_ = function(s) {
      return a.handleClick(s);
    }, a.handleKeyDown_ = function(s) {
      return a.handleKeyDown(s);
    }, a.emitTapEvents(), a.enable(), a;
  }
  var r = t.prototype;
  return r.createEl = function(i, a, s) {
    i === void 0 && (i = "div"), a === void 0 && (a = {}), s === void 0 && (s = {}), a = sr(
      {
        className: this.buildCSSClass(),
        tabIndex: 0
      },
      a
    ), i === "button" && vt.error(
      "Creating a ClickableComponent with an HTML element of " + i + " is not supported; use a Button instead."
    ), s = sr(
      {
        role: "button"
      },
      s
    ), this.tabIndex_ = a.tabIndex;
    var o = St(i, a, s);
    return o.appendChild(
      St(
        "span",
        {
          className: "vjs-icon-placeholder"
        },
        {
          "aria-hidden": !0
        }
      )
    ), this.createControlTextEl(o), o;
  }, r.dispose = function() {
    this.controlTextEl_ = null, e.prototype.dispose.call(this);
  }, r.createControlTextEl = function(i) {
    return this.controlTextEl_ = St(
      "span",
      {
        className: "vjs-control-text"
      },
      {
        // let the screen reader user know that the text of the element may change
        "aria-live": "polite"
      }
    ), i && i.appendChild(this.controlTextEl_), this.controlText(this.controlText_, i), this.controlTextEl_;
  }, r.controlText = function(i, a) {
    if (a === void 0 && (a = this.el()), i === void 0)
      return this.controlText_ || "Need Text";
    var s = this.localize(i);
    this.controlText_ = i, ys(this.controlTextEl_, s), !this.nonIconControl && !this.player_.options_.noUITitleAttributes && a.tagName === "CX-TOOLTIP" && (a.content = s);
  }, r.buildCSSClass = function() {
    return "vjs-control vjs-button " + e.prototype.buildCSSClass.call(this);
  }, r.enable = function() {
    this.enabled_ || (this.enabled_ = !0, this.removeClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "false"), typeof this.tabIndex_ < "u" && this.el_.setAttribute("tabIndex", this.tabIndex_), this.on(["tap", "click"], this.handleClick_), this.on("keydown", this.handleKeyDown_));
  }, r.disable = function() {
    this.enabled_ = !1, this.addClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "true"), typeof this.tabIndex_ < "u" && this.el_.removeAttribute("tabIndex"), this.off("mouseover", this.handleMouseOver_), this.off("mouseout", this.handleMouseOut_), this.off(["tap", "click"], this.handleClick_), this.off("keydown", this.handleKeyDown_);
  }, r.handleLanguagechange = function() {
    this.controlText(this.controlText_);
  }, r.handleClick = function(i) {
    this.options_.clickHandler && this.options_.clickHandler.call(this, arguments);
  }, r.handleKeyDown = function(i) {
    lt.isEventKey(i, "Space") || lt.isEventKey(i, "Enter") ? (i.preventDefault(), i.stopPropagation(), this.trigger("click")) : e.prototype.handleKeyDown.call(this, i);
  }, t;
}(ye);
ye.registerComponent("ClickableComponent", Bh);
var JM = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.update(), a.update_ = function(s) {
      return a.update(s);
    }, n.on("posterchange", a.update_), a;
  }
  var r = t.prototype;
  return r.dispose = function() {
    this.player().off("posterchange", this.update_), e.prototype.dispose.call(this);
  }, r.createEl = function() {
    var i = St("div", {
      className: "vjs-poster",
      // Don't want poster to be tabbable.
      tabIndex: -1
    });
    return i;
  }, r.update = function(i) {
    var a = this.player().poster();
    this.setSrc(a), a ? this.show() : this.hide();
  }, r.setSrc = function(i) {
    var a = "";
    i && (a = 'url("' + i + '")'), this.el_.style.backgroundImage = a;
  }, r.handleClick = function(i) {
    if (this.player_.controls()) {
      var a = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
      this.player_.tech(!0) && // We've observed a bug in IE and Edge when playing back DRM content where
      // calling .focus() on the video element causes the video to go black,
      // so we avoid it in that specific case
      !((Ml || Cl) && a) && this.player_.tech(!0).focus(), this.player_.paused() ? fn(this.player_.play()) : this.player_.pause();
    }
  }, t;
}(Bh);
ye.registerComponent("PosterImage", JM);
var Ri = "#222", qv = "#ccc", e3 = {
  casual: '"Comic Sans MS", Impact, fantasy',
  monospace: "monospace",
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: "sans-serif",
  proportionalSerif: "serif",
  sansSerif: "sans-serif",
  script: '"Monotype Corsiva", cursive',
  serif: "serif",
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};
function df(e, t) {
  var r;
  if (e.length === 4)
    r = e[1] + e[1] + e[2] + e[2] + e[3] + e[3];
  else if (e.length === 7)
    r = e.slice(1);
  else
    throw new Error(
      "Invalid color code provided, " + e + "; must be formatted as e.g. #f0e or #f604e2."
    );
  return "rgba(" + parseInt(r.slice(0, 2), 16) + "," + parseInt(r.slice(2, 4), 16) + "," + parseInt(r.slice(4, 6), 16) + "," + t + ")";
}
function pf(e, t, r) {
  try {
    e.style[t] = r;
  } catch {
    return;
  }
}
var t3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a) {
    var s;
    s = e.call(this, n, i, a) || this;
    var o = function(l) {
      return s.updateDisplay(l);
    };
    return n.on("loadstart", function(u) {
      return s.toggleDisplay(u);
    }), n.on("texttrackchange", o), n.on("loadedmetadata", function(u) {
      return s.preselectTrack(u);
    }), n.ready(
      $t(ze(s), function() {
        if (n.tech_ && n.tech_.featuresNativeTextTracks) {
          this.hide();
          return;
        }
        n.on("fullscreenchange", o), n.on("playerresize", o), j.addEventListener("orientationchange", o), n.on("dispose", function() {
          return j.removeEventListener(
            "orientationchange",
            o
          );
        });
        for (var u = this.options_.playerOptions.tracks || [], l = 0; l < u.length; l++)
          this.player_.addRemoteTextTrack(u[l], !0);
        this.preselectTrack();
      })
    ), s;
  }
  var r = t.prototype;
  return r.preselectTrack = function() {
    for (var i = {
      captions: 1,
      subtitles: 1
    }, a = this.player_.textTracks(), s = this.player_.cache_.selectedLanguage, o, u, l, c = 0; c < a.length; c++) {
      var h = a[c];
      s && s.enabled && s.language && s.language === h.language && h.kind in i ? h.kind === s.kind ? l = h : l || (l = h) : s && !s.enabled ? (l = null, o = null, u = null) : h.default && (h.kind === "descriptions" && !o ? o = h : h.kind in i && !u && (u = h));
    }
    l ? l.mode = "showing" : u ? u.mode = "showing" : o && (o.mode = "showing");
  }, r.toggleDisplay = function() {
    this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show();
  }, r.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-text-track-display"
      },
      {
        "aria-atomic": "true",
        "aria-live": "off",
        translate: "yes"
      }
    );
  }, r.clearDisplay = function() {
    typeof j.WebVTT == "function" && j.WebVTT.processCues(j, [], this.el_);
  }, r.updateDisplay = function() {
    var i = this.player_.textTracks(), a = this.options_.allowMultipleShowingTracks;
    if (this.clearDisplay(), a) {
      for (var s = [], o = 0; o < i.length; ++o) {
        var u = i[o];
        u.mode === "showing" && s.push(u);
      }
      this.updateForTrack(s);
      return;
    }
    for (var l = null, c = null, h = i.length; h--; ) {
      var f = i[h];
      f.mode === "showing" && (f.kind === "descriptions" ? l = f : c = f);
    }
    c ? (this.getAttribute("aria-live") !== "off" && this.setAttribute("aria-live", "off"), this.updateForTrack(c)) : l && (this.getAttribute("aria-live") !== "assertive" && this.setAttribute("aria-live", "assertive"), this.updateForTrack(l));
  }, r.updateDisplayState = function(i) {
    for (var a = this.player_.textTrackSettings.getValues(), s = i.activeCues, o = s.length; o--; ) {
      var u = s[o];
      if (u) {
        var l = u.displayState;
        if (a.color && (l.firstChild.style.color = a.color), a.textOpacity && pf(
          l.firstChild,
          "color",
          df(a.color || "#fff", a.textOpacity)
        ), a.backgroundColor && (l.firstChild.style.backgroundColor = a.backgroundColor), a.backgroundOpacity && pf(
          l.firstChild,
          "backgroundColor",
          df(
            a.backgroundColor || "#000",
            a.backgroundOpacity
          )
        ), a.windowColor && (a.windowOpacity ? pf(
          l,
          "backgroundColor",
          df(a.windowColor, a.windowOpacity)
        ) : l.style.backgroundColor = a.windowColor), a.edgeStyle && (a.edgeStyle === "dropshadow" ? l.firstChild.style.textShadow = "2px 2px 3px " + Ri + ", 2px 2px 4px " + Ri + ", 2px 2px 5px " + Ri : a.edgeStyle === "raised" ? l.firstChild.style.textShadow = "1px 1px " + Ri + ", 2px 2px " + Ri + ", 3px 3px " + Ri : a.edgeStyle === "depressed" ? l.firstChild.style.textShadow = "1px 1px " + qv + ", 0 1px " + qv + ", -1px -1px " + Ri + ", 0 -1px " + Ri : a.edgeStyle === "uniform" && (l.firstChild.style.textShadow = "0 0 4px " + Ri + ", 0 0 4px " + Ri + ", 0 0 4px " + Ri + ", 0 0 4px " + Ri)), a.fontPercent && a.fontPercent !== 1) {
          var c = j.parseFloat(l.style.fontSize);
          l.style.fontSize = c * a.fontPercent + "px", l.style.height = "auto", l.style.top = "auto";
        }
        a.fontFamily && a.fontFamily !== "default" && (a.fontFamily === "small-caps" ? l.firstChild.style.fontVariant = "small-caps" : l.firstChild.style.fontFamily = e3[a.fontFamily]);
      }
    }
  }, r.updateForTrack = function(i) {
    if (Array.isArray(i) || (i = [i]), !(typeof j.WebVTT != "function" || i.every(function(d) {
      return !d.activeCues;
    }))) {
      for (var a = [], s = 0; s < i.length; ++s)
        for (var o = i[s], u = 0; u < o.activeCues.length; ++u)
          a.push(o.activeCues[u]);
      j.WebVTT.processCues(j, a, this.el_);
      for (var l = 0; l < i.length; ++l) {
        for (var c = i[l], h = 0; h < c.activeCues.length; ++h) {
          var f = c.activeCues[h].displayState;
          Gn(f, "vjs-text-track-cue"), Gn(
            f,
            "vjs-text-track-cue-" + (c.language ? c.language : l)
          ), c.language && Co(f, "lang", c.language);
        }
        this.player_.textTrackSettings && this.updateDisplayState(c);
      }
    }
  }, t;
}(ye);
ye.registerComponent("TextTrackDisplay", t3);
var r3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.createEl = function() {
    var i = this.player_.isAudio(), a = this.localize(i ? "Audio Player" : "Video Player"), s = St("span", {
      className: "vjs-control-text",
      textContent: this.localize("{1} is loading.", [a])
    }), o = e.prototype.createEl.call(this, "div", {
      className: "vjs-loading-spinner",
      dir: "ltr"
    });
    return o.appendChild(s), o;
  }, t;
}(ye);
ye.registerComponent("LoadingSpinner", r3);
var ji = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.createEl = function(i, a, s) {
    a === void 0 && (a = {}), s === void 0 && (s = {}), i = "button", a = sr(
      {
        className: this.buildCSSClass()
      },
      a
    ), s = sr(
      {
        // Necessary since the default button type is "submit"
        type: "button"
      },
      s
    );
    var o = St(i, a, s);
    if (o.appendChild(
      St(
        "span",
        {
          className: "vjs-icon-placeholder"
        },
        {
          "aria-hidden": !0
        }
      )
    ), this.createControlTextEl(o), o.classList.contains("vjs-button")) {
      var u = Te.createElement("cx-tooltip");
      return u.hoist = !0, u.content = this.controlText_, u.appendChild(o), o.style.cursor = "pointer", u;
    }
    return o;
  }, r.addChild = function(i, a) {
    a === void 0 && (a = {});
    var s = this.constructor.name;
    return vt.warn(
      "Adding an actionable (user controllable) child to a Button (" + s + ") is not supported; use a ClickableComponent instead."
    ), ye.prototype.addChild.call(this, i, a);
  }, r.enable = function() {
    e.prototype.enable.call(this), this.el_.removeAttribute("disabled");
  }, r.disable = function() {
    e.prototype.disable.call(this), this.el_.setAttribute("disabled", "disabled");
  }, r.handleKeyDown = function(i) {
    if (lt.isEventKey(i, "Space") || lt.isEventKey(i, "Enter")) {
      i.stopPropagation();
      return;
    }
    e.prototype.handleKeyDown.call(this, i);
  }, t;
}(Bh);
ye.registerComponent("Button", ji);
var s1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.mouseused_ = !1, a.on("mousedown", function(s) {
      return a.handleMouseDown(s);
    }), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-big-play-button";
  }, r.handleClick = function(i) {
    var a = this.player_.play();
    if (this.mouseused_ && i.clientX && i.clientY) {
      var s = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
      fn(a), this.player_.tech(!0) && // We've observed a bug in IE and Edge when playing back DRM content where
      // calling .focus() on the video element causes the video to go black,
      // so we avoid it in that specific case
      !((Ml || Cl) && s) && this.player_.tech(!0).focus();
      return;
    }
    var o = this.player_.getChild("controlBar"), u = o && o.getChild("playToggle");
    if (!u) {
      this.player_.tech(!0).focus();
      return;
    }
    var l = function() {
      return u.focus();
    };
    hu(a) ? a.then(l, function() {
    }) : this.setTimeout(l, 1);
  }, r.handleKeyDown = function(i) {
    this.mouseused_ = !1, e.prototype.handleKeyDown.call(this, i);
  }, r.handleMouseDown = function(i) {
    this.mouseused_ = !0;
  }, t;
}(ji);
s1.prototype.controlText_ = "Play Video";
ye.registerComponent("BigPlayButton", s1);
var i3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.controlText(
      i && i.controlText || a.localize("Close")
    ), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-close-button " + e.prototype.buildCSSClass.call(this);
  }, r.handleClick = function(i) {
    this.trigger({
      bubbles: !1,
      type: "close"
    });
  }, r.handleKeyDown = function(i) {
    lt.isEventKey(i, "Esc") ? (i.preventDefault(), i.stopPropagation(), this.trigger("click")) : e.prototype.handleKeyDown.call(this, i);
  }, t;
}(ji);
ye.registerComponent("CloseButton", i3);
var o1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return i === void 0 && (i = {}), a = e.call(this, n, i) || this, i.replay = i.replay === void 0 || i.replay, a.on(n, "play", function(s) {
      return a.handlePlay(s);
    }), a.on(n, "pause", function(s) {
      return a.handlePause(s);
    }), i.replay && a.on(n, "ended", function(s) {
      return a.handleEnded(s);
    }), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-play-control " + e.prototype.buildCSSClass.call(this);
  }, r.handleClick = function(i) {
    this.player_.paused() ? fn(this.player_.play()) : this.player_.pause();
  }, r.handleSeeked = function(i) {
    this.removeClass("vjs-ended"), this.player_.paused() ? this.handlePause(i) : this.handlePlay(i);
  }, r.handlePlay = function(i) {
    this.removeClass("vjs-ended"), this.removeClass("vjs-paused"), this.addClass("vjs-playing"), this.controlText("Pause");
  }, r.handlePause = function(i) {
    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.controlText("Play");
  }, r.handleEnded = function(i) {
    var a = this;
    this.removeClass("vjs-playing"), this.addClass("vjs-ended"), this.controlText("Replay"), this.one(this.player_, "seeked", function(s) {
      return a.handleSeeked(s);
    });
  }, t;
}(ji);
o1.prototype.controlText_ = "Play";
ye.registerComponent("PlayToggle", o1);
var u1 = function(t, r) {
  t = t < 0 ? 0 : t;
  var n = Math.floor(t % 60), i = Math.floor(t / 60 % 60), a = Math.floor(t / 3600), s = Math.floor(r / 60 % 60), o = Math.floor(r / 3600);
  return (isNaN(t) || t === 1 / 0) && (a = i = n = "-"), a = a > 0 || o > 0 ? a + ":" : "", i = ((a || s >= 10) && i < 10 ? "0" + i : i) + ":", n = n < 10 ? "0" + n : n, a + i + n;
}, Up = u1;
function n3(e) {
  Up = e;
}
function a3() {
  Up = u1;
}
function Lo(e, t) {
  return t === void 0 && (t = e), Up(e, t);
}
var Go = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.on(n, ["timeupdate", "ended"], function(s) {
      return a.updateContent(s);
    }), a.updateTextNode_(), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    var i = this.buildCSSClass(), a = e.prototype.createEl.call(this, "div", {
      className: i + " vjs-time-control vjs-control"
    }), s = St(
      "span",
      {
        className: "vjs-control-text",
        textContent: this.localize(this.labelText_) + ""
      },
      {
        role: "presentation"
      }
    );
    return a.appendChild(s), this.contentEl_ = St(
      "span",
      {
        className: i + "-display"
      },
      {
        // tell screen readers not to automatically read the time as it changes
        "aria-live": "off",
        // span elements have no implicit role, but some screen readers (notably VoiceOver)
        // treat them as a break between items in the DOM when using arrow keys
        // (or left-to-right swipes on iOS) to read contents of a page. Using
        // role='presentation' causes VoiceOver to NOT treat this span as a break.
        role: "presentation"
      }
    ), a.appendChild(this.contentEl_), a;
  }, r.dispose = function() {
    this.contentEl_ = null, this.textNode_ = null, e.prototype.dispose.call(this);
  }, r.updateTextNode_ = function(i) {
    var a = this;
    i === void 0 && (i = 0), i = Lo(i), this.formattedTime_ !== i && (this.formattedTime_ = i, this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", function() {
      if (a.contentEl_) {
        var s = a.textNode_;
        s && a.contentEl_.firstChild !== s && (s = null, vt.warn(
          "TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead."
        )), a.textNode_ = Te.createTextNode(a.formattedTime_), a.textNode_ && (s ? a.contentEl_.replaceChild(a.textNode_, s) : a.contentEl_.appendChild(a.textNode_));
      }
    }));
  }, r.updateContent = function(i) {
  }, t;
}(ye);
Go.prototype.labelText_ = "Time";
Go.prototype.controlText_ = "Time";
ye.registerComponent("TimeDisplay", Go);
var Gp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-current-time";
  }, r.updateContent = function(i) {
    var a;
    this.player_.ended() ? a = this.player_.duration() : a = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(), this.updateTextNode_(a);
  }, t;
}(Go);
Gp.prototype.labelText_ = "Current Time";
Gp.prototype.controlText_ = "Current Time";
ye.registerComponent("CurrentTimeDisplay", Gp);
var Vp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    a = e.call(this, n, i) || this;
    var s = function(u) {
      return a.updateContent(u);
    };
    return a.on(n, "durationchange", s), a.on(n, "loadstart", s), a.on(n, "loadedmetadata", s), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-duration";
  }, r.updateContent = function(i) {
    var a = this.player_.duration();
    this.updateTextNode_(a);
  }, t;
}(Go);
Vp.prototype.labelText_ = "Duration";
Vp.prototype.controlText_ = "Duration";
ye.registerComponent("DurationDisplay", Vp);
var s3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.createEl = function() {
    var i = e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-time-control vjs-time-divider"
      },
      {
        // this element and its contents can be hidden from assistive techs since
        // it is made extraneous by the announcement of the control text
        // for the current time and duration displays
        "aria-hidden": !0
      }
    ), a = e.prototype.createEl.call(this, "div"), s = e.prototype.createEl.call(this, "span", {
      textContent: "/"
    });
    return a.appendChild(s), i.appendChild(a), i;
  }, t;
}(ye);
ye.registerComponent("TimeDivider", s3);
var Hp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.on(n, "durationchange", function(s) {
      return a.updateContent(s);
    }), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-remaining-time";
  }, r.createEl = function() {
    var i = e.prototype.createEl.call(this);
    return this.options_.displayNegative !== !1 && i.insertBefore(
      St(
        "span",
        {},
        {
          "aria-hidden": !0
        },
        "-"
      ),
      this.contentEl_
    ), i;
  }, r.updateContent = function(i) {
    if (typeof this.player_.duration() == "number") {
      var a;
      this.player_.ended() ? a = 0 : this.player_.remainingTimeDisplay ? a = this.player_.remainingTimeDisplay() : a = this.player_.remainingTime(), this.updateTextNode_(a);
    }
  }, t;
}(Go);
Hp.prototype.labelText_ = "Remaining Time";
Hp.prototype.controlText_ = "Remaining Time";
ye.registerComponent("RemainingTimeDisplay", Hp);
var o3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.updateShowing(), a.on(a.player(), "durationchange", function(s) {
      return a.updateShowing(s);
    }), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    var i = e.prototype.createEl.call(this, "div", {
      className: "vjs-live-control vjs-control"
    });
    return this.contentEl_ = St(
      "div",
      {
        className: "vjs-live-display"
      },
      {
        "aria-live": "off"
      }
    ), this.contentEl_.appendChild(
      St("span", {
        className: "vjs-control-text",
        textContent: this.localize("Stream Type") + ""
      })
    ), this.contentEl_.appendChild(Te.createTextNode(this.localize("LIVE"))), i.appendChild(this.contentEl_), i;
  }, r.dispose = function() {
    this.contentEl_ = null, e.prototype.dispose.call(this);
  }, r.updateShowing = function(i) {
    this.player().duration() === 1 / 0 ? this.show() : this.hide();
  }, t;
}(ye);
ye.registerComponent("LiveDisplay", o3);
var l1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.updateLiveEdgeStatus(), a.player_.liveTracker && (a.updateLiveEdgeStatusHandler_ = function(s) {
      return a.updateLiveEdgeStatus(s);
    }, a.on(
      a.player_.liveTracker,
      "liveedgechange",
      a.updateLiveEdgeStatusHandler_
    )), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    var i = e.prototype.createEl.call(this, "button", {
      className: "vjs-seek-to-live-control vjs-control"
    });
    return this.textEl_ = St(
      "span",
      {
        className: "vjs-seek-to-live-text",
        textContent: this.localize("LIVE")
      },
      {
        "aria-hidden": "true"
      }
    ), i.appendChild(this.textEl_), i;
  }, r.updateLiveEdgeStatus = function() {
    !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0), this.addClass("vjs-at-live-edge"), this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1), this.removeClass("vjs-at-live-edge"), this.controlText("Seek to live, currently behind live"));
  }, r.handleClick = function() {
    this.player_.liveTracker.seekToLiveEdge();
  }, r.dispose = function() {
    this.player_.liveTracker && this.off(
      this.player_.liveTracker,
      "liveedgechange",
      this.updateLiveEdgeStatusHandler_
    ), this.textEl_ = null, e.prototype.dispose.call(this);
  }, t;
}(ji);
l1.prototype.controlText_ = "Seek to live, currently playing live";
ye.registerComponent("SeekToLive", l1);
var Fh = function(t, r, n) {
  return t = Number(t), Math.min(n, Math.max(r, isNaN(t) ? r : t));
}, zp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.handleMouseDown_ = function(s) {
      return a.handleMouseDown(s);
    }, a.handleMouseUp_ = function(s) {
      return a.handleMouseUp(s);
    }, a.handleKeyDown_ = function(s) {
      return a.handleKeyDown(s);
    }, a.handleClick_ = function(s) {
      return a.handleClick(s);
    }, a.handleMouseMove_ = function(s) {
      return a.handleMouseMove(s);
    }, a.update_ = function(s) {
      return a.update(s);
    }, a.bar = a.getChild(a.options_.barName), a.vertical(!!a.options_.vertical), a.enable(), a;
  }
  var r = t.prototype;
  return r.enabled = function() {
    return this.enabled_;
  }, r.enable = function() {
    this.enabled() || (this.on("mousedown", this.handleMouseDown_), this.on("touchstart", this.handleMouseDown_), this.on("keydown", this.handleKeyDown_), this.on("click", this.handleClick_), this.on(this.player_, "controlsvisible", this.update), this.playerEvent && this.on(this.player_, this.playerEvent, this.update), this.removeClass("disabled"), this.setAttribute("tabindex", 0), this.enabled_ = !0);
  }, r.disable = function() {
    if (this.enabled()) {
      var i = this.bar.el_.ownerDocument;
      this.off("mousedown", this.handleMouseDown_), this.off("touchstart", this.handleMouseDown_), this.off("keydown", this.handleKeyDown_), this.off("click", this.handleClick_), this.off(this.player_, "controlsvisible", this.update_), this.off(i, "mousemove", this.handleMouseMove_), this.off(i, "mouseup", this.handleMouseUp_), this.off(i, "touchmove", this.handleMouseMove_), this.off(i, "touchend", this.handleMouseUp_), this.removeAttribute("tabindex"), this.addClass("disabled"), this.playerEvent && this.off(this.player_, this.playerEvent, this.update), this.enabled_ = !1;
    }
  }, r.createEl = function(i, a, s) {
    return a === void 0 && (a = {}), s === void 0 && (s = {}), a.className = a.className + " vjs-slider", a = sr(
      {
        tabIndex: 0
      },
      a
    ), s = sr(
      {
        "aria-valuemax": 100,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        role: "slider",
        tabIndex: 0
      },
      s
    ), e.prototype.createEl.call(this, i, a, s);
  }, r.handleMouseDown = function(i) {
    var a = this.bar.el_.ownerDocument;
    i.type === "mousedown" && i.preventDefault(), i.type === "touchstart" && !ea && i.preventDefault(), N_(), this.addClass("vjs-sliding"), this.trigger("slideractive"), this.on(a, "mousemove", this.handleMouseMove_), this.on(a, "mouseup", this.handleMouseUp_), this.on(a, "touchmove", this.handleMouseMove_), this.on(a, "touchend", this.handleMouseUp_), this.handleMouseMove(i, !0);
  }, r.handleMouseMove = function(i) {
  }, r.handleMouseUp = function() {
    var i = this.bar.el_.ownerDocument;
    U_(), this.removeClass("vjs-sliding"), this.trigger("sliderinactive"), this.off(i, "mousemove", this.handleMouseMove_), this.off(i, "mouseup", this.handleMouseUp_), this.off(i, "touchmove", this.handleMouseMove_), this.off(i, "touchend", this.handleMouseUp_), this.update();
  }, r.update = function() {
    var i = this;
    if (!(!this.el_ || !this.bar)) {
      var a = this.getProgress();
      return a === this.progress_ || (this.progress_ = a, this.requestNamedAnimationFrame("Slider#update", function() {
        var s = i.vertical() ? "height" : "width";
        i.bar.el().style[s] = (a * 100).toFixed(2) + "%";
      })), a;
    }
  }, r.getProgress = function() {
    return Number(Fh(this.getPercent(), 0, 1).toFixed(4));
  }, r.calculateDistance = function(i) {
    var a = Ph(this.el_, i);
    return this.vertical() ? a.y : a.x;
  }, r.handleKeyDown = function(i) {
    lt.isEventKey(i, "Left") || lt.isEventKey(i, "Down") ? (i.preventDefault(), i.stopPropagation(), this.stepBack()) : lt.isEventKey(i, "Right") || lt.isEventKey(i, "Up") ? (i.preventDefault(), i.stopPropagation(), this.stepForward()) : e.prototype.handleKeyDown.call(this, i);
  }, r.handleClick = function(i) {
    i.stopPropagation(), i.preventDefault();
  }, r.vertical = function(i) {
    if (i === void 0)
      return this.vertical_ || !1;
    this.vertical_ = !!i, this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal");
  }, t;
}(ye);
ye.registerComponent("Slider", zp);
var mf = function(t, r) {
  return Fh(t / r * 100, 0, 100).toFixed(2) + "%";
}, u3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.partEls_ = [], a.on(n, "progress", function(s) {
      return a.update(s);
    }), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    var i = e.prototype.createEl.call(this, "div", {
      className: "vjs-load-progress"
    }), a = St("span", {
      className: "vjs-control-text"
    }), s = St("span", {
      textContent: this.localize("Loaded")
    }), o = Te.createTextNode(": ");
    return this.percentageEl_ = St("span", {
      className: "vjs-control-text-loaded-percentage",
      textContent: "0%"
    }), i.appendChild(a), a.appendChild(s), a.appendChild(o), a.appendChild(this.percentageEl_), i;
  }, r.dispose = function() {
    this.partEls_ = null, this.percentageEl_ = null, e.prototype.dispose.call(this);
  }, r.update = function(i) {
    var a = this;
    this.requestNamedAnimationFrame("LoadProgressBar#update", function() {
      var s = a.player_.liveTracker, o = a.player_.buffered(), u = s && s.isLive() ? s.seekableEnd() : a.player_.duration(), l = a.player_.bufferedEnd(), c = a.partEls_, h = mf(l, u);
      a.percent_ !== h && (a.el_.style.width = h, ys(a.percentageEl_, h), a.percent_ = h);
      for (var f = 0; f < o.length; f++) {
        var d = o.start(f), p = o.end(f), _ = c[f];
        _ || (_ = a.el_.appendChild(St()), c[f] = _), !(_.dataset.start === d && _.dataset.end === p) && (_.dataset.start = d, _.dataset.end = p, _.style.left = mf(d, l), _.style.width = mf(p - d, l));
      }
      for (var v = c.length; v > o.length; v--)
        a.el_.removeChild(c[v - 1]);
      c.length = o.length;
    });
  }, t;
}(ye);
ye.registerComponent("LoadProgressBar", u3);
var l3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.update = Yn(
      $t(ze(a), a.update),
      Ji
    ), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-time-tooltip"
      },
      {
        "aria-hidden": "true"
      }
    );
  }, r.update = function(i, a, s) {
    var o = ml(this.el_), u = Mo(this.player_.el()), l = i.width * a;
    if (!(!u || !o)) {
      var c = i.left - u.left + l, h = i.width - l + (u.right - i.right), f = o.width / 2;
      c < f ? f += f - c : h < f && (f = h), f < 0 ? f = 0 : f > o.width && (f = o.width), f = Math.round(f), this.el_.style.right = "-" + f + "px", this.write(s);
    }
  }, r.write = function(i) {
    ys(this.el_, i);
  }, r.updateTime = function(i, a, s, o) {
    var u = this;
    this.requestNamedAnimationFrame("TimeTooltip#updateTime", function() {
      var l, c = u.player_.duration();
      if (u.player_.liveTracker && u.player_.liveTracker.isLive()) {
        var h = u.player_.liveTracker.liveWindow(), f = h - a * h;
        l = (f < 1 ? "" : "-") + Lo(f, h);
      } else
        l = Lo(s, c);
      u.update(i, a, l), o && o();
    });
  }, t;
}(ye);
ye.registerComponent("TimeTooltip", l3);
var Wp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.update = Yn(
      $t(ze(a), a.update),
      Ji
    ), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-play-progress vjs-slider-bar"
      },
      {
        "aria-hidden": "true"
      }
    );
  }, r.update = function(i, a) {
    var s = this.getChild("timeTooltip");
    if (s) {
      var o = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      s.updateTime(i, a, o);
    }
  }, t;
}(ye);
Wp.prototype.options_ = {
  children: []
};
!ci && !Jn && Wp.prototype.options_.children.push("timeTooltip");
ye.registerComponent("PlayProgressBar", Wp);
var c1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.update = Yn(
      $t(ze(a), a.update),
      Ji
    ), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  }, r.update = function(i, a) {
    var s = this, o = a * this.player_.duration();
    this.getChild("timeTooltip").updateTime(
      i,
      a,
      o,
      function() {
        s.el_.style.left = i.width * a + "px";
      }
    );
  }, t;
}(ye);
c1.prototype.options_ = {
  children: ["timeTooltip"]
};
ye.registerComponent("MouseTimeDisplay", c1);
var Xl = 5, Xv = 12, jp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.setEventHandlers_(), a;
  }
  var r = t.prototype;
  return r.setEventHandlers_ = function() {
    var i = this;
    this.update_ = $t(this, this.update), this.update = Yn(this.update_, Ji), this.on(
      this.player_,
      ["ended", "durationchange", "timeupdate"],
      this.update
    ), this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update), this.updateInterval = null, this.enableIntervalHandler_ = function(a) {
      return i.enableInterval_(a);
    }, this.disableIntervalHandler_ = function(a) {
      return i.disableInterval_(a);
    }, this.on(this.player_, ["playing"], this.enableIntervalHandler_), this.on(
      this.player_,
      ["ended", "pause", "waiting"],
      this.disableIntervalHandler_
    ), "hidden" in Te && "visibilityState" in Te && this.on(Te, "visibilitychange", this.toggleVisibility_);
  }, r.toggleVisibility_ = function(i) {
    Te.visibilityState === "hidden" ? (this.cancelNamedAnimationFrame("SeekBar#update"), this.cancelNamedAnimationFrame("Slider#update"), this.disableInterval_(i)) : (!this.player_.ended() && !this.player_.paused() && this.enableInterval_(), this.update());
  }, r.enableInterval_ = function() {
    this.updateInterval || (this.updateInterval = this.setInterval(
      this.update,
      Ji
    ));
  }, r.disableInterval_ = function(i) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && i && i.type !== "ended" || this.updateInterval && (this.clearInterval(this.updateInterval), this.updateInterval = null);
  }, r.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-progress-holder"
      },
      {
        "aria-label": this.localize("Progress Bar")
      }
    );
  }, r.update = function(i) {
    var a = this;
    if (Te.visibilityState !== "hidden") {
      var s = e.prototype.update.call(this);
      return this.requestNamedAnimationFrame("SeekBar#update", function() {
        var o = a.player_.ended() ? a.player_.duration() : a.getCurrentTime_(), u = a.player_.liveTracker, l = a.player_.duration();
        u && u.isLive() && (l = a.player_.liveTracker.liveCurrentTime()), a.percent_ !== s && (a.el_.setAttribute("aria-valuenow", (s * 100).toFixed(2)), a.percent_ = s), (a.currentTime_ !== o || a.duration_ !== l) && (a.el_.setAttribute(
          "aria-valuetext",
          a.localize(
            "progress bar timing: currentTime={1} duration={2}",
            [Lo(o, l), Lo(l, l)],
            "{1} of {2}"
          )
        ), a.currentTime_ = o, a.duration_ = l), a.bar && a.bar.update(
          Mo(a.el()),
          a.getProgress()
        );
      }), s;
    }
  }, r.userSeek_ = function(i) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(i);
  }, r.getCurrentTime_ = function() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  }, r.getPercent = function() {
    var i = this.getCurrentTime_(), a, s = this.player_.liveTracker;
    return s && s.isLive() ? (a = (i - s.seekableStart()) / s.liveWindow(), s.atLiveEdge() && (a = 1)) : a = i / this.player_.duration(), a;
  }, r.handleMouseDown = function(i) {
    vl(i) && (i.stopPropagation(), this.videoWasPlaying = !this.player_.paused(), this.player_.pause(), e.prototype.handleMouseDown.call(this, i));
  }, r.handleMouseMove = function(i, a) {
    if (a === void 0 && (a = !1), !!vl(i)) {
      !a && !this.player_.scrubbing() && this.player_.scrubbing(!0);
      var s, o = this.calculateDistance(i), u = this.player_.liveTracker;
      if (!u || !u.isLive())
        s = o * this.player_.duration(), s === this.player_.duration() && (s = s - 0.1);
      else {
        if (o >= 0.99) {
          u.seekToLiveEdge();
          return;
        }
        var l = u.seekableStart(), c = u.liveCurrentTime();
        if (s = l + o * u.liveWindow(), s >= c && (s = c), s <= l && (s = l + 0.1), s === 1 / 0)
          return;
      }
      this.userSeek_(s);
    }
  }, r.enable = function() {
    e.prototype.enable.call(this);
    var i = this.getChild("mouseTimeDisplay");
    i && i.show();
  }, r.disable = function() {
    e.prototype.disable.call(this);
    var i = this.getChild("mouseTimeDisplay");
    i && i.hide();
  }, r.handleMouseUp = function(i) {
    e.prototype.handleMouseUp.call(this, i), i && i.stopPropagation(), this.player_.scrubbing(!1), this.player_.trigger({
      manuallyTriggered: !0,
      target: this,
      type: "timeupdate"
    }), this.videoWasPlaying ? fn(this.player_.play()) : this.update_();
  }, r.stepForward = function() {
    this.userSeek_(this.player_.currentTime() + Xl);
  }, r.stepBack = function() {
    this.userSeek_(this.player_.currentTime() - Xl);
  }, r.handleAction = function(i) {
    this.player_.paused() ? this.player_.play() : this.player_.pause();
  }, r.handleKeyDown = function(i) {
    var a = this.player_.liveTracker;
    if (lt.isEventKey(i, "Space") || lt.isEventKey(i, "Enter"))
      i.preventDefault(), i.stopPropagation(), this.handleAction(i);
    else if (lt.isEventKey(i, "Home"))
      i.preventDefault(), i.stopPropagation(), this.userSeek_(0);
    else if (lt.isEventKey(i, "End"))
      i.preventDefault(), i.stopPropagation(), a && a.isLive() ? this.userSeek_(a.liveCurrentTime()) : this.userSeek_(this.player_.duration());
    else if (/^[0-9]$/.test(lt(i))) {
      i.preventDefault(), i.stopPropagation();
      var s = (lt.codes[lt(i)] - lt.codes[0]) * 10 / 100;
      a && a.isLive() ? this.userSeek_(
        a.seekableStart() + a.liveWindow() * s
      ) : this.userSeek_(this.player_.duration() * s);
    } else lt.isEventKey(i, "PgDn") ? (i.preventDefault(), i.stopPropagation(), this.userSeek_(
      this.player_.currentTime() - Xl * Xv
    )) : lt.isEventKey(i, "PgUp") ? (i.preventDefault(), i.stopPropagation(), this.userSeek_(
      this.player_.currentTime() + Xl * Xv
    )) : e.prototype.handleKeyDown.call(this, i);
  }, r.dispose = function() {
    this.disableInterval_(), this.off(
      this.player_,
      ["ended", "durationchange", "timeupdate"],
      this.update
    ), this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.update), this.off(this.player_, ["playing"], this.enableIntervalHandler_), this.off(
      this.player_,
      ["ended", "pause", "waiting"],
      this.disableIntervalHandler_
    ), "hidden" in Te && "visibilityState" in Te && this.off(Te, "visibilitychange", this.toggleVisibility_), e.prototype.dispose.call(this);
  }, t;
}(zp);
jp.prototype.options_ = {
  barName: "playProgressBar",
  children: ["loadProgressBar", "playProgressBar"]
};
!ci && !Jn && jp.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
ye.registerComponent("SeekBar", jp);
var h1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.handleMouseMove = Yn(
      $t(ze(a), a.handleMouseMove),
      Ji
    ), a.throttledHandleMouseSeek = Yn(
      $t(ze(a), a.handleMouseSeek),
      Ji
    ), a.handleMouseUpHandler_ = function(s) {
      return a.handleMouseUp(s);
    }, a.handleMouseDownHandler_ = function(s) {
      return a.handleMouseDown(s);
    }, a.enable(), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: "vjs-progress-control vjs-control"
    });
  }, r.handleMouseMove = function(i) {
    var a = this.getChild("seekBar");
    if (a) {
      var s = a.getChild("playProgressBar"), o = a.getChild("mouseTimeDisplay");
      if (!(!s && !o)) {
        var u = a.el(), l = ml(u), c = Ph(u, i).x;
        c = Fh(c, 0, 1), o && o.update(l, c), s && s.update(l, a.getProgress());
      }
    }
  }, r.handleMouseSeek = function(i) {
    var a = this.getChild("seekBar");
    a && a.handleMouseMove(i);
  }, r.enabled = function() {
    return this.enabled_;
  }, r.disable = function() {
    if (this.children().forEach(function(a) {
      return a.disable && a.disable();
    }), !!this.enabled() && (this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.off(this.el_, "mousemove", this.handleMouseMove), this.removeListenersAddedOnMousedownAndTouchstart(), this.addClass("disabled"), this.enabled_ = !1, this.player_.scrubbing())) {
      var i = this.getChild("seekBar");
      this.player_.scrubbing(!1), i.videoWasPlaying && fn(this.player_.play());
    }
  }, r.enable = function() {
    this.children().forEach(function(i) {
      return i.enable && i.enable();
    }), !this.enabled() && (this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.on(this.el_, "mousemove", this.handleMouseMove), this.removeClass("disabled"), this.enabled_ = !0);
  }, r.removeListenersAddedOnMousedownAndTouchstart = function() {
    var i = this.el_.ownerDocument;
    this.off(i, "mousemove", this.throttledHandleMouseSeek), this.off(i, "touchmove", this.throttledHandleMouseSeek), this.off(i, "mouseup", this.handleMouseUpHandler_), this.off(i, "touchend", this.handleMouseUpHandler_);
  }, r.handleMouseDown = function(i) {
    var a = this.el_.ownerDocument, s = this.getChild("seekBar");
    s && s.handleMouseDown(i), this.on(a, "mousemove", this.throttledHandleMouseSeek), this.on(a, "touchmove", this.throttledHandleMouseSeek), this.on(a, "mouseup", this.handleMouseUpHandler_), this.on(a, "touchend", this.handleMouseUpHandler_);
  }, r.handleMouseUp = function(i) {
    var a = this.getChild("seekBar");
    a && a.handleMouseUp(i), this.removeListenersAddedOnMousedownAndTouchstart();
  }, t;
}(ye);
h1.prototype.options_ = {
  children: ["seekBar"]
};
ye.registerComponent("ProgressControl", h1);
var f1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.on(
      n,
      ["enterpictureinpicture", "leavepictureinpicture"],
      function(s) {
        return a.handlePictureInPictureChange(s);
      }
    ), a.on(
      n,
      ["disablepictureinpicturechanged", "loadedmetadata"],
      function(s) {
        return a.handlePictureInPictureEnabledChange(s);
      }
    ), a.on(
      n,
      ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"],
      function() {
        var s = n.currentType().substring(0, 5) === "audio";
        s || n.audioPosterMode() || n.audioOnlyMode() ? (n.isInPictureInPicture() && n.exitPictureInPicture(), a.hide()) : a.show();
      }
    ), a.disable(), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-picture-in-picture-control " + e.prototype.buildCSSClass.call(this);
  }, r.handlePictureInPictureEnabledChange = function() {
    Te.pictureInPictureEnabled && this.player_.disablePictureInPicture() === !1 ? this.enable() : this.disable();
  }, r.handlePictureInPictureChange = function(i) {
    this.player_.isInPictureInPicture() ? this.controlText("Exit Picture-in-Picture") : this.controlText("Picture-in-Picture"), this.handlePictureInPictureEnabledChange();
  }, r.handleClick = function(i) {
    this.player_.isInPictureInPicture() ? this.player_.exitPictureInPicture() : this.player_.requestPictureInPicture();
  }, t;
}(ji);
f1.prototype.controlText_ = "Picture-in-Picture";
ye.registerComponent("PictureInPictureToggle", f1);
var d1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.on(n, "fullscreenchange", function(s) {
      return a.handleFullscreenChange(s);
    }), Te[n.fsApi_.fullscreenEnabled] === !1 && a.disable(), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-fullscreen-control " + e.prototype.buildCSSClass.call(this);
  }, r.handleFullscreenChange = function(i) {
    this.player_.isFullscreen() ? this.controlText("Non-Fullscreen") : this.controlText("Fullscreen");
  }, r.handleClick = function(i) {
    this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen();
  }, t;
}(ji);
d1.prototype.controlText_ = "Fullscreen";
ye.registerComponent("FullscreenToggle", d1);
var c3 = function(t, r) {
  r.tech_ && !r.tech_.featuresVolumeControl && t.addClass("vjs-hidden"), t.on(r, "loadstart", function() {
    r.tech_.featuresVolumeControl ? t.removeClass("vjs-hidden") : t.addClass("vjs-hidden");
  });
}, h3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.createEl = function() {
    var i = e.prototype.createEl.call(this, "div", {
      className: "vjs-volume-level"
    });
    return i.appendChild(
      e.prototype.createEl.call(this, "span", {
        className: "vjs-control-text"
      })
    ), i;
  }, t;
}(ye);
ye.registerComponent("VolumeLevel", h3);
var f3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.update = Yn(
      $t(ze(a), a.update),
      Ji
    ), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-volume-tooltip"
      },
      {
        "aria-hidden": "true"
      }
    );
  }, r.update = function(i, a, s, o) {
    if (!s) {
      var u = Mo(this.el_), l = Mo(this.player_.el()), c = i.width * a;
      if (!l || !u)
        return;
      var h = i.left - l.left + c, f = i.width - c + (l.right - i.right), d = u.width / 2;
      h < d ? d += d - h : f < d && (d = f), d < 0 ? d = 0 : d > u.width && (d = u.width), this.el_.style.right = "-" + d + "px";
    }
    this.write(o + "%");
  }, r.write = function(i) {
    ys(this.el_, i);
  }, r.updateVolume = function(i, a, s, o, u) {
    var l = this;
    this.requestNamedAnimationFrame(
      "VolumeLevelTooltip#updateVolume",
      function() {
        l.update(i, a, s, o.toFixed(0)), u && u();
      }
    );
  }, t;
}(ye);
ye.registerComponent("VolumeLevelTooltip", f3);
var p1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.update = Yn(
      $t(ze(a), a.update),
      Ji
    ), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  }, r.update = function(i, a, s) {
    var o = this, u = 100 * a;
    this.getChild("volumeLevelTooltip").updateVolume(
      i,
      a,
      s,
      u,
      function() {
        s ? o.el_.style.bottom = i.height * a + "px" : o.el_.style.left = i.width * a + "px";
      }
    );
  }, t;
}(ye);
p1.prototype.options_ = {
  children: ["volumeLevelTooltip"]
};
ye.registerComponent(
  "MouseVolumeLevelDisplay",
  p1
);
var kh = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.on("slideractive", function(s) {
      return a.updateLastVolume_(s);
    }), a.on(n, "volumechange", function(s) {
      return a.updateARIAAttributes(s);
    }), n.ready(function() {
      return a.updateARIAAttributes();
    }), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: "vjs-volume-bar vjs-slider-bar"
      },
      {
        "aria-label": this.localize("Volume Level"),
        "aria-live": "polite"
      }
    );
  }, r.handleMouseDown = function(i) {
    vl(i) && e.prototype.handleMouseDown.call(this, i);
  }, r.handleMouseMove = function(i) {
    var a = this.getChild("mouseVolumeLevelDisplay");
    if (a) {
      var s = this.el(), o = Mo(s), u = this.vertical(), l = Ph(s, i);
      l = u ? l.y : l.x, l = Fh(l, 0, 1), a.update(o, l, u);
    }
    vl(i) && (this.checkMuted(), this.player_.volume(this.calculateDistance(i)));
  }, r.checkMuted = function() {
    this.player_.muted() && this.player_.muted(!1);
  }, r.getPercent = function() {
    return this.player_.muted() ? 0 : this.player_.volume();
  }, r.stepForward = function() {
    this.checkMuted(), this.player_.volume(this.player_.volume() + 0.1);
  }, r.stepBack = function() {
    this.checkMuted(), this.player_.volume(this.player_.volume() - 0.1);
  }, r.updateARIAAttributes = function(i) {
    var a = this.player_.muted() ? 0 : this.volumeAsPercentage_();
    this.el_.setAttribute("aria-valuenow", a), this.el_.setAttribute("aria-valuetext", a + "%");
  }, r.volumeAsPercentage_ = function() {
    return Math.round(this.player_.volume() * 100);
  }, r.updateLastVolume_ = function() {
    var i = this, a = this.player_.volume();
    this.one("sliderinactive", function() {
      i.player_.volume() === 0 && i.player_.lastVolume_(a);
    });
  }, t;
}(zp);
kh.prototype.options_ = {
  barName: "volumeLevel",
  children: ["volumeLevel"]
};
!ci && !Jn && kh.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
kh.prototype.playerEvent = "volumechange";
ye.registerComponent("VolumeBar", kh);
var m1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return i === void 0 && (i = {}), i.vertical = i.vertical || !1, (typeof i.volumeBar > "u" || dl(i.volumeBar)) && (i.volumeBar = i.volumeBar || {}, i.volumeBar.vertical = i.vertical), a = e.call(this, n, i) || this, c3(ze(a), n), a.throttledHandleMouseMove = Yn(
      $t(ze(a), a.handleMouseMove),
      Ji
    ), a.handleMouseUpHandler_ = function(s) {
      return a.handleMouseUp(s);
    }, a.on("mousedown", function(s) {
      return a.handleMouseDown(s);
    }), a.on("touchstart", function(s) {
      return a.handleMouseDown(s);
    }), a.on("mousemove", function(s) {
      return a.handleMouseMove(s);
    }), a.on(a.volumeBar, ["focus", "slideractive"], function() {
      a.volumeBar.addClass("vjs-slider-active"), a.addClass("vjs-slider-active"), a.trigger("slideractive");
    }), a.on(a.volumeBar, ["blur", "sliderinactive"], function() {
      a.volumeBar.removeClass("vjs-slider-active"), a.removeClass("vjs-slider-active"), a.trigger("sliderinactive");
    }), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    var i = "vjs-volume-horizontal";
    return this.options_.vertical && (i = "vjs-volume-vertical"), e.prototype.createEl.call(this, "div", {
      className: "vjs-volume-control vjs-control " + i
    });
  }, r.handleMouseDown = function(i) {
    var a = this.el_.ownerDocument;
    this.on(a, "mousemove", this.throttledHandleMouseMove), this.on(a, "touchmove", this.throttledHandleMouseMove), this.on(a, "mouseup", this.handleMouseUpHandler_), this.on(a, "touchend", this.handleMouseUpHandler_);
  }, r.handleMouseUp = function(i) {
    var a = this.el_.ownerDocument;
    this.off(a, "mousemove", this.throttledHandleMouseMove), this.off(a, "touchmove", this.throttledHandleMouseMove), this.off(a, "mouseup", this.handleMouseUpHandler_), this.off(a, "touchend", this.handleMouseUpHandler_);
  }, r.handleMouseMove = function(i) {
    this.volumeBar.handleMouseMove(i);
  }, t;
}(ye);
m1.prototype.options_ = {
  children: ["volumeBar"]
};
ye.registerComponent("VolumeControl", m1);
var d3 = function(t, r) {
  r.tech_ && !r.tech_.featuresMuteControl && t.addClass("vjs-hidden"), t.on(r, "loadstart", function() {
    r.tech_.featuresMuteControl ? t.removeClass("vjs-hidden") : t.addClass("vjs-hidden");
  });
}, v1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, d3(ze(a), n), a.on(n, ["loadstart", "volumechange"], function(s) {
      return a.update(s);
    }), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-mute-control " + e.prototype.buildCSSClass.call(this);
  }, r.handleClick = function(i) {
    var a = this.player_.volume(), s = this.player_.lastVolume_();
    if (a === 0) {
      var o = s < 0.1 ? 0.1 : s;
      this.player_.volume(o), this.player_.muted(!1);
    } else
      this.player_.muted(!this.player_.muted());
  }, r.update = function(i) {
    this.updateIcon_(), this.updateControlText_();
  }, r.updateIcon_ = function() {
    var i = this.player_.volume(), a = 3;
    this.player_.tech_ && this.player_.tech_.el_ && this.player_.muted(this.player_.tech_.el_.muted), i === 0 || this.player_.muted() ? a = 0 : i < 0.33 ? a = 1 : i < 0.67 && (a = 2);
    for (var s = 0; s < 4; s++)
      Dl(this.el_, "vjs-vol-" + s);
    Gn(this.el_, "vjs-vol-" + a);
  }, r.updateControlText_ = function() {
    var i = this.player_.muted() || this.player_.volume() === 0, a = i ? "Unmute" : "Mute";
    this.controlText() !== a && this.controlText(a);
  }, t;
}(ji);
v1.prototype.controlText_ = "Mute";
ye.registerComponent("MuteToggle", v1);
var g1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return i === void 0 && (i = {}), typeof i.inline < "u" ? i.inline = i.inline : i.inline = !0, (typeof i.volumeControl > "u" || dl(i.volumeControl)) && (i.volumeControl = i.volumeControl || {}, i.volumeControl.vertical = !i.inline), a = e.call(this, n, i) || this, a.handleKeyPressHandler_ = function(s) {
      return a.handleKeyPress(s);
    }, a.on(n, ["loadstart"], function(s) {
      return a.volumePanelState_(s);
    }), a.on(a.muteToggle, "keyup", function(s) {
      return a.handleKeyPress(s);
    }), a.on(a.volumeControl, "keyup", function(s) {
      return a.handleVolumeControlKeyUp(s);
    }), a.on("keydown", function(s) {
      return a.handleKeyPress(s);
    }), a.on("mouseover", function(s) {
      return a.handleMouseOver(s);
    }), a.on("mouseout", function(s) {
      return a.handleMouseOut(s);
    }), a.on(a.volumeControl, ["slideractive"], a.sliderActive_), a.on(a.volumeControl, ["sliderinactive"], a.sliderInactive_), a;
  }
  var r = t.prototype;
  return r.sliderActive_ = function() {
    this.addClass("vjs-slider-active");
  }, r.sliderInactive_ = function() {
    this.removeClass("vjs-slider-active");
  }, r.volumePanelState_ = function() {
    this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"), this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only");
  }, r.createEl = function() {
    var i = "vjs-volume-panel-horizontal";
    return this.options_.inline || (i = "vjs-volume-panel-vertical"), e.prototype.createEl.call(this, "div", {
      className: "vjs-volume-panel vjs-control " + i
    });
  }, r.dispose = function() {
    this.handleMouseOut(), e.prototype.dispose.call(this);
  }, r.handleVolumeControlKeyUp = function(i) {
    lt.isEventKey(i, "Esc") && this.muteToggle.focus();
  }, r.handleMouseOver = function(i) {
    this.addClass("vjs-hover"), Pi(Te, "keyup", this.handleKeyPressHandler_);
  }, r.handleMouseOut = function(i) {
    this.removeClass("vjs-hover"), zr(Te, "keyup", this.handleKeyPressHandler_);
  }, r.handleKeyPress = function(i) {
    lt.isEventKey(i, "Esc") && this.handleMouseOut();
  }, t;
}(ye);
g1.prototype.options_ = {
  children: ["muteToggle", "volumeControl"]
};
ye.registerComponent("VolumePanel", g1);
var y1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, i && (a.menuButton_ = i.menuButton), a.focusedChild_ = -1, a.on("keydown", function(s) {
      return a.handleKeyDown(s);
    }), a.boundHandleBlur_ = function(s) {
      return a.handleBlur(s);
    }, a.boundHandleTapClick_ = function(s) {
      return a.handleTapClick(s);
    }, a;
  }
  var r = t.prototype;
  return r.addEventListenerForItem = function(i) {
    i instanceof ye && (this.on(i, "blur", this.boundHandleBlur_), this.on(i, ["tap", "click"], this.boundHandleTapClick_));
  }, r.removeEventListenerForItem = function(i) {
    i instanceof ye && (this.off(i, "blur", this.boundHandleBlur_), this.off(i, ["tap", "click"], this.boundHandleTapClick_));
  }, r.removeChild = function(i) {
    typeof i == "string" && (i = this.getChild(i)), this.removeEventListenerForItem(i), e.prototype.removeChild.call(this, i);
  }, r.addItem = function(i) {
    var a = this.addChild(i);
    a && this.addEventListenerForItem(a);
  }, r.createEl = function() {
    var i = this.options_.contentElType || "ul";
    this.contentEl_ = St(i, {
      className: "vjs-menu-content"
    }), this.contentEl_.setAttribute("role", "menu");
    var a = e.prototype.createEl.call(this, "div", {
      append: this.contentEl_,
      className: "vjs-menu"
    });
    return a.appendChild(this.contentEl_), Pi(a, "click", function(s) {
      s.preventDefault(), s.stopImmediatePropagation();
    }), a;
  }, r.dispose = function() {
    this.contentEl_ = null, this.boundHandleBlur_ = null, this.boundHandleTapClick_ = null, e.prototype.dispose.call(this);
  }, r.handleBlur = function(i) {
    var a = i.relatedTarget || Te.activeElement;
    if (!this.children().some(function(o) {
      return o.el() === a;
    })) {
      var s = this.menuButton_;
      s && s.buttonPressed_ && a !== s.el().firstChild && s.unpressButton();
    }
  }, r.handleTapClick = function(i) {
    if (this.menuButton_) {
      this.menuButton_.unpressButton();
      var a = this.children();
      if (!Array.isArray(a))
        return;
      var s = a.filter(function(o) {
        return o.el() === i.target;
      })[0];
      if (!s)
        return;
      s.name() !== "CaptionSettingsMenuItem" && this.menuButton_.focus();
    }
  }, r.handleKeyDown = function(i) {
    lt.isEventKey(i, "Left") || lt.isEventKey(i, "Down") ? (i.preventDefault(), i.stopPropagation(), this.stepForward()) : (lt.isEventKey(i, "Right") || lt.isEventKey(i, "Up")) && (i.preventDefault(), i.stopPropagation(), this.stepBack());
  }, r.stepForward = function() {
    var i = 0;
    this.focusedChild_ !== void 0 && (i = this.focusedChild_ + 1), this.focus(i);
  }, r.stepBack = function() {
    var i = 0;
    this.focusedChild_ !== void 0 && (i = this.focusedChild_ - 1), this.focus(i);
  }, r.focus = function(i) {
    i === void 0 && (i = 0);
    var a = this.children().slice(), s = a.length && a[0].hasClass("vjs-menu-title");
    s && a.shift(), a.length > 0 && (i < 0 ? i = 0 : i >= a.length && (i = a.length - 1), this.focusedChild_ = i, a[i].el_.focus());
  }, t;
}(ye);
ye.registerComponent("Menu", y1);
var qp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    i === void 0 && (i = {}), a = e.call(this, n, i) || this, a.menuButton_ = new ji(n, i), a.menuButton_.controlText(a.controlText_), a.menuButton_.el_.setAttribute("aria-haspopup", "true");
    var s = ji.prototype.buildCSSClass();
    a.menuButton_.el_.className = a.buildCSSClass() + " " + s, a.menuButton_.removeClass("vjs-control"), a.addChild(a.menuButton_), a.update(), a.enabled_ = !0;
    var o = function(l) {
      return a.handleClick(l);
    };
    return a.handleMenuKeyUp_ = function(u) {
      return a.handleMenuKeyUp(u);
    }, a.on(a.menuButton_, "tap", o), a.on(a.menuButton_, "click", o), a.on(a.menuButton_, "keydown", function(u) {
      return a.handleKeyDown(u);
    }), a.on(a.menuButton_, "mouseenter", function() {
      a.addClass("vjs-hover"), a.menu.show(), Pi(Te, "keyup", a.handleMenuKeyUp_);
    }), a.on("mouseleave", function(u) {
      return a.handleMouseLeave(u);
    }), a.on("keydown", function(u) {
      return a.handleSubmenuKeyDown(u);
    }), a;
  }
  var r = t.prototype;
  return r.update = function() {
    var i = this.createMenu();
    this.menu && (this.menu.dispose(), this.removeChild(this.menu)), this.menu = i, this.addChild(i), this.buttonPressed_ = !1, this.menuButton_.el_.setAttribute("aria-expanded", "false"), this.items && this.items.length <= this.hideThreshold_ ? (this.hide(), this.menu.contentEl_.removeAttribute("role")) : (this.show(), this.menu.contentEl_.setAttribute("role", "menu"));
  }, r.createMenu = function() {
    var i = new y1(this.player_, {
      menuButton: this
    });
    if (this.hideThreshold_ = 0, this.options_.title) {
      var a = St("li", {
        className: "vjs-menu-title",
        tabIndex: -1,
        textContent: mr(this.options_.title)
      }), s = new ye(this.player_, {
        el: a
      });
      i.addItem(s);
    }
    if (this.items = this.createItems(), this.items)
      for (var o = 0; o < this.items.length; o++)
        i.addItem(this.items[o]);
    return i;
  }, r.createItems = function() {
  }, r.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "div",
      {
        className: this.buildWrapperCSSClass()
      },
      {}
    );
  }, r.buildWrapperCSSClass = function() {
    var i = "vjs-menu-button";
    this.options_.inline === !0 ? i += "-inline" : i += "-popup";
    var a = ji.prototype.buildCSSClass();
    return "vjs-menu-button " + i + " " + a + " " + e.prototype.buildCSSClass.call(this);
  }, r.buildCSSClass = function() {
    var i = "vjs-menu-button";
    return this.options_.inline === !0 ? i += "-inline" : i += "-popup", "vjs-menu-button " + i + " " + e.prototype.buildCSSClass.call(this);
  }, r.controlText = function(i, a) {
    return a === void 0 && (a = this.menuButton_.el()), this.menuButton_.controlText(i, a);
  }, r.dispose = function() {
    this.handleMouseLeave(), e.prototype.dispose.call(this);
  }, r.handleClick = function(i) {
    this.buttonPressed_ ? this.unpressButton() : this.pressButton();
  }, r.handleMouseLeave = function(i) {
    this.removeClass("vjs-hover"), zr(Te, "keyup", this.handleMenuKeyUp_);
  }, r.focus = function() {
    this.menuButton_.focus();
  }, r.blur = function() {
    this.menuButton_.blur();
  }, r.handleKeyDown = function(i) {
    lt.isEventKey(i, "Esc") || lt.isEventKey(i, "Tab") ? (this.buttonPressed_ && this.unpressButton(), lt.isEventKey(i, "Tab") || (i.preventDefault(), this.menuButton_.focus())) : (lt.isEventKey(i, "Up") || lt.isEventKey(i, "Down")) && (this.buttonPressed_ || (i.preventDefault(), this.pressButton()));
  }, r.handleMenuKeyUp = function(i) {
    (lt.isEventKey(i, "Esc") || lt.isEventKey(i, "Tab")) && this.removeClass("vjs-hover");
  }, r.handleSubmenuKeyPress = function(i) {
    this.handleSubmenuKeyDown(i);
  }, r.handleSubmenuKeyDown = function(i) {
    (lt.isEventKey(i, "Esc") || lt.isEventKey(i, "Tab")) && (this.buttonPressed_ && this.unpressButton(), lt.isEventKey(i, "Tab") || (i.preventDefault(), this.menuButton_.focus()));
  }, r.pressButton = function() {
    if (this.enabled_) {
      if (this.buttonPressed_ = !0, this.menu.show(), this.menu.lockShowing(), this.menuButton_.el_.setAttribute("aria-expanded", "true"), ci && I_())
        return;
      this.menu.focus();
    }
  }, r.unpressButton = function() {
    this.enabled_ && (this.buttonPressed_ = !1, this.menu.unlockShowing(), this.menu.hide(), this.menuButton_.el_.setAttribute("aria-expanded", "false"));
  }, r.disable = function() {
    this.unpressButton(), this.enabled_ = !1, this.addClass("vjs-disabled"), this.menuButton_.disable();
  }, r.enable = function() {
    this.enabled_ = !0, this.removeClass("vjs-disabled"), this.menuButton_.enable();
  }, t;
}(ye);
ye.registerComponent("MenuButton", qp);
var Xp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(r, n) {
    var i, a = n.tracks;
    if (i = e.call(this, r, n) || this, i.items.length <= 1 && i.hide(), !a)
      return ze(i);
    var s = $t(ze(i), i.update);
    return a.addEventListener("removetrack", s), a.addEventListener("addtrack", s), a.addEventListener("labelchange", s), i.player_.on("ready", s), i.player_.on("dispose", function() {
      a.removeEventListener("removetrack", s), a.removeEventListener("addtrack", s), a.removeEventListener("labelchange", s);
    }), i;
  }
  return t;
}(qp);
ye.registerComponent("TrackButton", Xp);
var p3 = ["Tab", "Esc", "Up", "Down", "Right", "Left"], Ll = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.selectable = i.selectable, a.isSelected_ = i.selected || !1, a.multiSelectable = i.multiSelectable, a.selected(a.isSelected_), a.selectable ? a.multiSelectable ? a.el_.setAttribute("role", "menuitemcheckbox") : a.el_.setAttribute("role", "menuitemradio") : a.el_.setAttribute("role", "menuitem"), a;
  }
  var r = t.prototype;
  return r.createEl = function(i, a, s) {
    this.nonIconControl = !0;
    var o = e.prototype.createEl.call(
      this,
      "li",
      sr(
        {
          className: "vjs-menu-item",
          tabIndex: -1
        },
        a
      ),
      s
    );
    return o.replaceChild(
      St("span", {
        className: "vjs-menu-item-text",
        textContent: this.localize(this.options_.label)
      }),
      o.querySelector(".vjs-icon-placeholder")
    ), o;
  }, r.handleKeyDown = function(i) {
    p3.some(function(a) {
      return lt.isEventKey(i, a);
    }) || e.prototype.handleKeyDown.call(this, i);
  }, r.handleClick = function(i) {
    this.selected(!0);
  }, r.selected = function(i) {
    this.selectable && (i ? (this.addClass("vjs-selected"), this.el_.setAttribute("aria-checked", "true"), this.controlText(", selected"), this.isSelected_ = !0) : (this.removeClass("vjs-selected"), this.el_.setAttribute("aria-checked", "false"), this.controlText(""), this.isSelected_ = !1));
  }, t;
}(Bh);
ye.registerComponent("MenuItem", Ll);
var Rl = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a, s = i.track, o = n.textTracks();
    i.label = s.label || s.language || "Unknown", i.selected = s.mode === "showing", a = e.call(this, n, i) || this, a.track = s, a.kinds = (i.kinds || [i.kind || a.track.kind]).filter(
      Boolean
    );
    var u = function() {
      for (var f = arguments.length, d = new Array(f), p = 0; p < f; p++)
        d[p] = arguments[p];
      a.handleTracksChange.apply(ze(a), d);
    }, l = function() {
      for (var f = arguments.length, d = new Array(f), p = 0; p < f; p++)
        d[p] = arguments[p];
      a.handleSelectedLanguageChange.apply(
        ze(a),
        d
      );
    };
    if (n.on(["loadstart", "texttrackchange"], u), o.addEventListener("change", u), o.addEventListener(
      "selectedlanguagechange",
      l
    ), a.on("dispose", function() {
      n.off(["loadstart", "texttrackchange"], u), o.removeEventListener("change", u), o.removeEventListener(
        "selectedlanguagechange",
        l
      );
    }), o.onchange === void 0) {
      var c;
      a.on(["tap", "click"], function() {
        if (typeof j.Event != "object")
          try {
            c = new j.Event("change");
          } catch {
          }
        c || (c = Te.createEvent("Event"), c.initEvent("change", !0, !0)), o.dispatchEvent(c);
      });
    }
    return a.handleTracksChange(), a;
  }
  var r = t.prototype;
  return r.handleClick = function(i) {
    var a = this.track, s = this.player_.textTracks();
    if (e.prototype.handleClick.call(this, i), !!s)
      for (var o = 0; o < s.length; o++) {
        var u = s[o];
        this.kinds.indexOf(u.kind) !== -1 && (u === a ? u.mode !== "showing" && (u.mode = "showing") : u.mode !== "disabled" && (u.mode = "disabled"));
      }
  }, r.handleTracksChange = function(i) {
    var a = this.track.mode === "showing";
    a !== this.isSelected_ && this.selected(a);
  }, r.handleSelectedLanguageChange = function(i) {
    if (this.track.mode === "showing") {
      var a = this.player_.cache_.selectedLanguage;
      if (a && a.enabled && a.language === this.track.language && a.kind !== this.track.kind)
        return;
      this.player_.cache_.selectedLanguage = {
        enabled: !0,
        kind: this.track.kind,
        language: this.track.language
      };
    }
  }, r.dispose = function() {
    this.track = null, e.prototype.dispose.call(this);
  }, t;
}(Ll);
ye.registerComponent("TextTrackMenuItem", Rl);
var _1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    return i.track = {
      default: !1,
      // it is no longer necessary to store `kind` or `kinds` on the track itself
      // since they are now stored in the `kinds` property of all instances of
      // TextTrackMenuItem, but this will remain for backwards compatibility
      kind: i.kind,
      kinds: i.kinds,
      mode: "disabled",
      player: n
    }, i.kinds || (i.kinds = [i.kind]), i.label ? i.track.label = i.label : i.track.label = i.kinds.join(" and ") + " off", i.selectable = !0, i.multiSelectable = !1, e.call(this, n, i) || this;
  }
  var r = t.prototype;
  return r.handleTracksChange = function(i) {
    for (var a = this.player().textTracks(), s = !0, o = 0, u = a.length; o < u; o++) {
      var l = a[o];
      if (this.options_.kinds.indexOf(l.kind) > -1 && l.mode === "showing") {
        s = !1;
        break;
      }
    }
    s !== this.isSelected_ && this.selected(s);
  }, r.handleSelectedLanguageChange = function(i) {
    for (var a = this.player().textTracks(), s = !0, o = 0, u = a.length; o < u; o++) {
      var l = a[o];
      if (["captions", "descriptions", "subtitles"].indexOf(l.kind) > -1 && l.mode === "showing") {
        s = !1;
        break;
      }
    }
    s && (this.player_.cache_.selectedLanguage = {
      enabled: !1
    });
  }, t;
}(Rl);
ye.registerComponent("OffTextTrackMenuItem", _1);
var Vo = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    return i === void 0 && (i = {}), i.tracks = n.textTracks(), e.call(this, n, i) || this;
  }
  var r = t.prototype;
  return r.createItems = function(i, a) {
    i === void 0 && (i = []), a === void 0 && (a = Rl);
    var s;
    this.label_ && (s = this.label_ + " off"), i.push(
      new _1(this.player_, {
        kind: this.kind_,
        kinds: this.kinds_,
        label: s
      })
    ), this.hideThreshold_ += 1;
    var o = this.player_.textTracks();
    Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]);
    for (var u = 0; u < o.length; u++) {
      var l = o[u];
      if (this.kinds_.indexOf(l.kind) > -1) {
        var c = new a(this.player_, {
          kind: this.kind_,
          kinds: this.kinds_,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: !1,
          // MenuItem is selectable
          selectable: !0,
          track: l
        });
        c.addClass("vjs-" + l.kind + "-menu-item"), c.setAttribute("title", l.label), i.push(c);
      }
    }
    return i;
  }, t;
}(Xp);
ye.registerComponent("TextTrackButton", Vo);
var b1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a, s = i.track, o = i.cue, u = n.currentTime();
    return i.selectable = !0, i.multiSelectable = !1, i.label = o.text, i.selected = o.startTime <= u && u < o.endTime, a = e.call(this, n, i) || this, a.track = s, a.cue = o, a;
  }
  var r = t.prototype;
  return r.handleClick = function(i) {
    e.prototype.handleClick.call(this), this.player_.currentTime(this.cue.startTime);
  }, t;
}(Ll);
ye.registerComponent("ChaptersTrackMenuItem", b1);
var Yp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a) {
    var s;
    return s = e.call(this, n, i, a) || this, s.selectCurrentItem_ = function() {
      s.items.forEach(function(o) {
        o.selected(s.track_.activeCues[0] === o.cue);
      });
    }, s;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-chapters-button " + e.prototype.buildCSSClass.call(this);
  }, r.buildWrapperCSSClass = function() {
    return "vjs-chapters-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, r.update = function(i) {
    if (!(i && i.track && i.track.kind !== "chapters")) {
      var a = this.findChaptersTrack();
      a !== this.track_ ? (this.setTrack(a), e.prototype.update.call(this)) : (!this.items || a && a.cues && a.cues.length !== this.items.length) && e.prototype.update.call(this);
    }
  }, r.setTrack = function(i) {
    if (this.track_ !== i) {
      if (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)), this.track_) {
        var a = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        a && a.removeEventListener("load", this.updateHandler_), this.track_.removeEventListener("cuechange", this.selectCurrentItem_), this.track_ = null;
      }
      if (this.track_ = i, this.track_) {
        this.track_.mode = "hidden";
        var s = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        s && s.addEventListener("load", this.updateHandler_), this.track_.addEventListener("cuechange", this.selectCurrentItem_);
      }
    }
  }, r.findChaptersTrack = function() {
    for (var i = this.player_.textTracks() || [], a = i.length - 1; a >= 0; a--) {
      var s = i[a];
      if (s.kind === this.kind_)
        return s;
    }
  }, r.getMenuCaption = function() {
    return this.track_ && this.track_.label ? this.track_.label : this.localize(mr(this.kind_));
  }, r.createMenu = function() {
    return this.options_.title = this.getMenuCaption(), e.prototype.createMenu.call(this);
  }, r.createItems = function() {
    var i = [];
    if (!this.track_)
      return i;
    var a = this.track_.cues;
    if (!a)
      return i;
    for (var s = 0, o = a.length; s < o; s++) {
      var u = a[s], l = new b1(this.player_, {
        cue: u,
        track: this.track_
      });
      i.push(l);
    }
    return i;
  }, t;
}(Vo);
Yp.prototype.kind_ = "chapters";
Yp.prototype.controlText_ = "Chapters";
ye.registerComponent("ChaptersButton", Yp);
var Qp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a) {
    var s;
    s = e.call(this, n, i, a) || this;
    var o = n.textTracks(), u = $t(
      ze(s),
      s.handleTracksChange
    );
    return o.addEventListener("change", u), s.on("dispose", function() {
      o.removeEventListener("change", u);
    }), s;
  }
  var r = t.prototype;
  return r.handleTracksChange = function(i) {
    for (var a = this.player().textTracks(), s = !1, o = 0, u = a.length; o < u; o++) {
      var l = a[o];
      if (l.kind !== this.kind_ && l.mode === "showing") {
        s = !0;
        break;
      }
    }
    s ? this.disable() : this.enable();
  }, r.buildCSSClass = function() {
    return "vjs-descriptions-button " + e.prototype.buildCSSClass.call(this);
  }, r.buildWrapperCSSClass = function() {
    return "vjs-descriptions-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, t;
}(Vo);
Qp.prototype.kind_ = "descriptions";
Qp.prototype.controlText_ = "Descriptions";
ye.registerComponent("DescriptionsButton", Qp);
var Kp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a) {
    return e.call(this, n, i, a) || this;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-subtitles-button " + e.prototype.buildCSSClass.call(this);
  }, r.buildWrapperCSSClass = function() {
    return "vjs-subtitles-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, t;
}(Vo);
Kp.prototype.kind_ = "subtitles";
Kp.prototype.controlText_ = "Subtitles";
ye.registerComponent("SubtitlesButton", Kp);
var $p = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return i.track = {
      default: !1,
      kind: i.kind,
      label: i.kind + " settings",
      mode: "disabled",
      player: n,
      selectable: !1
    }, i.selectable = !1, i.name = "CaptionSettingsMenuItem", a = e.call(this, n, i) || this, a.addClass("vjs-texttrack-settings"), a.controlText(", opens " + i.kind + " settings dialog"), a;
  }
  var r = t.prototype;
  return r.handleClick = function(i) {
    this.player().getChild("textTrackSettings").open();
  }, t;
}(Rl);
ye.registerComponent(
  "CaptionSettingsMenuItem",
  $p
);
var Zp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a) {
    return e.call(this, n, i, a) || this;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-captions-button " + e.prototype.buildCSSClass.call(this);
  }, r.buildWrapperCSSClass = function() {
    return "vjs-captions-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, r.createItems = function() {
    var i = [];
    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (i.push(
      new $p(this.player_, {
        kind: this.kind_
      })
    ), this.hideThreshold_ += 1), e.prototype.createItems.call(this, i);
  }, t;
}(Vo);
Zp.prototype.kind_ = "captions";
Zp.prototype.controlText_ = "Captions";
ye.registerComponent("CaptionsButton", Zp);
var x1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.createEl = function(i, a, s) {
    var o = e.prototype.createEl.call(
      this,
      i,
      a,
      s
    ), u = o.querySelector(".vjs-menu-item-text");
    return this.options_.track.kind === "captions" && (u.appendChild(
      St(
        "span",
        {
          className: "vjs-icon-placeholder"
        },
        {
          "aria-hidden": !0
        }
      )
    ), u.appendChild(
      St("span", {
        className: "vjs-control-text",
        // space added as the text will visually flow with the
        // label
        textContent: " " + this.localize("Captions")
      })
    )), o;
  }, t;
}(Rl);
ye.registerComponent("SubsCapsMenuItem", x1);
var Jp = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return i === void 0 && (i = {}), a = e.call(this, n, i) || this, a.label_ = "subtitles", ["en", "en-us", "en-ca", "fr-ca"].indexOf(a.player_.language_) > -1 && (a.label_ = "captions"), a.menuButton_.controlText(mr(a.label_)), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-subs-caps-button " + e.prototype.buildCSSClass.call(this);
  }, r.buildWrapperCSSClass = function() {
    return "vjs-subs-caps-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, r.createItems = function() {
    var i = [];
    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (i.push(
      new $p(this.player_, {
        kind: this.label_
      })
    ), this.hideThreshold_ += 1), i = e.prototype.createItems.call(
      this,
      i,
      x1
    ), i;
  }, t;
}(Vo);
Jp.prototype.kinds_ = ["captions", "subtitles"];
Jp.prototype.controlText_ = "Subtitles";
ye.registerComponent("SubsCapsButton", Jp);
var A1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a, s = i.track, o = n.audioTracks();
    i.label = s.label || s.language || "Unknown", i.selected = s.enabled, a = e.call(this, n, i) || this, a.track = s, a.addClass("vjs-" + s.kind + "-menu-item"), a.setAttribute("title", s.label);
    var u = function() {
      for (var c = arguments.length, h = new Array(c), f = 0; f < c; f++)
        h[f] = arguments[f];
      a.handleTracksChange.apply(ze(a), h);
    };
    return o.addEventListener("change", u), a.on("dispose", function() {
      o.removeEventListener("change", u);
    }), a;
  }
  var r = t.prototype;
  return r.createEl = function(i, a, s) {
    var o = e.prototype.createEl.call(this, i, a, s), u = o.querySelector(".vjs-menu-item-text");
    return this.options_.track.kind === "main-desc" && (u.appendChild(
      St(
        "span",
        {
          className: "vjs-icon-placeholder"
        },
        {
          "aria-hidden": !0
        }
      )
    ), u.appendChild(
      St("span", {
        className: "vjs-control-text",
        textContent: " " + this.localize("Descriptions")
      })
    )), o;
  }, r.handleClick = function(i) {
    if (e.prototype.handleClick.call(this, i), this.track.enabled = !0, this.player_.tech_.featuresNativeAudioTracks)
      for (var a = this.player_.audioTracks(), s = 0; s < a.length; s++) {
        var o = a[s];
        o !== this.track && (o.enabled = o === this.track);
      }
  }, r.handleTracksChange = function(i) {
    this.selected(this.track.enabled);
  }, t;
}(Ll);
ye.registerComponent("AudioTrackMenuItem", A1);
var T1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    return i === void 0 && (i = {}), i.tracks = n.audioTracks(), e.call(this, n, i) || this;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-audio-button " + e.prototype.buildCSSClass.call(this);
  }, r.buildWrapperCSSClass = function() {
    return "vjs-audio-button " + e.prototype.buildWrapperCSSClass.call(this);
  }, r.createItems = function(i) {
    i === void 0 && (i = []), this.hideThreshold_ = 1;
    for (var a = this.player_.audioTracks(), s = 0; s < a.length; s++) {
      var o = a[s];
      i.push(
        new A1(this.player_, {
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: !1,
          // MenuItem is selectable
          selectable: !0,
          track: o
        })
      );
    }
    return i;
  }, t;
}(Xp);
T1.prototype.controlText_ = "Audio Track";
ye.registerComponent("AudioTrackButton", T1);
var em = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a, s = i.rate, o = parseFloat(s, 10);
    return i.label = s, i.selected = o === n.playbackRate(), i.selectable = !0, i.multiSelectable = !1, a = e.call(this, n, i) || this, a.label = s, a.rate = o, a.on(n, "ratechange", function(u) {
      return a.update(u);
    }), a;
  }
  var r = t.prototype;
  return r.handleClick = function(i) {
    e.prototype.handleClick.call(this), this.player().playbackRate(this.rate);
  }, r.update = function(i) {
    this.selected(this.player().playbackRate() === this.rate);
  }, t;
}(Ll);
em.prototype.contentElType = "button";
ye.registerComponent("PlaybackRateMenuItem", em);
var E1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.menuButton_.el_.setAttribute("aria-describedby", a.labelElId_), a.updateVisibility(), a.updateLabel(), a.on(n, "loadstart", function(s) {
      return a.updateVisibility(s);
    }), a.on(n, "ratechange", function(s) {
      return a.updateLabel(s);
    }), a.on(n, "playbackrateschange", function(s) {
      return a.handlePlaybackRateschange(s);
    }), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    var i = e.prototype.createEl.call(this);
    return this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_, this.labelEl_ = St("div", {
      className: "vjs-playback-rate-value",
      id: this.labelElId_,
      textContent: "1x"
    }), i.appendChild(this.labelEl_), i;
  }, r.dispose = function() {
    this.labelEl_ = null, e.prototype.dispose.call(this);
  }, r.buildCSSClass = function() {
    return "vjs-playback-rate " + e.prototype.buildCSSClass.call(this);
  }, r.buildWrapperCSSClass = function() {
    return "vjs-playback-rate " + e.prototype.buildWrapperCSSClass.call(this);
  }, r.createItems = function() {
    for (var i = this.playbackRates(), a = [], s = i.length - 1; s >= 0; s--)
      a.push(
        new em(this.player(), {
          rate: i[s] + "x"
        })
      );
    return a;
  }, r.updateARIAAttributes = function() {
    this.el().setAttribute("aria-valuenow", this.player().playbackRate());
  }, r.handlePlaybackRateschange = function(i) {
    this.update();
  }, r.playbackRates = function() {
    var i = this.player();
    return i.playbackRates && i.playbackRates() || [];
  }, r.playbackRateSupported = function() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  }, r.updateVisibility = function(i) {
    this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden");
  }, r.updateLabel = function(i) {
    this.playbackRateSupported() && (this.labelEl_.textContent = this.player().playbackRate() + "x");
  }, t;
}(qp);
E1.prototype.controlText_ = "Playback Rate";
ye.registerComponent("PlaybackRateMenuButton", E1);
var w1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-spacer " + e.prototype.buildCSSClass.call(this);
  }, r.createEl = function(i, a, s) {
    return i === void 0 && (i = "div"), a === void 0 && (a = {}), s === void 0 && (s = {}), a.className || (a.className = this.buildCSSClass()), e.prototype.createEl.call(this, i, a, s);
  }, t;
}(ye);
ye.registerComponent("Spacer", w1);
var m3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-custom-control-spacer " + e.prototype.buildCSSClass.call(this);
  }, r.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: this.buildCSSClass(),
      // No-flex/table-cell mode requires there be some content
      // in the cell to fill the remaining space of the table.
      textContent: ""
    });
  }, t;
}(w1);
ye.registerComponent("CustomControlSpacer", m3);
var zc = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(this, "div", {
      className: "vjs-control-bar",
      dir: "ltr"
    });
  }, t;
}(ye);
zc.prototype.options_ = {
  children: [
    "playToggle",
    "volumePanel",
    "currentTimeDisplay",
    "timeDivider",
    "durationDisplay",
    "progressControl",
    "liveDisplay",
    "seekToLive",
    "remainingTimeDisplay",
    "customControlSpacer",
    "playbackRateMenuButton",
    "chaptersButton",
    "descriptionsButton",
    "subsCapsButton",
    "audioTrackButton",
    "fullscreenToggle"
  ]
};
"exitPictureInPicture" in Te && zc.prototype.options_.children.splice(
  zc.prototype.options_.children.length - 1,
  0,
  "pictureInPictureToggle"
);
ye.registerComponent("ControlBar", zc);
var S1 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.on(n, "error", function(s) {
      return a.open(s);
    }), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-error-display " + e.prototype.buildCSSClass.call(this);
  }, r.content = function() {
    var i = this.player().error();
    return i ? this.localize(i.message) : "";
  }, t;
}(No);
S1.prototype.options_ = Bi({}, No.prototype.options_, {
  fillAlways: !0,
  pauseOnOpen: !1,
  temporary: !1,
  uncloseable: !0
});
ye.registerComponent("ErrorDisplay", S1);
var vf = "vjs-text-track-settings", Yv = ["#000", "Black"], Qv = ["#00F", "Blue"], Kv = ["#0FF", "Cyan"], $v = ["#0F0", "Green"], Zv = ["#F0F", "Magenta"], Jv = ["#F00", "Red"], eg = ["#FFF", "White"], tg = ["#FF0", "Yellow"], gf = ["1", "Opaque"], yf = ["0.5", "Semi-Transparent"], rg = ["0", "Transparent"], Ra = {
  backgroundColor: {
    id: "captions-background-color-%s",
    label: "Color",
    options: [
      Yv,
      eg,
      Jv,
      $v,
      Qv,
      tg,
      Zv,
      Kv
    ],
    selector: ".vjs-bg-color > select"
  },
  backgroundOpacity: {
    id: "captions-background-opacity-%s",
    label: "Transparency",
    options: [gf, yf, rg],
    selector: ".vjs-bg-opacity > select"
  },
  color: {
    id: "captions-foreground-color-%s",
    label: "Color",
    options: [
      eg,
      Yv,
      Jv,
      $v,
      Qv,
      tg,
      Zv,
      Kv
    ],
    selector: ".vjs-fg-color > select"
  },
  edgeStyle: {
    id: "%s",
    label: "Text Edge Style",
    options: [
      ["none", "None"],
      ["raised", "Raised"],
      ["depressed", "Depressed"],
      ["uniform", "Uniform"],
      ["dropshadow", "Dropshadow"]
    ],
    selector: ".vjs-edge-style > select"
  },
  fontFamily: {
    id: "captions-font-family-%s",
    label: "Font Family",
    options: [
      ["proportionalSansSerif", "Proportional Sans-Serif"],
      ["monospaceSansSerif", "Monospace Sans-Serif"],
      ["proportionalSerif", "Proportional Serif"],
      ["monospaceSerif", "Monospace Serif"],
      ["casual", "Casual"],
      ["script", "Script"],
      ["small-caps", "Small Caps"]
    ],
    selector: ".vjs-font-family > select"
  },
  fontPercent: {
    default: 2,
    id: "captions-font-size-%s",
    label: "Font Size",
    options: [
      ["0.50", "50%"],
      ["0.75", "75%"],
      ["1.00", "100%"],
      ["1.25", "125%"],
      ["1.50", "150%"],
      ["1.75", "175%"],
      ["2.00", "200%"],
      ["3.00", "300%"],
      ["4.00", "400%"]
    ],
    parser: function(t) {
      return t === "1.00" ? null : Number(t);
    },
    selector: ".vjs-font-percent > select"
  },
  textOpacity: {
    id: "captions-foreground-opacity-%s",
    label: "Transparency",
    options: [gf, yf],
    selector: ".vjs-text-opacity > select"
  },
  // Options for this object are defined below.
  windowColor: {
    id: "captions-window-color-%s",
    label: "Color",
    selector: ".vjs-window-color > select"
  },
  // Options for this object are defined below.
  windowOpacity: {
    id: "captions-window-opacity-%s",
    label: "Transparency",
    options: [rg, yf, gf],
    selector: ".vjs-window-opacity > select"
  }
};
Ra.windowColor.options = Ra.backgroundColor.options;
function C1(e, t) {
  if (t && (e = t(e)), e && e !== "none")
    return e;
}
function v3(e, t) {
  var r = e.options[e.options.selectedIndex].value;
  return C1(r, t);
}
function g3(e, t, r) {
  if (t) {
    for (var n = 0; n < e.options.length; n++)
      if (C1(e.options[n].value, r) === t) {
        e.selectedIndex = n;
        break;
      }
  }
}
var y3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return i.temporary = !1, a = e.call(this, n, i) || this, a.updateDisplay = a.updateDisplay.bind(
      ze(a)
    ), a.fill(), a.hasBeenOpened_ = a.hasBeenFilled_ = !0, a.endDialog = St("p", {
      className: "vjs-control-text",
      textContent: a.localize("End of dialog window.")
    }), a.el().appendChild(a.endDialog), a.setDefaults(), i.persistTextTrackSettings === void 0 && (a.options_.persistTextTrackSettings = a.options_.playerOptions.persistTextTrackSettings), a.on(a.$(".vjs-done-button"), "click", function() {
      a.saveSettings(), a.close();
    }), a.on(a.$(".vjs-default-button"), "click", function() {
      a.setDefaults(), a.updateDisplay();
    }), Bs(Ra, function(s) {
      a.on(a.$(s.selector), "change", a.updateDisplay);
    }), a.options_.persistTextTrackSettings && a.restoreSettings(), a;
  }
  var r = t.prototype;
  return r.dispose = function() {
    this.endDialog = null, e.prototype.dispose.call(this);
  }, r.createElSelect_ = function(i, a, s) {
    var o = this;
    a === void 0 && (a = ""), s === void 0 && (s = "label");
    var u = Ra[i], l = u.id.replace("%s", this.id_), c = [a, l].join(" ").trim();
    return [
      "<" + s + ' id="' + l + '" class="' + (s === "label" ? "vjs-label" : "") + '">',
      this.localize(u.label),
      "</" + s + ">",
      '<select aria-labelledby="' + c + '">'
    ].concat(
      u.options.map(function(h) {
        var f = l + "-" + h[1].replace(/\W+/g, "");
        return [
          '<option id="' + f + '" value="' + h[0] + '" ',
          'aria-labelledby="' + c + " " + f + '">',
          o.localize(h[1]),
          "</option>"
        ].join("");
      })
    ).concat("</select>").join("");
  }, r.createElFgColor_ = function() {
    var i = "captions-text-legend-" + this.id_;
    return [
      '<fieldset class="vjs-fg-color vjs-track-setting">',
      '<legend id="' + i + '">',
      this.localize("Text"),
      "</legend>",
      this.createElSelect_("color", i),
      '<span class="vjs-text-opacity vjs-opacity">',
      this.createElSelect_("textOpacity", i),
      "</span>",
      "</fieldset>"
    ].join("");
  }, r.createElBgColor_ = function() {
    var i = "captions-background-" + this.id_;
    return [
      '<fieldset class="vjs-bg-color vjs-track-setting">',
      '<legend id="' + i + '">',
      this.localize("Background"),
      "</legend>",
      this.createElSelect_("backgroundColor", i),
      '<span class="vjs-bg-opacity vjs-opacity">',
      this.createElSelect_("backgroundOpacity", i),
      "</span>",
      "</fieldset>"
    ].join("");
  }, r.createElWinColor_ = function() {
    var i = "captions-window-" + this.id_;
    return [
      '<fieldset class="vjs-window-color vjs-track-setting">',
      '<legend id="' + i + '">',
      this.localize("Window"),
      "</legend>",
      this.createElSelect_("windowColor", i),
      '<span class="vjs-window-opacity vjs-opacity">',
      this.createElSelect_("windowOpacity", i),
      "</span>",
      "</fieldset>"
    ].join("");
  }, r.createElColors_ = function() {
    return St("div", {
      className: "vjs-track-settings-colors",
      innerHTML: [
        this.createElFgColor_(),
        this.createElBgColor_(),
        this.createElWinColor_()
      ].join("")
    });
  }, r.createElFont_ = function() {
    return St("div", {
      className: "vjs-track-settings-font",
      innerHTML: [
        '<fieldset class="vjs-font-percent vjs-track-setting">',
        this.createElSelect_("fontPercent", "", "legend"),
        "</fieldset>",
        '<fieldset class="vjs-edge-style vjs-track-setting">',
        this.createElSelect_("edgeStyle", "", "legend"),
        "</fieldset>",
        '<fieldset class="vjs-font-family vjs-track-setting">',
        this.createElSelect_("fontFamily", "", "legend"),
        "</fieldset>"
      ].join("")
    });
  }, r.createElControls_ = function() {
    var i = this.localize(
      "restore all settings to the default values"
    );
    return St("div", {
      className: "vjs-track-settings-controls",
      innerHTML: [
        '<button type="button" class="vjs-default-button" title="' + i + '">',
        this.localize("Reset"),
        '<span class="vjs-control-text"> ' + i + "</span>",
        "</button>",
        '<button type="button" class="vjs-done-button">' + this.localize("Done") + "</button>"
      ].join("")
    });
  }, r.content = function() {
    return [
      this.createElColors_(),
      this.createElFont_(),
      this.createElControls_()
    ];
  }, r.label = function() {
    return this.localize("Caption Settings Dialog");
  }, r.description = function() {
    return this.localize(
      "Beginning of dialog window. Escape will cancel and close the window."
    );
  }, r.buildCSSClass = function() {
    return e.prototype.buildCSSClass.call(this) + " vjs-text-track-settings";
  }, r.getValues = function() {
    var i = this;
    return sM(
      Ra,
      function(a, s, o) {
        var u = v3(
          i.$(s.selector),
          s.parser
        );
        return u !== void 0 && (a[o] = u), a;
      },
      {}
    );
  }, r.setValues = function(i) {
    var a = this;
    Bs(Ra, function(s, o) {
      g3(a.$(s.selector), i[o], s.parser);
    });
  }, r.setDefaults = function() {
    var i = this;
    Bs(Ra, function(a) {
      var s = a.hasOwnProperty("default") ? a.default : 0;
      i.$(a.selector).selectedIndex = s;
    });
  }, r.restoreSettings = function() {
    var i;
    try {
      i = JSON.parse(j.localStorage.getItem(vf));
    } catch (a) {
      vt.warn(a);
    }
    i && this.setValues(i);
  }, r.saveSettings = function() {
    if (this.options_.persistTextTrackSettings) {
      var i = this.getValues();
      try {
        Object.keys(i).length ? j.localStorage.setItem(
          vf,
          JSON.stringify(i)
        ) : j.localStorage.removeItem(vf);
      } catch (a) {
        vt.warn(a);
      }
    }
  }, r.updateDisplay = function() {
    var i = this.player_.getChild("textTrackDisplay");
    i && i.updateDisplay();
  }, r.conditionalBlur_ = function() {
    this.previouslyActiveEl_ = null;
    var i = this.player_.controlBar, a = i && i.subsCapsButton, s = i && i.captionsButton;
    a ? a.focus() : s && s.focus();
  }, t;
}(No);
ye.registerComponent("TextTrackSettings", y3);
var _3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a, s = i.ResizeObserver || j.ResizeObserver;
    i.ResizeObserver === null && (s = !1);
    var o = Kt(
      {
        createEl: !s,
        reportTouchActivity: !1
      },
      i
    );
    return a = e.call(this, n, o) || this, a.ResizeObserver = i.ResizeObserver || j.ResizeObserver, a.loadListener_ = null, a.resizeObserver_ = null, a.debouncedHandler_ = gM(
      function() {
        a.resizeHandler();
      },
      100,
      !1,
      ze(a)
    ), s ? (a.resizeObserver_ = new a.ResizeObserver(a.debouncedHandler_), a.resizeObserver_.observe(n.el())) : (a.loadListener_ = function() {
      if (!(!a.el_ || !a.el_.contentWindow)) {
        var u = a.debouncedHandler_, l = a.unloadListener_ = function() {
          zr(this, "resize", u), zr(this, "unload", l), l = null;
        };
        Pi(a.el_.contentWindow, "unload", l), Pi(a.el_.contentWindow, "resize", u);
      }
    }, a.one("load", a.loadListener_)), a;
  }
  var r = t.prototype;
  return r.createEl = function() {
    return e.prototype.createEl.call(
      this,
      "iframe",
      {
        className: "vjs-resize-manager",
        tabIndex: -1,
        title: this.localize("No content")
      },
      {
        "aria-hidden": "true"
      }
    );
  }, r.resizeHandler = function() {
    !this.player_ || !this.player_.trigger || this.player_.trigger("playerresize");
  }, r.dispose = function() {
    this.debouncedHandler_ && this.debouncedHandler_.cancel(), this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()), this.resizeObserver_.disconnect()), this.loadListener_ && this.off("load", this.loadListener_), this.el_ && this.el_.contentWindow && this.unloadListener_ && this.unloadListener_.call(this.el_.contentWindow), this.ResizeObserver = null, this.resizeObserver = null, this.debouncedHandler_ = null, this.loadListener_ = null, e.prototype.dispose.call(this);
  }, t;
}(ye);
ye.registerComponent("ResizeManager", _3);
var b3 = {
  liveTolerance: 15,
  trackingThreshold: 20
}, x3 = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a, s = Kt(b3, i, {
      createEl: !1
    });
    return a = e.call(this, n, s) || this, a.handleVisibilityChange_ = function(o) {
      return a.handleVisibilityChange(o);
    }, a.trackLiveHandler_ = function() {
      return a.trackLive_();
    }, a.handlePlay_ = function(o) {
      return a.handlePlay(o);
    }, a.handleFirstTimeupdate_ = function(o) {
      return a.handleFirstTimeupdate(o);
    }, a.handleSeeked_ = function(o) {
      return a.handleSeeked(o);
    }, a.seekToLiveEdge_ = function(o) {
      return a.seekToLiveEdge(o);
    }, a.reset_(), a.on(a.player_, "durationchange", function(o) {
      return a.handleDurationchange(o);
    }), a.on(a.player_, "canplay", function() {
      return a.toggleTracking();
    }), Ml && "hidden" in Te && "visibilityState" in Te && a.on(Te, "visibilitychange", a.handleVisibilityChange_), a;
  }
  var r = t.prototype;
  return r.handleVisibilityChange = function() {
    this.player_.duration() === 1 / 0 && (Te.hidden ? this.stopTracking() : this.startTracking());
  }, r.trackLive_ = function() {
    var i = this.player_.seekable();
    if (!(!i || !i.length)) {
      var a = Number(j.performance.now().toFixed(4)), s = this.lastTime_ === -1 ? 0 : (a - this.lastTime_) / 1e3;
      this.lastTime_ = a, this.pastSeekEnd_ = this.pastSeekEnd() + s;
      var o = this.liveCurrentTime(), u = this.player_.currentTime(), l = this.player_.paused() || this.seekedBehindLive_ || Math.abs(o - u) > this.options_.liveTolerance;
      (!this.timeupdateSeen_ || o === 1 / 0) && (l = !1), l !== this.behindLiveEdge_ && (this.behindLiveEdge_ = l, this.trigger("liveedgechange"));
    }
  }, r.handleDurationchange = function() {
    this.toggleTracking();
  }, r.toggleTracking = function() {
    this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold ? (this.player_.options_.liveui && this.player_.addClass("vjs-liveui"), this.startTracking()) : (this.player_.removeClass("vjs-liveui"), this.stopTracking());
  }, r.startTracking = function() {
    this.isTracking() || (this.timeupdateSeen_ || (this.timeupdateSeen_ = this.player_.hasStarted()), this.trackingInterval_ = this.setInterval(
      this.trackLiveHandler_,
      Ji
    ), this.trackLive_(), this.on(this.player_, ["play", "pause"], this.trackLiveHandler_), this.timeupdateSeen_ ? this.on(this.player_, "seeked", this.handleSeeked_) : (this.one(this.player_, "play", this.handlePlay_), this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_)));
  }, r.handleFirstTimeupdate = function() {
    this.timeupdateSeen_ = !0, this.on(this.player_, "seeked", this.handleSeeked_);
  }, r.handleSeeked = function() {
    var i = Math.abs(
      this.liveCurrentTime() - this.player_.currentTime()
    );
    this.seekedBehindLive_ = this.nextSeekedFromUser_ && i > 2, this.nextSeekedFromUser_ = !1, this.trackLive_();
  }, r.handlePlay = function() {
    this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
  }, r.reset_ = function() {
    this.lastTime_ = -1, this.pastSeekEnd_ = 0, this.lastSeekEnd_ = -1, this.behindLiveEdge_ = !0, this.timeupdateSeen_ = !1, this.seekedBehindLive_ = !1, this.nextSeekedFromUser_ = !1, this.clearInterval(this.trackingInterval_), this.trackingInterval_ = null, this.off(this.player_, ["play", "pause"], this.trackLiveHandler_), this.off(this.player_, "seeked", this.handleSeeked_), this.off(this.player_, "play", this.handlePlay_), this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_), this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
  }, r.nextSeekedFromUser = function() {
    this.nextSeekedFromUser_ = !0;
  }, r.stopTracking = function() {
    this.isTracking() && (this.reset_(), this.trigger("liveedgechange"));
  }, r.seekableEnd = function() {
    for (var i = this.player_.seekable(), a = [], s = i ? i.length : 0; s--; )
      a.push(i.end(s));
    return a.length ? a.sort()[a.length - 1] : 1 / 0;
  }, r.seekableStart = function() {
    for (var i = this.player_.seekable(), a = [], s = i ? i.length : 0; s--; )
      a.push(i.start(s));
    return a.length ? a.sort()[0] : 0;
  }, r.liveWindow = function() {
    var i = this.liveCurrentTime();
    return i === 1 / 0 ? 0 : i - this.seekableStart();
  }, r.isLive = function() {
    return this.isTracking();
  }, r.atLiveEdge = function() {
    return !this.behindLiveEdge();
  }, r.liveCurrentTime = function() {
    return this.pastSeekEnd() + this.seekableEnd();
  }, r.pastSeekEnd = function() {
    var i = this.seekableEnd();
    return this.lastSeekEnd_ !== -1 && i !== this.lastSeekEnd_ && (this.pastSeekEnd_ = 0), this.lastSeekEnd_ = i, this.pastSeekEnd_;
  }, r.behindLiveEdge = function() {
    return this.behindLiveEdge_;
  }, r.isTracking = function() {
    return typeof this.trackingInterval_ == "number";
  }, r.seekToLiveEdge = function() {
    this.seekedBehindLive_ = !1, !this.atLiveEdge() && (this.nextSeekedFromUser_ = !1, this.player_.currentTime(this.liveCurrentTime()));
  }, r.dispose = function() {
    this.off(Te, "visibilitychange", this.handleVisibilityChange_), this.stopTracking(), e.prototype.dispose.call(this);
  }, t;
}(ye);
ye.registerComponent("LiveTracker", x3);
var ld = function(t) {
  var r = t.el();
  if (r.hasAttribute("src"))
    return t.triggerSourceset(r.src), !0;
  var n = t.$$("source"), i = [], a = "";
  if (!n.length)
    return !1;
  for (var s = 0; s < n.length; s++) {
    var o = n[s].src;
    o && i.indexOf(o) === -1 && i.push(o);
  }
  return i.length ? (i.length === 1 && (a = i[0]), t.triggerSourceset(a), !0) : !1;
}, A3 = Object.defineProperty({}, "innerHTML", {
  get: function() {
    return this.cloneNode(!0).innerHTML;
  },
  set: function(t) {
    var r = Te.createElement(this.nodeName.toLowerCase());
    r.innerHTML = t;
    for (var n = Te.createDocumentFragment(); r.childNodes.length; )
      n.appendChild(r.childNodes[0]);
    return this.innerText = "", j.Element.prototype.appendChild.call(this, n), this.innerHTML;
  }
}), M1 = function(t, r) {
  for (var n = {}, i = 0; i < t.length && (n = Object.getOwnPropertyDescriptor(t[i], r), !(n && n.set && n.get)); i++)
    ;
  return n.enumerable = !0, n.configurable = !0, n;
}, T3 = function(t) {
  return M1(
    [
      t.el(),
      j.HTMLMediaElement.prototype,
      j.Element.prototype,
      A3
    ],
    "innerHTML"
  );
}, ig = function(t) {
  var r = t.el();
  if (!r.resetSourceWatch_) {
    var n = {}, i = T3(t), a = function(o) {
      return function() {
        for (var u = arguments.length, l = new Array(u), c = 0; c < u; c++)
          l[c] = arguments[c];
        var h = o.apply(r, l);
        return ld(t), h;
      };
    };
    ["append", "appendChild", "insertAdjacentHTML"].forEach(function(s) {
      r[s] && (n[s] = r[s], r[s] = a(n[s]));
    }), Object.defineProperty(
      r,
      "innerHTML",
      Kt(i, {
        set: a(i.set)
      })
    ), r.resetSourceWatch_ = function() {
      r.resetSourceWatch_ = null, Object.keys(n).forEach(function(s) {
        r[s] = n[s];
      }), Object.defineProperty(r, "innerHTML", i);
    }, t.one("sourceset", r.resetSourceWatch_);
  }
}, E3 = Object.defineProperty({}, "src", {
  get: function() {
    return this.hasAttribute("src") ? t1(
      j.Element.prototype.getAttribute.call(this, "src")
    ) : "";
  },
  set: function(t) {
    return j.Element.prototype.setAttribute.call(this, "src", t), t;
  }
}), w3 = function(t) {
  return M1(
    [t.el(), j.HTMLMediaElement.prototype, E3],
    "src"
  );
}, S3 = function(t) {
  if (t.featuresSourceset) {
    var r = t.el();
    if (!r.resetSourceset_) {
      var n = w3(t), i = r.setAttribute, a = r.load;
      Object.defineProperty(
        r,
        "src",
        Kt(n, {
          set: function(o) {
            var u = n.set.call(r, o);
            return t.triggerSourceset(r.src), u;
          }
        })
      ), r.setAttribute = function(s, o) {
        var u = i.call(r, s, o);
        return /src/i.test(s) && t.triggerSourceset(r.src), u;
      }, r.load = function() {
        var s = a.call(r);
        return ld(t) || (t.triggerSourceset(""), ig(t)), s;
      }, r.currentSrc ? t.triggerSourceset(r.currentSrc) : ld(t) || ig(t), r.resetSourceset_ = function() {
        r.resetSourceset_ = null, r.load = a, r.setAttribute = i, Object.defineProperty(r, "src", n), r.resetSourceWatch_ && r.resetSourceWatch_();
      };
    }
  }
}, tm = function(t, r, n, i) {
  i === void 0 && (i = !0);
  var a = function(u) {
    return Object.defineProperty(t, r, {
      enumerable: !0,
      value: u,
      writable: !0
    });
  }, s = {
    configurable: !0,
    enumerable: !0,
    get: function() {
      var u = n();
      return a(u), u;
    }
  };
  return i && (s.set = a), Object.defineProperty(t, r, s);
}, Oe = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    a = e.call(this, n, i) || this;
    var s = n.source, o = !1;
    if (a.featuresVideoFrameCallback = a.featuresVideoFrameCallback && a.el_.tagName === "VIDEO", s && (a.el_.currentSrc !== s.src || n.tag && n.tag.initNetworkState_ === 3) ? a.setSource(s) : a.handleLateInit_(a.el_), n.enableSourceset && a.setupSourcesetHandling_(), a.isScrubbing_ = !1, a.el_.hasChildNodes()) {
      for (var u = a.el_.childNodes, l = u.length, c = []; l--; ) {
        var h = u[l], f = h.nodeName.toLowerCase();
        f === "track" && (a.featuresNativeTextTracks ? (a.remoteTextTrackEls().addTrackElement_(h), a.remoteTextTracks().addTrack(h.track), a.textTracks().addTrack(h.track), !o && !a.el_.hasAttribute("crossorigin") && Oh(h.src) && (o = !0)) : c.push(h));
      }
      for (var d = 0; d < c.length; d++)
        a.el_.removeChild(c[d]);
    }
    return a.proxyNativeTracks_(), a.featuresNativeTextTracks && o && vt.warn(
      `Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.
This may prevent text tracks from loading.`
    ), a.restoreMetadataTracksInIOSNativePlayer_(), (So || Pp || M_) && n.nativeControlsForTouch === !0 && a.setControls(!0), a.proxyWebkitFullscreen_(), a.triggerReady(), a;
  }
  var r = t.prototype;
  return r.dispose = function() {
    this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(), t.disposeMediaElement(this.el_), this.options_ = null, e.prototype.dispose.call(this);
  }, r.setupSourcesetHandling_ = function() {
    S3(this);
  }, r.restoreMetadataTracksInIOSNativePlayer_ = function() {
    var i = this.textTracks(), a, s = function() {
      a = [];
      for (var l = 0; l < i.length; l++) {
        var c = i[l];
        c.kind === "metadata" && a.push({
          storedMode: c.mode,
          track: c
        });
      }
    };
    s(), i.addEventListener("change", s), this.on("dispose", function() {
      return i.removeEventListener(
        "change",
        s
      );
    });
    var o = function u() {
      for (var l = 0; l < a.length; l++) {
        var c = a[l];
        c.track.mode === "disabled" && c.track.mode !== c.storedMode && (c.track.mode = c.storedMode);
      }
      i.removeEventListener("change", u);
    };
    this.on("webkitbeginfullscreen", function() {
      i.removeEventListener("change", s), i.removeEventListener("change", o), i.addEventListener("change", o);
    }), this.on("webkitendfullscreen", function() {
      i.removeEventListener("change", s), i.addEventListener("change", s), i.removeEventListener("change", o);
    });
  }, r.overrideNative_ = function(i, a) {
    var s = this;
    if (a === this["featuresNative" + i + "Tracks"]) {
      var o = i.toLowerCase();
      this[o + "TracksListeners_"] && Object.keys(this[o + "TracksListeners_"]).forEach(
        function(u) {
          var l = s.el()[o + "Tracks"];
          l.removeEventListener(
            u,
            s[o + "TracksListeners_"][u]
          );
        }
      ), this["featuresNative" + i + "Tracks"] = !a, this[o + "TracksListeners_"] = null, this.proxyNativeTracksForType_(o);
    }
  }, r.overrideNativeAudioTracks = function(i) {
    this.overrideNative_("Audio", i);
  }, r.overrideNativeVideoTracks = function(i) {
    this.overrideNative_("Video", i);
  }, r.proxyNativeTracksForType_ = function(i) {
    var a = this, s = Oi[i], o = this.el()[s.getterName], u = this[s.getterName]();
    if (!(!this["featuresNative" + s.capitalName + "Tracks"] || !o || !o.addEventListener)) {
      var l = {
        addtrack: function(f) {
          u.addTrack(f.track);
        },
        change: function(f) {
          var d = {
            currentTarget: u,
            srcElement: u,
            target: u,
            type: "change"
          };
          u.trigger(d), i === "text" && a[Po.remoteText.getterName]().trigger(d);
        },
        removetrack: function(f) {
          u.removeTrack(f.track);
        }
      }, c = function() {
        for (var f = [], d = 0; d < u.length; d++) {
          for (var p = !1, _ = 0; _ < o.length; _++)
            if (o[_] === u[d]) {
              p = !0;
              break;
            }
          p || f.push(u[d]);
        }
        for (; f.length; )
          u.removeTrack(f.shift());
      };
      this[s.getterName + "Listeners_"] = l, Object.keys(l).forEach(function(h) {
        var f = l[h];
        o.addEventListener(h, f), a.on("dispose", function(d) {
          return o.removeEventListener(h, f);
        });
      }), this.on("loadstart", c), this.on("dispose", function(h) {
        return a.off("loadstart", c);
      });
    }
  }, r.proxyNativeTracks_ = function() {
    var i = this;
    Oi.names.forEach(function(a) {
      i.proxyNativeTracksForType_(a);
    });
  }, r.createEl = function() {
    var i = this.options_.tag;
    if (!i || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
      if (i) {
        var a = i.cloneNode(!0);
        i.parentNode && i.parentNode.insertBefore(a, i), t.disposeMediaElement(i), i = a;
      } else {
        i = Te.createElement("video");
        var s = this.options_.tag && Ln(this.options_.tag), o = Kt({}, s);
        (!So || this.options_.nativeControlsForTouch !== !0) && delete o.controls, F_(
          i,
          sr(o, {
            class: "vjs-tech",
            id: this.options_.techId
          })
        );
      }
      i.playerId = this.options_.playerId;
    }
    typeof this.options_.preload < "u" && Co(i, "preload", this.options_.preload), this.options_.disablePictureInPicture !== void 0 && (i.disablePictureInPicture = this.options_.disablePictureInPicture);
    for (var u = ["loop", "muted", "playsinline", "autoplay"], l = 0; l < u.length; l++) {
      var c = u[l], h = this.options_[c];
      typeof h < "u" && (h ? Co(i, c, c) : Dh(i, c), i[c] = h);
    }
    return i;
  }, r.handleLateInit_ = function(i) {
    if (!(i.networkState === 0 || i.networkState === 3)) {
      if (i.readyState === 0) {
        var a = !1, s = function() {
          a = !0;
        };
        this.on("loadstart", s);
        var o = function() {
          a || this.trigger("loadstart");
        };
        this.on("loadedmetadata", o), this.ready(function() {
          this.off("loadstart", s), this.off("loadedmetadata", o), a || this.trigger("loadstart");
        });
        return;
      }
      var u = ["loadstart"];
      u.push("loadedmetadata"), i.readyState >= 2 && u.push("loadeddata"), i.readyState >= 3 && u.push("canplay"), i.readyState >= 4 && u.push("canplaythrough"), this.ready(function() {
        u.forEach(function(l) {
          this.trigger(l);
        }, this);
      });
    }
  }, r.setScrubbing = function(i) {
    this.isScrubbing_ = i;
  }, r.scrubbing = function() {
    return this.isScrubbing_;
  }, r.setCurrentTime = function(i) {
    try {
      this.isScrubbing_ && this.el_.fastSeek && Mh ? this.el_.fastSeek(i) : this.el_.currentTime = i;
    } catch (a) {
      vt(a, "Video is not ready. (Video.js)");
    }
  }, r.duration = function() {
    var i = this;
    if (this.el_.duration === 1 / 0 && Jn && ea && this.el_.currentTime === 0) {
      var a = function s() {
        i.el_.currentTime > 0 && (i.el_.duration === 1 / 0 && i.trigger("durationchange"), i.off("timeupdate", s));
      };
      return this.on("timeupdate", a), NaN;
    }
    return this.el_.duration || NaN;
  }, r.width = function() {
    return this.el_.offsetWidth;
  }, r.height = function() {
    return this.el_.offsetHeight;
  }, r.proxyWebkitFullscreen_ = function() {
    var i = this;
    if ("webkitDisplayingFullscreen" in this.el_) {
      var a = function() {
        this.trigger("fullscreenchange", {
          isFullscreen: !1
        }), this.el_.controls && !this.options_.nativeControlsForTouch && this.controls() && (this.el_.controls = !1);
      }, s = function() {
        "webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture" && (this.one("webkitendfullscreen", a), this.trigger("fullscreenchange", {
          isFullscreen: !0,
          // set a flag in case another tech triggers fullscreenchange
          nativeIOSFullscreen: !0
        }));
      };
      this.on("webkitbeginfullscreen", s), this.on("dispose", function() {
        i.off("webkitbeginfullscreen", s), i.off("webkitendfullscreen", a);
      });
    }
  }, r.supportsFullScreen = function() {
    if (typeof this.el_.webkitEnterFullScreen == "function") {
      var i = j.navigator && j.navigator.userAgent || "";
      if (/Android/.test(i) || !/Chrome|Mac OS X 10.5/.test(i))
        return !0;
    }
    return !1;
  }, r.enterFullScreen = function() {
    var i = this.el_;
    if (i.paused && i.networkState <= i.HAVE_METADATA)
      fn(this.el_.play()), this.setTimeout(function() {
        i.pause();
        try {
          i.webkitEnterFullScreen();
        } catch (a) {
          this.trigger("fullscreenerror", a);
        }
      }, 0);
    else
      try {
        i.webkitEnterFullScreen();
      } catch (a) {
        this.trigger("fullscreenerror", a);
      }
  }, r.exitFullScreen = function() {
    if (!this.el_.webkitDisplayingFullscreen) {
      this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
      return;
    }
    this.el_.webkitExitFullScreen();
  }, r.requestPictureInPicture = function() {
    return this.el_.requestPictureInPicture();
  }, r.requestVideoFrameCallback = function(i) {
    return this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.requestVideoFrameCallback(i) : e.prototype.requestVideoFrameCallback.call(this, i);
  }, r.cancelVideoFrameCallback = function(i) {
    this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.cancelVideoFrameCallback(i) : e.prototype.cancelVideoFrameCallback.call(this, i);
  }, r.src = function(i) {
    if (i === void 0)
      return this.el_.src;
    this.setSrc(i);
  }, r.reset = function() {
    t.resetMediaElement(this.el_);
  }, r.currentSrc = function() {
    return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc;
  }, r.setControls = function(i) {
    this.el_.controls = !!i;
  }, r.addTextTrack = function(i, a, s) {
    return this.featuresNativeTextTracks ? this.el_.addTextTrack(i, a, s) : e.prototype.addTextTrack.call(this, i, a, s);
  }, r.createRemoteTextTrack = function(i) {
    if (!this.featuresNativeTextTracks)
      return e.prototype.createRemoteTextTrack.call(this, i);
    var a = Te.createElement("track");
    return i.kind && (a.kind = i.kind), i.label && (a.label = i.label), (i.language || i.srclang) && (a.srclang = i.language || i.srclang), i.default && (a.default = i.default), i.id && (a.id = i.id), i.src && (a.src = i.src), a;
  }, r.addRemoteTextTrack = function(i, a) {
    var s = e.prototype.addRemoteTextTrack.call(
      this,
      i,
      a
    );
    return this.featuresNativeTextTracks && this.el().appendChild(s), s;
  }, r.removeRemoteTextTrack = function(i) {
    if (e.prototype.removeRemoteTextTrack.call(this, i), this.featuresNativeTextTracks)
      for (var a = this.$$("track"), s = a.length; s--; )
        (i === a[s] || i === a[s].track) && this.el().removeChild(a[s]);
  }, r.getVideoPlaybackQuality = function() {
    if (typeof this.el().getVideoPlaybackQuality == "function")
      return this.el().getVideoPlaybackQuality();
    var i = {};
    return typeof this.el().webkitDroppedFrameCount < "u" && typeof this.el().webkitDecodedFrameCount < "u" && (i.droppedVideoFrames = this.el().webkitDroppedFrameCount, i.totalVideoFrames = this.el().webkitDecodedFrameCount), j.performance && typeof j.performance.now == "function" ? i.creationTime = j.performance.now() : j.performance && j.performance.timing && typeof j.performance.timing.navigationStart == "number" && (i.creationTime = j.Date.now() - j.performance.timing.navigationStart), i;
  }, t;
}(jt);
tm(Oe, "TEST_VID", function() {
  if (Bo()) {
    var e = Te.createElement("video"), t = Te.createElement("track");
    return t.kind = "captions", t.srclang = "en", t.label = "English", e.appendChild(t), e;
  }
});
Oe.isSupported = function() {
  try {
    Oe.TEST_VID.volume = 0.5;
  } catch {
    return !1;
  }
  return !!(Oe.TEST_VID && Oe.TEST_VID.canPlayType);
};
Oe.canPlayType = function(e) {
  return Oe.TEST_VID.canPlayType(e);
};
Oe.canPlaySource = function(e, t) {
  return Oe.canPlayType(e.type);
};
Oe.canControlVolume = function() {
  try {
    var e = Oe.TEST_VID.volume;
    Oe.TEST_VID.volume = e / 2 + 0.1;
    var t = e !== Oe.TEST_VID.volume;
    return t && ci ? (j.setTimeout(function() {
      Oe && Oe.prototype && (Oe.prototype.featuresVolumeControl = e !== Oe.TEST_VID.volume);
    }), !1) : t;
  } catch {
    return !1;
  }
};
Oe.canMuteVolume = function() {
  try {
    var e = Oe.TEST_VID.muted;
    return Oe.TEST_VID.muted = !e, Oe.TEST_VID.muted ? Co(Oe.TEST_VID, "muted", "muted") : Dh(Oe.TEST_VID, "muted", "muted"), e !== Oe.TEST_VID.muted;
  } catch {
    return !1;
  }
};
Oe.canControlPlaybackRate = function() {
  if (Jn && ea && P_ < 58)
    return !1;
  try {
    var e = Oe.TEST_VID.playbackRate;
    return Oe.TEST_VID.playbackRate = e / 2 + 0.1, e !== Oe.TEST_VID.playbackRate;
  } catch {
    return !1;
  }
};
Oe.canOverrideAttributes = function() {
  try {
    var e = function() {
    };
    Object.defineProperty(Te.createElement("video"), "src", {
      get: e,
      set: e
    }), Object.defineProperty(Te.createElement("audio"), "src", {
      get: e,
      set: e
    }), Object.defineProperty(Te.createElement("video"), "innerHTML", {
      get: e,
      set: e
    }), Object.defineProperty(Te.createElement("audio"), "innerHTML", {
      get: e,
      set: e
    });
  } catch {
    return !1;
  }
  return !0;
};
Oe.supportsNativeTextTracks = function() {
  return Mh || ci && ea;
};
Oe.supportsNativeVideoTracks = function() {
  return !!(Oe.TEST_VID && Oe.TEST_VID.videoTracks);
};
Oe.supportsNativeAudioTracks = function() {
  return !!(Oe.TEST_VID && Oe.TEST_VID.audioTracks);
};
Oe.Events = [
  "loadstart",
  "suspend",
  "abort",
  "error",
  "emptied",
  "stalled",
  "loadedmetadata",
  "loadeddata",
  "canplay",
  "canplaythrough",
  "playing",
  "waiting",
  "seeking",
  "seeked",
  "ended",
  "durationchange",
  "timeupdate",
  "progress",
  "play",
  "pause",
  "ratechange",
  "resize",
  "volumechange"
];
[
  ["featuresMuteControl", "canMuteVolume"],
  ["featuresPlaybackRate", "canControlPlaybackRate"],
  ["featuresSourceset", "canOverrideAttributes"],
  ["featuresNativeTextTracks", "supportsNativeTextTracks"],
  ["featuresNativeVideoTracks", "supportsNativeVideoTracks"],
  ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]
].forEach(function(e) {
  var t = e[0], r = e[1];
  tm(
    Oe.prototype,
    t,
    function() {
      return Oe[r]();
    },
    !0
  );
});
Oe.prototype.featuresVolumeControl = Oe.canControlVolume();
Oe.prototype.movingMediaElementInDOM = !ci;
Oe.prototype.featuresFullscreenResize = !0;
Oe.prototype.featuresProgressEvents = !0;
Oe.prototype.featuresTimeupdateEvents = !0;
Oe.prototype.featuresVideoFrameCallback = !!(Oe.TEST_VID && Oe.TEST_VID.requestVideoFrameCallback);
var Wc;
Oe.patchCanPlayType = function() {
  Cp >= 4 && !D_ && !ea && (Wc = Oe.TEST_VID && Oe.TEST_VID.constructor.prototype.canPlayType, Oe.TEST_VID.constructor.prototype.canPlayType = function(e) {
    var t = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
    return e && t.test(e) ? "maybe" : Wc.call(this, e);
  });
};
Oe.unpatchCanPlayType = function() {
  var e = Oe.TEST_VID.constructor.prototype.canPlayType;
  return Wc && (Oe.TEST_VID.constructor.prototype.canPlayType = Wc), e;
};
Oe.patchCanPlayType();
Oe.disposeMediaElement = function(e) {
  if (e) {
    for (e.parentNode && e.parentNode.removeChild(e); e.hasChildNodes(); )
      e.removeChild(e.firstChild);
    e.removeAttribute("src"), typeof e.load == "function" && function() {
      try {
        e.load();
      } catch {
      }
    }();
  }
};
Oe.resetMediaElement = function(e) {
  if (e) {
    for (var t = e.querySelectorAll("source"), r = t.length; r--; )
      e.removeChild(t[r]);
    e.removeAttribute("src"), typeof e.load == "function" && function() {
      try {
        e.load();
      } catch {
      }
    }();
  }
};
[
  /**
   * Get the value of `muted` from the media element. `muted` indicates
   * that the volume for the media should be set to silent. This does not actually change
   * the `volume` attribute.
   *
   * @method Html5#muted
   * @return {boolean}
   *         - True if the value of `volume` should be ignored and the audio set to silent.
   *         - False if the value of `volume` should be used.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
   * whether the media should start muted or not. Only changes the default state of the
   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
   * current state.
   *
   * @method Html5#defaultMuted
   * @return {boolean}
   *         - The value of `defaultMuted` from the media element.
   *         - True indicates that the media should start muted.
   *         - False indicates that the media should not start muted
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Get the value of `autoplay` from the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#autoplay
   * @return {boolean}
   *         - The value of `autoplay` from the media element.
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Get the value of `controls` from the media element. `controls` indicates
   * whether the native media controls should be shown or hidden.
   *
   * @method Html5#controls
   * @return {boolean}
   *         - The value of `controls` from the media element.
   *         - True indicates that native controls should be showing.
   *         - False indicates that native controls should be hidden.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
   */
  "controls",
  /**
   * Get the value of `loop` from the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#loop
   * @return {boolean}
   *         - The value of `loop` from the media element.
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(e) {
  Oe.prototype[e] = function() {
    return this.el_[e] || this.el_.hasAttribute(e);
  };
});
[
  /**
   * Set the value of `muted` on the media element. `muted` indicates that the current
   * audio level should be silent.
   *
   * @method Html5#setMuted
   * @param {boolean} muted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
   * audio level should be silent, but will only effect the muted level on initial playback..
   *
   * @method Html5.prototype.setDefaultMuted
   * @param {boolean} defaultMuted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Set the value of `autoplay` on the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#setAutoplay
   * @param {boolean} autoplay
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Set the value of `loop` on the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#setLoop
   * @param {boolean} loop
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(e) {
  Oe.prototype["set" + mr(e)] = function(t) {
    this.el_[e] = t, t ? this.el_.setAttribute(e, e) : this.el_.removeAttribute(e);
  };
});
[
  /**
   * Get the value of `paused` from the media element. `paused` indicates whether the media element
   * is currently paused or not.
   *
   * @method Html5#paused
   * @return {boolean}
   *         The value of `paused` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
   */
  "paused",
  /**
   * Get the value of `currentTime` from the media element. `currentTime` indicates
   * the current second that the media is at in playback.
   *
   * @method Html5#currentTime
   * @return {number}
   *         The value of `currentTime` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
   */
  "currentTime",
  /**
   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
   * object that represents the parts of the media that are already downloaded and
   * available for playback.
   *
   * @method Html5#buffered
   * @return {TimeRange}
   *         The value of `buffered` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
   */
  "buffered",
  /**
   * Get the value of `volume` from the media element. `volume` indicates
   * the current playback volume of audio for a media. `volume` will be a value from 0
   * (silent) to 1 (loudest and default).
   *
   * @method Html5#volume
   * @return {number}
   *         The value of `volume` from the media element. Value will be between 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Get the value of `poster` from the media element. `poster` indicates
   * that the url of an image file that can/will be shown when no media data is available.
   *
   * @method Html5#poster
   * @return {string}
   *         The value of `poster` from the media element. Value will be a url to an
   *         image.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
   */
  "poster",
  /**
   * Get the value of `preload` from the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#preload
   * @return {string}
   *         The value of `preload` from the media element. Will be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Get the value of the `error` from the media element. `error` indicates any
   * MediaError that may have occurred during playback. If error returns null there is no
   * current error.
   *
   * @method Html5#error
   * @return {MediaError|null}
   *         The value of `error` from the media element. Will be `MediaError` if there
   *         is a current error and null otherwise.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
   */
  "error",
  /**
   * Get the value of `seeking` from the media element. `seeking` indicates whether the
   * media is currently seeking to a new position or not.
   *
   * @method Html5#seeking
   * @return {boolean}
   *         - The value of `seeking` from the media element.
   *         - True indicates that the media is currently seeking to a new position.
   *         - False indicates that the media is not seeking to a new position at this time.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
   */
  "seeking",
  /**
   * Get the value of `seekable` from the media element. `seekable` returns a
   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
   *
   * @method Html5#seekable
   * @return {TimeRange}
   *         The value of `seekable` from the media element. A `TimeRange` object
   *         indicating the current ranges of time that can be seeked to.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
   */
  "seekable",
  /**
   * Get the value of `ended` from the media element. `ended` indicates whether
   * the media has reached the end or not.
   *
   * @method Html5#ended
   * @return {boolean}
   *         - The value of `ended` from the media element.
   *         - True indicates that the media has ended.
   *         - False indicates that the media has not ended.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
   */
  "ended",
  /**
   * Get the value of `playbackRate` from the media element. `playbackRate` indicates
   * the rate at which the media is currently playing back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#playbackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
   * the rate at which the media is currently playing back. This value will not indicate the current
   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
   *
   * Examples:
   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.defaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "defaultPlaybackRate",
  /**
   * Get the value of 'disablePictureInPicture' from the video element.
   *
   * @method Html5#disablePictureInPicture
   * @return {boolean} value
   *         - The value of `disablePictureInPicture` from the video element.
   *         - True indicates that the video can't be played in Picture-In-Picture mode
   *         - False indicates that the video can be played in Picture-In-Picture mode
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Get the value of `played` from the media element. `played` returns a `TimeRange`
   * object representing points in the media timeline that have been played.
   *
   * @method Html5#played
   * @return {TimeRange}
   *         The value of `played` from the media element. A `TimeRange` object indicating
   *         the ranges of time that have been played.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
   */
  "played",
  /**
   * Get the value of `networkState` from the media element. `networkState` indicates
   * the current network state. It returns an enumeration from the following list:
   * - 0: NETWORK_EMPTY
   * - 1: NETWORK_IDLE
   * - 2: NETWORK_LOADING
   * - 3: NETWORK_NO_SOURCE
   *
   * @method Html5#networkState
   * @return {number}
   *         The value of `networkState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
   */
  "networkState",
  /**
   * Get the value of `readyState` from the media element. `readyState` indicates
   * the current state of the media element. It returns an enumeration from the
   * following list:
   * - 0: HAVE_NOTHING
   * - 1: HAVE_METADATA
   * - 2: HAVE_CURRENT_DATA
   * - 3: HAVE_FUTURE_DATA
   * - 4: HAVE_ENOUGH_DATA
   *
   * @method Html5#readyState
   * @return {number}
   *         The value of `readyState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
   */
  "readyState",
  /**
   * Get the value of `videoWidth` from the video element. `videoWidth` indicates
   * the current width of the video in css pixels.
   *
   * @method Html5#videoWidth
   * @return {number}
   *         The value of `videoWidth` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoWidth",
  /**
   * Get the value of `videoHeight` from the video element. `videoHeight` indicates
   * the current height of the video in css pixels.
   *
   * @method Html5#videoHeight
   * @return {number}
   *         The value of `videoHeight` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoHeight",
  /**
   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#crossOrigin
   * @return {string}
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(e) {
  Oe.prototype[e] = function() {
    return this.el_[e];
  };
});
[
  /**
   * Set the value of `volume` on the media element. `volume` indicates the current
   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
   * so on.
   *
   * @method Html5#setVolume
   * @param {number} percentAsDecimal
   *        The volume percent as a decimal. Valid range is from 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Set the value of `src` on the media element. `src` indicates the current
   * {@link Tech~SourceObject} for the media.
   *
   * @method Html5#setSrc
   * @param {Tech~SourceObject} src
   *        The source object to set as the current source.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
   */
  "src",
  /**
   * Set the value of `poster` on the media element. `poster` is the url to
   * an image file that can/will be shown when no media data is available.
   *
   * @method Html5#setPoster
   * @param {string} poster
   *        The url to an image that should be used as the `poster` for the media
   *        element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
   */
  "poster",
  /**
   * Set the value of `preload` on the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#setPreload
   * @param {string} preload
   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Set the value of `playbackRate` on the media element. `playbackRate` indicates
   * the rate at which the media should play back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#setPlaybackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
   * the rate at which the media should play back upon initial startup. Changing this value
   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
   *
   * Example Values:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.setDefaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
   */
  "defaultPlaybackRate",
  /**
   * Prevents the browser from suggesting a Picture-in-Picture context menu
   * or to request Picture-in-Picture automatically in some cases.
   *
   * @method Html5#setDisablePictureInPicture
   * @param {boolean} value
   *         The true value will disable Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#setCrossOrigin
   * @param {string} crossOrigin
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(e) {
  Oe.prototype["set" + mr(e)] = function(t) {
    this.el_[e] = t;
  };
});
[
  /**
   * A wrapper around the media elements `pause` function. This will call the `HTML5`
   * media elements `pause` function.
   *
   * @method Html5#pause
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
   */
  "pause",
  /**
   * A wrapper around the media elements `load` function. This will call the `HTML5`s
   * media element `load` function.
   *
   * @method Html5#load
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
   */
  "load",
  /**
   * A wrapper around the media elements `play` function. This will call the `HTML5`s
   * media element `play` function.
   *
   * @method Html5#play
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
   */
  "play"
].forEach(function(e) {
  Oe.prototype[e] = function() {
    return this.el_[e]();
  };
});
jt.withSourceHandlers(Oe);
Oe.nativeSourceHandler = {};
Oe.nativeSourceHandler.canPlayType = function(e) {
  try {
    return Oe.TEST_VID.canPlayType(e);
  } catch {
    return "";
  }
};
Oe.nativeSourceHandler.canHandleSource = function(e, t) {
  if (e.type)
    return Oe.nativeSourceHandler.canPlayType(e.type);
  if (e.src) {
    var r = kp(e.src);
    return Oe.nativeSourceHandler.canPlayType("video/" + r);
  }
  return "";
};
Oe.nativeSourceHandler.handleSource = function(e, t, r) {
  t.setSrc(e.src);
};
Oe.nativeSourceHandler.dispose = function() {
};
Oe.registerSourceHandler(Oe.nativeSourceHandler);
jt.registerTech("Html5", Oe);
var D1 = [
  /**
   * Fired while the user agent is downloading media data.
   *
   * @event Player#progress
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `progress` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechProgress_
   * @fires Player#progress
   * @listens Tech#progress
   */
  "progress",
  /**
   * Fires when the loading of an audio/video is aborted.
   *
   * @event Player#abort
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `abort` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechAbort_
   * @fires Player#abort
   * @listens Tech#abort
   */
  "abort",
  /**
   * Fires when the browser is intentionally not getting media data.
   *
   * @event Player#suspend
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `suspend` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechSuspend_
   * @fires Player#suspend
   * @listens Tech#suspend
   */
  "suspend",
  /**
   * Fires when the current playlist is empty.
   *
   * @event Player#emptied
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `emptied` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechEmptied_
   * @fires Player#emptied
   * @listens Tech#emptied
   */
  "emptied",
  /**
   * Fires when the browser is trying to get media data, but data is not available.
   *
   * @event Player#stalled
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `stalled` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechStalled_
   * @fires Player#stalled
   * @listens Tech#stalled
   */
  "stalled",
  /**
   * Fires when the browser has loaded meta data for the audio/video.
   *
   * @event Player#loadedmetadata
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoadedmetadata_
   * @fires Player#loadedmetadata
   * @listens Tech#loadedmetadata
   */
  "loadedmetadata",
  /**
   * Fires when the browser has loaded the current frame of the audio/video.
   *
   * @event Player#loadeddata
   * @type {event}
   */
  /**
   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoaddeddata_
   * @fires Player#loadeddata
   * @listens Tech#loadeddata
   */
  "loadeddata",
  /**
   * Fires when the current playback position has changed.
   *
   * @event Player#timeupdate
   * @type {event}
   */
  /**
   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTimeUpdate_
   * @fires Player#timeupdate
   * @listens Tech#timeupdate
   */
  "timeupdate",
  /**
   * Fires when the video's intrinsic dimensions change
   *
   * @event Player#resize
   * @type {event}
   */
  /**
   * Retrigger the `resize` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechResize_
   * @fires Player#resize
   * @listens Tech#resize
   */
  "resize",
  /**
   * Fires when the volume has been changed
   *
   * @event Player#volumechange
   * @type {event}
   */
  /**
   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechVolumechange_
   * @fires Player#volumechange
   * @listens Tech#volumechange
   */
  "volumechange",
  /**
   * Fires when the text track has been changed
   *
   * @event Player#texttrackchange
   * @type {event}
   */
  /**
   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTexttrackchange_
   * @fires Player#texttrackchange
   * @listens Tech#texttrackchange
   */
  "texttrackchange"
], _f = {
  canplay: "CanPlay",
  canplaythrough: "CanPlayThrough",
  playing: "Playing",
  seeked: "Seeked"
}, cd = [
  "tiny",
  "xsmall",
  "small",
  "medium",
  "large",
  "xlarge",
  "huge"
], ic = {};
cd.forEach(function(e) {
  var t = e.charAt(0) === "x" ? "x-" + e.substring(1) : e;
  ic[e] = "vjs-layout-" + t;
});
var C3 = {
  huge: 1 / 0,
  large: 1440,
  medium: 768,
  small: 425,
  tiny: 210,
  xlarge: 2560,
  xsmall: 320
}, br = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a) {
    var s;
    if (n.id = n.id || i.id || "vjs_video_" + ta(), i = sr(t.getTagSettings(n), i), i.initChildren = !1, i.createEl = !1, i.evented = !1, i.reportTouchActivity = !1, !i.language)
      if (typeof n.closest == "function") {
        var o = n.closest("[lang]");
        o && o.getAttribute && (i.language = o.getAttribute("lang"));
      } else
        for (var u = n; u && u.nodeType === 1; ) {
          if (Ln(u).hasOwnProperty("lang")) {
            i.language = u.getAttribute("lang");
            break;
          }
          u = u.parentNode;
        }
    if (s = e.call(this, null, i, a) || this, s.boundDocumentFullscreenChange_ = function(f) {
      return s.documentFullscreenChange_(f);
    }, s.boundFullWindowOnEscKey_ = function(f) {
      return s.fullWindowOnEscKey(f);
    }, s.boundUpdateStyleEl_ = function(f) {
      return s.updateStyleEl_(f);
    }, s.boundApplyInitTime_ = function(f) {
      return s.applyInitTime_(f);
    }, s.boundUpdateCurrentBreakpoint_ = function(f) {
      return s.updateCurrentBreakpoint_(f);
    }, s.boundHandleTechClick_ = function(f) {
      return s.handleTechClick_(f);
    }, s.boundHandleTechDoubleClick_ = function(f) {
      return s.handleTechDoubleClick_(f);
    }, s.boundHandleTechTouchStart_ = function(f) {
      return s.handleTechTouchStart_(f);
    }, s.boundHandleTechTouchMove_ = function(f) {
      return s.handleTechTouchMove_(f);
    }, s.boundHandleTechTouchEnd_ = function(f) {
      return s.handleTechTouchEnd_(f);
    }, s.boundHandleTechTap_ = function(f) {
      return s.handleTechTap_(f);
    }, s.isFullscreen_ = !1, s.log = w_(s.id_), s.fsApi_ = Uc, s.isPosterFromTech_ = !1, s.queuedCallbacks_ = [], s.isReady_ = !1, s.hasStarted_ = !1, s.userActive_ = !1, s.debugEnabled_ = !1, s.audioOnlyMode_ = !1, s.audioPosterMode_ = !1, s.audioOnlyCache_ = {
      hiddenChildren: [],
      playerHeight: null
    }, !s.options_ || !s.options_.techOrder || !s.options_.techOrder.length)
      throw new Error(
        "No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?"
      );
    if (s.tag = n, s.tagAttributes = n && Ln(n), s.language(s.options_.language), i.languages) {
      var l = {};
      Object.getOwnPropertyNames(i.languages).forEach(function(f) {
        l[f.toLowerCase()] = i.languages[f];
      }), s.languages_ = l;
    } else
      s.languages_ = t.prototype.options_.languages;
    s.resetCache_(), s.poster_ = i.poster || "", s.controls_ = !!i.controls, n.controls = !1, n.removeAttribute("controls"), s.changingSrc_ = !1, s.playCallbacks_ = [], s.playTerminatedQueue_ = [], n.hasAttribute("autoplay") ? s.autoplay(!0) : s.autoplay(s.options_.autoplay), i.plugins && Object.keys(i.plugins).forEach(function(f) {
      if (typeof s[f] != "function")
        throw new Error('plugin "' + f + '" does not exist');
    }), s.scrubbing_ = !1, s.el_ = s.createEl(), Op(ze(s), {
      eventBusKey: "el_"
    }), s.fsApi_.requestFullscreen && (Pi(
      Te,
      s.fsApi_.fullscreenchange,
      s.boundDocumentFullscreenChange_
    ), s.on(
      s.fsApi_.fullscreenchange,
      s.boundDocumentFullscreenChange_
    )), s.fluid_ && s.on(["playerreset", "resize"], s.boundUpdateStyleEl_);
    var c = Kt(s.options_);
    i.plugins && Object.keys(i.plugins).forEach(function(f) {
      s[f](i.plugins[f]);
    }), i.debug && s.debug(!0), s.options_.playerOptions = c, s.middleware_ = [], s.playbackRates(i.playbackRates), s.initChildren(), s.isAudio(n.nodeName.toLowerCase() === "audio"), s.controls() ? s.addClass("vjs-controls-enabled") : s.addClass("vjs-controls-disabled"), s.el_.setAttribute("role", "region"), s.isAudio() ? s.el_.setAttribute("aria-label", s.localize("Audio Player")) : s.el_.setAttribute("aria-label", s.localize("Video Player")), s.isAudio() && s.addClass("vjs-audio"), s.flexNotSupported_() && s.addClass("vjs-no-flex"), So && s.addClass("vjs-touch-enabled"), ci || s.addClass("vjs-workinghover"), t.players[s.id_] = ze(s);
    var h = A_.split(".")[0];
    return s.addClass("vjs-v" + h), s.userActive(!0), s.reportUserActivity(), s.one("play", function(f) {
      return s.listenForUserActivity_(f);
    }), s.on("stageclick", function(f) {
      return s.handleStageClick_(f);
    }), s.on("keydown", function(f) {
      return s.handleKeyDown(f);
    }), s.on("languagechange", function(f) {
      return s.handleLanguagechange(f);
    }), s.breakpoints(s.options_.breakpoints), s.responsive(s.options_.responsive), s.on("ready", function() {
      s.audioPosterMode(s.options_.audioPosterMode), s.audioOnlyMode(s.options_.audioOnlyMode);
    }), s;
  }
  var r = t.prototype;
  return r.dispose = function() {
    var i = this;
    this.trigger("dispose"), this.off("dispose"), zr(
      Te,
      this.fsApi_.fullscreenchange,
      this.boundDocumentFullscreenChange_
    ), zr(Te, "keydown", this.boundFullWindowOnEscKey_), this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_), this.styleEl_ = null), t.players[this.id_] = null, this.tag && this.tag.player && (this.tag.player = null), this.el_ && this.el_.player && (this.el_.player = null), this.tech_ && (this.tech_.dispose(), this.isPosterFromTech_ = !1, this.poster_ = ""), this.playerElIngest_ && (this.playerElIngest_ = null), this.tag && (this.tag = null), XM(this), Zr.names.forEach(function(a) {
      var s = Zr[a], o = i[s.getterName]();
      o && o.off && o.off();
    }), e.prototype.dispose.call(this, {
      restoreEl: this.options_.restoreEl
    });
  }, r.createEl = function() {
    var i = this.tag, a, s = this.playerElIngest_ = i.parentNode && i.parentNode.hasAttribute && i.parentNode.hasAttribute("data-vjs-player"), o = this.tag.tagName.toLowerCase() === "video-js";
    s ? a = this.el_ = i.parentNode : o || (a = this.el_ = e.prototype.createEl.call(this, "div"));
    var u = Ln(i);
    if (o) {
      for (a = this.el_ = i, i = this.tag = Te.createElement("video"); a.children.length; )
        i.appendChild(a.firstChild);
      Ga(a, "video-js") || Gn(a, "video-js"), a.appendChild(i), s = this.playerElIngest_ = a, Object.keys(a).forEach(function(p) {
        try {
          i[p] = a[p];
        } catch {
        }
      });
    }
    if (i.setAttribute("tabindex", "-1"), u.tabindex = "-1", (Ml || ea && L_) && (i.setAttribute("role", "application"), u.role = "application"), i.removeAttribute("width"), i.removeAttribute("height"), "width" in u && delete u.width, "height" in u && delete u.height, Object.getOwnPropertyNames(u).forEach(function(p) {
      o && p === "class" || a.setAttribute(p, u[p]), o && i.setAttribute(p, u[p]);
    }), i.playerId = i.id, i.id += "_html5_api", i.className = "vjs-tech", i.player = a.player = this, this.addClass("vjs-paused"), j.VIDEOJS_NO_DYNAMIC_STYLE !== !0) {
      this.styleEl_ = q_("vjs-styles-dimensions");
      var l = ga(".vjs-styles-defaults"), c = ga("head");
      c.insertBefore(
        this.styleEl_,
        l ? l.nextSibling : c.firstChild
      );
    }
    this.fill_ = !1, this.fluid_ = !1, this.width(this.options_.width), this.height(this.options_.height), this.fill(this.options_.fill), this.fluid(this.options_.fluid), this.aspectRatio(this.options_.aspectRatio), this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
    for (var h = i.getElementsByTagName("a"), f = 0; f < h.length; f++) {
      var d = h.item(f);
      Gn(d, "vjs-hidden"), d.setAttribute("hidden", "hidden");
    }
    return i.initNetworkState_ = i.networkState, i.parentNode && !s && i.parentNode.insertBefore(a, i), rd(i, a), this.children_.unshift(i), this.el_.setAttribute("lang", this.language_), this.el_.setAttribute("translate", "no"), this.el_ = a, a;
  }, r.crossOrigin = function(i) {
    if (!i)
      return this.techGet_("crossOrigin");
    if (i !== "anonymous" && i !== "use-credentials") {
      vt.warn(
        'crossOrigin must be "anonymous" or "use-credentials", given "' + i + '"'
      );
      return;
    }
    this.techCall_("setCrossOrigin", i);
  }, r.width = function(i) {
    return this.dimension("width", i);
  }, r.height = function(i) {
    return this.dimension("height", i);
  }, r.dimension = function(i, a) {
    var s = i + "_";
    if (a === void 0)
      return this[s] || 0;
    if (a === "" || a === "auto") {
      this[s] = void 0, this.updateStyleEl_();
      return;
    }
    var o = parseFloat(a);
    if (isNaN(o)) {
      vt.error(
        'Improper value "' + a + '" supplied for for ' + i
      );
      return;
    }
    this[s] = o, this.updateStyleEl_();
  }, r.fluid = function(i) {
    var a = this;
    if (i === void 0)
      return !!this.fluid_;
    this.fluid_ = !!i, Vn(this) && this.off(["playerreset", "resize"], this.boundUpdateStyleEl_), i ? (this.addClass("vjs-fluid"), this.fill(!1), yM(this, function() {
      a.on(["playerreset", "resize"], a.boundUpdateStyleEl_);
    })) : this.removeClass("vjs-fluid"), this.updateStyleEl_();
  }, r.fill = function(i) {
    if (i === void 0)
      return !!this.fill_;
    this.fill_ = !!i, i ? (this.addClass("vjs-fill"), this.fluid(!1)) : this.removeClass("vjs-fill");
  }, r.aspectRatio = function(i) {
    if (i === void 0)
      return this.aspectRatio_;
    if (!/^\d+\:\d+$/.test(i))
      throw new Error(
        "Improper value supplied for aspect ratio. The format should be width:height, for example 16:9."
      );
    this.aspectRatio_ = i, this.fluid(!0), this.updateStyleEl_();
  }, r.updateStyleEl_ = function() {
    if (j.VIDEOJS_NO_DYNAMIC_STYLE === !0) {
      var i = typeof this.width_ == "number" ? this.width_ : this.options_.width, a = typeof this.height_ == "number" ? this.height_ : this.options_.height, s = this.tech_ && this.tech_.el();
      s && (i >= 0 && (s.width = i), a >= 0 && (s.height = a));
      return;
    }
    var o, u, l, c;
    this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto" ? l = this.aspectRatio_ : this.videoWidth() > 0 ? l = this.videoWidth() + ":" + this.videoHeight() : l = "16:9";
    var h = l.split(":"), f = h[1] / h[0];
    this.width_ !== void 0 ? o = this.width_ : this.height_ !== void 0 ? o = this.height_ / f : o = this.videoWidth() || 300, this.height_ !== void 0 ? u = this.height_ : u = o * f, /^[^a-zA-Z]/.test(this.id()) ? c = "dimensions-" + this.id() : c = this.id() + "-dimensions", this.addClass(c), X_(
      this.styleEl_,
      `
      .` + c + ` {
        width: ` + o + `px;
        height: ` + u + `px;
      }

      .` + c + `.vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: ` + f * 100 + `%;
      }
    `
    );
  }, r.loadTech_ = function(i, a) {
    var s = this;
    this.tech_ && this.unloadTech_();
    var o = mr(i), u = i.charAt(0).toLowerCase() + i.slice(1);
    o !== "Html5" && this.tag && (jt.getTech("Html5").disposeMediaElement(this.tag), this.tag.player = null, this.tag = null), this.techName_ = o, this.isReady_ = !1;
    var l = this.autoplay();
    (typeof this.autoplay() == "string" || this.autoplay() === !0 && this.options_.normalizeAutoplay) && (l = !1);
    var c = {
      autoplay: l,
      disablePictureInPicture: this.options_.disablePictureInPicture,
      language: this.language(),
      loop: this.options_.loop,
      muted: this.options_.muted,
      canOverridePoster: !!this.options_.techCanOverridePoster,
      nativeControlsForTouch: this.options_.nativeControlsForTouch,
      Promise: this.options_.Promise,
      playerId: this.id(),
      enableSourceset: this.options_.enableSourceset,
      source: a,
      playerElIngest: this.playerElIngest_ || !1,
      playsinline: this.options_.playsinline,
      poster: this.poster(),
      techId: this.id() + "_" + u + "_api",
      preload: this.options_.preload,
      "vtt.js": this.options_["vtt.js"]
    };
    Zr.names.forEach(function(f) {
      var d = Zr[f];
      c[d.getterName] = s[d.privateName];
    }), sr(c, this.options_[o]), sr(c, this.options_[u]), sr(c, this.options_[i.toLowerCase()]), this.tag && (c.tag = this.tag), a && a.src === this.cache_.src && this.cache_.currentTime > 0 && (c.startTime = this.cache_.currentTime);
    var h = jt.getTech(i);
    if (!h)
      throw new Error(
        "No Tech named '" + o + "' exists! '" + o + "' should be registered using videojs.registerTech()'"
      );
    this.tech_ = new h(c), this.tech_.ready($t(this, this.handleTechReady_), !0), Nv.jsonToTextTracks(this.textTracksJson_ || [], this.tech_), D1.forEach(function(f) {
      s.on(s.tech_, f, function(d) {
        return s["handleTech" + mr(f) + "_"](d);
      });
    }), Object.keys(_f).forEach(function(f) {
      s.on(s.tech_, f, function(d) {
        if (s.tech_.playbackRate() === 0 && s.tech_.seeking()) {
          s.queuedCallbacks_.push({
            callback: s["handleTech" + _f[f] + "_"].bind(
              s
            ),
            event: d
          });
          return;
        }
        s["handleTech" + _f[f] + "_"](d);
      });
    }), this.on(this.tech_, "loadstart", function(f) {
      return s.handleTechLoadStart_(f);
    }), this.on(this.tech_, "sourceset", function(f) {
      return s.handleTechSourceset_(f);
    }), this.on(this.tech_, "waiting", function(f) {
      return s.handleTechWaiting_(f);
    }), this.on(this.tech_, "ended", function(f) {
      return s.handleTechEnded_(f);
    }), this.on(this.tech_, "seeking", function(f) {
      return s.handleTechSeeking_(f);
    }), this.on(this.tech_, "play", function(f) {
      return s.handleTechPlay_(f);
    }), this.on(this.tech_, "firstplay", function(f) {
      return s.handleTechFirstPlay_(f);
    }), this.on(this.tech_, "pause", function(f) {
      return s.handleTechPause_(f);
    }), this.on(this.tech_, "durationchange", function(f) {
      return s.handleTechDurationChange_(f);
    }), this.on(this.tech_, "fullscreenchange", function(f, d) {
      return s.handleTechFullscreenChange_(f, d);
    }), this.on(this.tech_, "fullscreenerror", function(f, d) {
      return s.handleTechFullscreenError_(f, d);
    }), this.on(this.tech_, "enterpictureinpicture", function(f) {
      return s.handleTechEnterPictureInPicture_(f);
    }), this.on(this.tech_, "leavepictureinpicture", function(f) {
      return s.handleTechLeavePictureInPicture_(f);
    }), this.on(this.tech_, "error", function(f) {
      return s.handleTechError_(f);
    }), this.on(this.tech_, "posterchange", function(f) {
      return s.handleTechPosterChange_(f);
    }), this.on(this.tech_, "textdata", function(f) {
      return s.handleTechTextData_(f);
    }), this.on(this.tech_, "ratechange", function(f) {
      return s.handleTechRateChange_(f);
    }), this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_), this.usingNativeControls(this.techGet_("controls")), this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(), this.tech_.el().parentNode !== this.el() && (o !== "Html5" || !this.tag) && rd(this.tech_.el(), this.el()), this.tag && (this.tag.player = null, this.tag = null);
  }, r.unloadTech_ = function() {
    var i = this;
    Zr.names.forEach(function(a) {
      var s = Zr[a];
      i[s.privateName] = i[s.getterName]();
    }), this.textTracksJson_ = Nv.textTracksToJson(this.tech_), this.isReady_ = !1, this.tech_.dispose(), this.tech_ = !1, this.isPosterFromTech_ && (this.poster_ = "", this.trigger("posterchange")), this.isPosterFromTech_ = !1;
  }, r.tech = function(i) {
    return i === void 0 && vt.warn(
      `Using the tech directly can be dangerous. I hope you know what you're doing.
See https://github.com/videojs/video.js/issues/2617 for more info.
`
    ), this.tech_;
  }, r.addTechControlsListeners_ = function() {
    this.removeTechControlsListeners_(), this.on(this.tech_, "click", this.boundHandleTechClick_), this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_), this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.on(this.tech_, "tap", this.boundHandleTechTap_);
  }, r.removeTechControlsListeners_ = function() {
    this.off(this.tech_, "tap", this.boundHandleTechTap_), this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.off(this.tech_, "click", this.boundHandleTechClick_), this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
  }, r.handleTechReady_ = function() {
    this.triggerReady(), this.cache_.volume && this.techCall_("setVolume", this.cache_.volume), this.handleTechPosterChange_(), this.handleTechDurationChange_();
  }, r.handleTechLoadStart_ = function() {
    this.removeClass("vjs-ended"), this.removeClass("vjs-seeking"), this.error(null), this.handleTechDurationChange_(), this.paused() ? (this.hasStarted(!1), this.trigger("loadstart")) : (this.trigger("loadstart"), this.trigger("firstplay")), this.manualAutoplay_(
      this.autoplay() === !0 && this.options_.normalizeAutoplay ? "play" : this.autoplay()
    );
  }, r.manualAutoplay_ = function(i) {
    var a = this;
    if (!(!this.tech_ || typeof i != "string")) {
      var s = function() {
        var l = a.muted();
        a.muted(!0);
        var c = function() {
          a.muted(l);
        };
        a.playTerminatedQueue_.push(c);
        var h = a.play();
        if (hu(h))
          return h.catch(function(f) {
            throw c(), new Error(
              "Rejection at manualAutoplay. Restoring muted value. " + (f || "")
            );
          });
      }, o;
      if (i === "any" && !this.muted() ? (o = this.play(), hu(o) && (o = o.catch(s))) : i === "muted" && !this.muted() ? o = s() : o = this.play(), !!hu(o))
        return o.then(function() {
          a.trigger({
            autoplay: i,
            type: "autoplay-success"
          });
        }).catch(function() {
          a.trigger({
            autoplay: i,
            type: "autoplay-failure"
          });
        });
    }
  }, r.updateSourceCaches_ = function(i) {
    i === void 0 && (i = "");
    var a = i, s = "";
    typeof a != "string" && (a = i.src, s = i.type), this.cache_.source = this.cache_.source || {}, this.cache_.sources = this.cache_.sources || [], a && !s && (s = KM(this, a)), this.cache_.source = Kt({}, i, {
      src: a,
      type: s
    });
    for (var o = this.cache_.sources.filter(function(d) {
      return d.src && d.src === a;
    }), u = [], l = this.$$("source"), c = [], h = 0; h < l.length; h++) {
      var f = Ln(l[h]);
      u.push(f), f.src && f.src === a && c.push(f.src);
    }
    c.length && !o.length ? this.cache_.sources = u : o.length || (this.cache_.sources = [this.cache_.source]), this.cache_.src = a;
  }, r.handleTechSourceset_ = function(i) {
    var a = this;
    if (!this.changingSrc_) {
      var s = function(c) {
        return a.updateSourceCaches_(c);
      }, o = this.currentSource().src, u = i.src;
      o && !/^blob:/.test(o) && /^blob:/.test(u) && (!this.lastSource_ || this.lastSource_.tech !== u && this.lastSource_.player !== o) && (s = function() {
      }), s(u), i.src || this.tech_.any(["sourceset", "loadstart"], function(l) {
        if (l.type !== "sourceset") {
          var c = a.techGet("currentSrc");
          a.lastSource_.tech = c, a.updateSourceCaches_(c);
        }
      });
    }
    this.lastSource_ = {
      player: this.currentSource().src,
      tech: i.src
    }, this.trigger({
      src: i.src,
      type: "sourceset"
    });
  }, r.hasStarted = function(i) {
    if (i === void 0)
      return this.hasStarted_;
    i !== this.hasStarted_ && (this.hasStarted_ = i, this.hasStarted_ ? (this.addClass("vjs-has-started"), this.trigger("firstplay")) : this.removeClass("vjs-has-started"));
  }, r.handleTechPlay_ = function() {
    this.removeClass("vjs-ended"), this.removeClass("vjs-paused"), this.addClass("vjs-playing"), this.hasStarted(!0), this.trigger("play");
  }, r.handleTechRateChange_ = function() {
    this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0 && (this.queuedCallbacks_.forEach(function(i) {
      return i.callback(i.event);
    }), this.queuedCallbacks_ = []), this.cache_.lastPlaybackRate = this.tech_.playbackRate(), this.trigger("ratechange");
  }, r.handleTechWaiting_ = function() {
    var i = this;
    this.addClass("vjs-waiting"), this.trigger("waiting");
    var a = this.currentTime(), s = function o() {
      a !== i.currentTime() && (i.removeClass("vjs-waiting"), i.off("timeupdate", o));
    };
    this.on("timeupdate", s);
  }, r.handleTechCanPlay_ = function() {
    this.removeClass("vjs-waiting"), this.trigger("canplay");
  }, r.handleTechCanPlayThrough_ = function() {
    this.removeClass("vjs-waiting"), this.trigger("canplaythrough");
  }, r.handleTechPlaying_ = function() {
    this.removeClass("vjs-waiting"), this.trigger("playing");
  }, r.handleTechSeeking_ = function() {
    this.addClass("vjs-seeking"), this.trigger("seeking");
  }, r.handleTechSeeked_ = function() {
    this.removeClass("vjs-seeking"), this.removeClass("vjs-ended"), this.trigger("seeked");
  }, r.handleTechFirstPlay_ = function() {
    this.options_.starttime && (vt.warn(
      "Passing the `starttime` option to the player will be deprecated in 6.0"
    ), this.currentTime(this.options_.starttime)), this.addClass("vjs-has-started"), this.trigger("firstplay");
  }, r.handleTechPause_ = function() {
    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.trigger("pause");
  }, r.handleTechEnded_ = function() {
    this.addClass("vjs-ended"), this.removeClass("vjs-waiting"), this.options_.loop ? (this.currentTime(0), this.play()) : this.paused() || this.pause(), this.trigger("ended");
  }, r.handleTechDurationChange_ = function() {
    this.duration(this.techGet_("duration"));
  }, r.handleTechClick_ = function(i) {
    this.controls_ && (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click == "function" ? this.options_.userActions.click.call(this, i) : this.paused() ? fn(this.play()) : this.pause());
  }, r.handleTechDoubleClick_ = function(i) {
    if (this.controls_) {
      var a = Array.prototype.some.call(
        this.$$(".vjs-control-bar, .vjs-modal-dialog"),
        function(s) {
          return s.contains(i.target);
        }
      );
      a || (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick == "function" ? this.options_.userActions.doubleClick.call(this, i) : this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen());
    }
  }, r.handleTechTap_ = function() {
    this.userActive(!this.userActive());
  }, r.handleTechTouchStart_ = function() {
    this.userWasActive = this.userActive();
  }, r.handleTechTouchMove_ = function() {
    this.userWasActive && this.reportUserActivity();
  }, r.handleTechTouchEnd_ = function(i) {
    i.cancelable && i.preventDefault();
  }, r.handleStageClick_ = function() {
    this.reportUserActivity();
  }, r.toggleFullscreenClass_ = function() {
    this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen");
  }, r.documentFullscreenChange_ = function(i) {
    var a = i.target.player;
    if (!(a && a !== this)) {
      var s = this.el(), o = Te[this.fsApi_.fullscreenElement] === s;
      !o && s.matches ? o = s.matches(":" + this.fsApi_.fullscreen) : !o && s.msMatchesSelector && (o = s.msMatchesSelector(":" + this.fsApi_.fullscreen)), this.isFullscreen(o);
    }
  }, r.handleTechFullscreenChange_ = function(i, a) {
    var s = this;
    a && (a.nativeIOSFullscreen && (this.addClass("vjs-ios-native-fs"), this.tech_.one("webkitendfullscreen", function() {
      s.removeClass("vjs-ios-native-fs");
    })), this.isFullscreen(a.isFullscreen));
  }, r.handleTechFullscreenError_ = function(i, a) {
    this.trigger("fullscreenerror", a);
  }, r.togglePictureInPictureClass_ = function() {
    this.isInPictureInPicture() ? this.addClass("vjs-picture-in-picture") : this.removeClass("vjs-picture-in-picture");
  }, r.handleTechEnterPictureInPicture_ = function(i) {
    this.isInPictureInPicture(!0);
  }, r.handleTechLeavePictureInPicture_ = function(i) {
    this.isInPictureInPicture(!1);
  }, r.handleTechError_ = function() {
    var i = this.tech_.error();
    this.error(i);
  }, r.handleTechTextData_ = function() {
    var i = null;
    arguments.length > 1 && (i = arguments[1]), this.trigger("textdata", i);
  }, r.getCache = function() {
    return this.cache_;
  }, r.resetCache_ = function() {
    this.cache_ = {
      // Right now, the currentTime is not _really_ cached because it is always
      // retrieved from the tech (see: currentTime). However, for completeness,
      // we set it to zero here to ensure that if we do start actually caching
      // it, we reset it along with everything else.
      currentTime: 0,
      duration: NaN,
      inactivityTimeout: this.options_.inactivityTimeout,
      initTime: 0,
      lastPlaybackRate: this.defaultPlaybackRate(),
      lastVolume: 1,
      media: null,
      playbackRates: [],
      source: {},
      sources: [],
      src: "",
      volume: 1
    };
  }, r.techCall_ = function(i, a) {
    this.ready(function() {
      if (i in jM)
        return zM(this.middleware_, this.tech_, i, a);
      if (i in Wv)
        return zv(this.middleware_, this.tech_, i, a);
      try {
        this.tech_ && this.tech_[i](a);
      } catch (s) {
        throw vt(s), s;
      }
    }, !0);
  }, r.techGet_ = function(i) {
    if (!(!this.tech_ || !this.tech_.isReady_)) {
      if (i in WM)
        return HM(this.middleware_, this.tech_, i);
      if (i in Wv)
        return zv(this.middleware_, this.tech_, i);
      try {
        return this.tech_[i]();
      } catch (a) {
        throw this.tech_[i] === void 0 ? (vt(
          "Video.js: " + i + " method not defined for " + this.techName_ + " playback technology.",
          a
        ), a) : a.name === "TypeError" ? (vt(
          "Video.js: " + i + " unavailable on " + this.techName_ + " playback technology element.",
          a
        ), this.tech_.isReady_ = !1, a) : (vt(a), a);
      }
    }
  }, r.play = function() {
    var i = this, a = this.options_.Promise || j.Promise;
    return a ? new a(function(s) {
      i.play_(s);
    }) : this.play_();
  }, r.play_ = function(i) {
    var a = this;
    i === void 0 && (i = fn), this.playCallbacks_.push(i);
    var s = !!(!this.changingSrc_ && (this.src() || this.currentSrc())), o = !!(Mh || ci);
    if (this.waitToPlay_ && (this.off(["ready", "loadstart"], this.waitToPlay_), this.waitToPlay_ = null), !this.isReady_ || !s) {
      this.waitToPlay_ = function(c) {
        a.play_();
      }, this.one(["ready", "loadstart"], this.waitToPlay_), !s && o && this.load();
      return;
    }
    var u = this.techGet_("play"), l = o && this.hasClass("vjs-ended");
    l && this.resetProgressBar_(), u === null ? this.runPlayTerminatedQueue_() : this.runPlayCallbacks_(u);
  }, r.runPlayTerminatedQueue_ = function() {
    var i = this.playTerminatedQueue_.slice(0);
    this.playTerminatedQueue_ = [], i.forEach(function(a) {
      a();
    });
  }, r.runPlayCallbacks_ = function(i) {
    var a = this.playCallbacks_.slice(0);
    this.playCallbacks_ = [], this.playTerminatedQueue_ = [], a.forEach(function(s) {
      s(i);
    });
  }, r.pause = function() {
    this.techCall_("pause");
  }, r.paused = function() {
    return this.techGet_("paused") !== !1;
  }, r.played = function() {
    return this.techGet_("played") || Va(0, 0);
  }, r.scrubbing = function(i) {
    if (typeof i > "u")
      return this.scrubbing_;
    this.scrubbing_ = !!i, this.techCall_("setScrubbing", this.scrubbing_), i ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing");
  }, r.currentTime = function(i) {
    if (typeof i < "u") {
      if (i < 0 && (i = 0), !this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
        this.cache_.initTime = i, this.off("canplay", this.boundApplyInitTime_), this.one("canplay", this.boundApplyInitTime_);
        return;
      }
      this.techCall_("setCurrentTime", i), this.cache_.initTime = 0;
      return;
    }
    return this.cache_.currentTime = this.techGet_("currentTime") || 0, this.cache_.currentTime;
  }, r.applyInitTime_ = function() {
    this.currentTime(this.cache_.initTime);
  }, r.duration = function(i) {
    if (i === void 0)
      return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
    i = parseFloat(i), i < 0 && (i = 1 / 0), i !== this.cache_.duration && (this.cache_.duration = i, i === 1 / 0 ? this.addClass("vjs-live") : this.removeClass("vjs-live"), isNaN(i) || this.trigger("durationchange"));
  }, r.remainingTime = function() {
    return this.duration() - this.currentTime();
  }, r.remainingTimeDisplay = function() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  }, r.buffered = function() {
    var i = this.techGet_("buffered");
    return (!i || !i.length) && (i = Va(0, 0)), i;
  }, r.bufferedPercent = function() {
    return J_(this.buffered(), this.duration());
  }, r.bufferedEnd = function() {
    var i = this.buffered(), a = this.duration(), s = i.end(i.length - 1);
    return s > a && (s = a), s;
  }, r.volume = function(i) {
    var a;
    if (i !== void 0) {
      a = Math.max(0, Math.min(1, parseFloat(i))), this.cache_.volume = a, this.techCall_("setVolume", a), a > 0 && this.lastVolume_(a);
      return;
    }
    return a = parseFloat(this.techGet_("volume")), isNaN(a) ? 1 : a;
  }, r.muted = function(i) {
    if (i !== void 0) {
      this.techCall_("setMuted", i);
      return;
    }
    return this.techGet_("muted") || !1;
  }, r.defaultMuted = function(i) {
    return i !== void 0 ? this.techCall_("setDefaultMuted", i) : this.techGet_("defaultMuted") || !1;
  }, r.lastVolume_ = function(i) {
    if (i !== void 0 && i !== 0) {
      this.cache_.lastVolume = i;
      return;
    }
    return this.cache_.lastVolume;
  }, r.supportsFullScreen = function() {
    return this.techGet_("supportsFullScreen") || !1;
  }, r.isFullscreen = function(i) {
    if (i !== void 0) {
      var a = this.isFullscreen_;
      this.isFullscreen_ = !!i, this.isFullscreen_ !== a && this.fsApi_.prefixed && this.trigger("fullscreenchange"), this.toggleFullscreenClass_();
      return;
    }
    return this.isFullscreen_;
  }, r.requestFullscreen = function(i) {
    var a = this.options_.Promise || j.Promise;
    if (a) {
      var s = this;
      return new a(function(o, u) {
        function l() {
          s.off("fullscreenerror", h), s.off("fullscreenchange", c);
        }
        function c() {
          l(), o();
        }
        function h(d, p) {
          l(), u(p);
        }
        s.one("fullscreenchange", c), s.one("fullscreenerror", h);
        var f = s.requestFullscreenHelper_(i);
        f && (f.then(l, l), f.then(o, u));
      });
    }
    return this.requestFullscreenHelper_();
  }, r.requestFullscreenHelper_ = function(i) {
    var a = this, s;
    if (this.fsApi_.prefixed || (s = this.options_.fullscreen && this.options_.fullscreen.options || {}, i !== void 0 && (s = i)), this.fsApi_.requestFullscreen) {
      var o = this.el_[this.fsApi_.requestFullscreen](s);
      return o && o.then(
        function() {
          return a.isFullscreen(!0);
        },
        function() {
          return a.isFullscreen(!1);
        }
      ), o;
    } else this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("enterFullScreen") : this.enterFullWindow();
  }, r.exitFullscreen = function() {
    var i = this.options_.Promise || j.Promise;
    if (i) {
      var a = this;
      return new i(function(s, o) {
        function u() {
          a.off("fullscreenerror", c), a.off("fullscreenchange", l);
        }
        function l() {
          u(), s();
        }
        function c(f, d) {
          u(), o(d);
        }
        a.one("fullscreenchange", l), a.one("fullscreenerror", c);
        var h = a.exitFullscreenHelper_();
        h && (h.then(u, u), h.then(s, o));
      });
    }
    return this.exitFullscreenHelper_();
  }, r.exitFullscreenHelper_ = function() {
    var i = this;
    if (this.fsApi_.requestFullscreen) {
      var a = Te[this.fsApi_.exitFullscreen]();
      return a && fn(
        a.then(function() {
          return i.isFullscreen(!1);
        })
      ), a;
    } else this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("exitFullScreen") : this.exitFullWindow();
  }, r.enterFullWindow = function() {
    this.isFullscreen(!0), this.isFullWindow = !0, this.docOrigOverflow = Te.documentElement.style.overflow, Pi(Te, "keydown", this.boundFullWindowOnEscKey_), Te.documentElement.style.overflow = "hidden", Gn(Te.body, "vjs-full-window"), this.trigger("enterFullWindow");
  }, r.fullWindowOnEscKey = function(i) {
    lt.isEventKey(i, "Esc") && this.isFullscreen() === !0 && (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen());
  }, r.exitFullWindow = function() {
    this.isFullscreen(!1), this.isFullWindow = !1, zr(Te, "keydown", this.boundFullWindowOnEscKey_), Te.documentElement.style.overflow = this.docOrigOverflow, Dl(Te.body, "vjs-full-window"), this.trigger("exitFullWindow");
  }, r.disablePictureInPicture = function(i) {
    if (i === void 0)
      return this.techGet_("disablePictureInPicture");
    this.techCall_("setDisablePictureInPicture", i), this.options_.disablePictureInPicture = i, this.trigger("disablepictureinpicturechanged");
  }, r.isInPictureInPicture = function(i) {
    if (i !== void 0) {
      this.isInPictureInPicture_ = !!i, this.togglePictureInPictureClass_();
      return;
    }
    return !!this.isInPictureInPicture_;
  }, r.requestPictureInPicture = function() {
    if ("pictureInPictureEnabled" in Te && this.disablePictureInPicture() === !1)
      return this.techGet_("requestPictureInPicture");
  }, r.exitPictureInPicture = function() {
    if ("pictureInPictureEnabled" in Te)
      return Te.exitPictureInPicture();
  }, r.handleKeyDown = function(i) {
    var a = this.options_.userActions;
    if (!(!a || !a.hotkeys)) {
      var s = function(u) {
        var l = u.tagName.toLowerCase();
        if (u.isContentEditable)
          return !0;
        var c = [
          "button",
          "checkbox",
          "hidden",
          "radio",
          "reset",
          "submit"
        ];
        if (l === "input")
          return c.indexOf(u.type) === -1;
        var h = ["textarea"];
        return h.indexOf(l) !== -1;
      };
      s(this.el_.ownerDocument.activeElement) || (typeof a.hotkeys == "function" ? a.hotkeys.call(this, i) : this.handleHotkeys(i));
    }
  }, r.handleHotkeys = function(i) {
    var a = this.options_.userActions ? this.options_.userActions.hotkeys : {}, s = a.fullscreenKey, o = s === void 0 ? function(_) {
      return lt.isEventKey(_, "f");
    } : s, u = a.muteKey, l = u === void 0 ? function(_) {
      return lt.isEventKey(_, "m");
    } : u, c = a.playPauseKey, h = c === void 0 ? function(_) {
      return lt.isEventKey(_, "k") || lt.isEventKey(_, "Space");
    } : c;
    if (o.call(this, i)) {
      i.preventDefault(), i.stopPropagation();
      var f = ye.getComponent("FullscreenToggle");
      Te[this.fsApi_.fullscreenEnabled] !== !1 && f.prototype.handleClick.call(this, i);
    } else if (l.call(this, i)) {
      i.preventDefault(), i.stopPropagation();
      var d = ye.getComponent("MuteToggle");
      d.prototype.handleClick.call(this, i);
    } else if (h.call(this, i)) {
      i.preventDefault(), i.stopPropagation();
      var p = ye.getComponent("PlayToggle");
      p.prototype.handleClick.call(this, i);
    }
  }, r.canPlayType = function(i) {
    for (var a, s = 0, o = this.options_.techOrder; s < o.length; s++) {
      var u = o[s], l = jt.getTech(u);
      if (l || (l = ye.getComponent(u)), !l) {
        vt.error(
          'The "' + u + '" tech is undefined. Skipped browser support check for that tech.'
        );
        continue;
      }
      if (l.isSupported() && (a = l.canPlayType(i), a))
        return a;
    }
    return "";
  }, r.selectSource = function(i) {
    var a = this, s = this.options_.techOrder.map(function(h) {
      return [h, jt.getTech(h)];
    }).filter(function(h) {
      var f = h[0], d = h[1];
      return d ? d.isSupported() : (vt.error(
        'The "' + f + '" tech is undefined. Skipped browser support check for that tech.'
      ), !1);
    }), o = function(f, d, p) {
      var _;
      return f.some(function(v) {
        return d.some(function(x) {
          if (_ = p(v, x), _)
            return !0;
        });
      }), _;
    }, u, l = function(f) {
      return function(d, p) {
        return f(p, d);
      };
    }, c = function(f, d) {
      var p = f[0], _ = f[1];
      if (_.canPlaySource(d, a.options_[p.toLowerCase()]))
        return {
          source: d,
          tech: p
        };
    };
    return this.options_.sourceOrder ? u = o(
      i,
      s,
      l(c)
    ) : u = o(
      s,
      i,
      c
    ), u || !1;
  }, r.handleSrc_ = function(i, a) {
    var s = this;
    if (typeof i > "u")
      return this.cache_.src || "";
    this.resetRetryOnError_ && this.resetRetryOnError_();
    var o = $M(i);
    if (!o.length) {
      this.setTimeout(function() {
        this.error({
          code: 4,
          message: this.options_.notSupportedMessage
        });
      }, 0);
      return;
    }
    if (this.changingSrc_ = !0, a || (this.cache_.sources = o), this.updateSourceCaches_(o[0]), GM(this, o[0], function(c, h) {
      s.middleware_ = h, a || (s.cache_.sources = o), s.updateSourceCaches_(c);
      var f = s.src_(c);
      if (f) {
        if (o.length > 1)
          return s.handleSrc_(o.slice(1));
        s.changingSrc_ = !1, s.setTimeout(function() {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0), s.triggerReady();
        return;
      }
      VM(h, s.tech_);
    }), this.options_.retryOnError && o.length > 1) {
      var u = function() {
        s.error(null), s.handleSrc_(o.slice(1), !0);
      }, l = function() {
        s.off("error", u);
      };
      this.one("error", u), this.one("playing", l), this.resetRetryOnError_ = function() {
        s.off("error", u), s.off("playing", l);
      };
    }
  }, r.src = function(i) {
    return this.handleSrc_(i, !1);
  }, r.src_ = function(i) {
    var a = this, s = this.selectSource([i]);
    return s ? xM(s.tech, this.techName_) ? (this.ready(function() {
      this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", i) : this.techCall_("src", i.src), this.changingSrc_ = !1;
    }, !0), !1) : (this.changingSrc_ = !0, this.loadTech_(s.tech, s.source), this.tech_.ready(function() {
      a.changingSrc_ = !1;
    }), !1) : !0;
  }, r.load = function() {
    this.techCall_("load");
  }, r.reset = function() {
    var i = this, a = this.options_.Promise || j.Promise;
    if (this.paused() || !a)
      this.doReset_();
    else {
      var s = this.play();
      fn(
        s.then(function() {
          return i.doReset_();
        })
      );
    }
  }, r.doReset_ = function() {
    this.tech_ && this.tech_.clearTracks("text"), this.resetCache_(), this.poster(""), this.loadTech_(this.options_.techOrder[0], null), this.techCall_("reset"), this.resetControlBarUI_(), Vn(this) && this.trigger("playerreset");
  }, r.resetControlBarUI_ = function() {
    this.resetProgressBar_(), this.resetPlaybackRate_(), this.resetVolumeBar_();
  }, r.resetProgressBar_ = function() {
    this.currentTime(0);
    var i = this.controlBar || {}, a = i.durationDisplay, s = i.remainingTimeDisplay;
    a && a.updateContent(), s && s.updateContent();
  }, r.resetPlaybackRate_ = function() {
    this.playbackRate(this.defaultPlaybackRate()), this.handleTechRateChange_();
  }, r.resetVolumeBar_ = function() {
    this.volume(1), this.trigger("volumechange");
  }, r.currentSources = function() {
    var i = this.currentSource(), a = [];
    return Object.keys(i).length !== 0 && a.push(i), this.cache_.sources || a;
  }, r.currentSource = function() {
    return this.cache_.source || {};
  }, r.currentSrc = function() {
    return this.currentSource() && this.currentSource().src || "";
  }, r.currentType = function() {
    return this.currentSource() && this.currentSource().type || "";
  }, r.preload = function(i) {
    if (i !== void 0) {
      this.techCall_("setPreload", i), this.options_.preload = i;
      return;
    }
    return this.techGet_("preload");
  }, r.autoplay = function(i) {
    if (i === void 0)
      return this.options_.autoplay || !1;
    var a;
    typeof i == "string" && /(any|play|muted)/.test(i) || i === !0 && this.options_.normalizeAutoplay ? (this.options_.autoplay = i, this.manualAutoplay_(typeof i == "string" ? i : "play"), a = !1) : i ? this.options_.autoplay = !0 : this.options_.autoplay = !1, a = typeof a > "u" ? this.options_.autoplay : a, this.tech_ && this.techCall_("setAutoplay", a);
  }, r.playsinline = function(i) {
    return i !== void 0 ? (this.techCall_("setPlaysinline", i), this.options_.playsinline = i, this) : this.techGet_("playsinline");
  }, r.loop = function(i) {
    if (i !== void 0) {
      this.techCall_("setLoop", i), this.options_.loop = i;
      return;
    }
    return this.techGet_("loop");
  }, r.poster = function(i) {
    if (i === void 0)
      return this.poster_;
    i || (i = ""), i !== this.poster_ && (this.poster_ = i, this.techCall_("setPoster", i), this.isPosterFromTech_ = !1, this.trigger("posterchange"));
  }, r.handleTechPosterChange_ = function() {
    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
      var i = this.tech_.poster() || "";
      i !== this.poster_ && (this.poster_ = i, this.isPosterFromTech_ = !0, this.trigger("posterchange"));
    }
  }, r.controls = function(i) {
    if (i === void 0)
      return !!this.controls_;
    i = !!i, this.controls_ !== i && (this.controls_ = i, this.usingNativeControls() && this.techCall_("setControls", i), this.controls_ ? (this.removeClass("vjs-controls-disabled"), this.addClass("vjs-controls-enabled"), this.trigger("controlsenabled"), this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"), this.addClass("vjs-controls-disabled"), this.trigger("controlsdisabled"), this.usingNativeControls() || this.removeTechControlsListeners_()));
  }, r.usingNativeControls = function(i) {
    if (i === void 0)
      return !!this.usingNativeControls_;
    i = !!i, this.usingNativeControls_ !== i && (this.usingNativeControls_ = i, this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"), this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"), this.trigger("usingcustomcontrols")));
  }, r.error = function(i) {
    var a = this;
    if (i === void 0)
      return this.error_ || null;
    if (va("beforeerror").forEach(function(o) {
      var u = o(a, i);
      if (!(Xn(u) && !Array.isArray(u) || typeof u == "string" || typeof u == "number" || u === null)) {
        a.log.error(
          "please return a value that MediaError expects in beforeerror hooks"
        );
        return;
      }
      i = u;
    }), this.options_.suppressNotSupportedError && i && i.code === 4) {
      var s = function() {
        this.error(i);
      };
      this.options_.suppressNotSupportedError = !1, this.any(["click", "touchstart"], s), this.one("loadstart", function() {
        this.off(["click", "touchstart"], s);
      });
      return;
    }
    if (i === null) {
      this.error_ = i, this.removeClass("vjs-error"), this.errorDisplay && this.errorDisplay.close();
      return;
    }
    this.error_ = new ii(i), this.addClass("vjs-error"), vt.error(
      "(CODE:" + this.error_.code + " " + ii.errorTypes[this.error_.code] + ")",
      this.error_.message,
      this.error_
    ), this.trigger("error"), va("error").forEach(function(o) {
      return o(a, a.error_);
    });
  }, r.reportUserActivity = function(i) {
    this.userActivity_ = !0;
  }, r.userActive = function(i) {
    if (i === void 0)
      return this.userActive_;
    if (i = !!i, i !== this.userActive_) {
      if (this.userActive_ = i, this.userActive_) {
        this.userActivity_ = !0, this.removeClass("vjs-user-inactive"), this.addClass("vjs-user-active"), this.trigger("useractive");
        return;
      }
      this.tech_ && this.tech_.one("mousemove", function(a) {
        a.stopPropagation(), a.preventDefault();
      }), this.userActivity_ = !1, this.removeClass("vjs-user-active"), this.addClass("vjs-user-inactive"), this.trigger("userinactive");
    }
  }, r.listenForUserActivity_ = function() {
    var i, a, s, o = $t(this, this.reportUserActivity), u = function(p) {
      (p.screenX !== a || p.screenY !== s) && (a = p.screenX, s = p.screenY, o());
    }, l = function() {
      o(), this.clearInterval(i), i = this.setInterval(o, 250);
    }, c = function(p) {
      o(), this.clearInterval(i);
    };
    this.on("mousedown", l), this.on("mousemove", u), this.on("mouseup", c), this.on("mouseleave", c);
    var h = this.getChild("controlBar");
    h && !ci && !Jn && (h.on("mouseenter", function(d) {
      this.player().options_.inactivityTimeout !== 0 && (this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout), this.player().options_.inactivityTimeout = 0;
    }), h.on("mouseleave", function(d) {
      this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
    })), this.on("keydown", o), this.on("keyup", o);
    var f;
    this.setInterval(function() {
      if (this.userActivity_) {
        this.userActivity_ = !1, this.userActive(!0), this.clearTimeout(f);
        var d = this.options_.inactivityTimeout;
        d <= 0 || (f = this.setTimeout(function() {
          this.userActivity_ || this.userActive(!1);
        }, d));
      }
    }, 250);
  }, r.playbackRate = function(i) {
    if (i !== void 0) {
      this.techCall_("setPlaybackRate", i);
      return;
    }
    return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1;
  }, r.defaultPlaybackRate = function(i) {
    return i !== void 0 ? this.techCall_("setDefaultPlaybackRate", i) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1;
  }, r.isAudio = function(i) {
    if (i !== void 0) {
      this.isAudio_ = !!i;
      return;
    }
    return !!this.isAudio_;
  }, r.enableAudioOnlyUI_ = function() {
    var i = this;
    this.addClass("vjs-audio-only-mode");
    var a = this.children(), s = this.getChild("ControlBar"), o = s && s.currentHeight();
    a.forEach(function(u) {
      u !== s && u.el_ && !u.hasClass("vjs-hidden") && (u.hide(), i.audioOnlyCache_.hiddenChildren.push(u));
    }), this.audioOnlyCache_.playerHeight = this.currentHeight(), this.height(o), this.trigger("audioonlymodechange");
  }, r.disableAudioOnlyUI_ = function() {
    this.removeClass("vjs-audio-only-mode"), this.audioOnlyCache_.hiddenChildren.forEach(function(i) {
      return i.show();
    }), this.height(this.audioOnlyCache_.playerHeight), this.trigger("audioonlymodechange");
  }, r.audioOnlyMode = function(i) {
    var a = this;
    if (typeof i != "boolean" || i === this.audioOnlyMode_)
      return this.audioOnlyMode_;
    this.audioOnlyMode_ = i;
    var s = this.options_.Promise || j.Promise;
    if (s) {
      if (i) {
        var o = [];
        return this.isInPictureInPicture() && o.push(this.exitPictureInPicture()), this.isFullscreen() && o.push(this.exitFullscreen()), this.audioPosterMode() && o.push(this.audioPosterMode(!1)), s.all(o).then(function() {
          return a.enableAudioOnlyUI_();
        });
      }
      return s.resolve().then(function() {
        return a.disableAudioOnlyUI_();
      });
    }
    i ? (this.isInPictureInPicture() && this.exitPictureInPicture(), this.isFullscreen() && this.exitFullscreen(), this.enableAudioOnlyUI_()) : this.disableAudioOnlyUI_();
  }, r.enablePosterModeUI_ = function() {
    var i = this.tech_ && this.tech_;
    i.hide(), this.addClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange");
  }, r.disablePosterModeUI_ = function() {
    var i = this.tech_ && this.tech_;
    i.show(), this.removeClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange");
  }, r.audioPosterMode = function(i) {
    var a = this;
    if (typeof i != "boolean" || i === this.audioPosterMode_)
      return this.audioPosterMode_;
    this.audioPosterMode_ = i;
    var s = this.options_.Promise || j.Promise;
    if (s) {
      if (i) {
        if (this.audioOnlyMode()) {
          var o = this.audioOnlyMode(!1);
          return o.then(function() {
            a.enablePosterModeUI_();
          });
        }
        return s.resolve().then(function() {
          a.enablePosterModeUI_();
        });
      }
      return s.resolve().then(function() {
        a.disablePosterModeUI_();
      });
    }
    if (i) {
      this.audioOnlyMode() && this.audioOnlyMode(!1), this.enablePosterModeUI_();
      return;
    }
    this.disablePosterModeUI_();
  }, r.addTextTrack = function(i, a, s) {
    if (this.tech_)
      return this.tech_.addTextTrack(i, a, s);
  }, r.addRemoteTextTrack = function(i, a) {
    if (this.tech_)
      return this.tech_.addRemoteTextTrack(i, a);
  }, r.removeRemoteTextTrack = function(i) {
    i === void 0 && (i = {});
    var a = i, s = a.track;
    if (s || (s = i), this.tech_)
      return this.tech_.removeRemoteTextTrack(s);
  }, r.getVideoPlaybackQuality = function() {
    return this.techGet_("getVideoPlaybackQuality");
  }, r.videoWidth = function() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  }, r.videoHeight = function() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  }, r.language = function(i) {
    if (i === void 0)
      return this.language_;
    this.language_ !== String(i).toLowerCase() && (this.language_ = String(i).toLowerCase(), Vn(this) && this.trigger("languagechange"));
  }, r.languages = function() {
    return Kt(t.prototype.options_.languages, this.languages_);
  }, r.toJSON = function() {
    var i = Kt(this.options_), a = i.tracks;
    i.tracks = [];
    for (var s = 0; s < a.length; s++) {
      var o = a[s];
      o = Kt(o), o.player = void 0, i.tracks[s] = o;
    }
    return i;
  }, r.createModal = function(i, a) {
    var s = this;
    a = a || {}, a.content = i || "";
    var o = new No(this, a);
    return this.addChild(o), o.on("dispose", function() {
      s.removeChild(o);
    }), o.open(), o;
  }, r.updateCurrentBreakpoint_ = function() {
    if (this.responsive())
      for (var i = this.currentBreakpoint(), a = this.currentWidth(), s = 0; s < cd.length; s++) {
        var o = cd[s], u = this.breakpoints_[o];
        if (a <= u) {
          if (i === o)
            return;
          i && this.removeClass(ic[i]), this.addClass(ic[o]), this.breakpoint_ = o;
          break;
        }
      }
  }, r.removeCurrentBreakpoint_ = function() {
    var i = this.currentBreakpointClass();
    this.breakpoint_ = "", i && this.removeClass(i);
  }, r.breakpoints = function(i) {
    return i === void 0 ? sr(this.breakpoints_) : (this.breakpoint_ = "", this.breakpoints_ = sr({}, C3, i), this.updateCurrentBreakpoint_(), sr(this.breakpoints_));
  }, r.responsive = function(i) {
    if (i === void 0)
      return this.responsive_;
    i = !!i;
    var a = this.responsive_;
    if (i !== a)
      return this.responsive_ = i, i ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_), this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_), this.removeCurrentBreakpoint_()), i;
  }, r.currentBreakpoint = function() {
    return this.breakpoint_;
  }, r.currentBreakpointClass = function() {
    return ic[this.breakpoint_] || "";
  }, r.loadMedia = function(i, a) {
    var s = this;
    if (!(!i || typeof i != "object")) {
      this.reset(), this.cache_.media = Kt(i);
      var o = this.cache_.media, u = o.artwork, l = o.poster, c = o.src, h = o.textTracks;
      !u && l && (this.cache_.media.artwork = [
        {
          src: l,
          type: Hc(l)
        }
      ]), c && this.src(c), l && this.poster(l), Array.isArray(h) && h.forEach(function(f) {
        return s.addRemoteTextTrack(f, !1);
      }), this.ready(a);
    }
  }, r.getMedia = function() {
    if (!this.cache_.media) {
      var i = this.poster(), a = this.currentSources(), s = Array.prototype.map.call(
        this.remoteTextTracks(),
        function(u) {
          return {
            kind: u.kind,
            label: u.label,
            language: u.language,
            src: u.src
          };
        }
      ), o = {
        src: a,
        textTracks: s
      };
      return i && (o.poster = i, o.artwork = [
        {
          src: o.poster,
          type: Hc(o.poster)
        }
      ]), o;
    }
    return Kt(this.cache_.media);
  }, t.getTagSettings = function(i) {
    var a = {
      sources: [],
      tracks: []
    }, s = Ln(i), o = s["data-setup"];
    if (Ga(i, "vjs-fill") && (s.fill = !0), Ga(i, "vjs-fluid") && (s.fluid = !0), o !== null) {
      var u = PC(o || "{}"), l = u[0], c = u[1];
      l && vt.error(l), sr(s, c);
    }
    if (sr(a, s), i.hasChildNodes())
      for (var h = i.childNodes, f = 0, d = h.length; f < d; f++) {
        var p = h[f], _ = p.nodeName.toLowerCase();
        _ === "source" ? a.sources.push(Ln(p)) : _ === "track" && a.tracks.push(Ln(p));
      }
    return a;
  }, r.flexNotSupported_ = function() {
    var i = Te.createElement("i");
    return !("flexBasis" in i.style || "webkitFlexBasis" in i.style || "mozFlexBasis" in i.style || "msFlexBasis" in i.style || // IE10-specific (2012 flex spec), available for completeness
    "msFlexOrder" in i.style);
  }, r.debug = function(i) {
    if (i === void 0)
      return this.debugEnabled_;
    i ? (this.trigger("debugon"), this.previousLogLevel_ = this.log.level, this.log.level("debug"), this.debugEnabled_ = !0) : (this.trigger("debugoff"), this.log.level(this.previousLogLevel_), this.previousLogLevel_ = void 0, this.debugEnabled_ = !1);
  }, r.playbackRates = function(i) {
    if (i === void 0)
      return this.cache_.playbackRates;
    Array.isArray(i) && i.every(function(a) {
      return typeof a == "number";
    }) && (this.cache_.playbackRates = i, this.trigger("playbackrateschange"));
  }, t;
}(ye);
Zr.names.forEach(function(e) {
  var t = Zr[e];
  br.prototype[t.getterName] = function() {
    return this.tech_ ? this.tech_[t.getterName]() : (this[t.privateName] = this[t.privateName] || new t.ListClass(), this[t.privateName]);
  };
});
br.prototype.crossorigin = br.prototype.crossOrigin;
br.players = {};
var Zo = j.navigator;
br.prototype.options_ = {
  // Included control sets
  children: [
    "mediaLoader",
    "posterImage",
    "textTrackDisplay",
    "loadingSpinner",
    "bigPlayButton",
    "liveTracker",
    "controlBar",
    "errorDisplay",
    "textTrackSettings",
    "resizeManager"
  ],
  html5: {},
  // default inactivity timeout
  inactivityTimeout: 2e3,
  language: Zo && (Zo.languages && Zo.languages[0] || Zo.userLanguage || Zo.language) || "en",
  // locales and their language translations
  languages: {},
  breakpoints: {},
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],
  liveui: !1,
  audioOnlyMode: !1,
  audioPosterMode: !1,
  // Default order of fallback technology
  techOrder: jt.defaultTechOrder_,
  fullscreen: {
    options: {
      navigationUI: "hide"
    }
  },
  normalizeAutoplay: !1,
  // Default message to show when a video cannot be played.
  notSupportedMessage: "No compatible source was found for this media.",
  // default playback rates
  playbackRates: [],
  responsive: !1
};
[
  /**
   * Returns whether or not the player is in the "ended" state.
   *
   * @return {Boolean} True if the player is in the ended state, false if not.
   * @method Player#ended
   */
  "ended",
  /**
   * Returns whether or not the player is in the "seeking" state.
   *
   * @return {Boolean} True if the player is in the seeking state, false if not.
   * @method Player#seeking
   */
  "seeking",
  /**
   * Returns the TimeRanges of the media that are currently available
   * for seeking to.
   *
   * @return {TimeRanges} the seekable intervals of the media timeline
   * @method Player#seekable
   */
  "seekable",
  /**
   * Returns the current state of network activity for the element, from
   * the codes in the list below.
   * - NETWORK_EMPTY (numeric value 0)
   *   The element has not yet been initialised. All attributes are in
   *   their initial states.
   * - NETWORK_IDLE (numeric value 1)
   *   The element's resource selection algorithm is active and has
   *   selected a resource, but it is not actually using the network at
   *   this time.
   * - NETWORK_LOADING (numeric value 2)
   *   The user agent is actively trying to download data.
   * - NETWORK_NO_SOURCE (numeric value 3)
   *   The element's resource selection algorithm is active, but it has
   *   not yet found a resource to use.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
   * @return {number} the current network activity state
   * @method Player#networkState
   */
  "networkState",
  /**
   * Returns a value that expresses the current state of the element
   * with respect to rendering the current playback position, from the
   * codes in the list below.
   * - HAVE_NOTHING (numeric value 0)
   *   No information regarding the media resource is available.
   * - HAVE_METADATA (numeric value 1)
   *   Enough of the resource has been obtained that the duration of the
   *   resource is available.
   * - HAVE_CURRENT_DATA (numeric value 2)
   *   Data for the immediate current playback position is available.
   * - HAVE_FUTURE_DATA (numeric value 3)
   *   Data for the immediate current playback position is available, as
   *   well as enough data for the user agent to advance the current
   *   playback position in the direction of playback.
   * - HAVE_ENOUGH_DATA (numeric value 4)
   *   The user agent estimates that enough data is available for
   *   playback to proceed uninterrupted.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
   * @return {number} the current playback rendering state
   * @method Player#readyState
   */
  "readyState"
].forEach(function(e) {
  br.prototype[e] = function() {
    return this.techGet_(e);
  };
});
D1.forEach(function(e) {
  br.prototype["handleTech" + mr(e) + "_"] = function() {
    return this.trigger(e);
  };
});
ye.registerComponent("Player", br);
var jc = "plugin", Fs = "activePlugins_", Ls = {}, qc = function(t) {
  return Ls.hasOwnProperty(t);
}, nc = function(t) {
  return qc(t) ? Ls[t] : void 0;
}, P1 = function(t, r) {
  t[Fs] = t[Fs] || {}, t[Fs][r] = !0;
}, Xc = function(t, r, n) {
  var i = (n ? "before" : "") + "pluginsetup";
  t.trigger(i, r), t.trigger(i + ":" + r.name, r);
}, M3 = function(t, r) {
  var n = function() {
    Xc(
      this,
      {
        instance: null,
        name: t,
        plugin: r
      },
      !0
    );
    var a = r.apply(this, arguments);
    return P1(this, t), Xc(this, {
      instance: a,
      name: t,
      plugin: r
    }), a;
  };
  return Object.keys(r).forEach(function(i) {
    n[i] = r[i];
  }), n;
}, ng = function(t, r) {
  return r.prototype.name = t, function() {
    Xc(
      this,
      {
        instance: null,
        name: t,
        plugin: r
      },
      !0
    );
    for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
      i[a] = arguments[a];
    var s = xy(r, [this].concat(i));
    return this[t] = function() {
      return s;
    }, Xc(this, s.getEventHash()), s;
  };
}, En = /* @__PURE__ */ function() {
  function e(r) {
    if (this.constructor === e)
      throw new Error("Plugin must be sub-classed; not directly instantiated.");
    this.player = r, this.log || (this.log = this.player.log.createLogger(this.name)), Op(this), delete this.trigger, Z_(this, this.constructor.defaultState), P1(r, this.name), this.dispose = this.dispose.bind(this), r.on("dispose", this.dispose);
  }
  var t = e.prototype;
  return t.version = function() {
    return this.constructor.VERSION;
  }, t.getEventHash = function(n) {
    return n === void 0 && (n = {}), n.name = this.name, n.plugin = this.constructor, n.instance = this, n;
  }, t.trigger = function(n, i) {
    return i === void 0 && (i = {}), ko(this.eventBusEl_, n, this.getEventHash(i));
  }, t.handleStateChanged = function(n) {
  }, t.dispose = function() {
    var n = this.name, i = this.player;
    this.trigger("dispose"), this.off(), i.off("dispose", this.dispose), i[Fs][n] = !1, this.player = this.state = null, i[n] = ng(n, Ls[n]);
  }, e.isBasic = function(n) {
    var i = typeof n == "string" ? nc(n) : n;
    return typeof i == "function" && !e.prototype.isPrototypeOf(i.prototype);
  }, e.registerPlugin = function(n, i) {
    if (typeof n != "string")
      throw new Error(
        'Illegal plugin name, "' + n + '", must be a string, was ' + typeof n + "."
      );
    if (qc(n))
      vt.warn(
        'A plugin named "' + n + '" already exists. You may want to avoid re-registering plugins!'
      );
    else if (br.prototype.hasOwnProperty(n))
      throw new Error(
        'Illegal plugin name, "' + n + '", cannot share a name with an existing player method!'
      );
    if (typeof i != "function")
      throw new Error(
        'Illegal plugin for "' + n + '", must be a function, was ' + typeof i + "."
      );
    return Ls[n] = i, n !== jc && (e.isBasic(i) ? br.prototype[n] = M3(n, i) : br.prototype[n] = ng(n, i)), i;
  }, e.deregisterPlugin = function(n) {
    if (n === jc)
      throw new Error("Cannot de-register base plugin.");
    qc(n) && (delete Ls[n], delete br.prototype[n]);
  }, e.getPlugins = function(n) {
    n === void 0 && (n = Object.keys(Ls));
    var i;
    return n.forEach(function(a) {
      var s = nc(a);
      s && (i = i || {}, i[a] = s);
    }), i;
  }, e.getPluginVersion = function(n) {
    var i = nc(n);
    return i && i.VERSION || "";
  }, e;
}();
En.getPlugin = nc;
En.BASE_PLUGIN_NAME = jc;
En.registerPlugin(jc, En);
br.prototype.usingPlugin = function(e) {
  return !!this[Fs] && this[Fs][e] === !0;
};
br.prototype.hasPlugin = function(e) {
  return !!qc(e);
};
var ag = !1, D3 = function(t, r) {
  r === void 0 && (r = {}), ag || (vt.warn(
    "videojs.extend is deprecated as of Video.js 7.22.0 and will be removed in Video.js 8.0.0"
  ), ag = !0);
  var n = function() {
    t.apply(this, arguments);
  }, i = {};
  typeof r == "object" ? (r.constructor !== Object.prototype.constructor && (n = r.constructor), i = r) : typeof r == "function" && (n = r), iw(n, t), t && (n.super_ = t);
  for (var a in i)
    i.hasOwnProperty(a) && (n.prototype[a] = i[a]);
  return n;
}, L1 = function(t) {
  return t.indexOf("#") === 0 ? t.slice(1) : t;
};
function X(e, t, r) {
  var n = X.getPlayer(e);
  if (n)
    return t && vt.warn(
      'Player "' + e + '" is already initialised. Options will not be applied.'
    ), r && n.ready(r), n;
  var i = typeof e == "string" ? ga("#" + L1(e)) : e;
  if (!Fo(i))
    throw new TypeError("The element or ID supplied is not valid. (videojs)");
  (!i.ownerDocument.defaultView || !i.ownerDocument.body.contains(i)) && vt.warn("The element supplied is not included in the DOM"), t = t || {}, t.restoreEl === !0 && (t.restoreEl = (i.parentNode && i.parentNode.hasAttribute("data-vjs-player") ? i.parentNode : i).cloneNode(!0)), va("beforesetup").forEach(function(s) {
    var o = s(i, Kt(t));
    if (!Xn(o) || Array.isArray(o)) {
      vt.error("please return an object in beforesetup hooks");
      return;
    }
    t = Kt(t, o);
  });
  var a = ye.getComponent("Player");
  return n = new a(i, t, r), va("setup").forEach(function(s) {
    return s(n);
  }), n;
}
X.hooks_ = Rn;
X.hooks = va;
X.hook = rM;
X.hookOnce = iM;
X.removeHook = T_;
if (j.VIDEOJS_NO_DYNAMIC_STYLE !== !0 && Bo()) {
  var Yl = ga(".vjs-styles-defaults");
  if (!Yl) {
    Yl = q_("vjs-styles-defaults");
    var bf = ga("head");
    bf && bf.insertBefore(Yl, bf.firstChild), X_(
      Yl,
      `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: 56.25%
      }
    `
    );
  }
}
nd(1, X);
X.VERSION = A_;
X.options = br.prototype.options_;
X.getPlayers = function() {
  return br.players;
};
X.getPlayer = function(e) {
  var t = br.players, r;
  if (typeof e == "string") {
    var n = L1(e), i = t[n];
    if (i)
      return i;
    r = ga("#" + n);
  } else
    r = e;
  if (Fo(r)) {
    var a = r, s = a.player, o = a.playerId;
    if (s || t[o])
      return s || t[o];
  }
};
X.getAllPlayers = function() {
  return (
    // Disposed players leave a key with a `null` value, so we need to make sure
    // we filter those out.
    Object.keys(br.players).map(function(e) {
      return br.players[e];
    }).filter(Boolean)
  );
};
X.players = br.players;
X.getComponent = ye.getComponent;
X.registerComponent = function(e, t) {
  jt.isTech(t) && vt.warn(
    "The " + e + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)"
  ), ye.registerComponent.call(ye, e, t);
};
X.getTech = jt.getTech;
X.registerTech = jt.registerTech;
X.use = UM;
Object.defineProperty(X, "middleware", {
  enumerable: !0,
  value: {},
  writeable: !1
});
Object.defineProperty(X.middleware, "TERMINATOR", {
  enumerable: !0,
  value: Vc,
  writeable: !1
});
X.browser = lM;
X.TOUCH_ENABLED = So;
X.extend = D3;
X.mergeOptions = Kt;
X.bind = $t;
X.registerPlugin = En.registerPlugin;
X.deregisterPlugin = En.deregisterPlugin;
X.plugin = function(e, t) {
  return vt.warn(
    "videojs.plugin() is deprecated; use videojs.registerPlugin() instead"
  ), En.registerPlugin(e, t);
};
X.getPlugins = En.getPlugins;
X.getPlugin = En.getPlugin;
X.getPluginVersion = En.getPluginVersion;
X.addLanguage = function(e, t) {
  var r;
  return e = ("" + e).toLowerCase(), X.options.languages = Kt(
    X.options.languages,
    (r = {}, r[e] = t, r)
  ), X.options.languages[e];
};
X.log = vt;
X.createLogger = w_;
X.createTimeRange = X.createTimeRanges = Va;
X.formatTime = Lo;
X.setFormatTime = n3;
X.resetFormatTime = a3;
X.parseUrl = Fp;
X.isCrossOrigin = Oh;
X.EventTarget = Ir;
X.on = Pi;
X.one = Rh;
X.off = zr;
X.trigger = ko;
X.xhr = Ry;
X.TextTrack = Pl;
X.AudioTrack = r1;
X.VideoTrack = i1;
[
  "isEl",
  "isTextNode",
  "createEl",
  "hasClass",
  "addClass",
  "removeClass",
  "toggleClass",
  "setAttributes",
  "getAttributes",
  "emptyEl",
  "appendContent",
  "insertContent"
].forEach(function(e) {
  X[e] = function() {
    return vt.warn(
      "videojs." + e + "() is deprecated; use videojs.dom." + e + "() instead"
    ), W_[e].apply(null, arguments);
  };
});
X.computedStyle = pl;
X.dom = W_;
X.url = BM;
X.defineLazyProperty = tm;
X.addLanguage("en", {
  "Non-Fullscreen": "Exit Fullscreen"
});
/* ! @name @videojs/http-streaming @version 2.16.2 @license Apache-2.0 */
var Hi = _h, Yc = function(t, r, n) {
  return t && n && n.responseURL && r !== n.responseURL ? n.responseURL : r;
}, nn = function(t) {
  return X.log.debug ? X.log.debug.bind(X, "VHS:", t + " >") : function() {
  };
}, ya = 1 / 30, dn = ya * 3, R1 = function(t, r) {
  var n = [], i;
  if (t && t.length)
    for (i = 0; i < t.length; i++)
      r(t.start(i), t.end(i)) && n.push([t.start(i), t.end(i)]);
  return X.createTimeRanges(n);
}, Rs = function(t, r) {
  return R1(t, function(n, i) {
    return n - dn <= r && i + dn >= r;
  });
}, Ql = function(t, r) {
  return R1(t, function(n) {
    return n - ya >= r;
  });
}, P3 = function(t) {
  if (t.length < 2)
    return X.createTimeRanges();
  for (var r = [], n = 1; n < t.length; n++) {
    var i = t.end(n - 1), a = t.start(n);
    r.push([i, a]);
  }
  return X.createTimeRanges(r);
}, L3 = function(t, r) {
  var n = null, i = null, a = 0, s = [], o = [];
  if (!t || !t.length || !r || !r.length)
    return X.createTimeRange();
  for (var u = t.length; u--; )
    s.push({
      time: t.start(u),
      type: "start"
    }), s.push({
      time: t.end(u),
      type: "end"
    });
  for (u = r.length; u--; )
    s.push({
      time: r.start(u),
      type: "start"
    }), s.push({
      time: r.end(u),
      type: "end"
    });
  for (s.sort(function(l, c) {
    return l.time - c.time;
  }), u = 0; u < s.length; u++)
    s[u].type === "start" ? (a++, a === 2 && (n = s[u].time)) : s[u].type === "end" && (a--, a === 1 && (i = s[u].time)), n !== null && i !== null && (o.push([n, i]), n = null, i = null);
  return X.createTimeRanges(o);
}, I1 = function(t) {
  var r = [];
  if (!t || !t.length)
    return "";
  for (var n = 0; n < t.length; n++)
    r.push(t.start(n) + " => " + t.end(n));
  return r.join(", ");
}, R3 = function(t, r, n) {
  n === void 0 && (n = 1);
  var i = t.length ? t.end(t.length - 1) : 0;
  return (i - r) / n;
}, Ba = function(t) {
  for (var r = [], n = 0; n < t.length; n++)
    r.push({
      end: t.end(n),
      start: t.start(n)
    });
  return r;
}, I3 = function(t, r) {
  if (t === r)
    return !1;
  if (!t && r || !r && t || t.length !== r.length)
    return !0;
  for (var n = 0; n < t.length; n++)
    if (t.start(n) !== r.start(n) || t.end(n) !== r.end(n))
      return !0;
  return !1;
}, sg = function(t) {
  if (!(!t || !t.length || !t.end))
    return t.end(t.length - 1);
}, rm = function(t, r) {
  var n = 0;
  if (!t || !t.length)
    return n;
  for (var i = 0; i < t.length; i++) {
    var a = t.start(i), s = t.end(i);
    if (!(r > s)) {
      if (r > a && r <= s) {
        n += s - r;
        continue;
      }
      n += s - a;
    }
  }
  return n;
}, og = X.createTimeRange, im = function(t, r) {
  if (!r.preload)
    return r.duration;
  var n = 0;
  return (r.parts || []).forEach(function(i) {
    n += i.duration;
  }), (r.preloadHints || []).forEach(function(i) {
    i.type === "PART" && (n += t.partTargetDuration);
  }), n;
}, hd = function(t) {
  return (t.segments || []).reduce(function(r, n, i) {
    return n.parts ? n.parts.forEach(function(a, s) {
      r.push({
        duration: a.duration,
        part: a,
        partIndex: s,
        segment: n,
        segmentIndex: i
      });
    }) : r.push({
      duration: n.duration,
      part: null,
      partIndex: null,
      segment: n,
      segmentIndex: i
    }), r;
  }, []);
}, O1 = function(t) {
  var r = t.segments && t.segments.length && t.segments[t.segments.length - 1];
  return r && r.parts || [];
}, B1 = function(t) {
  var r = t.preloadSegment;
  if (r) {
    var n = r.parts, i = r.preloadHints, a = (i || []).reduce(function(s, o) {
      return s + (o.type === "PART" ? 1 : 0);
    }, 0);
    return a += n && n.length ? n.length : 0, a;
  }
}, F1 = function(t, r) {
  if (r.endList)
    return 0;
  if (t && t.suggestedPresentationDelay)
    return t.suggestedPresentationDelay;
  var n = O1(r).length > 0;
  return n && r.serverControl && r.serverControl.partHoldBack ? r.serverControl.partHoldBack : n && r.partTargetDuration ? r.partTargetDuration * 3 : r.serverControl && r.serverControl.holdBack ? r.serverControl.holdBack : r.targetDuration ? r.targetDuration * 3 : 0;
}, O3 = function(t, r) {
  var n = 0, i = r - t.mediaSequence, a = t.segments[i];
  if (a) {
    if (typeof a.start < "u")
      return {
        precise: !0,
        result: a.start
      };
    if (typeof a.end < "u")
      return {
        precise: !0,
        result: a.end - a.duration
      };
  }
  for (; i--; ) {
    if (a = t.segments[i], typeof a.end < "u")
      return {
        precise: !0,
        result: n + a.end
      };
    if (n += im(t, a), typeof a.start < "u")
      return {
        precise: !0,
        result: n + a.start
      };
  }
  return {
    precise: !1,
    result: n
  };
}, B3 = function(t, r) {
  for (var n = 0, i, a = r - t.mediaSequence; a < t.segments.length; a++) {
    if (i = t.segments[a], typeof i.start < "u")
      return {
        precise: !0,
        result: i.start - n
      };
    if (n += im(t, i), typeof i.end < "u")
      return {
        precise: !0,
        result: i.end - n
      };
  }
  return {
    precise: !1,
    result: -1
  };
}, k1 = function(t, r, n) {
  if (typeof r > "u" && (r = t.mediaSequence + t.segments.length), r < t.mediaSequence)
    return 0;
  var i = O3(t, r);
  if (i.precise)
    return i.result;
  var a = B3(t, r);
  return a.precise ? a.result : i.result + n;
}, N1 = function(t, r, n) {
  if (!t)
    return 0;
  if (typeof n != "number" && (n = 0), typeof r > "u") {
    if (t.totalDuration)
      return t.totalDuration;
    if (!t.endList)
      return j.Infinity;
  }
  return k1(t, r, n);
}, fu = function(t) {
  var r = t.defaultDuration, n = t.durationList, i = t.startIndex, a = t.endIndex, s = 0;
  if (i > a) {
    var o = [a, i];
    i = o[0], a = o[1];
  }
  if (i < 0) {
    for (var u = i; u < Math.min(0, a); u++)
      s += r;
    i = 0;
  }
  for (var l = i; l < a; l++)
    s += n[l].duration;
  return s;
}, U1 = function(t, r, n, i) {
  if (!t || !t.segments)
    return null;
  if (t.endList)
    return N1(t);
  if (r === null)
    return null;
  r = r || 0;
  var a = k1(
    t,
    t.mediaSequence + t.segments.length,
    r
  );
  return n && (i = typeof i == "number" ? i : F1(null, t), a -= i), Math.max(0, a);
}, F3 = function(t, r, n) {
  var i = !0, a = r || 0, s = U1(
    t,
    r,
    i,
    n
  );
  return s === null ? og() : og(a, s);
}, k3 = function(t) {
  for (var r = t.playlist, n = t.currentTime, i = t.startingSegmentIndex, a = t.startingPartIndex, s = t.startTime, o = t.experimentalExactManifestTimings, u = n - s, l = hd(r), c = 0, h = 0; h < l.length; h++) {
    var f = l[h];
    if (i === f.segmentIndex && !(typeof a == "number" && typeof f.partIndex == "number" && a !== f.partIndex)) {
      c = h;
      break;
    }
  }
  if (u < 0) {
    if (c > 0)
      for (var d = c - 1; d >= 0; d--) {
        var p = l[d];
        if (u += p.duration, o) {
          if (u < 0)
            continue;
        } else if (u + ya <= 0)
          continue;
        return {
          partIndex: p.partIndex,
          segmentIndex: p.segmentIndex,
          startTime: s - fu({
            defaultDuration: r.targetDuration,
            durationList: l,
            endIndex: d,
            startIndex: c
          })
        };
      }
    return {
      partIndex: l[0] && l[0].partIndex || null,
      segmentIndex: l[0] && l[0].segmentIndex || 0,
      startTime: n
    };
  }
  if (c < 0) {
    for (var _ = c; _ < 0; _++)
      if (u -= r.targetDuration, u < 0)
        return {
          partIndex: l[0] && l[0].partIndex || null,
          segmentIndex: l[0] && l[0].segmentIndex || 0,
          startTime: n
        };
    c = 0;
  }
  for (var v = c; v < l.length; v++) {
    var x = l[v];
    if (u -= x.duration, o) {
      if (u > 0)
        continue;
    } else if (u - ya >= 0)
      continue;
    return {
      partIndex: x.partIndex,
      segmentIndex: x.segmentIndex,
      startTime: s + fu({
        defaultDuration: r.targetDuration,
        durationList: l,
        endIndex: v,
        startIndex: c
      })
    };
  }
  return {
    partIndex: l[l.length - 1].partIndex,
    segmentIndex: l[l.length - 1].segmentIndex,
    startTime: n
  };
}, G1 = function(t) {
  return t.excludeUntil && t.excludeUntil > Date.now();
}, nm = function(t) {
  return t.excludeUntil && t.excludeUntil === 1 / 0;
}, Nh = function(t) {
  var r = G1(t);
  return !t.disabled && !r;
}, N3 = function(t) {
  return t.disabled;
}, U3 = function(t) {
  for (var r = 0; r < t.segments.length; r++)
    if (t.segments[r].key)
      return !0;
  return !1;
}, V1 = function(t, r) {
  return r.attributes && r.attributes[t];
}, G3 = function(t, r, n, i) {
  if (i === void 0 && (i = 0), !V1("BANDWIDTH", n))
    return NaN;
  var a = t * n.attributes.BANDWIDTH;
  return (a - i * 8) / r;
}, fd = function(t, r) {
  if (t.playlists.length === 1)
    return !0;
  var n = r.attributes.BANDWIDTH || Number.MAX_VALUE;
  return t.playlists.filter(function(i) {
    return Nh(i) ? (i.attributes.BANDWIDTH || 0) < n : !1;
  }).length === 0;
}, am = function(t, r) {
  return !t && !r || !t && r || t && !r ? !1 : !!(t === r || t.id && r.id && t.id === r.id || t.resolvedUri && r.resolvedUri && t.resolvedUri === r.resolvedUri || t.uri && r.uri && t.uri === r.uri);
}, ug = function(t, r) {
  var n = t && t.mediaGroups && t.mediaGroups.AUDIO || {}, i = !1;
  for (var a in n) {
    for (var s in n[a])
      if (i = r(n[a][s]), i)
        break;
    if (i)
      break;
  }
  return !!i;
}, Il = function(t) {
  if (!t || !t.playlists || !t.playlists.length) {
    var r = ug(t, function(s) {
      return s.playlists && s.playlists.length || s.uri;
    });
    return r;
  }
  for (var n = function(o) {
    var u = t.playlists[o], l = u.attributes && u.attributes.CODECS;
    if (l && l.split(",").every(function(h) {
      return wy(h);
    }))
      return "continue";
    var c = ug(t, function(h) {
      return am(u, h);
    });
    return c ? "continue" : {
      v: !1
    };
  }, i = 0; i < t.playlists.length; i++) {
    var a = n(i);
    if (a !== "continue" && typeof a == "object")
      return a.v;
  }
  return !0;
}, li = {
  duration: N1,
  estimateSegmentRequestTime: G3,
  getMediaInfoForTime: k3,
  hasAttribute: V1,
  isAes: U3,
  isAudioOnly: Il,
  isBlacklisted: G1,
  isDisabled: N3,
  isEnabled: Nh,
  isIncompatible: nm,
  liveEdgeDelay: F1,
  isLowestEnabledRendition: fd,
  seekable: F3,
  playlistEnd: U1,
  playlistMatch: am,
  segmentDurationWithParts: im
}, H1 = X.log, sm = function(t, r) {
  return t + "-" + r;
}, V3 = function(t, r, n) {
  return "placeholder-uri-" + t + "-" + r + "-" + n;
}, H3 = function(t) {
  var r = t.onwarn, n = t.oninfo, i = t.manifestString, a = t.customTagParsers, s = a === void 0 ? [] : a, o = t.customTagMappers, u = o === void 0 ? [] : o, l = t.experimentalLLHLS, c = new rS();
  r && c.on("warn", r), n && c.on("info", n), s.forEach(function(_) {
    return c.addParser(_);
  }), u.forEach(function(_) {
    return c.addTagMapper(_);
  }), c.push(i), c.end();
  var h = c.manifest;
  if (l || ([
    "preloadSegment",
    "skip",
    "serverControl",
    "renditionReports",
    "partInf",
    "partTargetDuration"
  ].forEach(function(_) {
    h.hasOwnProperty(_) && delete h[_];
  }), h.segments && h.segments.forEach(function(_) {
    ["parts", "preloadHints"].forEach(function(v) {
      _.hasOwnProperty(v) && delete _[v];
    });
  })), !h.targetDuration) {
    var f = 10;
    h.segments && h.segments.length && (f = h.segments.reduce(function(_, v) {
      return Math.max(_, v.duration);
    }, 0)), r && r("manifest has no targetDuration defaulting to " + f), h.targetDuration = f;
  }
  var d = O1(h);
  if (d.length && !h.partTargetDuration) {
    var p = d.reduce(function(_, v) {
      return Math.max(_, v.duration);
    }, 0);
    r && (r(
      "manifest has no partTargetDuration defaulting to " + p
    ), H1.error(
      "LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed."
    )), h.partTargetDuration = p;
  }
  return h;
}, Ho = function(t, r) {
  t.mediaGroups && ["AUDIO", "SUBTITLES"].forEach(function(n) {
    if (t.mediaGroups[n])
      for (var i in t.mediaGroups[n])
        for (var a in t.mediaGroups[n][i]) {
          var s = t.mediaGroups[n][i][a];
          r(s, n, i, a);
        }
  });
}, z1 = function(t) {
  var r = t.playlist, n = t.uri, i = t.id;
  r.id = i, r.playlistErrors_ = 0, n && (r.uri = n), r.attributes = r.attributes || {};
}, z3 = function(t) {
  for (var r = t.playlists.length; r--; ) {
    var n = t.playlists[r];
    z1({
      id: sm(r, n.uri),
      playlist: n
    }), n.resolvedUri = Hi(t.uri, n.uri), t.playlists[n.id] = n, t.playlists[n.uri] = n, n.attributes.BANDWIDTH || H1.warn(
      "Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute."
    );
  }
}, W3 = function(t) {
  Ho(t, function(r) {
    r.uri && (r.resolvedUri = Hi(t.uri, r.uri));
  });
}, j3 = function(t, r) {
  var n = sm(0, r), i = {
    mediaGroups: {
      AUDIO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {},
      VIDEO: {}
    },
    playlists: [
      {
        // m3u8-parser does not attach an attributes property to media playlists so make
        // sure that the property is attached to avoid undefined reference errors
        attributes: {},
        id: n,
        resolvedUri: r,
        uri: r
      }
    ],
    resolvedUri: j.location.href,
    uri: j.location.href
  };
  return i.playlists[n] = i.playlists[0], i.playlists[r] = i.playlists[0], i;
}, W1 = function(t, r, n) {
  n === void 0 && (n = V3), t.uri = r;
  for (var i = 0; i < t.playlists.length; i++)
    if (!t.playlists[i].uri) {
      var a = "placeholder-uri-" + i;
      t.playlists[i].uri = a;
    }
  var s = Il(t);
  Ho(
    t,
    function(o, u, l, c) {
      if (!o.playlists || !o.playlists.length) {
        if (s && u === "AUDIO" && !o.uri)
          for (var h = 0; h < t.playlists.length; h++) {
            var f = t.playlists[h];
            if (f.attributes && f.attributes.AUDIO && f.attributes.AUDIO === l)
              return;
          }
        o.playlists = [Bi({}, o)];
      }
      o.playlists.forEach(function(d, p) {
        var _ = n(u, l, c, d), v = sm(p, _);
        d.uri ? d.resolvedUri = d.resolvedUri || Hi(t.uri, d.uri) : (d.uri = p === 0 ? _ : v, d.resolvedUri = d.uri), d.id = d.id || v, d.attributes = d.attributes || {}, t.playlists[d.id] = d, t.playlists[d.uri] = d;
      });
    }
  ), z3(t), W3(t);
}, Qc = X.mergeOptions, q3 = X.EventTarget, X3 = function(t, r) {
  if (r.endList || !r.serverControl)
    return t;
  var n = {};
  if (r.serverControl.canBlockReload) {
    var i = r.preloadSegment, a = r.mediaSequence + r.segments.length;
    if (i) {
      var s = i.parts || [], o = B1(r) - 1;
      o > -1 && o !== s.length - 1 && (n._HLS_part = o), (o > -1 || s.length) && a--;
    }
    n._HLS_msn = a;
  }
  if (r.serverControl && r.serverControl.canSkipUntil && (n._HLS_skip = r.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(n).length) {
    var u = new j.URL(t);
    ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(l) {
      n.hasOwnProperty(l) && u.searchParams.set(l, n[l]);
    }), t = u.toString();
  }
  return t;
}, Y3 = function(t, r) {
  if (!t)
    return r;
  var n = Qc(t, r);
  if (t.preloadHints && !r.preloadHints && delete n.preloadHints, t.parts && !r.parts)
    delete n.parts;
  else if (t.parts && r.parts)
    for (var i = 0; i < r.parts.length; i++)
      t.parts && t.parts[i] && (n.parts[i] = Qc(t.parts[i], r.parts[i]));
  return !t.skipped && r.skipped && (n.skipped = !1), t.preload && !r.preload && (n.preload = !1), n;
}, Q3 = function(t, r, n) {
  var i = t.slice(), a = r.slice();
  n = n || 0;
  for (var s = [], o, u = 0; u < a.length; u++) {
    var l = i[u + n], c = a[u];
    l ? (o = l.map || o, s.push(Y3(l, c))) : (o && !c.map && (c.map = o), s.push(c));
  }
  return s;
}, j1 = function(t, r) {
  !t.resolvedUri && t.uri && (t.resolvedUri = Hi(r, t.uri)), t.key && !t.key.resolvedUri && (t.key.resolvedUri = Hi(r, t.key.uri)), t.map && !t.map.resolvedUri && (t.map.resolvedUri = Hi(r, t.map.uri)), t.map && t.map.key && !t.map.key.resolvedUri && (t.map.key.resolvedUri = Hi(r, t.map.key.uri)), t.parts && t.parts.length && t.parts.forEach(function(n) {
    n.resolvedUri || (n.resolvedUri = Hi(r, n.uri));
  }), t.preloadHints && t.preloadHints.length && t.preloadHints.forEach(function(n) {
    n.resolvedUri || (n.resolvedUri = Hi(r, n.uri));
  });
}, q1 = function(t) {
  var r = t.segments || [], n = t.preloadSegment;
  if (n && n.parts && n.parts.length) {
    if (n.preloadHints) {
      for (var i = 0; i < n.preloadHints.length; i++)
        if (n.preloadHints[i].type === "MAP")
          return r;
    }
    n.duration = t.targetDuration, n.preload = !0, r.push(n);
  }
  return r;
}, X1 = function(t, r) {
  return t === r || t.segments && r.segments && t.segments.length === r.segments.length && t.endList === r.endList && t.mediaSequence === r.mediaSequence && t.preloadSegment === r.preloadSegment;
}, dd = function(t, r, n) {
  n === void 0 && (n = X1);
  var i = Qc(t, {}), a = i.playlists[r.id];
  if (!a || n(a, r))
    return null;
  r.segments = q1(r);
  var s = Qc(a, r);
  if (s.preloadSegment && !r.preloadSegment && delete s.preloadSegment, a.segments) {
    if (r.skip) {
      r.segments = r.segments || [];
      for (var o = 0; o < r.skip.skippedSegments; o++)
        r.segments.unshift({
          skipped: !0
        });
    }
    s.segments = Q3(
      a.segments,
      r.segments,
      r.mediaSequence - a.mediaSequence
    );
  }
  s.segments.forEach(function(l) {
    j1(l, s.resolvedUri);
  });
  for (var u = 0; u < i.playlists.length; u++)
    i.playlists[u].id === r.id && (i.playlists[u] = s);
  return i.playlists[r.id] = s, i.playlists[r.uri] = s, Ho(
    t,
    function(l, c, h, f) {
      if (l.playlists)
        for (var d = 0; d < l.playlists.length; d++)
          r.id === l.playlists[d].id && (l.playlists[d] = s);
    }
  ), i;
}, pd = function(t, r) {
  var n = t.segments || [], i = n[n.length - 1], a = i && i.parts && i.parts[i.parts.length - 1], s = a && a.duration || i && i.duration;
  return r && s ? s * 1e3 : (t.partTargetDuration || t.targetDuration || 10) * 500;
}, Is = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a) {
    var s;
    if (a === void 0 && (a = {}), s = e.call(this) || this, !n)
      throw new Error("A non-empty playlist URL or object is required");
    s.logger_ = nn("PlaylistLoader");
    var o = a, u = o.withCredentials, l = u === void 0 ? !1 : u, c = o.handleManifestRedirects, h = c === void 0 ? !1 : c;
    s.src = n, s.vhs_ = i, s.withCredentials = l, s.handleManifestRedirects = h;
    var f = i.options_;
    return s.customTagParsers = f && f.customTagParsers || [], s.customTagMappers = f && f.customTagMappers || [], s.experimentalLLHLS = f && f.experimentalLLHLS || !1, X.browser.IE_VERSION && (s.experimentalLLHLS = !1), s.state = "HAVE_NOTHING", s.handleMediaupdatetimeout_ = s.handleMediaupdatetimeout_.bind(
      ze(s)
    ), s.on("mediaupdatetimeout", s.handleMediaupdatetimeout_), s;
  }
  var r = t.prototype;
  return r.handleMediaupdatetimeout_ = function() {
    var i = this;
    if (this.state === "HAVE_METADATA") {
      var a = this.media(), s = Hi(this.master.uri, a.uri);
      this.experimentalLLHLS && (s = X3(s, a)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr(
        {
          uri: s,
          withCredentials: this.withCredentials
        },
        function(o, u) {
          if (i.request) {
            if (o)
              return i.playlistRequestError(
                i.request,
                i.media(),
                "HAVE_METADATA"
              );
            i.haveMetadata({
              id: i.media().id,
              playlistString: i.request.responseText,
              url: i.media().uri
            });
          }
        }
      );
    }
  }, r.playlistRequestError = function(i, a, s) {
    var o = a.uri, u = a.id;
    this.request = null, s && (this.state = s), this.error = {
      code: i.status >= 500 ? 4 : 2,
      message: "HLS playlist request error at URL: " + o + ".",
      playlist: this.master.playlists[u],
      responseText: i.responseText,
      status: i.status
    }, this.trigger("error");
  }, r.parseManifest_ = function(i) {
    var a = this, s = i.url, o = i.manifestString;
    return H3({
      customTagMappers: this.customTagMappers,
      customTagParsers: this.customTagParsers,
      experimentalLLHLS: this.experimentalLLHLS,
      manifestString: o,
      oninfo: function(l) {
        var c = l.message;
        return a.logger_("m3u8-parser info for " + s + ": " + c);
      },
      onwarn: function(l) {
        var c = l.message;
        return a.logger_("m3u8-parser warn for " + s + ": " + c);
      }
    });
  }, r.haveMetadata = function(i) {
    var a = i.playlistString, s = i.playlistObject, o = i.url, u = i.id;
    this.request = null, this.state = "HAVE_METADATA";
    var l = s || this.parseManifest_({
      manifestString: a,
      url: o
    });
    l.lastRequest = Date.now(), z1({
      id: u,
      playlist: l,
      uri: o
    });
    var c = dd(this.master, l);
    this.targetDuration = l.partTargetDuration || l.targetDuration, this.pendingMedia_ = null, c ? (this.master = c, this.media_ = this.master.playlists[u]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(pd(this.media(), !!c)), this.trigger("loadedplaylist");
  }, r.dispose = function() {
    this.trigger("dispose"), this.stopRequest(), j.clearTimeout(this.mediaUpdateTimeout), j.clearTimeout(this.finalRenditionTimeout), this.off();
  }, r.stopRequest = function() {
    if (this.request) {
      var i = this.request;
      this.request = null, i.onreadystatechange = null, i.abort();
    }
  }, r.media = function(i, a) {
    var s = this;
    if (!i)
      return this.media_;
    if (this.state === "HAVE_NOTHING")
      throw new Error("Cannot switch media playlist from " + this.state);
    if (typeof i == "string") {
      if (!this.master.playlists[i])
        throw new Error("Unknown playlist URI: " + i);
      i = this.master.playlists[i];
    }
    if (j.clearTimeout(this.finalRenditionTimeout), a) {
      var o = (i.partTargetDuration || i.targetDuration) / 2 * 1e3 || 5e3;
      this.finalRenditionTimeout = j.setTimeout(
        this.media.bind(this, i, !1),
        o
      );
      return;
    }
    var u = this.state, l = !this.media_ || i.id !== this.media_.id, c = this.master.playlists[i.id];
    if (c && c.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved
    // media playlist or, for the case of demuxed audio, a resolved audio media group)
    i.endList && i.segments.length) {
      this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = i, l && (this.trigger("mediachanging"), u === "HAVE_MASTER" ? this.trigger("loadedmetadata") : this.trigger("mediachange"));
      return;
    }
    if (this.updateMediaUpdateTimeout_(pd(i, !0)), !!l) {
      if (this.state = "SWITCHING_MEDIA", this.request) {
        if (i.resolvedUri === this.request.url)
          return;
        this.request.onreadystatechange = null, this.request.abort(), this.request = null;
      }
      this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = i, this.request = this.vhs_.xhr(
        {
          uri: i.resolvedUri,
          withCredentials: this.withCredentials
        },
        function(h, f) {
          if (s.request) {
            if (i.lastRequest = Date.now(), i.resolvedUri = Yc(
              s.handleManifestRedirects,
              i.resolvedUri,
              f
            ), h)
              return s.playlistRequestError(
                s.request,
                i,
                u
              );
            s.haveMetadata({
              id: i.id,
              playlistString: f.responseText,
              url: i.uri
            }), u === "HAVE_MASTER" ? s.trigger("loadedmetadata") : s.trigger("mediachange");
          }
        }
      );
    }
  }, r.pause = function() {
    this.mediaUpdateTimeout && (j.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), this.state === "HAVE_NOTHING" && (this.started = !1), this.state === "SWITCHING_MEDIA" ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MASTER" : this.state === "HAVE_CURRENT_METADATA" && (this.state = "HAVE_METADATA");
  }, r.load = function(i) {
    var a = this;
    this.mediaUpdateTimeout && (j.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null);
    var s = this.media();
    if (i) {
      var o = s ? (s.partTargetDuration || s.targetDuration) / 2 * 1e3 : 5e3;
      this.mediaUpdateTimeout = j.setTimeout(function() {
        a.mediaUpdateTimeout = null, a.load();
      }, o);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    s && !s.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist");
  }, r.updateMediaUpdateTimeout_ = function(i) {
    var a = this;
    this.mediaUpdateTimeout && (j.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), !(!this.media() || this.media().endList) && (this.mediaUpdateTimeout = j.setTimeout(function() {
      a.mediaUpdateTimeout = null, a.trigger("mediaupdatetimeout"), a.updateMediaUpdateTimeout_(i);
    }, i));
  }, r.start = function() {
    var i = this;
    if (this.started = !0, typeof this.src == "object") {
      this.src.uri || (this.src.uri = j.location.href), this.src.resolvedUri = this.src.uri, setTimeout(function() {
        i.setupInitialPlaylist(i.src);
      }, 0);
      return;
    }
    this.request = this.vhs_.xhr(
      {
        uri: this.src,
        withCredentials: this.withCredentials
      },
      function(a, s) {
        if (i.request) {
          if (i.request = null, a)
            return i.error = {
              // MEDIA_ERR_NETWORK
              code: 2,
              message: "HLS playlist request error at URL: " + i.src + ".",
              responseText: s.responseText,
              status: s.status
            }, i.state === "HAVE_NOTHING" && (i.started = !1), i.trigger("error");
          i.src = Yc(
            i.handleManifestRedirects,
            i.src,
            s
          );
          var o = i.parseManifest_({
            manifestString: s.responseText,
            url: i.src
          });
          i.setupInitialPlaylist(o);
        }
      }
    );
  }, r.srcUri = function() {
    return typeof this.src == "string" ? this.src : this.src.uri;
  }, r.setupInitialPlaylist = function(i) {
    if (this.state = "HAVE_MASTER", i.playlists) {
      this.master = i, W1(this.master, this.srcUri()), i.playlists.forEach(function(s) {
        s.segments = q1(s), s.segments.forEach(function(o) {
          j1(o, s.resolvedUri);
        });
      }), this.trigger("loadedplaylist"), this.request || this.media(this.master.playlists[0]);
      return;
    }
    var a = this.srcUri() || j.location.href;
    this.master = j3(i, a), this.haveMetadata({
      id: this.master.playlists[0].id,
      playlistObject: i,
      url: a
    }), this.trigger("loadedmetadata");
  }, t;
}(q3), K3 = X.xhr, $3 = X.mergeOptions, md = function(t, r, n, i) {
  var a = t.responseType === "arraybuffer" ? t.response : t.responseText;
  !r && a && (t.responseTime = Date.now(), t.roundTripTime = t.responseTime - t.requestTime, t.bytesReceived = a.byteLength || a.length, t.bandwidth || (t.bandwidth = Math.floor(
    t.bytesReceived / t.roundTripTime * 8 * 1e3
  ))), n.headers && (t.responseHeaders = n.headers), r && r.code === "ETIMEDOUT" && (t.timedout = !0), !r && !t.aborted && n.statusCode !== 200 && n.statusCode !== 206 && n.statusCode !== 0 && (r = new Error(
    "XHR Failed with a response of: " + (t && (a || t.responseText))
  )), i(r, t);
}, Y1 = function() {
  var t = function r(n, i) {
    n = $3(
      {
        timeout: 45e3
      },
      n
    );
    var a = r.beforeRequest || X.Vhs.xhr.beforeRequest;
    if (a && typeof a == "function") {
      var s = a(n);
      s && (n = s);
    }
    var o = X.Vhs.xhr.original === !0 ? K3 : X.Vhs.xhr, u = o(n, function(c, h) {
      return md(u, c, h, i);
    }), l = u.abort;
    return u.abort = function() {
      return u.aborted = !0, l.apply(u, arguments);
    }, u.uri = n.uri, u.requestTime = Date.now(), u;
  };
  return t.original = !0, t;
}, Z3 = function(t) {
  var r, n = t.offset;
  return typeof t.offset == "bigint" || typeof t.length == "bigint" ? r = j.BigInt(t.offset) + j.BigInt(t.length) - j.BigInt(1) : r = t.offset + t.length - 1, "bytes=" + n + "-" + r;
}, vd = function(t) {
  var r = {};
  return t.byterange && (r.Range = Z3(t.byterange)), r;
}, J3 = function(t, r) {
  return t.start(r) + "-" + t.end(r);
}, eD = function(t, r) {
  var n = t.toString(16);
  return "00".substring(0, 2 - n.length) + n + (r % 2 ? " " : "");
}, tD = function(t) {
  return t >= 32 && t < 126 ? String.fromCharCode(t) : ".";
}, Q1 = function(t) {
  var r = {};
  return Object.keys(t).forEach(function(n) {
    var i = t[n];
    Ay(i) ? r[n] = {
      byteLength: i.byteLength,
      byteOffset: i.byteOffset,
      bytes: i.buffer
    } : r[n] = i;
  }), r;
}, Kc = function(t) {
  var r = t.byterange || {
    length: 1 / 0,
    offset: 0
  };
  return [r.length, r.offset, t.resolvedUri].join(
    ","
  );
}, K1 = function(t) {
  return t.resolvedUri;
}, $1 = function(t) {
  for (var r = Array.prototype.slice.call(t), n = 16, i = "", a, s, o = 0; o < r.length / n; o++)
    a = r.slice(o * n, o * n + n).map(eD).join(""), s = r.slice(o * n, o * n + n).map(tD).join(""), i += a + " " + s + `
`;
  return i;
}, rD = function(t) {
  var r = t.bytes;
  return $1(r);
}, iD = function(t) {
  var r = "", n;
  for (n = 0; n < t.length; n++)
    r += J3(t, n) + " ";
  return r;
}, nD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTransferableMessage: Q1,
  hexDump: $1,
  initSegmentId: Kc,
  segmentKeyId: K1,
  tagDump: rD,
  textRanges: iD
}), Z1 = 0.25, aD = function(t, r) {
  if (!r.dateTimeObject)
    return null;
  var n = r.videoTimingInfo.transmuxerPrependedSeconds, i = r.videoTimingInfo.transmuxedPresentationStart, a = i + n, s = t - a;
  return new Date(
    r.dateTimeObject.getTime() + s * 1e3
  );
}, sD = function(t) {
  return t.transmuxedPresentationEnd - t.transmuxedPresentationStart - t.transmuxerPrependedSeconds;
}, oD = function(t, r) {
  var n;
  try {
    n = new Date(t);
  } catch {
    return null;
  }
  if (!r || !r.segments || r.segments.length === 0)
    return null;
  var i = r.segments[0];
  if (n < i.dateTimeObject)
    return null;
  for (var a = 0; a < r.segments.length - 1; a++) {
    i = r.segments[a];
    var s = r.segments[a + 1].dateTimeObject;
    if (n < s)
      break;
  }
  var o = r.segments[r.segments.length - 1], u = o.dateTimeObject, l = o.videoTimingInfo ? sD(o.videoTimingInfo) : o.duration + o.duration * Z1, c = new Date(
    u.getTime() + l * 1e3
  );
  return n > c ? null : (n > u && (i = o), {
    estimatedStart: i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationStart : li.duration(
      r,
      r.mediaSequence + r.segments.indexOf(i)
    ),
    segment: i,
    // Although, given that all segments have accurate date time objects, the segment
    // selected should be accurate, unless the video has been transmuxed at some point
    // (determined by the presence of the videoTimingInfo object), the segment's "player
    // time" (the start time in the player) can't be considered accurate.
    type: i.videoTimingInfo ? "accurate" : "estimate"
  });
}, uD = function(t, r) {
  if (!r || !r.segments || r.segments.length === 0)
    return null;
  for (var n = 0, i, a = 0; a < r.segments.length && (i = r.segments[a], n = i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationEnd : n + i.duration, !(t <= n)); a++)
    ;
  var s = r.segments[r.segments.length - 1];
  if (s.videoTimingInfo && s.videoTimingInfo.transmuxedPresentationEnd < t)
    return null;
  if (t > n) {
    if (t > n + s.duration * Z1)
      return null;
    i = s;
  }
  return {
    estimatedStart: i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationStart : n - i.duration,
    segment: i,
    // Because videoTimingInfo is only set after transmux, it is the only way to get
    // accurate timing values.
    type: i.videoTimingInfo ? "accurate" : "estimate"
  };
}, lD = function(t, r) {
  var n, i;
  try {
    n = new Date(t), i = new Date(r);
  } catch {
  }
  var a = n.getTime(), s = i.getTime();
  return (s - a) / 1e3;
}, cD = function(t) {
  if (!t.segments || t.segments.length === 0)
    return !1;
  for (var r = 0; r < t.segments.length; r++) {
    var n = t.segments[r];
    if (!n.dateTimeObject)
      return !1;
  }
  return !0;
}, hD = function(t) {
  var r = t.playlist, n = t.time, i = n === void 0 ? void 0 : n, a = t.callback;
  if (!a)
    throw new Error("getProgramTime: callback must be provided");
  if (!r || i === void 0)
    return a({
      message: "getProgramTime: playlist and time must be provided"
    });
  var s = uD(i, r);
  if (!s)
    return a({
      message: "valid programTime was not found"
    });
  if (s.type === "estimate")
    return a({
      message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
      seekTime: s.estimatedStart
    });
  var o = {
    mediaSeconds: i
  }, u = aD(i, s.segment);
  return u && (o.programDateTime = u.toISOString()), a(null, o);
}, fD = function e(t) {
  var r = t.programTime, n = t.playlist, i = t.retryCount, a = i === void 0 ? 2 : i, s = t.seekTo, o = t.pauseAfterSeek, u = o === void 0 ? !0 : o, l = t.tech, c = t.callback;
  if (!c)
    throw new Error("seekToProgramTime: callback must be provided");
  if (typeof r > "u" || !n || !s)
    return c({
      message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
    });
  if (!n.endList && !l.hasStarted_)
    return c({
      message: "player must be playing a live stream to start buffering"
    });
  if (!cD(n))
    return c({
      message: "programDateTime tags must be provided in the manifest " + n.resolvedUri
    });
  var h = oD(r, n);
  if (!h)
    return c({
      message: r + " was not found in the stream"
    });
  var f = h.segment, d = lD(f.dateTimeObject, r);
  if (h.type === "estimate") {
    if (a === 0)
      return c({
        message: r + " is not buffered yet. Try again"
      });
    s(h.estimatedStart + d), l.one("seeked", function() {
      e({
        callback: c,
        pauseAfterSeek: u,
        playlist: n,
        programTime: r,
        retryCount: a - 1,
        seekTo: s,
        tech: l
      });
    });
    return;
  }
  var p = f.start + d, _ = function() {
    return c(null, l.currentTime());
  };
  l.one("seeked", _), u && l.pause(), s(p);
}, xf = function(t, r) {
  if (t.readyState === 4)
    return r();
}, dD = function(t, r, n) {
  var i = [], a, s = !1, o = function(f, d, p, _) {
    return d.abort(), s = !0, n(f, d, p, _);
  }, u = function(f, d) {
    if (!s) {
      if (f)
        return o(f, d, "", i);
      var p = d.responseText.substring(
        i && i.byteLength || 0,
        d.responseText.length
      );
      if (i = cw(i, Ty(p, !0)), a = a || iu(i), i.length < 10 || a && i.length < a + 2)
        return xf(d, function() {
          return o(f, d, "", i);
        });
      var _ = ip(i);
      return _ === "ts" && i.length < 188 ? xf(d, function() {
        return o(f, d, "", i);
      }) : !_ && i.length < 376 ? xf(d, function() {
        return o(f, d, "", i);
      }) : o(null, d, _, i);
    }
  }, l = {
    beforeSend: function(f) {
      f.overrideMimeType("text/plain; charset=x-user-defined"), f.addEventListener("progress", function(d) {
        return d.total, d.loaded, md(
          f,
          null,
          {
            statusCode: f.status
          },
          u
        );
      });
    },
    uri: t
  }, c = r(l, function(h, f) {
    return md(c, h, f, u);
  });
  return c;
}, pD = X.EventTarget, J1 = X.mergeOptions, lg = function(t, r) {
  if (!X1(t, r) || t.sidx && r.sidx && (t.sidx.offset !== r.sidx.offset || t.sidx.length !== r.sidx.length))
    return !1;
  if (!t.sidx && r.sidx || t.sidx && !r.sidx || t.segments && !r.segments || !t.segments && r.segments)
    return !1;
  if (!t.segments && !r.segments)
    return !0;
  for (var n = 0; n < t.segments.length; n++) {
    var i = t.segments[n], a = r.segments[n];
    if (i.uri !== a.uri)
      return !1;
    if (!(!i.byterange && !a.byterange)) {
      var s = i.byterange, o = a.byterange;
      if (s && !o || !s && o || s.offset !== o.offset || s.length !== o.length)
        return !1;
    }
  }
  return !0;
}, mD = function(t, r, n, i) {
  var a = i.attributes.NAME || n;
  return "placeholder-uri-" + t + "-" + r + "-" + a;
}, vD = function(t) {
  var r = t.masterXml, n = t.srcUrl, i = t.clientOffset, a = t.sidxMapping, s = t.previousManifest, o = xC(r, {
    clientOffset: i,
    manifestUri: n,
    previousManifest: s,
    sidxMapping: a
  });
  return W1(o, n, mD), o;
}, gD = function(t, r) {
  Ho(t, function(n, i, a, s) {
    s in r.mediaGroups[i][a] || delete t.mediaGroups[i][a][s];
  });
}, yD = function(t, r, n) {
  for (var i = !0, a = J1(t, {
    // These are top level properties that can be updated
    duration: r.duration,
    minimumUpdatePeriod: r.minimumUpdatePeriod,
    timelineStarts: r.timelineStarts
  }), s = 0; s < r.playlists.length; s++) {
    var o = r.playlists[s];
    if (o.sidx) {
      var u = Eh(o.sidx);
      n && n[u] && n[u].sidx && gp(
        o,
        n[u].sidx,
        o.sidx.resolvedUri
      );
    }
    var l = dd(
      a,
      o,
      lg
    );
    l && (a = l, i = !1);
  }
  return Ho(r, function(c, h, f, d) {
    if (c.playlists && c.playlists.length) {
      var p = c.playlists[0].id, _ = dd(
        a,
        c.playlists[0],
        lg
      );
      _ && (a = _, d in a.mediaGroups[h][f] || (a.mediaGroups[h][f][d] = c), a.mediaGroups[h][f][d].playlists[0] = a.playlists[p], i = !1);
    }
  }), gD(a, r), r.minimumUpdatePeriod !== t.minimumUpdatePeriod && (i = !1), i ? null : a;
}, _D = function(t, r) {
  var n = !t.map && !r.map, i = n || !!(t.map && r.map && t.map.byterange.offset === r.map.byterange.offset && t.map.byterange.length === r.map.byterange.length);
  return i && t.uri === r.uri && t.byterange.offset === r.byterange.offset && t.byterange.length === r.byterange.length;
}, cg = function(t, r) {
  var n = {};
  for (var i in t) {
    var a = t[i], s = a.sidx;
    if (s) {
      var o = Eh(s);
      if (!r[o])
        break;
      var u = r[o].sidxInfo;
      _D(u, s) && (n[o] = r[o]);
    }
  }
  return n;
}, bD = function(t, r) {
  var n = cg(t.playlists, r), i = n;
  return Ho(
    t,
    function(a, s, o, u) {
      if (a.playlists && a.playlists.length) {
        var l = a.playlists;
        i = J1(
          i,
          cg(l, r)
        );
      }
    }
  ), i;
}, gd = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a, s) {
    var o;
    a === void 0 && (a = {}), o = e.call(this) || this, o.masterPlaylistLoader_ = s || ze(o), s || (o.isMaster_ = !0);
    var u = a, l = u.withCredentials, c = l === void 0 ? !1 : l, h = u.handleManifestRedirects, f = h === void 0 ? !1 : h;
    if (o.vhs_ = i, o.withCredentials = c, o.handleManifestRedirects = f, !n)
      throw new Error("A non-empty playlist URL or object is required");
    return o.on("minimumUpdatePeriod", function() {
      o.refreshXml_();
    }), o.on("mediaupdatetimeout", function() {
      o.refreshMedia_(o.media().id);
    }), o.state = "HAVE_NOTHING", o.loadedPlaylists_ = {}, o.logger_ = nn("DashPlaylistLoader"), o.isMaster_ ? (o.masterPlaylistLoader_.srcUrl = n, o.masterPlaylistLoader_.sidxMapping_ = {}) : o.childPlaylist_ = n, o;
  }
  var r = t.prototype;
  return r.requestErrored_ = function(i, a, s) {
    if (!this.request)
      return !0;
    if (this.request = null, i)
      return this.error = typeof i == "object" && !(i instanceof Error) ? i : {
        // MEDIA_ERR_NETWORK
        code: 2,
        message: "DASH request error at URL: " + a.uri,
        response: a.response,
        status: a.status
      }, s && (this.state = s), this.trigger("error"), !0;
  }, r.addSidxSegments_ = function(i, a, s) {
    var o = this, u = i.sidx && Eh(i.sidx);
    if (!i.sidx || !u || this.masterPlaylistLoader_.sidxMapping_[u]) {
      this.mediaRequest_ = j.setTimeout(function() {
        return s(!1);
      }, 0);
      return;
    }
    var l = Yc(
      this.handleManifestRedirects,
      i.sidx.resolvedUri
    ), c = function(f, d) {
      if (!o.requestErrored_(f, d, a)) {
        var p = o.masterPlaylistLoader_.sidxMapping_, _;
        try {
          _ = CC($e(d.response).subarray(8));
        } catch (v) {
          o.requestErrored_(v, d, a);
          return;
        }
        return p[u] = {
          sidx: _,
          sidxInfo: i.sidx
        }, gp(i, _, i.sidx.resolvedUri), s(!0);
      }
    };
    this.request = dD(
      l,
      this.vhs_.xhr,
      function(h, f, d, p) {
        if (h)
          return c(h, f);
        if (!d || d !== "mp4")
          return c(
            {
              blacklistDuration: 1 / 0,
              // MEDIA_ERR_NETWORK
              code: 2,
              internal: !0,
              message: "Unsupported " + (d || "unknown") + " container type for sidx segment at URL: " + l,
              playlist: i,
              // response is just bytes in this case
              // but we really don't want to return that.
              response: "",
              status: f.status
            },
            f
          );
        var _ = i.sidx.byterange, v = _.offset, x = _.length;
        if (p.length >= x + v)
          return c(h, {
            response: p.subarray(v, v + x),
            status: f.status,
            uri: f.uri
          });
        o.request = o.vhs_.xhr(
          {
            headers: vd({
              byterange: i.sidx.byterange
            }),
            responseType: "arraybuffer",
            uri: l
          },
          c
        );
      }
    );
  }, r.dispose = function() {
    this.trigger("dispose"), this.stopRequest(), this.loadedPlaylists_ = {}, j.clearTimeout(this.minimumUpdatePeriodTimeout_), j.clearTimeout(this.mediaRequest_), j.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.mediaRequest_ = null, this.minimumUpdatePeriodTimeout_ = null, this.masterPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_), this.masterPlaylistLoader_.createMupOnMedia_ = null), this.off();
  }, r.hasPendingRequest = function() {
    return this.request || this.mediaRequest_;
  }, r.stopRequest = function() {
    if (this.request) {
      var i = this.request;
      this.request = null, i.onreadystatechange = null, i.abort();
    }
  }, r.media = function(i) {
    var a = this;
    if (!i)
      return this.media_;
    if (this.state === "HAVE_NOTHING")
      throw new Error("Cannot switch media playlist from " + this.state);
    var s = this.state;
    if (typeof i == "string") {
      if (!this.masterPlaylistLoader_.master.playlists[i])
        throw new Error("Unknown playlist URI: " + i);
      i = this.masterPlaylistLoader_.master.playlists[i];
    }
    var o = !this.media_ || i.id !== this.media_.id;
    if (o && this.loadedPlaylists_[i.id] && this.loadedPlaylists_[i.id].endList) {
      this.state = "HAVE_METADATA", this.media_ = i, o && (this.trigger("mediachanging"), this.trigger("mediachange"));
      return;
    }
    o && (this.media_ && this.trigger("mediachanging"), this.addSidxSegments_(i, s, function(u) {
      a.haveMetadata({
        playlist: i,
        startingState: s
      });
    }));
  }, r.haveMetadata = function(i) {
    var a = i.startingState, s = i.playlist;
    this.state = "HAVE_METADATA", this.loadedPlaylists_[s.id] = s, this.mediaRequest_ = null, this.refreshMedia_(s.id), a === "HAVE_MASTER" ? this.trigger("loadedmetadata") : this.trigger("mediachange");
  }, r.pause = function() {
    this.masterPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_), this.masterPlaylistLoader_.createMupOnMedia_ = null), this.stopRequest(), j.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.isMaster_ && (j.clearTimeout(
      this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_
    ), this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null), this.state === "HAVE_NOTHING" && (this.started = !1);
  }, r.load = function(i) {
    var a = this;
    j.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null;
    var s = this.media();
    if (i) {
      var o = s ? s.targetDuration / 2 * 1e3 : 5e3;
      this.mediaUpdateTimeout = j.setTimeout(function() {
        return a.load();
      }, o);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    s && !s.endList ? (this.isMaster_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"), this.updateMinimumUpdatePeriodTimeout_()), this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist");
  }, r.start = function() {
    var i = this;
    if (this.started = !0, !this.isMaster_) {
      this.mediaRequest_ = j.setTimeout(function() {
        return i.haveMaster_();
      }, 0);
      return;
    }
    this.requestMaster_(function(a, s) {
      i.haveMaster_(), !i.hasPendingRequest() && !i.media_ && i.media(i.masterPlaylistLoader_.master.playlists[0]);
    });
  }, r.requestMaster_ = function(i) {
    var a = this;
    this.request = this.vhs_.xhr(
      {
        uri: this.masterPlaylistLoader_.srcUrl,
        withCredentials: this.withCredentials
      },
      function(s, o) {
        if (a.requestErrored_(s, o)) {
          a.state === "HAVE_NOTHING" && (a.started = !1);
          return;
        }
        var u = o.responseText !== a.masterPlaylistLoader_.masterXml_;
        if (a.masterPlaylistLoader_.masterXml_ = o.responseText, o.responseHeaders && o.responseHeaders.date ? a.masterLoaded_ = Date.parse(o.responseHeaders.date) : a.masterLoaded_ = Date.now(), a.masterPlaylistLoader_.srcUrl = Yc(
          a.handleManifestRedirects,
          a.masterPlaylistLoader_.srcUrl,
          o
        ), u) {
          a.handleMaster_(), a.syncClientServerClock_(function() {
            return i(o, u);
          });
          return;
        }
        return i(o, u);
      }
    );
  }, r.syncClientServerClock_ = function(i) {
    var a = this, s = AC(this.masterPlaylistLoader_.masterXml_);
    if (s === null)
      return this.masterPlaylistLoader_.clientOffset_ = this.masterLoaded_ - Date.now(), i();
    if (s.method === "DIRECT")
      return this.masterPlaylistLoader_.clientOffset_ = s.value - Date.now(), i();
    this.request = this.vhs_.xhr(
      {
        method: s.method,
        uri: Hi(this.masterPlaylistLoader_.srcUrl, s.value),
        withCredentials: this.withCredentials
      },
      function(o, u) {
        if (a.request) {
          if (o)
            return a.masterPlaylistLoader_.clientOffset_ = a.masterLoaded_ - Date.now(), i();
          var l;
          s.method === "HEAD" ? !u.responseHeaders || !u.responseHeaders.date ? l = a.masterLoaded_ : l = Date.parse(u.responseHeaders.date) : l = Date.parse(u.responseText), a.masterPlaylistLoader_.clientOffset_ = l - Date.now(), i();
        }
      }
    );
  }, r.haveMaster_ = function() {
    this.state = "HAVE_MASTER", this.isMaster_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_);
  }, r.handleMaster_ = function() {
    this.mediaRequest_ = null;
    var i = this.masterPlaylistLoader_.master, a = vD({
      clientOffset: this.masterPlaylistLoader_.clientOffset_,
      masterXml: this.masterPlaylistLoader_.masterXml_,
      previousManifest: i,
      sidxMapping: this.masterPlaylistLoader_.sidxMapping_,
      srcUrl: this.masterPlaylistLoader_.srcUrl
    });
    i && (a = yD(
      i,
      a,
      this.masterPlaylistLoader_.sidxMapping_
    )), this.masterPlaylistLoader_.master = a || i;
    var s = this.masterPlaylistLoader_.master.locations && this.masterPlaylistLoader_.master.locations[0];
    return s && s !== this.masterPlaylistLoader_.srcUrl && (this.masterPlaylistLoader_.srcUrl = s), (!i || a && a.minimumUpdatePeriod !== i.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(), !!a;
  }, r.updateMinimumUpdatePeriodTimeout_ = function() {
    var i = this.masterPlaylistLoader_;
    i.createMupOnMedia_ && (i.off("loadedmetadata", i.createMupOnMedia_), i.createMupOnMedia_ = null), i.minimumUpdatePeriodTimeout_ && (j.clearTimeout(i.minimumUpdatePeriodTimeout_), i.minimumUpdatePeriodTimeout_ = null);
    var a = i.master && i.master.minimumUpdatePeriod;
    if (a === 0 && (i.media() ? a = i.media().targetDuration * 1e3 : (i.createMupOnMedia_ = i.updateMinimumUpdatePeriodTimeout_, i.one("loadedmetadata", i.createMupOnMedia_))), typeof a != "number" || a <= 0) {
      a < 0 && this.logger_(
        "found invalid minimumUpdatePeriod of " + a + ", not setting a timeout"
      );
      return;
    }
    this.createMUPTimeout_(a);
  }, r.createMUPTimeout_ = function(i) {
    var a = this.masterPlaylistLoader_;
    a.minimumUpdatePeriodTimeout_ = j.setTimeout(function() {
      a.minimumUpdatePeriodTimeout_ = null, a.trigger("minimumUpdatePeriod"), a.createMUPTimeout_(i);
    }, i);
  }, r.refreshXml_ = function() {
    var i = this;
    this.requestMaster_(function(a, s) {
      s && (i.media_ && (i.media_ = i.masterPlaylistLoader_.master.playlists[i.media_.id]), i.masterPlaylistLoader_.sidxMapping_ = bD(
        i.masterPlaylistLoader_.master,
        i.masterPlaylistLoader_.sidxMapping_
      ), i.addSidxSegments_(
        i.media(),
        i.state,
        function(o) {
          i.refreshMedia_(i.media().id);
        }
      ));
    });
  }, r.refreshMedia_ = function(i) {
    var a = this;
    if (!i)
      throw new Error("refreshMedia_ must take a media id");
    this.media_ && this.isMaster_ && this.handleMaster_();
    var s = this.masterPlaylistLoader_.master.playlists, o = !this.media_ || this.media_ !== s[i];
    if (o ? this.media_ = s[i] : this.trigger("playlistunchanged"), !this.mediaUpdateTimeout) {
      var u = function l() {
        a.media().endList || (a.mediaUpdateTimeout = j.setTimeout(
          function() {
            a.trigger("mediaupdatetimeout"), l();
          },
          pd(a.media(), !!o)
        ));
      };
      u();
    }
    this.trigger("loadedplaylist");
  }, t;
}(pD), Pr = {
  BACK_BUFFER_LENGTH: 30,
  // A fudge factor to apply to advertised playlist bitrates to account for
  // temporary flucations in client bandwidth
  BANDWIDTH_VARIANCE: 1.2,
  // If the buffer is greater than the high water line, we won't switch down
  BUFFER_HIGH_WATER_LINE: 30,
  // How much of the buffer must be filled before we consider upswitching
  BUFFER_LOW_WATER_LINE: 0,
  BUFFER_LOW_WATER_LINE_RATE: 1,
  // TODO: Remove this when experimentalBufferBasedABR is removed
  EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
  GOAL_BUFFER_LENGTH: 30,
  GOAL_BUFFER_LENGTH_RATE: 1,
  // 0.5 MB/s
  INITIAL_BANDWIDTH: 4194304,
  MAX_BUFFER_LOW_WATER_LINE: 30,
  MAX_GOAL_BUFFER_LENGTH: 60
}, xD = function(t) {
  for (var r = new Uint8Array(new ArrayBuffer(t.length)), n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r.buffer;
}, eb = function(t) {
  return t.on = t.addEventListener, t.off = t.removeEventListener, t;
}, AD = function(t) {
  try {
    return URL.createObjectURL(
      new Blob([t], {
        type: "application/javascript"
      })
    );
  } catch {
    var r = new BlobBuilder();
    return r.append(t), URL.createObjectURL(r.getBlob());
  }
}, tb = function(t) {
  return function() {
    var r = AD(t), n = eb(new Worker(r));
    n.objURL = r;
    var i = n.terminate;
    return n.on = n.addEventListener, n.off = n.removeEventListener, n.terminate = function() {
      return URL.revokeObjectURL(r), i.call(this);
    }, n;
  };
}, rb = function(t) {
  return "var browserWorkerPolyFill = " + eb.toString() + `;
browserWorkerPolyFill(self);
` + t;
}, ib = function(t) {
  return t.toString().replace(/^function.+?{/, "").slice(0, -1);
}, TD = rb(
  ib(function() {
    var e = function() {
      this.init = function() {
        var m = {};
        this.on = function(y, g) {
          m[y] || (m[y] = []), m[y] = m[y].concat(g);
        }, this.off = function(y, g) {
          var b;
          return m[y] ? (b = m[y].indexOf(g), m[y] = m[y].slice(), m[y].splice(b, 1), b > -1) : !1;
        }, this.trigger = function(y) {
          var g, b, w, S;
          if (g = m[y], !!g)
            if (arguments.length === 2)
              for (w = g.length, b = 0; b < w; ++b)
                g[b].call(this, arguments[1]);
            else {
              for (S = [], b = arguments.length, b = 1; b < arguments.length; ++b)
                S.push(arguments[b]);
              for (w = g.length, b = 0; b < w; ++b)
                g[b].apply(this, S);
            }
        }, this.dispose = function() {
          m = {};
        };
      };
    };
    e.prototype.pipe = function(P) {
      return this.on("data", function(m) {
        P.push(m);
      }), this.on("done", function(m) {
        P.flush(m);
      }), this.on("partialdone", function(m) {
        P.partialFlush(m);
      }), this.on("endedtimeline", function(m) {
        P.endTimeline(m);
      }), this.on("reset", function(m) {
        P.reset(m);
      }), P;
    }, e.prototype.push = function(P) {
      this.trigger("data", P);
    }, e.prototype.flush = function(P) {
      this.trigger("done", P);
    }, e.prototype.partialFlush = function(P) {
      this.trigger("partialdone", P);
    }, e.prototype.endTimeline = function(P) {
      this.trigger("endedtimeline", P);
    }, e.prototype.reset = function(P) {
      this.trigger("reset", P);
    };
    var t = e, r = Math.pow(2, 32), n = function(m) {
      var y = new DataView(m.buffer, m.byteOffset, m.byteLength), g;
      return y.getBigUint64 ? (g = y.getBigUint64(0), g < Number.MAX_SAFE_INTEGER ? Number(g) : g) : y.getUint32(0) * r + y.getUint32(4);
    }, i = {
      MAX_UINT32: r,
      getUint64: n
    }, a = i.MAX_UINT32, s, o, u, l, c, h, f, d, p, _, v, x, E, M, C, R, B, k, F, I, H, Q, ee, oe, de, he, fe, V, G, se, re, Ce, K, xe, pe, Re;
    (function() {
      var P;
      if (ee = {
        avc1: [],
        // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        // codingname
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        smhd: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        styp: [],
        tfdt: [],
        tfhd: [],
        tkhd: [],
        traf: [],
        trak: [],
        trex: [],
        trun: [],
        vmhd: []
      }, !(typeof Uint8Array > "u")) {
        for (P in ee)
          ee.hasOwnProperty(P) && (ee[P] = [
            P.charCodeAt(0),
            P.charCodeAt(1),
            P.charCodeAt(2),
            P.charCodeAt(3)
          ]);
        oe = new Uint8Array([
          105,
          115,
          111,
          109
        ]), he = new Uint8Array([
          97,
          118,
          99,
          49
        ]), de = new Uint8Array([0, 0, 0, 1]), fe = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          // pre_defined
          118,
          105,
          100,
          101,
          // handler_type: 'vide'
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          86,
          105,
          100,
          101,
          111,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
          // name: 'VideoHandler'
        ]), V = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          // pre_defined
          115,
          111,
          117,
          110,
          // handler_type: 'soun'
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          83,
          111,
          117,
          110,
          100,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
          // name: 'SoundHandler'
        ]), G = {
          audio: V,
          video: fe
        }, Ce = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          1,
          // entry_count
          0,
          0,
          0,
          12,
          // entry_size
          117,
          114,
          108,
          32,
          // 'url' type
          0,
          // version 0
          0,
          0,
          1
          // entry_flags
        ]), re = new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          0,
          0,
          // balance, 0 means centered
          0,
          0
          // reserved
        ]), K = new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0
          // entry_count
        ]), xe = K, pe = new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          // sample_size
          0,
          0,
          0,
          0
          // sample_count
        ]), Re = K, se = new Uint8Array([
          0,
          // version
          0,
          0,
          1,
          // flags
          0,
          0,
          // graphicsmode
          0,
          0,
          0,
          0,
          0,
          0
          // opcolor
        ]);
      }
    })(), s = function(m) {
      var y = [], g = 0, b, w, S;
      for (b = 1; b < arguments.length; b++)
        y.push(arguments[b]);
      for (b = y.length; b--; )
        g += y[b].byteLength;
      for (w = new Uint8Array(g + 8), S = new DataView(w.buffer, w.byteOffset, w.byteLength), S.setUint32(0, w.byteLength), w.set(m, 4), b = 0, g = 8; b < y.length; b++)
        w.set(y[b], g), g += y[b].byteLength;
      return w;
    }, o = function() {
      return s(ee.dinf, s(ee.dref, Ce));
    }, u = function(m) {
      return s(
        ee.esds,
        new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          // ES_Descriptor
          3,
          // tag, ES_DescrTag
          25,
          // length
          0,
          0,
          // ES_ID
          0,
          // streamDependenceFlag, URL_flag, reserved, streamPriority
          // DecoderConfigDescriptor
          4,
          // tag, DecoderConfigDescrTag
          17,
          // length
          64,
          // object type
          21,
          // streamType
          0,
          6,
          0,
          // bufferSizeDB
          0,
          0,
          218,
          192,
          // maxBitrate
          0,
          0,
          218,
          192,
          // avgBitrate
          // DecoderSpecificInfo
          5,
          // tag, DecoderSpecificInfoTag
          2,
          // length
          // ISO/IEC 14496-3, AudioSpecificConfig
          // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
          m.audioobjecttype << 3 | m.samplingfrequencyindex >>> 1,
          m.samplingfrequencyindex << 7 | m.channelcount << 3,
          6,
          1,
          2
          // GASpecificConfig
        ])
      );
    }, l = function() {
      return s(
        ee.ftyp,
        oe,
        de,
        oe,
        he
      );
    }, R = function(m) {
      return s(ee.hdlr, G[m]);
    }, c = function(m) {
      return s(ee.mdat, m);
    }, C = function(m) {
      var y = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        2,
        // creation_time
        0,
        0,
        0,
        3,
        // modification_time
        0,
        1,
        95,
        144,
        // timescale, 90,000 "ticks" per second
        m.duration >>> 24 & 255,
        m.duration >>> 16 & 255,
        m.duration >>> 8 & 255,
        m.duration & 255,
        // duration
        85,
        196,
        // 'und' language (undetermined)
        0,
        0
      ]);
      return m.samplerate && (y[12] = m.samplerate >>> 24 & 255, y[13] = m.samplerate >>> 16 & 255, y[14] = m.samplerate >>> 8 & 255, y[15] = m.samplerate & 255), s(ee.mdhd, y);
    }, M = function(m) {
      return s(ee.mdia, C(m), R(m.type), f(m));
    }, h = function(m) {
      return s(
        ee.mfhd,
        new Uint8Array([
          0,
          0,
          0,
          0,
          // flags
          (m & 4278190080) >> 24,
          (m & 16711680) >> 16,
          (m & 65280) >> 8,
          m & 255
          // sequence_number
        ])
      );
    }, f = function(m) {
      return s(
        ee.minf,
        m.type === "video" ? s(ee.vmhd, se) : s(ee.smhd, re),
        o(),
        k(m)
      );
    }, d = function(m, y) {
      for (var g = [], b = y.length; b--; )
        g[b] = I(y[b]);
      return s.apply(
        null,
        [ee.moof, h(m)].concat(g)
      );
    }, p = function(m) {
      for (var y = m.length, g = []; y--; )
        g[y] = x(m[y]);
      return s.apply(
        null,
        [ee.moov, v(4294967295)].concat(g).concat(_(m))
      );
    }, _ = function(m) {
      for (var y = m.length, g = []; y--; )
        g[y] = H(m[y]);
      return s.apply(null, [ee.mvex].concat(g));
    }, v = function(m) {
      var y = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1,
        // creation_time
        0,
        0,
        0,
        2,
        // modification_time
        0,
        1,
        95,
        144,
        // timescale, 90,000 "ticks" per second
        (m & 4278190080) >> 24,
        (m & 16711680) >> 16,
        (m & 65280) >> 8,
        m & 255,
        // duration
        0,
        1,
        0,
        0,
        // 1.0 rate
        1,
        0,
        // 1.0 volume
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        // transformation: unity matrix
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        255,
        255,
        255,
        255
        // next_track_ID
      ]);
      return s(ee.mvhd, y);
    }, B = function(m) {
      var y = m.samples || [], g = new Uint8Array(4 + y.length), b, w;
      for (w = 0; w < y.length; w++)
        b = y[w].flags, g[w + 4] = b.dependsOn << 4 | b.isDependedOn << 2 | b.hasRedundancy;
      return s(ee.sdtp, g);
    }, k = function(m) {
      return s(
        ee.stbl,
        F(m),
        s(ee.stts, Re),
        s(ee.stsc, xe),
        s(ee.stsz, pe),
        s(ee.stco, K)
      );
    }, function() {
      var P, m;
      F = function(g) {
        return s(
          ee.stsd,
          new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            1
          ]),
          g.type === "video" ? P(g) : m(g)
        );
      }, P = function(g) {
        var b = g.sps || [], w = g.pps || [], S = [], N = [], q, $;
        for (q = 0; q < b.length; q++)
          S.push((b[q].byteLength & 65280) >>> 8), S.push(b[q].byteLength & 255), S = S.concat(
            Array.prototype.slice.call(b[q])
          );
        for (q = 0; q < w.length; q++)
          N.push((w[q].byteLength & 65280) >>> 8), N.push(w[q].byteLength & 255), N = N.concat(
            Array.prototype.slice.call(w[q])
          );
        if ($ = [
          ee.avc1,
          new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            // data_reference_index
            0,
            0,
            // pre_defined
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // pre_defined
            (g.width & 65280) >> 8,
            g.width & 255,
            // width
            (g.height & 65280) >> 8,
            g.height & 255,
            // height
            0,
            72,
            0,
            0,
            // horizresolution
            0,
            72,
            0,
            0,
            // vertresolution
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            // frame_count
            19,
            118,
            105,
            100,
            101,
            111,
            106,
            115,
            45,
            99,
            111,
            110,
            116,
            114,
            105,
            98,
            45,
            104,
            108,
            115,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // compressorname
            0,
            24,
            // depth = 24
            17,
            17
            // pre_defined = -1
          ]),
          s(
            ee.avcC,
            new Uint8Array(
              [
                1,
                // configurationVersion
                g.profileIdc,
                // AVCProfileIndication
                g.profileCompatibility,
                // profile_compatibility
                g.levelIdc,
                // AVCLevelIndication
                255
                // lengthSizeMinusOne, hard-coded to 4 bytes
              ].concat(
                [b.length],
                // numOfSequenceParameterSets
                S,
                // "SPS"
                [w.length],
                // numOfPictureParameterSets
                N
                // "PPS"
              )
            )
          ),
          s(
            ee.btrt,
            new Uint8Array([
              0,
              28,
              156,
              128,
              // bufferSizeDB
              0,
              45,
              198,
              192,
              // maxBitrate
              0,
              45,
              198,
              192
              // avgBitrate
            ])
          )
        ], g.sarRatio) {
          var Y = g.sarRatio[0], te = g.sarRatio[1];
          $.push(
            s(
              ee.pasp,
              new Uint8Array([
                (Y & 4278190080) >> 24,
                (Y & 16711680) >> 16,
                (Y & 65280) >> 8,
                Y & 255,
                (te & 4278190080) >> 24,
                (te & 16711680) >> 16,
                (te & 65280) >> 8,
                te & 255
              ])
            )
          );
        }
        return s.apply(null, $);
      }, m = function(g) {
        return s(
          ee.mp4a,
          new Uint8Array([
            // SampleEntry, ISO/IEC 14496-12
            0,
            0,
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            // data_reference_index
            // AudioSampleEntry, ISO/IEC 14496-12
            0,
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            // reserved
            (g.channelcount & 65280) >> 8,
            g.channelcount & 255,
            // channelcount
            (g.samplesize & 65280) >> 8,
            g.samplesize & 255,
            // samplesize
            0,
            0,
            // pre_defined
            0,
            0,
            // reserved
            (g.samplerate & 65280) >> 8,
            g.samplerate & 255,
            0,
            0
            // samplerate, 16.16
            // MP4AudioSampleEntry, ISO/IEC 14496-14
          ]),
          u(g)
        );
      };
    }(), E = function(m) {
      var y = new Uint8Array([
        0,
        // version 0
        0,
        0,
        7,
        // flags
        0,
        0,
        0,
        0,
        // creation_time
        0,
        0,
        0,
        0,
        // modification_time
        (m.id & 4278190080) >> 24,
        (m.id & 16711680) >> 16,
        (m.id & 65280) >> 8,
        m.id & 255,
        // track_ID
        0,
        0,
        0,
        0,
        // reserved
        (m.duration & 4278190080) >> 24,
        (m.duration & 16711680) >> 16,
        (m.duration & 65280) >> 8,
        m.duration & 255,
        // duration
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        // layer
        0,
        0,
        // alternate_group
        1,
        0,
        // non-audio track volume
        0,
        0,
        // reserved
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        // transformation: unity matrix
        (m.width & 65280) >> 8,
        m.width & 255,
        0,
        0,
        // width
        (m.height & 65280) >> 8,
        m.height & 255,
        0,
        0
        // height
      ]);
      return s(ee.tkhd, y);
    }, I = function(m) {
      var y, g, b, w, S, N, q;
      return y = s(
        ee.tfhd,
        new Uint8Array([
          0,
          // version 0
          0,
          0,
          58,
          // flags
          (m.id & 4278190080) >> 24,
          (m.id & 16711680) >> 16,
          (m.id & 65280) >> 8,
          m.id & 255,
          // track_ID
          0,
          0,
          0,
          1,
          // sample_description_index
          0,
          0,
          0,
          0,
          // default_sample_duration
          0,
          0,
          0,
          0,
          // default_sample_size
          0,
          0,
          0,
          0
          // default_sample_flags
        ])
      ), N = Math.floor(
        m.baseMediaDecodeTime / a
      ), q = Math.floor(
        m.baseMediaDecodeTime % a
      ), g = s(
        ee.tfdt,
        new Uint8Array([
          1,
          // version 1
          0,
          0,
          0,
          // flags
          // baseMediaDecodeTime
          N >>> 24 & 255,
          N >>> 16 & 255,
          N >>> 8 & 255,
          N & 255,
          q >>> 24 & 255,
          q >>> 16 & 255,
          q >>> 8 & 255,
          q & 255
        ])
      ), S = 92, m.type === "audio" ? (b = Q(m, S), s(
        ee.traf,
        y,
        g,
        b
      )) : (w = B(m), b = Q(
        m,
        w.length + S
      ), s(
        ee.traf,
        y,
        g,
        b,
        w
      ));
    }, x = function(m) {
      return m.duration = m.duration || 4294967295, s(ee.trak, E(m), M(m));
    }, H = function(m) {
      var y = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        (m.id & 4278190080) >> 24,
        (m.id & 16711680) >> 16,
        (m.id & 65280) >> 8,
        m.id & 255,
        // track_ID
        0,
        0,
        0,
        1,
        // default_sample_description_index
        0,
        0,
        0,
        0,
        // default_sample_duration
        0,
        0,
        0,
        0,
        // default_sample_size
        0,
        1,
        0,
        1
        // default_sample_flags
      ]);
      return m.type !== "video" && (y[y.length - 1] = 0), s(ee.trex, y);
    }, function() {
      var P, m, y;
      y = function(b, w) {
        var S = 0, N = 0, q = 0, $ = 0;
        return b.length && (b[0].duration !== void 0 && (S = 1), b[0].size !== void 0 && (N = 2), b[0].flags !== void 0 && (q = 4), b[0].compositionTimeOffset !== void 0 && ($ = 8)), [
          0,
          // version 0
          0,
          S | N | q | $,
          1,
          // flags
          (b.length & 4278190080) >>> 24,
          (b.length & 16711680) >>> 16,
          (b.length & 65280) >>> 8,
          b.length & 255,
          // sample_count
          (w & 4278190080) >>> 24,
          (w & 16711680) >>> 16,
          (w & 65280) >>> 8,
          w & 255
          // data_offset
        ];
      }, m = function(b, w) {
        var S, N, q, $, Y, te;
        for ($ = b.samples || [], w += 20 + 16 * $.length, q = y($, w), N = new Uint8Array(q.length + $.length * 16), N.set(q), S = q.length, te = 0; te < $.length; te++)
          Y = $[te], N[S++] = (Y.duration & 4278190080) >>> 24, N[S++] = (Y.duration & 16711680) >>> 16, N[S++] = (Y.duration & 65280) >>> 8, N[S++] = Y.duration & 255, N[S++] = (Y.size & 4278190080) >>> 24, N[S++] = (Y.size & 16711680) >>> 16, N[S++] = (Y.size & 65280) >>> 8, N[S++] = Y.size & 255, N[S++] = Y.flags.isLeading << 2 | Y.flags.dependsOn, N[S++] = Y.flags.isDependedOn << 6 | Y.flags.hasRedundancy << 4 | Y.flags.paddingValue << 1 | Y.flags.isNonSyncSample, N[S++] = Y.flags.degradationPriority & 61440, N[S++] = Y.flags.degradationPriority & 15, N[S++] = (Y.compositionTimeOffset & 4278190080) >>> 24, N[S++] = (Y.compositionTimeOffset & 16711680) >>> 16, N[S++] = (Y.compositionTimeOffset & 65280) >>> 8, N[S++] = Y.compositionTimeOffset & 255;
        return s(ee.trun, N);
      }, P = function(b, w) {
        var S, N, q, $, Y, te;
        for ($ = b.samples || [], w += 20 + 8 * $.length, q = y($, w), S = new Uint8Array(q.length + $.length * 8), S.set(q), N = q.length, te = 0; te < $.length; te++)
          Y = $[te], S[N++] = (Y.duration & 4278190080) >>> 24, S[N++] = (Y.duration & 16711680) >>> 16, S[N++] = (Y.duration & 65280) >>> 8, S[N++] = Y.duration & 255, S[N++] = (Y.size & 4278190080) >>> 24, S[N++] = (Y.size & 16711680) >>> 16, S[N++] = (Y.size & 65280) >>> 8, S[N++] = Y.size & 255;
        return s(ee.trun, S);
      }, Q = function(b, w) {
        return b.type === "audio" ? P(b, w) : m(b, w);
      };
    }();
    var _e = {
      ftyp: l,
      initSegment: function(m) {
        var y = l(), g = p(m), b;
        return b = new Uint8Array(y.byteLength + g.byteLength), b.set(y), b.set(g, y.byteLength), b;
      },
      mdat: c,
      moof: d,
      moov: p
    }, Le = function(m) {
      var y, g, b = [], w = [];
      for (w.byteLength = 0, w.nalCount = 0, w.duration = 0, b.byteLength = 0, y = 0; y < m.length; y++)
        g = m[y], g.nalUnitType === "access_unit_delimiter_rbsp" ? (b.length && (b.duration = g.dts - b.dts, w.byteLength += b.byteLength, w.nalCount += b.length, w.duration += b.duration, w.push(b)), b = [g], b.byteLength = g.data.byteLength, b.pts = g.pts, b.dts = g.dts) : (g.nalUnitType === "slice_layer_without_partitioning_rbsp_idr" && (b.keyFrame = !0), b.duration = g.dts - b.dts, b.byteLength += g.data.byteLength, b.push(g));
      return w.length && (!b.duration || b.duration <= 0) && (b.duration = w[w.length - 1].duration), w.byteLength += b.byteLength, w.nalCount += b.length, w.duration += b.duration, w.push(b), w;
    }, He = function(m) {
      var y, g, b = [], w = [];
      for (b.byteLength = 0, b.nalCount = 0, b.duration = 0, b.pts = m[0].pts, b.dts = m[0].dts, w.byteLength = 0, w.nalCount = 0, w.duration = 0, w.pts = m[0].pts, w.dts = m[0].dts, y = 0; y < m.length; y++)
        g = m[y], g.keyFrame ? (b.length && (w.push(b), w.byteLength += b.byteLength, w.nalCount += b.nalCount, w.duration += b.duration), b = [g], b.nalCount = g.length, b.byteLength = g.byteLength, b.pts = g.pts, b.dts = g.dts, b.duration = g.duration) : (b.duration += g.duration, b.nalCount += g.length, b.byteLength += g.byteLength, b.push(g));
      return w.length && b.duration <= 0 && (b.duration = w[w.length - 1].duration), w.byteLength += b.byteLength, w.nalCount += b.nalCount, w.duration += b.duration, w.push(b), w;
    }, dt = function(m) {
      var y;
      return !m[0][0].keyFrame && m.length > 1 && (y = m.shift(), m.byteLength -= y.byteLength, m.nalCount -= y.nalCount, m[0][0].dts = y.dts, m[0][0].pts = y.pts, m[0][0].duration += y.duration), m;
    }, Ee = function() {
      return {
        flags: {
          degradationPriority: 0,
          dependsOn: 1,
          hasRedundancy: 0,
          isDependedOn: 0,
          isLeading: 0,
          isNonSyncSample: 1
        },
        size: 0
      };
    }, ct = function(m, y) {
      var g = Ee();
      return g.dataOffset = y, g.compositionTimeOffset = m.pts - m.dts, g.duration = m.duration, g.size = 4 * m.length, g.size += m.byteLength, m.keyFrame && (g.flags.dependsOn = 2, g.flags.isNonSyncSample = 0), g;
    }, Bt = function(m, y) {
      var g, b, w, S, N, q = y || 0, $ = [];
      for (g = 0; g < m.length; g++)
        for (S = m[g], b = 0; b < S.length; b++)
          N = S[b], w = ct(N, q), q += w.size, $.push(w);
      return $;
    }, Mt = function(m) {
      var y, g, b, w, S, N, q = 0, $ = m.byteLength, Y = m.nalCount, te = $ + 4 * Y, ce = new Uint8Array(te), De = new DataView(ce.buffer);
      for (y = 0; y < m.length; y++)
        for (w = m[y], g = 0; g < w.length; g++)
          for (S = w[g], b = 0; b < S.length; b++)
            N = S[b], De.setUint32(q, N.data.byteLength), q += 4, ce.set(N.data, q), q += N.data.byteLength;
      return ce;
    }, Ht = function(m, y) {
      var g, b = y || 0, w = [];
      return g = ct(m, b), w.push(g), w;
    }, yt = function(m) {
      var y, g, b = 0, w = m.byteLength, S = m.length, N = w + 4 * S, q = new Uint8Array(N), $ = new DataView(q.buffer);
      for (y = 0; y < m.length; y++)
        g = m[y], $.setUint32(b, g.data.byteLength), b += 4, q.set(g.data, b), b += g.data.byteLength;
      return q;
    }, Gt = {
      concatenateNalData: Mt,
      concatenateNalDataForFrame: yt,
      extendFirstKeyFrame: dt,
      generateSampleTable: Bt,
      generateSampleTableForFrame: Ht,
      groupFramesIntoGops: He,
      groupNalsIntoFrames: Le
    }, Et = [33, 16, 5, 32, 164, 27], gi = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252], xt = function(m) {
      for (var y = []; m--; )
        y.push(0);
      return y;
    }, cr = function(m) {
      return Object.keys(m).reduce(function(y, g) {
        return y[g] = new Uint8Array(
          m[g].reduce(function(b, w) {
            return b.concat(w);
          }, [])
        ), y;
      }, {});
    }, Vt, yi = function() {
      if (!Vt) {
        var m = {
          11025: [
            gi,
            xt(268),
            [3, 127, 248],
            xt(268),
            [6, 255, 240],
            xt(268),
            [13, 255, 224],
            xt(268),
            [27, 255, 192],
            xt(268),
            [55, 175, 128],
            xt(108),
            [112]
          ],
          12e3: [
            gi,
            xt(268),
            [3, 127, 248],
            xt(268),
            [6, 255, 240],
            xt(268),
            [13, 255, 224],
            xt(268),
            [27, 253, 128],
            xt(259),
            [56]
          ],
          16e3: [
            Et,
            [255, 192],
            xt(268),
            [55, 255, 128],
            xt(268),
            [111, 255],
            xt(269),
            [223, 108],
            xt(195),
            [1, 192]
          ],
          24e3: [
            Et,
            [255, 192],
            xt(268),
            [55, 255, 128],
            xt(268),
            [111, 112],
            xt(126),
            [224]
          ],
          32e3: [
            Et,
            [255, 192],
            xt(268),
            [55, 234],
            xt(226),
            [112]
          ],
          44100: [
            Et,
            [255, 192],
            xt(268),
            [55, 163, 128],
            xt(84),
            [112]
          ],
          48e3: [
            Et,
            [255, 192],
            xt(268),
            [55, 148, 128],
            xt(54),
            [112]
          ],
          64e3: [Et, [248, 192], xt(240), [56]],
          88200: [Et, [231], xt(170), [56]],
          8e3: [gi, xt(268), [3, 121, 16], xt(47), [7]],
          96e3: [Et, [227, 64], xt(154), [56]]
        };
        Vt = cr(m);
      }
      return Vt;
    }, gr = 9e4, ar, ae, Pe, Ie, Ze, Fe, st;
    ar = function(m) {
      return m * gr;
    }, ae = function(m, y) {
      return m * y;
    }, Pe = function(m) {
      return m / gr;
    }, Ie = function(m, y) {
      return m / y;
    }, Ze = function(m, y) {
      return ar(Ie(m, y));
    }, Fe = function(m, y) {
      return ae(Pe(m), y);
    }, st = function(m, y, g) {
      return Pe(
        g ? m : m - y
      );
    };
    var Ne = {
      ONE_SECOND_IN_TS: gr,
      audioTsToSeconds: Ie,
      audioTsToVideoTs: Ze,
      metadataTsToSeconds: st,
      secondsToAudioTs: ae,
      secondsToVideoTs: ar,
      videoTsToAudioTs: Fe,
      videoTsToSeconds: Pe
    }, mt = function(m) {
      var y, g, b = 0;
      for (y = 0; y < m.length; y++)
        g = m[y], b += g.data.byteLength;
      return b;
    }, Rt = function(m, y, g, b) {
      var w, S = 0, N = 0, q = 0, $ = 0, Y, te, ce;
      if (y.length && (w = Ne.audioTsToVideoTs(
        m.baseMediaDecodeTime,
        m.samplerate
      ), S = Math.ceil(
        Ne.ONE_SECOND_IN_TS / (m.samplerate / 1024)
      ), g && b && (N = w - Math.max(g, b), q = Math.floor(N / S), $ = q * S), !(q < 1 || $ > Ne.ONE_SECOND_IN_TS / 2))) {
        for (Y = yi()[m.samplerate], Y || (Y = y[0].data), te = 0; te < q; te++)
          ce = y[0], y.splice(0, 0, {
            data: Y,
            dts: ce.dts - S,
            pts: ce.pts - S
          });
        return m.baseMediaDecodeTime -= Math.floor(
          Ne.videoTsToAudioTs($, m.samplerate)
        ), $;
      }
    }, ht = function(m, y, g) {
      return y.minSegmentDts >= g ? m : (y.minSegmentDts = 1 / 0, m.filter(function(b) {
        return b.dts >= g ? (y.minSegmentDts = Math.min(y.minSegmentDts, b.dts), y.minSegmentPts = y.minSegmentDts, !0) : !1;
      }));
    }, Ct = function(m) {
      var y, g, b = [];
      for (y = 0; y < m.length; y++)
        g = m[y], b.push({
          duration: 1024,
          size: g.data.byteLength
          // For AAC audio, all samples contain 1024 samples
        });
      return b;
    }, Lt = function(m) {
      var y, g, b = 0, w = new Uint8Array(mt(m));
      for (y = 0; y < m.length; y++)
        g = m[y], w.set(g.data, b), b += g.data.byteLength;
      return w;
    }, wt = {
      concatenateFrameData: Lt,
      generateSampleTable: Ct,
      prefixWithSilence: Rt,
      trimAdtsFramesByEarliestDts: ht
    }, _t = Ne.ONE_SECOND_IN_TS, Fi = function(m, y) {
      typeof y.pts == "number" && (m.timelineStartInfo.pts === void 0 && (m.timelineStartInfo.pts = y.pts), m.minSegmentPts === void 0 ? m.minSegmentPts = y.pts : m.minSegmentPts = Math.min(m.minSegmentPts, y.pts), m.maxSegmentPts === void 0 ? m.maxSegmentPts = y.pts : m.maxSegmentPts = Math.max(m.maxSegmentPts, y.pts)), typeof y.dts == "number" && (m.timelineStartInfo.dts === void 0 && (m.timelineStartInfo.dts = y.dts), m.minSegmentDts === void 0 ? m.minSegmentDts = y.dts : m.minSegmentDts = Math.min(m.minSegmentDts, y.dts), m.maxSegmentDts === void 0 ? m.maxSegmentDts = y.dts : m.maxSegmentDts = Math.max(m.maxSegmentDts, y.dts));
    }, ni = function(m) {
      delete m.minSegmentDts, delete m.maxSegmentDts, delete m.minSegmentPts, delete m.maxSegmentPts;
    }, ra = function(m, y) {
      var g, b, w = m.minSegmentDts;
      return y || (w -= m.timelineStartInfo.dts), g = m.timelineStartInfo.baseMediaDecodeTime, g += w, g = Math.max(0, g), m.type === "audio" && (b = m.samplerate / _t, g *= b, g = Math.floor(g)), g;
    }, xr = {
      calculateTrackBaseMediaDecodeTime: ra,
      clearDtsInfo: ni,
      collectDtsInfo: Fi
    }, Xt = 4, an = 128, ia = function(m) {
      for (var y = 0, g = {
        payloadSize: 0,
        payloadType: -1
      }, b = 0, w = 0; y < m.byteLength && m[y] !== an; ) {
        for (; m[y] === 255; )
          b += 255, y++;
        for (b += m[y++]; m[y] === 255; )
          w += 255, y++;
        if (w += m[y++], !g.payload && b === Xt) {
          var S = String.fromCharCode(
            m[y + 3],
            m[y + 4],
            m[y + 5],
            m[y + 6]
          );
          if (S === "GA94") {
            g.payloadType = b, g.payloadSize = w, g.payload = m.subarray(y, y + w);
            break;
          } else
            g.payload = void 0;
        }
        y += w, b = 0, w = 0;
      }
      return g;
    }, ki = function(m) {
      return m.payload[0] !== 181 || (m.payload[1] << 8 | m.payload[2]) !== 49 || String.fromCharCode(
        m.payload[3],
        m.payload[4],
        m.payload[5],
        m.payload[6]
      ) !== "GA94" || m.payload[7] !== 3 ? null : m.payload.subarray(8, m.payload.length - 1);
    }, zo = function(m, y) {
      var g = [], b, w, S, N;
      if (!(y[0] & 64))
        return g;
      for (w = y[0] & 31, b = 0; b < w; b++)
        S = b * 3, N = {
          pts: m,
          type: y[S + 2] & 3
        }, y[S + 2] & 4 && (N.ccData = y[S + 3] << 8 | y[S + 4], g.push(N));
      return g;
    }, _s = function(m) {
      for (var y = m.byteLength, g = [], b = 1, w, S; b < y - 2; )
        m[b] === 0 && m[b + 1] === 0 && m[b + 2] === 3 ? (g.push(b + 2), b += 2) : b++;
      if (g.length === 0)
        return m;
      w = y - g.length, S = new Uint8Array(w);
      var N = 0;
      for (b = 0; b < w; N++, b++)
        N === g[0] && (N++, g.shift()), S[b] = m[N];
      return S;
    }, _i = {
      USER_DATA_REGISTERED_ITU_T_T35: Xt,
      discardEmulationPreventionBytes: _s,
      parseCaptionPackets: zo,
      parseSei: ia,
      parseUserData: ki
    }, Or = function P(m) {
      m = m || {}, P.prototype.init.call(this), this.parse708captions_ = typeof m.parse708captions == "boolean" ? m.parse708captions : !0, this.captionPackets_ = [], this.ccStreams_ = [
        new we(0, 0),
        new we(0, 1),
        new we(1, 0),
        new we(1, 1)
      ], this.parse708captions_ && (this.cc708Stream_ = new W({
        captionServices: m.captionServices
      })), this.reset(), this.ccStreams_.forEach(function(y) {
        y.on("data", this.trigger.bind(this, "data")), y.on("partialdone", this.trigger.bind(this, "partialdone")), y.on("done", this.trigger.bind(this, "done"));
      }, this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on(
        "partialdone",
        this.trigger.bind(this, "partialdone")
      ), this.cc708Stream_.on("done", this.trigger.bind(this, "done")));
    };
    Or.prototype = new t(), Or.prototype.push = function(P) {
      var m, y, g;
      if (P.nalUnitType === "sei_rbsp" && (m = _i.parseSei(P.escapedRBSP), !!m.payload && m.payloadType === _i.USER_DATA_REGISTERED_ITU_T_T35 && (y = _i.parseUserData(m), !!y))) {
        if (P.dts < this.latestDts_) {
          this.ignoreNextEqualDts_ = !0;
          return;
        } else if (P.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
          this.numSameDts_--, this.numSameDts_ || (this.ignoreNextEqualDts_ = !1);
          return;
        }
        g = _i.parseCaptionPackets(
          P.pts,
          y
        ), this.captionPackets_ = this.captionPackets_.concat(g), this.latestDts_ !== P.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = P.dts;
      }
    }, Or.prototype.flushCCStreams = function(P) {
      this.ccStreams_.forEach(function(m) {
        return P === "flush" ? m.flush() : m.partialFlush();
      }, this);
    }, Or.prototype.flushStream = function(P) {
      if (!this.captionPackets_.length) {
        this.flushCCStreams(P);
        return;
      }
      this.captionPackets_.forEach(function(m, y) {
        m.presortIndex = y;
      }), this.captionPackets_.sort(function(m, y) {
        return m.pts === y.pts ? m.presortIndex - y.presortIndex : m.pts - y.pts;
      }), this.captionPackets_.forEach(function(m) {
        m.type < 2 ? this.dispatchCea608Packet(m) : this.dispatchCea708Packet(m);
      }, this), this.captionPackets_.length = 0, this.flushCCStreams(P);
    }, Or.prototype.flush = function() {
      return this.flushStream("flush");
    }, Or.prototype.partialFlush = function() {
      return this.flushStream("partialFlush");
    }, Or.prototype.reset = function() {
      this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach(function(P) {
        P.reset();
      });
    }, Or.prototype.dispatchCea608Packet = function(P) {
      this.setsTextOrXDSActive(P) ? this.activeCea608Channel_[P.type] = null : this.setsChannel1Active(P) ? this.activeCea608Channel_[P.type] = 0 : this.setsChannel2Active(P) && (this.activeCea608Channel_[P.type] = 1), this.activeCea608Channel_[P.type] !== null && this.ccStreams_[(P.type << 1) + this.activeCea608Channel_[P.type]].push(P);
    }, Or.prototype.setsChannel1Active = function(P) {
      return (P.ccData & 30720) === 4096;
    }, Or.prototype.setsChannel2Active = function(P) {
      return (P.ccData & 30720) === 6144;
    }, Or.prototype.setsTextOrXDSActive = function(P) {
      return (P.ccData & 28928) === 256 || (P.ccData & 30974) === 4138 || (P.ccData & 30974) === 6186;
    }, Or.prototype.dispatchCea708Packet = function(P) {
      this.parse708captions_ && this.cc708Stream_.push(P);
    };
    var wn = {
      127: 9834,
      // 
      4128: 32,
      // Transparent Space
      4129: 160,
      // Nob-breaking Transparent Space
      4133: 8230,
      // 
      4138: 352,
      // 
      4140: 338,
      // 
      4144: 9608,
      // 
      4145: 8216,
      // 
      4146: 8217,
      // 
      4147: 8220,
      // 
      4148: 8221,
      // 
      4149: 8226,
      // 
      4153: 8482,
      // 
      4154: 353,
      // 
      4156: 339,
      // 
      4157: 8480,
      // 
      4159: 376,
      // 
      4214: 8539,
      // 
      4215: 8540,
      // 
      4216: 8541,
      // 
      4217: 8542,
      // 
      4218: 9168,
      // 
      4219: 9124,
      // 
      4220: 9123,
      // 
      4221: 9135,
      // 
      4222: 9126,
      // 
      4223: 9121,
      // 
      4256: 12600
      //  (CC char)
    }, Ni = function(m) {
      var y = wn[m] || m;
      return m & 4096 && m === y ? "" : String.fromCharCode(y);
    }, Sn = function(m) {
      return 32 <= m && m <= 127 || 160 <= m && m <= 255;
    }, Zt = function(m) {
      this.windowNum = m, this.reset();
    };
    Zt.prototype.reset = function() {
      this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0;
    }, Zt.prototype.getText = function() {
      return this.rows.join(`
`);
    }, Zt.prototype.clearText = function() {
      this.rows = [""], this.rowIdx = 0;
    }, Zt.prototype.newLine = function(P) {
      for (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow == "function" && this.beforeRowOverflow(P), this.rows.length > 0 && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount; )
        this.rows.shift(), this.rowIdx--;
    }, Zt.prototype.isEmpty = function() {
      return this.rows.length === 0 ? !0 : this.rows.length === 1 ? this.rows[0] === "" : !1;
    }, Zt.prototype.addText = function(P) {
      this.rows[this.rowIdx] += P;
    }, Zt.prototype.backspace = function() {
      if (!this.isEmpty()) {
        var P = this.rows[this.rowIdx];
        this.rows[this.rowIdx] = P.substr(0, P.length - 1);
      }
    };
    var O = function(m, y, g) {
      this.serviceNum = m, this.text = "", this.currentWindow = new Zt(-1), this.windows = [], this.stream = g, typeof y == "string" && this.createTextDecoder(y);
    };
    O.prototype.init = function(P, m) {
      this.startPts = P;
      for (var y = 0; y < 8; y++)
        this.windows[y] = new Zt(y), typeof m == "function" && (this.windows[y].beforeRowOverflow = m);
    }, O.prototype.setCurrentWindow = function(P) {
      this.currentWindow = this.windows[P];
    }, O.prototype.createTextDecoder = function(P) {
      if (typeof TextDecoder > "u")
        this.stream.trigger("log", {
          level: "warn",
          message: "The `encoding` option is unsupported without TextDecoder support"
        });
      else
        try {
          this.textDecoder_ = new TextDecoder(P);
        } catch (m) {
          this.stream.trigger("log", {
            level: "warn",
            message: "TextDecoder could not be created with " + P + " encoding. " + m
          });
        }
    };
    var W = function P(m) {
      m = m || {}, P.prototype.init.call(this);
      var y = this, g = m.captionServices || {}, b = {}, w;
      Object.keys(g).forEach(function(S) {
        w = g[S], /^SERVICE/.test(S) && (b[S] = w.encoding);
      }), this.serviceEncodings = b, this.current708Packet = null, this.services = {}, this.push = function(S) {
        S.type === 3 ? (y.new708Packet(), y.add708Bytes(S)) : (y.current708Packet === null && y.new708Packet(), y.add708Bytes(S));
      };
    };
    W.prototype = new t(), W.prototype.new708Packet = function() {
      this.current708Packet !== null && this.push708Packet(), this.current708Packet = {
        data: [],
        ptsVals: []
      };
    }, W.prototype.add708Bytes = function(P) {
      var m = P.ccData, y = m >>> 8, g = m & 255;
      this.current708Packet.ptsVals.push(P.pts), this.current708Packet.data.push(y), this.current708Packet.data.push(g);
    }, W.prototype.push708Packet = function() {
      var P = this.current708Packet, m = P.data, y = null, g = null, b = 0, w = m[b++];
      for (P.seq = w >> 6, P.sizeCode = w & 63; b < m.length; b++)
        w = m[b++], y = w >> 5, g = w & 31, y === 7 && g > 0 && (w = m[b++], y = w), this.pushServiceBlock(y, b, g), g > 0 && (b += g - 1);
    }, W.prototype.pushServiceBlock = function(P, m, y) {
      var g, b = m, w = this.current708Packet.data, S = this.services[P];
      for (S || (S = this.initService(P, b)); b < m + y && b < w.length; b++)
        g = w[b], Sn(g) ? b = this.handleText(b, S) : g === 24 ? b = this.multiByteCharacter(b, S) : g === 16 ? b = this.extendedCommands(b, S) : 128 <= g && g <= 135 ? b = this.setCurrentWindow(b, S) : 152 <= g && g <= 159 ? b = this.defineWindow(b, S) : g === 136 ? b = this.clearWindows(b, S) : g === 140 ? b = this.deleteWindows(b, S) : g === 137 ? b = this.displayWindows(b, S) : g === 138 ? b = this.hideWindows(b, S) : g === 139 ? b = this.toggleWindows(b, S) : g === 151 ? b = this.setWindowAttributes(b, S) : g === 144 ? b = this.setPenAttributes(b, S) : g === 145 ? b = this.setPenColor(b, S) : g === 146 ? b = this.setPenLocation(b, S) : g === 143 ? S = this.reset(b, S) : g === 8 ? S.currentWindow.backspace() : g === 12 ? S.currentWindow.clearText() : g === 13 ? S.currentWindow.pendingNewLine = !0 : g === 14 ? S.currentWindow.clearText() : g === 141 && b++;
    }, W.prototype.extendedCommands = function(P, m) {
      var y = this.current708Packet.data, g = y[++P];
      return Sn(g) && (P = this.handleText(P, m, {
        isExtended: !0
      })), P;
    }, W.prototype.getPts = function(P) {
      return this.current708Packet.ptsVals[Math.floor(P / 2)];
    }, W.prototype.initService = function(P, m) {
      var g = "SERVICE" + P, y = this, g, b;
      return g in this.serviceEncodings && (b = this.serviceEncodings[g]), this.services[P] = new O(P, b, y), this.services[P].init(this.getPts(m), function(w) {
        y.flushDisplayed(w, y.services[P]);
      }), this.services[P];
    }, W.prototype.handleText = function(P, m, y) {
      var g = y && y.isExtended, b = y && y.isMultiByte, w = this.current708Packet.data, S = g ? 4096 : 0, N = w[P], q = w[P + 1], $ = m.currentWindow, Y, te;
      return m.textDecoder_ && !g ? (b ? (te = [N, q], P++) : te = [N], Y = m.textDecoder_.decode(new Uint8Array(te))) : Y = Ni(S | N), $.pendingNewLine && !$.isEmpty() && $.newLine(this.getPts(P)), $.pendingNewLine = !1, $.addText(Y), P;
    }, W.prototype.multiByteCharacter = function(P, m) {
      var y = this.current708Packet.data, g = y[P + 1], b = y[P + 2];
      return Sn(g) && Sn(b) && (P = this.handleText(++P, m, {
        isMultiByte: !0
      })), P;
    }, W.prototype.setCurrentWindow = function(P, m) {
      var y = this.current708Packet.data, g = y[P], b = g & 7;
      return m.setCurrentWindow(b), P;
    }, W.prototype.defineWindow = function(P, m) {
      var y = this.current708Packet.data, g = y[P], b = g & 7;
      m.setCurrentWindow(b);
      var w = m.currentWindow;
      return g = y[++P], w.visible = (g & 32) >> 5, w.rowLock = (g & 16) >> 4, w.columnLock = (g & 8) >> 3, w.priority = g & 7, g = y[++P], w.relativePositioning = (g & 128) >> 7, w.anchorVertical = g & 127, g = y[++P], w.anchorHorizontal = g, g = y[++P], w.anchorPoint = (g & 240) >> 4, w.rowCount = g & 15, g = y[++P], w.columnCount = g & 63, g = y[++P], w.windowStyle = (g & 56) >> 3, w.penStyle = g & 7, w.virtualRowCount = w.rowCount + 1, P;
    }, W.prototype.setWindowAttributes = function(P, m) {
      var y = this.current708Packet.data, g = y[P], b = m.currentWindow.winAttr;
      return g = y[++P], b.fillOpacity = (g & 192) >> 6, b.fillRed = (g & 48) >> 4, b.fillGreen = (g & 12) >> 2, b.fillBlue = g & 3, g = y[++P], b.borderType = (g & 192) >> 6, b.borderRed = (g & 48) >> 4, b.borderGreen = (g & 12) >> 2, b.borderBlue = g & 3, g = y[++P], b.borderType += (g & 128) >> 5, b.wordWrap = (g & 64) >> 6, b.printDirection = (g & 48) >> 4, b.scrollDirection = (g & 12) >> 2, b.justify = g & 3, g = y[++P], b.effectSpeed = (g & 240) >> 4, b.effectDirection = (g & 12) >> 2, b.displayEffect = g & 3, P;
    }, W.prototype.flushDisplayed = function(P, m) {
      for (var y = [], g = 0; g < 8; g++)
        m.windows[g].visible && !m.windows[g].isEmpty() && y.push(m.windows[g].getText());
      m.endPts = P, m.text = y.join(`

`), this.pushCaption(m), m.startPts = P;
    }, W.prototype.pushCaption = function(P) {
      P.text !== "" && (this.trigger("data", {
        endPts: P.endPts,
        startPts: P.startPts,
        stream: "cc708_" + P.serviceNum,
        text: P.text
      }), P.text = "", P.startPts = P.endPts);
    }, W.prototype.displayWindows = function(P, m) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, m);
      for (var w = 0; w < 8; w++)
        g & 1 << w && (m.windows[w].visible = 1);
      return P;
    }, W.prototype.hideWindows = function(P, m) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, m);
      for (var w = 0; w < 8; w++)
        g & 1 << w && (m.windows[w].visible = 0);
      return P;
    }, W.prototype.toggleWindows = function(P, m) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, m);
      for (var w = 0; w < 8; w++)
        g & 1 << w && (m.windows[w].visible ^= 1);
      return P;
    }, W.prototype.clearWindows = function(P, m) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, m);
      for (var w = 0; w < 8; w++)
        g & 1 << w && m.windows[w].clearText();
      return P;
    }, W.prototype.deleteWindows = function(P, m) {
      var y = this.current708Packet.data, g = y[++P], b = this.getPts(P);
      this.flushDisplayed(b, m);
      for (var w = 0; w < 8; w++)
        g & 1 << w && m.windows[w].reset();
      return P;
    }, W.prototype.setPenAttributes = function(P, m) {
      var y = this.current708Packet.data, g = y[P], b = m.currentWindow.penAttr;
      return g = y[++P], b.textTag = (g & 240) >> 4, b.offset = (g & 12) >> 2, b.penSize = g & 3, g = y[++P], b.italics = (g & 128) >> 7, b.underline = (g & 64) >> 6, b.edgeType = (g & 56) >> 3, b.fontStyle = g & 7, P;
    }, W.prototype.setPenColor = function(P, m) {
      var y = this.current708Packet.data, g = y[P], b = m.currentWindow.penColor;
      return g = y[++P], b.fgOpacity = (g & 192) >> 6, b.fgRed = (g & 48) >> 4, b.fgGreen = (g & 12) >> 2, b.fgBlue = g & 3, g = y[++P], b.bgOpacity = (g & 192) >> 6, b.bgRed = (g & 48) >> 4, b.bgGreen = (g & 12) >> 2, b.bgBlue = g & 3, g = y[++P], b.edgeRed = (g & 48) >> 4, b.edgeGreen = (g & 12) >> 2, b.edgeBlue = g & 3, P;
    }, W.prototype.setPenLocation = function(P, m) {
      var y = this.current708Packet.data, g = y[P], b = m.currentWindow.penLoc;
      return m.currentWindow.pendingNewLine = !0, g = y[++P], b.row = g & 15, g = y[++P], b.column = g & 63, P;
    }, W.prototype.reset = function(P, m) {
      var y = this.getPts(P);
      return this.flushDisplayed(y, m), this.initService(m.serviceNum, P);
    };
    var J = {
      // 
      123: 231,
      // 
      124: 247,
      // 
      125: 209,
      42: 225,
      // 
      126: 241,
      // 
      // 
      92: 233,
      // 
      127: 9608,
      // 
      // 
      94: 237,
      // 
      304: 174,
      95: 243,
      // 
      305: 176,
      // 
      306: 189,
      96: 250,
      // 
      307: 191,
      // 
      308: 8482,
      // 
      309: 162,
      // 
      310: 163,
      // 
      311: 9834,
      // 
      312: 224,
      // 
      313: 160,
      //
      314: 232,
      // 
      315: 226,
      // 
      316: 234,
      // 
      317: 238,
      // 
      318: 244,
      // 
      319: 251,
      // 
      544: 193,
      // 
      545: 201,
      // 
      546: 211,
      // 
      547: 218,
      // 
      548: 220,
      // 
      549: 252,
      // 
      550: 8216,
      // 
      551: 161,
      // 
      552: 42,
      // *
      553: 39,
      // '
      554: 8212,
      // 
      555: 169,
      // 
      556: 8480,
      // 
      557: 8226,
      // 
      558: 8220,
      // 
      559: 8221,
      // 
      560: 192,
      // 
      561: 194,
      // 
      562: 199,
      // 
      563: 200,
      // 
      564: 202,
      // 
      565: 203,
      // 
      566: 235,
      // 
      567: 206,
      // 
      568: 207,
      // 
      569: 239,
      // 
      570: 212,
      // 
      571: 217,
      // 
      572: 249,
      // 
      573: 219,
      // 
      574: 171,
      // 
      575: 187,
      // 
      800: 195,
      // 
      801: 227,
      // 
      802: 205,
      // 
      803: 204,
      // 
      804: 236,
      // 
      805: 210,
      // 
      806: 242,
      // 
      807: 213,
      // 
      808: 245,
      // 
      809: 123,
      // {
      810: 125,
      // }
      811: 92,
      // \
      812: 94,
      // ^
      813: 95,
      // _
      814: 124,
      // |
      815: 126,
      // ~
      816: 196,
      // 
      817: 228,
      // 
      818: 214,
      // 
      819: 246,
      // 
      820: 223,
      // 
      821: 165,
      // 
      822: 164,
      // 
      823: 9474,
      // 
      824: 197,
      // 
      825: 229,
      // 
      826: 216,
      // 
      827: 248,
      // 
      828: 9484,
      // 
      829: 9488,
      // 
      830: 9492,
      // 
      831: 9496
      // 
    }, ge = function(m) {
      return m === null ? "" : (m = J[m] || m, String.fromCharCode(m));
    }, Me = 14, We = [
      4352,
      4384,
      4608,
      4640,
      5376,
      5408,
      5632,
      5664,
      5888,
      5920,
      4096,
      4864,
      4896,
      5120,
      5152
    ], Ke = function() {
      for (var m = [], y = Me + 1; y--; )
        m.push("");
      return m;
    }, we = function P(m, y) {
      P.prototype.init.call(this), this.field_ = m || 0, this.dataChannel_ = y || 0, this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1), this.setConstants(), this.reset(), this.push = function(g) {
        var b, w, S, N, q;
        if (b = g.ccData & 32639, b === this.lastControlCode_) {
          this.lastControlCode_ = null;
          return;
        }
        if ((b & 61440) === 4096 ? this.lastControlCode_ = b : b !== this.PADDING_ && (this.lastControlCode_ = null), S = b >>> 8, N = b & 255, b !== this.PADDING_)
          if (b === this.RESUME_CAPTION_LOADING_)
            this.mode_ = "popOn";
          else if (b === this.END_OF_CAPTION_)
            this.mode_ = "popOn", this.clearFormatting(g.pts), this.flushDisplayed(g.pts), w = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = w, this.startPts_ = g.pts;
          else if (b === this.ROLL_UP_2_ROWS_)
            this.rollUpRows_ = 2, this.setRollUp(g.pts);
          else if (b === this.ROLL_UP_3_ROWS_)
            this.rollUpRows_ = 3, this.setRollUp(g.pts);
          else if (b === this.ROLL_UP_4_ROWS_)
            this.rollUpRows_ = 4, this.setRollUp(g.pts);
          else if (b === this.CARRIAGE_RETURN_)
            this.clearFormatting(g.pts), this.flushDisplayed(g.pts), this.shiftRowsUp_(), this.startPts_ = g.pts;
          else if (b === this.BACKSPACE_)
            this.mode_ === "popOn" ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(
              0,
              -1
            ) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(
              0,
              -1
            );
          else if (b === this.ERASE_DISPLAYED_MEMORY_)
            this.flushDisplayed(g.pts), this.displayed_ = Ke();
          else if (b === this.ERASE_NON_DISPLAYED_MEMORY_)
            this.nonDisplayed_ = Ke();
          else if (b === this.RESUME_DIRECT_CAPTIONING_)
            this.mode_ !== "paintOn" && (this.flushDisplayed(g.pts), this.displayed_ = Ke()), this.mode_ = "paintOn", this.startPts_ = g.pts;
          else if (this.isSpecialCharacter(S, N))
            S = (S & 3) << 8, q = ge(S | N), this[this.mode_](g.pts, q), this.column_++;
          else if (this.isExtCharacter(S, N))
            this.mode_ === "popOn" ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(
              0,
              -1
            ) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(
              0,
              -1
            ), S = (S & 3) << 8, q = ge(S | N), this[this.mode_](g.pts, q), this.column_++;
          else if (this.isMidRowCode(S, N))
            this.clearFormatting(g.pts), this[this.mode_](g.pts, " "), this.column_++, (N & 14) === 14 && this.addFormatting(g.pts, ["i"]), (N & 1) === 1 && this.addFormatting(g.pts, ["u"]);
          else if (this.isOffsetControlCode(S, N))
            this.column_ += N & 3;
          else if (this.isPAC(S, N)) {
            var $ = We.indexOf(b & 7968);
            this.mode_ === "rollUp" && ($ - this.rollUpRows_ + 1 < 0 && ($ = this.rollUpRows_ - 1), this.setRollUp(g.pts, $)), $ !== this.row_ && (this.clearFormatting(g.pts), this.row_ = $), N & 1 && this.formatting_.indexOf("u") === -1 && this.addFormatting(g.pts, ["u"]), (b & 16) === 16 && (this.column_ = ((b & 14) >> 1) * 4), this.isColorPAC(N) && (N & 14) === 14 && this.addFormatting(g.pts, ["i"]);
          } else this.isNormalChar(S) && (N === 0 && (N = null), q = ge(S), q += ge(N), this[this.mode_](g.pts, q), this.column_ += q.length);
      };
    };
    we.prototype = new t(), we.prototype.flushDisplayed = function(P) {
      var m = this.displayed_.map(function(y, g) {
        try {
          return y.trim();
        } catch {
          return this.trigger("log", {
            level: "warn",
            message: "Skipping a malformed 608 caption at index " + g + "."
          }), "";
        }
      }, this).join(`
`).replace(/^\n+|\n+$/g, "");
      m.length && this.trigger("data", {
        endPts: P,
        startPts: this.startPts_,
        stream: this.name_,
        text: m
      });
    }, we.prototype.reset = function() {
      this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = Ke(), this.nonDisplayed_ = Ke(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = Me, this.rollUpRows_ = 2, this.formatting_ = [];
    }, we.prototype.setConstants = function() {
      this.dataChannel_ === 0 ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : this.dataChannel_ === 1 && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32, this.END_OF_CAPTION_ = this.CONTROL_ | 47, this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37, this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38, this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39, this.CARRIAGE_RETURN_ = this.CONTROL_ | 45, this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41, this.BACKSPACE_ = this.CONTROL_ | 33, this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44, this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
    }, we.prototype.isSpecialCharacter = function(P, m) {
      return P === this.EXT_ && m >= 48 && m <= 63;
    }, we.prototype.isExtCharacter = function(P, m) {
      return (P === this.EXT_ + 1 || P === this.EXT_ + 2) && m >= 32 && m <= 63;
    }, we.prototype.isMidRowCode = function(P, m) {
      return P === this.EXT_ && m >= 32 && m <= 47;
    }, we.prototype.isOffsetControlCode = function(P, m) {
      return P === this.OFFSET_ && m >= 33 && m <= 35;
    }, we.prototype.isPAC = function(P, m) {
      return P >= this.BASE_ && P < this.BASE_ + 8 && m >= 64 && m <= 127;
    }, we.prototype.isColorPAC = function(P) {
      return P >= 64 && P <= 79 || P >= 96 && P <= 127;
    }, we.prototype.isNormalChar = function(P) {
      return P >= 32 && P <= 127;
    }, we.prototype.setRollUp = function(P, m) {
      if (this.mode_ !== "rollUp" && (this.row_ = Me, this.mode_ = "rollUp", this.flushDisplayed(P), this.nonDisplayed_ = Ke(), this.displayed_ = Ke()), m !== void 0 && m !== this.row_)
        for (var y = 0; y < this.rollUpRows_; y++)
          this.displayed_[m - y] = this.displayed_[this.row_ - y], this.displayed_[this.row_ - y] = "";
      m === void 0 && (m = this.row_), this.topRow_ = m - this.rollUpRows_ + 1;
    }, we.prototype.addFormatting = function(P, m) {
      this.formatting_ = this.formatting_.concat(m);
      var y = m.reduce(function(g, b) {
        return g + "<" + b + ">";
      }, "");
      this[this.mode_](P, y);
    }, we.prototype.clearFormatting = function(P) {
      if (this.formatting_.length) {
        var m = this.formatting_.reverse().reduce(function(y, g) {
          return y + "</" + g + ">";
        }, "");
        this.formatting_ = [], this[this.mode_](P, m);
      }
    }, we.prototype.popOn = function(P, m) {
      var y = this.nonDisplayed_[this.row_];
      y += m, this.nonDisplayed_[this.row_] = y;
    }, we.prototype.rollUp = function(P, m) {
      var y = this.displayed_[this.row_];
      y += m, this.displayed_[this.row_] = y;
    }, we.prototype.shiftRowsUp_ = function() {
      var P;
      for (P = 0; P < this.topRow_; P++)
        this.displayed_[P] = "";
      for (P = this.row_ + 1; P < Me + 1; P++)
        this.displayed_[P] = "";
      for (P = this.topRow_; P < this.row_; P++)
        this.displayed_[P] = this.displayed_[P + 1];
      this.displayed_[this.row_] = "";
    }, we.prototype.paintOn = function(P, m) {
      var y = this.displayed_[this.row_];
      y += m, this.displayed_[this.row_] = y;
    };
    var et = {
      CaptionStream: Or,
      Cea608Stream: we,
      Cea708Stream: W
    }, nt = {
      ADTS_STREAM_TYPE: 15,
      H264_STREAM_TYPE: 27,
      METADATA_STREAM_TYPE: 21
    }, rt = 8589934592, Tt = 4294967296, Qe = "shared", Dt = function(m, y) {
      var g = 1;
      for (m > y && (g = -1); Math.abs(y - m) > Tt; )
        m += g * rt;
      return m;
    }, bt = function P(m) {
      var y, g;
      P.prototype.init.call(this), this.type_ = m || Qe, this.push = function(b) {
        this.type_ !== Qe && b.type !== this.type_ || (g === void 0 && (g = b.dts), b.dts = Dt(b.dts, g), b.pts = Dt(b.pts, g), y = b.dts, this.trigger("data", b));
      }, this.flush = function() {
        g = y, this.trigger("done");
      }, this.endTimeline = function() {
        this.flush(), this.trigger("endedtimeline");
      }, this.discontinuity = function() {
        g = void 0, y = void 0;
      }, this.reset = function() {
        this.discontinuity(), this.trigger("reset");
      };
    };
    bt.prototype = new t();
    var Jt = {
      TimestampRolloverStream: bt,
      handleRollover: Dt
    }, hr = function(m, y, g) {
      var b, w = "";
      for (b = y; b < g; b++)
        w += "%" + ("00" + m[b].toString(16)).slice(-2);
      return w;
    }, Nr = function(m, y, g) {
      return decodeURIComponent(hr(m, y, g));
    }, Cr = function(m, y, g) {
      return unescape(hr(m, y, g));
    }, sn = function(m) {
      return m[0] << 21 | m[1] << 14 | m[2] << 7 | m[3];
    }, na = {
      PRIV: function(m) {
        var y;
        for (y = 0; y < m.data.length; y++)
          if (m.data[y] === 0) {
            m.owner = Cr(m.data, 0, y);
            break;
          }
        m.privateData = m.data.subarray(y + 1), m.data = m.privateData;
      },
      TXXX: function(m) {
        var y;
        if (m.data[0] === 3) {
          for (y = 1; y < m.data.length; y++)
            if (m.data[y] === 0) {
              m.description = Nr(m.data, 1, y), m.value = Nr(m.data, y + 1, m.data.length).replace(
                /\0*$/,
                ""
              );
              break;
            }
          m.data = m.value;
        }
      },
      WXXX: function(m) {
        var y;
        if (m.data[0] === 3) {
          for (y = 1; y < m.data.length; y++)
            if (m.data[y] === 0) {
              m.description = Nr(m.data, 1, y), m.url = Nr(m.data, y + 1, m.data.length);
              break;
            }
        }
      }
    }, aa;
    aa = function(m) {
      var y = {
        // the bytes of the program-level descriptor field in MP2T
        // see ISO/IEC 13818-1:2013 (E), section 2.6 "Program and
        // program element descriptors"
        descriptor: m && m.descriptor
      }, g = 0, b = [], w = 0, S;
      if (aa.prototype.init.call(this), this.dispatchType = nt.METADATA_STREAM_TYPE.toString(16), y.descriptor)
        for (S = 0; S < y.descriptor.length; S++)
          this.dispatchType += ("00" + y.descriptor[S].toString(16)).slice(-2);
      this.push = function(N) {
        var q, $, Y, te, ce, De;
        if (N.type === "timed-metadata") {
          if (N.dataAlignmentIndicator && (w = 0, b.length = 0), b.length === 0 && (N.data.length < 10 || N.data[0] !== 73 || N.data[1] !== 68 || N.data[2] !== 51)) {
            this.trigger("log", {
              level: "warn",
              message: "Skipping unrecognized metadata packet"
            });
            return;
          }
          if (b.push(N), w += N.data.byteLength, b.length === 1 && (g = sn(N.data.subarray(6, 10)), g += 10), !(w < g)) {
            for (q = {
              data: new Uint8Array(g),
              dts: b[0].dts,
              frames: [],
              pts: b[0].pts
            }, ce = 0; ce < g; )
              q.data.set(b[0].data.subarray(0, g - ce), ce), ce += b[0].data.byteLength, w -= b[0].data.byteLength, b.shift();
            $ = 10, q.data[5] & 64 && ($ += 4, $ += sn(q.data.subarray(10, 14)), g -= sn(q.data.subarray(16, 20)));
            do {
              if (Y = sn(
                q.data.subarray($ + 4, $ + 8)
              ), Y < 1) {
                this.trigger("log", {
                  level: "warn",
                  message: "Malformed ID3 frame encountered. Skipping metadata parsing."
                });
                return;
              }
              if (De = String.fromCharCode(
                q.data[$],
                q.data[$ + 1],
                q.data[$ + 2],
                q.data[$ + 3]
              ), te = {
                data: q.data.subarray(
                  $ + 10,
                  $ + Y + 10
                ),
                id: De
              }, te.key = te.id, na[te.id] && (na[te.id](te), te.owner === "com.apple.streaming.transportStreamTimestamp")) {
                var Ue = te.data, Ae = (Ue[3] & 1) << 30 | Ue[4] << 22 | Ue[5] << 14 | Ue[6] << 6 | Ue[7] >>> 2;
                Ae *= 4, Ae += Ue[7] & 3, te.timeStamp = Ae, q.pts === void 0 && q.dts === void 0 && (q.pts = te.timeStamp, q.dts = te.timeStamp), this.trigger("timestamp", te);
              }
              q.frames.push(te), $ += 10, $ += Y;
            } while ($ < g);
            this.trigger("data", q);
          }
        }
      };
    }, aa.prototype = new t();
    var sa = aa, It = Jt.TimestampRolloverStream, bs, on, er, A = 188, T = 71;
    bs = function() {
      var m = new Uint8Array(A), y = 0;
      bs.prototype.init.call(this), this.push = function(g) {
        var b = 0, w = A, S;
        for (y ? (S = new Uint8Array(g.byteLength + y), S.set(m.subarray(0, y)), S.set(g, y), y = 0) : S = g; w < S.byteLength; ) {
          if (S[b] === T && S[w] === T) {
            this.trigger("data", S.subarray(b, w)), b += A, w += A;
            continue;
          }
          b++, w++;
        }
        b < S.byteLength && (m.set(S.subarray(b), 0), y = S.byteLength - b);
      }, this.flush = function() {
        y === A && m[0] === T && (this.trigger("data", m), y = 0), this.trigger("done");
      }, this.endTimeline = function() {
        this.flush(), this.trigger("endedtimeline");
      }, this.reset = function() {
        y = 0, this.trigger("reset");
      };
    }, bs.prototype = new t(), on = function() {
      var m, y, g, b;
      on.prototype.init.call(this), b = this, this.packetsWaitingForPmt = [], this.programMapTable = void 0, m = function(S, N) {
        var q = 0;
        N.payloadUnitStartIndicator && (q += S[q] + 1), N.type === "pat" ? y(S.subarray(q), N) : g(S.subarray(q), N);
      }, y = function(S, N) {
        N.section_number = S[7], N.last_section_number = S[8], b.pmtPid = (S[10] & 31) << 8 | S[11], N.pmtPid = b.pmtPid;
      }, g = function(S, N) {
        var q, $, Y, te;
        if (S[5] & 1) {
          for (b.programMapTable = {
            audio: null,
            "timed-metadata": {},
            video: null
          }, q = (S[1] & 15) << 8 | S[2], $ = 3 + q - 4, Y = (S[10] & 15) << 8 | S[11], te = 12 + Y; te < $; ) {
            var ce = S[te], De = (S[te + 1] & 31) << 8 | S[te + 2];
            ce === nt.H264_STREAM_TYPE && b.programMapTable.video === null ? b.programMapTable.video = De : ce === nt.ADTS_STREAM_TYPE && b.programMapTable.audio === null ? b.programMapTable.audio = De : ce === nt.METADATA_STREAM_TYPE && (b.programMapTable["timed-metadata"][De] = ce), te += ((S[te + 3] & 15) << 8 | S[te + 4]) + 5;
          }
          N.programMapTable = b.programMapTable;
        }
      }, this.push = function(w) {
        var S = {}, N = 4;
        if (S.payloadUnitStartIndicator = !!(w[1] & 64), S.pid = w[1] & 31, S.pid <<= 8, S.pid |= w[2], (w[3] & 48) >>> 4 > 1 && (N += w[N] + 1), S.pid === 0)
          S.type = "pat", m(w.subarray(N), S), this.trigger("data", S);
        else if (S.pid === this.pmtPid)
          for (S.type = "pmt", m(w.subarray(N), S), this.trigger("data", S); this.packetsWaitingForPmt.length; )
            this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
        else this.programMapTable === void 0 ? this.packetsWaitingForPmt.push([w, N, S]) : this.processPes_(w, N, S);
      }, this.processPes_ = function(w, S, N) {
        N.pid === this.programMapTable.video ? N.streamType = nt.H264_STREAM_TYPE : N.pid === this.programMapTable.audio ? N.streamType = nt.ADTS_STREAM_TYPE : N.streamType = this.programMapTable["timed-metadata"][N.pid], N.type = "pes", N.data = w.subarray(S), this.trigger("data", N);
      };
    }, on.prototype = new t(), on.STREAM_TYPES = {
      adts: 15,
      h264: 27
    }, er = function() {
      var m = this, y = !1, g = {
        data: [],
        size: 0
      }, b = {
        data: [],
        size: 0
      }, w = {
        data: [],
        size: 0
      }, S, N = function(Y, te) {
        var ce, De = Y[0] << 16 | Y[1] << 8 | Y[2];
        te.data = new Uint8Array(), De === 1 && (te.packetLength = 6 + (Y[4] << 8 | Y[5]), te.dataAlignmentIndicator = (Y[6] & 4) !== 0, ce = Y[7], ce & 192 && (te.pts = (Y[9] & 14) << 27 | (Y[10] & 255) << 20 | (Y[11] & 254) << 12 | (Y[12] & 255) << 5 | (Y[13] & 254) >>> 3, te.pts *= 4, te.pts += (Y[13] & 6) >>> 1, te.dts = te.pts, ce & 64 && (te.dts = (Y[14] & 14) << 27 | (Y[15] & 255) << 20 | (Y[16] & 254) << 12 | (Y[17] & 255) << 5 | (Y[18] & 254) >>> 3, te.dts *= 4, te.dts += (Y[18] & 6) >>> 1)), te.data = Y.subarray(9 + Y[8]));
      }, q = function(Y, te, ce) {
        var De = new Uint8Array(Y.size), Ue = {
          type: te
        }, Ae = 0, Je = 0, Ar = !1, Kr;
        if (!(!Y.data.length || Y.size < 9)) {
          for (Ue.trackId = Y.data[0].pid, Ae = 0; Ae < Y.data.length; Ae++)
            Kr = Y.data[Ae], De.set(Kr.data, Je), Je += Kr.data.byteLength;
          N(De, Ue), Ar = te === "video" || Ue.packetLength <= Y.size, (ce || Ar) && (Y.size = 0, Y.data.length = 0), Ar && m.trigger("data", Ue);
        }
      };
      er.prototype.init.call(this), this.push = function($) {
        ({
          pat: function() {
          },
          pes: function() {
            var te, ce;
            switch ($.streamType) {
              case nt.H264_STREAM_TYPE:
                te = g, ce = "video";
                break;
              case nt.ADTS_STREAM_TYPE:
                te = b, ce = "audio";
                break;
              case nt.METADATA_STREAM_TYPE:
                te = w, ce = "timed-metadata";
                break;
              default:
                return;
            }
            $.payloadUnitStartIndicator && q(te, ce, !0), te.data.push($), te.size += $.data.byteLength;
          },
          pmt: function() {
            var te = {
              tracks: [],
              type: "metadata"
            };
            S = $.programMapTable, S.video !== null && te.tracks.push({
              codec: "avc",
              id: +S.video,
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              type: "video"
            }), S.audio !== null && te.tracks.push({
              codec: "adts",
              id: +S.audio,
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              type: "audio"
            }), y = !0, m.trigger("data", te);
          }
        })[$.type]();
      }, this.reset = function() {
        g.size = 0, g.data.length = 0, b.size = 0, b.data.length = 0, this.trigger("reset");
      }, this.flushStreams_ = function() {
        q(g, "video"), q(b, "audio"), q(w, "timed-metadata");
      }, this.flush = function() {
        if (!y && S) {
          var $ = {
            tracks: [],
            type: "metadata"
          };
          S.video !== null && $.tracks.push({
            codec: "avc",
            id: +S.video,
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            type: "video"
          }), S.audio !== null && $.tracks.push({
            codec: "adts",
            id: +S.audio,
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            type: "audio"
          }), m.trigger("data", $);
        }
        y = !1, this.flushStreams_(), this.trigger("done");
      };
    }, er.prototype = new t();
    var D = {
      CaptionStream: et.CaptionStream,
      Cea608Stream: et.Cea608Stream,
      Cea708Stream: et.Cea708Stream,
      ElementaryStream: er,
      MP2T_PACKET_LENGTH: A,
      MetadataStream: sa,
      PAT_PID: 0,
      TimestampRolloverStream: It,
      TransportPacketStream: bs,
      TransportParseStream: on
    };
    for (var L in nt)
      nt.hasOwnProperty(L) && (D[L] = nt[L]);
    var U = D, Z = Ne.ONE_SECOND_IN_TS, ie, ve = [
      96e3,
      88200,
      64e3,
      48e3,
      44100,
      32e3,
      24e3,
      22050,
      16e3,
      12e3,
      11025,
      8e3,
      7350
    ];
    ie = function(m) {
      var y, g = 0;
      ie.prototype.init.call(this), this.skipWarn_ = function(b, w) {
        this.trigger("log", {
          level: "warn",
          message: "adts skiping bytes " + b + " to " + w + " in frame " + g + " outside syncword"
        });
      }, this.push = function(b) {
        var w = 0, S, N, q, $, Y;
        if (m || (g = 0), b.type === "audio") {
          y && y.length ? (q = y, y = new Uint8Array(
            q.byteLength + b.data.byteLength
          ), y.set(q), y.set(b.data, q.byteLength)) : y = b.data;
          for (var te; w + 7 < y.length; ) {
            if (y[w] !== 255 || (y[w + 1] & 246) !== 240) {
              typeof te != "number" && (te = w), w++;
              continue;
            }
            if (typeof te == "number" && (this.skipWarn_(te, w), te = null), N = (~y[w + 1] & 1) * 2, S = (y[w + 3] & 3) << 11 | y[w + 4] << 3 | (y[w + 5] & 224) >> 5, $ = ((y[w + 6] & 3) + 1) * 1024, Y = $ * Z / ve[(y[w + 2] & 60) >>> 2], y.byteLength - w < S)
              break;
            this.trigger("data", {
              audioobjecttype: (y[w + 2] >>> 6 & 3) + 1,
              channelcount: (y[w + 2] & 1) << 2 | (y[w + 3] & 192) >>> 6,
              // data is the frame without it's header
              data: y.subarray(w + 7 + N, w + S),
              dts: b.dts + g * Y,
              pts: b.pts + g * Y,
              sampleCount: $,
              samplerate: ve[(y[w + 2] & 60) >>> 2],
              // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
              samplesize: 16,
              samplingfrequencyindex: (y[w + 2] & 60) >>> 2
            }), g++, w += S;
          }
          typeof te == "number" && (this.skipWarn_(te, w), te = null), y = y.subarray(w);
        }
      }, this.flush = function() {
        g = 0, this.trigger("done");
      }, this.reset = function() {
        y = void 0, this.trigger("reset");
      }, this.endTimeline = function() {
        y = void 0, this.trigger("endedtimeline");
      };
    }, ie.prototype = new t();
    var me = ie, ne;
    ne = function(m) {
      var y = m.byteLength, g = 0, b = 0;
      this.length = function() {
        return 8 * y;
      }, this.bitsAvailable = function() {
        return 8 * y + b;
      }, this.loadWord = function() {
        var w = m.byteLength - y, S = new Uint8Array(4), N = Math.min(4, y);
        if (N === 0)
          throw new Error("no bytes available");
        S.set(
          m.subarray(w, w + N)
        ), g = new DataView(S.buffer).getUint32(0), b = N * 8, y -= N;
      }, this.skipBits = function(w) {
        var S;
        b > w ? (g <<= w, b -= w) : (w -= b, S = Math.floor(w / 8), w -= S * 8, y -= S, this.loadWord(), g <<= w, b -= w);
      }, this.readBits = function(w) {
        var S = Math.min(b, w), N = g >>> 32 - S;
        return b -= S, b > 0 ? g <<= S : y > 0 && this.loadWord(), S = w - S, S > 0 ? N << S | this.readBits(S) : N;
      }, this.skipLeadingZeros = function() {
        var w;
        for (w = 0; w < b; ++w)
          if (g & 2147483648 >>> w)
            return g <<= w, b -= w, w;
        return this.loadWord(), w + this.skipLeadingZeros();
      }, this.skipUnsignedExpGolomb = function() {
        this.skipBits(1 + this.skipLeadingZeros());
      }, this.skipExpGolomb = function() {
        this.skipBits(1 + this.skipLeadingZeros());
      }, this.readUnsignedExpGolomb = function() {
        var w = this.skipLeadingZeros();
        return this.readBits(w + 1) - 1;
      }, this.readExpGolomb = function() {
        var w = this.readUnsignedExpGolomb();
        return 1 & w ? 1 + w >>> 1 : -1 * (w >>> 1);
      }, this.readBoolean = function() {
        return this.readBits(1) === 1;
      }, this.readUnsignedByte = function() {
        return this.readBits(8);
      }, this.loadWord();
    };
    var le = ne, be, Ve, qe;
    Ve = function() {
      var m = 0, y, g;
      Ve.prototype.init.call(this), this.push = function(b) {
        var w;
        g ? (w = new Uint8Array(g.byteLength + b.data.byteLength), w.set(g), w.set(b.data, g.byteLength), g = w) : g = b.data;
        for (var S = g.byteLength; m < S - 3; m++)
          if (g[m + 2] === 1) {
            y = m + 5;
            break;
          }
        for (; y < S; )
          switch (g[y]) {
            case 0:
              if (g[y - 1] !== 0) {
                y += 2;
                break;
              } else if (g[y - 2] !== 0) {
                y++;
                break;
              }
              m + 3 !== y - 2 && this.trigger("data", g.subarray(m + 3, y - 2));
              do
                y++;
              while (g[y] !== 1 && y < S);
              m = y - 2, y += 3;
              break;
            case 1:
              if (g[y - 1] !== 0 || g[y - 2] !== 0) {
                y += 3;
                break;
              }
              this.trigger("data", g.subarray(m + 3, y - 2)), m = y - 2, y += 3;
              break;
            default:
              y += 3;
              break;
          }
        g = g.subarray(m), y -= m, m = 0;
      }, this.reset = function() {
        g = null, m = 0, this.trigger("reset");
      }, this.flush = function() {
        g && g.byteLength > 3 && this.trigger("data", g.subarray(m + 3)), g = null, m = 0, this.trigger("done");
      }, this.endTimeline = function() {
        this.flush(), this.trigger("endedtimeline");
      };
    }, Ve.prototype = new t(), qe = {
      100: !0,
      110: !0,
      118: !0,
      122: !0,
      128: !0,
      134: !0,
      // TODO: the three profiles below don't
      // appear to have sps data in the specificiation anymore?
      138: !0,
      139: !0,
      244: !0,
      44: !0,
      83: !0,
      86: !0
    }, be = function() {
      var m = new Ve(), y, g, b, w, S, N, q;
      be.prototype.init.call(this), y = this, this.push = function($) {
        $.type === "video" && (g = $.trackId, b = $.pts, w = $.dts, m.push($));
      }, m.on("data", function($) {
        var Y = {
          data: $,
          dts: w,
          nalUnitTypeCode: $[0] & 31,
          pts: b,
          trackId: g
        };
        switch (Y.nalUnitTypeCode) {
          case 5:
            Y.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
            break;
          case 6:
            Y.nalUnitType = "sei_rbsp", Y.escapedRBSP = S(
              $.subarray(1)
            );
            break;
          case 7:
            Y.nalUnitType = "seq_parameter_set_rbsp", Y.escapedRBSP = S(
              $.subarray(1)
            ), Y.config = N(Y.escapedRBSP);
            break;
          case 8:
            Y.nalUnitType = "pic_parameter_set_rbsp";
            break;
          case 9:
            Y.nalUnitType = "access_unit_delimiter_rbsp";
            break;
        }
        y.trigger("data", Y);
      }), m.on("done", function() {
        y.trigger("done");
      }), m.on("partialdone", function() {
        y.trigger("partialdone");
      }), m.on("reset", function() {
        y.trigger("reset");
      }), m.on("endedtimeline", function() {
        y.trigger("endedtimeline");
      }), this.flush = function() {
        m.flush();
      }, this.partialFlush = function() {
        m.partialFlush();
      }, this.reset = function() {
        m.reset();
      }, this.endTimeline = function() {
        m.endTimeline();
      }, q = function(Y, te) {
        var ce = 8, De = 8, Ue, Ae;
        for (Ue = 0; Ue < Y; Ue++)
          De !== 0 && (Ae = te.readExpGolomb(), De = (ce + Ae + 256) % 256), ce = De === 0 ? ce : De;
      }, S = function(Y) {
        for (var te = Y.byteLength, ce = [], De = 1, Ue, Ae; De < te - 2; )
          Y[De] === 0 && Y[De + 1] === 0 && Y[De + 2] === 3 ? (ce.push(De + 2), De += 2) : De++;
        if (ce.length === 0)
          return Y;
        Ue = te - ce.length, Ae = new Uint8Array(Ue);
        var Je = 0;
        for (De = 0; De < Ue; Je++, De++)
          Je === ce[0] && (Je++, ce.shift()), Ae[De] = Y[Je];
        return Ae;
      }, N = function(Y) {
        var te = 0, ce = 0, De = 0, Ue = 0, Ae, Je, Ar, Kr, Ma, zh, Cm, Mm, Dm, Wh, Pm, fr = [1, 1], Lm, Da;
        if (Ae = new le(Y), Je = Ae.readUnsignedByte(), Kr = Ae.readUnsignedByte(), Ar = Ae.readUnsignedByte(), Ae.skipUnsignedExpGolomb(), qe[Je] && (Ma = Ae.readUnsignedExpGolomb(), Ma === 3 && Ae.skipBits(1), Ae.skipUnsignedExpGolomb(), Ae.skipUnsignedExpGolomb(), Ae.skipBits(1), Ae.readBoolean()))
          for (Pm = Ma !== 3 ? 8 : 12, Da = 0; Da < Pm; Da++)
            Ae.readBoolean() && (Da < 6 ? q(16, Ae) : q(64, Ae));
        if (Ae.skipUnsignedExpGolomb(), zh = Ae.readUnsignedExpGolomb(), zh === 0)
          Ae.readUnsignedExpGolomb();
        else if (zh === 1)
          for (Ae.skipBits(1), Ae.skipExpGolomb(), Ae.skipExpGolomb(), Cm = Ae.readUnsignedExpGolomb(), Da = 0; Da < Cm; Da++)
            Ae.skipExpGolomb();
        if (Ae.skipUnsignedExpGolomb(), Ae.skipBits(1), Mm = Ae.readUnsignedExpGolomb(), Dm = Ae.readUnsignedExpGolomb(), Wh = Ae.readBits(1), Wh === 0 && Ae.skipBits(1), Ae.skipBits(1), Ae.readBoolean() && (te = Ae.readUnsignedExpGolomb(), ce = Ae.readUnsignedExpGolomb(), De = Ae.readUnsignedExpGolomb(), Ue = Ae.readUnsignedExpGolomb()), Ae.readBoolean() && Ae.readBoolean()) {
          switch (Lm = Ae.readUnsignedByte(), Lm) {
            case 1:
              fr = [1, 1];
              break;
            case 2:
              fr = [12, 11];
              break;
            case 3:
              fr = [10, 11];
              break;
            case 4:
              fr = [16, 11];
              break;
            case 5:
              fr = [40, 33];
              break;
            case 6:
              fr = [24, 11];
              break;
            case 7:
              fr = [20, 11];
              break;
            case 8:
              fr = [32, 11];
              break;
            case 9:
              fr = [80, 33];
              break;
            case 10:
              fr = [18, 11];
              break;
            case 11:
              fr = [15, 11];
              break;
            case 12:
              fr = [64, 33];
              break;
            case 13:
              fr = [160, 99];
              break;
            case 14:
              fr = [4, 3];
              break;
            case 15:
              fr = [3, 2];
              break;
            case 16:
              fr = [2, 1];
              break;
            case 255: {
              fr = [
                Ae.readUnsignedByte() << 8 | Ae.readUnsignedByte(),
                Ae.readUnsignedByte() << 8 | Ae.readUnsignedByte()
              ];
              break;
            }
          }
          fr && fr[0] / fr[1];
        }
        return {
          height: (2 - Wh) * (Dm + 1) * 16 - De * 2 - Ue * 2,
          levelIdc: Ar,
          profileCompatibility: Kr,
          profileIdc: Je,
          // sar is sample aspect ratio
          sarRatio: fr,
          width: (Mm + 1) * 16 - te * 2 - ce * 2
        };
      };
    }, be.prototype = new t();
    var it = {
      H264Stream: be,
      NalByteStream: Ve
    }, At = [
      96e3,
      88200,
      64e3,
      48e3,
      44100,
      32e3,
      24e3,
      22050,
      16e3,
      12e3,
      11025,
      8e3,
      7350
    ], ot = function(m, y) {
      var g = m[y + 6] << 21 | m[y + 7] << 14 | m[y + 8] << 7 | m[y + 9], b = m[y + 5], w = (b & 16) >> 4;
      return g = g >= 0 ? g : 0, w ? g + 20 : g + 10;
    }, ut = function P(m, y) {
      return m.length - y < 10 || m[y] !== 73 || m[y + 1] !== 68 || m[y + 2] !== 51 ? y : (y += ot(m, y), P(m, y));
    }, zt = function(m) {
      var y = ut(m, 0);
      return m.length >= y + 2 && (m[y] & 255) === 255 && (m[y + 1] & 240) === 240 && // verify that the 2 layer bits are 0, aka this
      // is not mp3 data but aac data.
      (m[y + 1] & 22) === 16;
    }, nr = function(m) {
      return m[0] << 21 | m[1] << 14 | m[2] << 7 | m[3];
    }, yr = function(m, y, g) {
      var b, w = "";
      for (b = y; b < g; b++)
        w += "%" + ("00" + m[b].toString(16)).slice(-2);
      return w;
    }, tr = function(m, y, g) {
      return unescape(yr(m, y, g));
    }, Mr = function(m, y) {
      var g = (m[y + 5] & 224) >> 5, b = m[y + 4] << 3, w = m[y + 3] & 6144;
      return w | b | g;
    }, qr = function(m, y) {
      return m[y] === 73 && m[y + 1] === 68 && m[y + 2] === 51 ? "timed-metadata" : m[y] & !0 && (m[y + 1] & 240) === 240 ? "audio" : null;
    }, Xr = function(m) {
      for (var y = 0; y + 5 < m.length; ) {
        if (m[y] !== 255 || (m[y + 1] & 246) !== 240) {
          y++;
          continue;
        }
        return At[(m[y + 2] & 60) >>> 2];
      }
      return null;
    }, Yr = function(m) {
      var y, g, b, w;
      y = 10, m[5] & 64 && (y += 4, y += nr(m.subarray(10, 14)));
      do {
        if (g = nr(
          m.subarray(y + 4, y + 8)
        ), g < 1)
          return null;
        if (w = String.fromCharCode(
          m[y],
          m[y + 1],
          m[y + 2],
          m[y + 3]
        ), w === "PRIV") {
          b = m.subarray(y + 10, y + g + 10);
          for (var S = 0; S < b.byteLength; S++)
            if (b[S] === 0) {
              var N = tr(b, 0, S);
              if (N === "com.apple.streaming.transportStreamTimestamp") {
                var q = b.subarray(S + 1), $ = (q[3] & 1) << 30 | q[4] << 22 | q[5] << 14 | q[6] << 6 | q[7] >>> 2;
                return $ *= 4, $ += q[7] & 3, $;
              }
              break;
            }
        }
        y += 10, y += g;
      } while (y < m.byteLength);
      return null;
    }, Dr = {
      isLikelyAacData: zt,
      parseAacTimestamp: Yr,
      parseAdtsSize: Mr,
      parseId3TagSize: ot,
      parseSampleRate: Xr,
      parseType: qr
    }, bi;
    bi = function() {
      var m = new Uint8Array(), y = 0;
      bi.prototype.init.call(this), this.setTimestamp = function(g) {
        y = g;
      }, this.push = function(g) {
        var b = 0, w = 0, S, N, q, $;
        for (m.length ? ($ = m.length, m = new Uint8Array(g.byteLength + $), m.set(m.subarray(0, $)), m.set(g, $)) : m = g; m.length - w >= 3; ) {
          if (m[w] === 73 && m[w + 1] === 68 && m[w + 2] === 51) {
            if (m.length - w < 10 || (b = Dr.parseId3TagSize(m, w), w + b > m.length))
              break;
            N = {
              data: m.subarray(w, w + b),
              type: "timed-metadata"
            }, this.trigger("data", N), w += b;
            continue;
          } else if ((m[w] & 255) === 255 && (m[w + 1] & 240) === 240) {
            if (m.length - w < 7 || (b = Dr.parseAdtsSize(m, w), w + b > m.length))
              break;
            q = {
              data: m.subarray(w, w + b),
              dts: y,
              pts: y,
              type: "audio"
            }, this.trigger("data", q), w += b;
            continue;
          }
          w++;
        }
        S = m.length - w, S > 0 ? m = m.subarray(w) : m = new Uint8Array();
      }, this.reset = function() {
        m = new Uint8Array(), this.trigger("reset");
      }, this.endTimeline = function() {
        m = new Uint8Array(), this.trigger("endedtimeline");
      };
    }, bi.prototype = new t();
    var ba = bi, xa = [
      "audioobjecttype",
      "channelcount",
      "samplerate",
      "samplingfrequencyindex",
      "samplesize"
    ], Cn = xa, Aa = [
      "width",
      "height",
      "profileIdc",
      "levelIdc",
      "profileCompatibility",
      "sarRatio"
    ], Mn = Aa, Ta = it.H264Stream, Ea = Dr.isLikelyAacData, wa = Ne.ONE_SECOND_IN_TS, Ui, Li, un, Wt, Eb = function(m, y) {
      y.stream = m, this.trigger("log", y);
    }, hm = function(m, y) {
      for (var g = Object.keys(y), b = 0; b < g.length; b++) {
        var w = g[b];
        w === "headOfPipeline" || !y[w].on || y[w].on("log", Eb.bind(m, w));
      }
    }, fm = function(m, y) {
      var g;
      if (m.length !== y.length)
        return !1;
      for (g = 0; g < m.length; g++)
        if (m[g] !== y[g])
          return !1;
      return !0;
    }, Gh = function(m, y, g, b, w, S) {
      var N = g - y, q = b - y, $ = w - g;
      return {
        baseMediaDecodeTime: m,
        end: {
          dts: m + q,
          pts: m + $
        },
        prependedContentDuration: S,
        start: {
          dts: m,
          pts: m + N
        }
      };
    };
    Li = function(m, y) {
      var g = [], b, w = 0, S = 0, N = 1 / 0;
      y = y || {}, b = y.firstSequenceNumber || 0, Li.prototype.init.call(this), this.push = function(q) {
        xr.collectDtsInfo(m, q), m && Cn.forEach(function($) {
          m[$] = q[$];
        }), g.push(q);
      }, this.setEarliestDts = function(q) {
        w = q;
      }, this.setVideoBaseMediaDecodeTime = function(q) {
        N = q;
      }, this.setAudioAppendStart = function(q) {
        S = q;
      }, this.flush = function() {
        var q, $, Y, te, ce, De, Ue;
        if (g.length === 0) {
          this.trigger("done", "AudioSegmentStream");
          return;
        }
        q = wt.trimAdtsFramesByEarliestDts(
          g,
          m,
          w
        ), m.baseMediaDecodeTime = xr.calculateTrackBaseMediaDecodeTime(
          m,
          y.keepOriginalTimestamps
        ), Ue = wt.prefixWithSilence(
          m,
          q,
          S,
          N
        ), m.samples = wt.generateSampleTable(q), Y = _e.mdat(wt.concatenateFrameData(q)), g = [], $ = _e.moof(b, [m]), te = new Uint8Array($.byteLength + Y.byteLength), b++, te.set($), te.set(Y, $.byteLength), xr.clearDtsInfo(m), ce = Math.ceil(
          wa * 1024 / m.samplerate
        ), q.length && (De = q.length * ce, this.trigger(
          "segmentTimingInfo",
          Gh(
            // The audio track's baseMediaDecodeTime is in audio clock cycles, but the
            // frame info is in video clock cycles. Convert to match expectation of
            // listeners (that all timestamps will be based on video clock cycles).
            Ne.audioTsToVideoTs(
              m.baseMediaDecodeTime,
              m.samplerate
            ),
            // frame times are already in video clock, as is segment duration
            q[0].dts,
            q[0].pts,
            q[0].dts + De,
            q[0].pts + De,
            Ue || 0
          )
        ), this.trigger("timingInfo", {
          end: q[0].pts + De,
          start: q[0].pts
        })), this.trigger("data", {
          boxes: te,
          track: m
        }), this.trigger("done", "AudioSegmentStream");
      }, this.reset = function() {
        xr.clearDtsInfo(m), g = [], this.trigger("reset");
      };
    }, Li.prototype = new t(), Ui = function(m, y) {
      var g, b = [], w = [], S, N;
      y = y || {}, g = y.firstSequenceNumber || 0, Ui.prototype.init.call(this), delete m.minPTS, this.gopCache_ = [], this.push = function(q) {
        xr.collectDtsInfo(m, q), q.nalUnitType === "seq_parameter_set_rbsp" && !S && (S = q.config, m.sps = [q.data], Mn.forEach(function($) {
          m[$] = S[$];
        }, this)), q.nalUnitType === "pic_parameter_set_rbsp" && !N && (N = q.data, m.pps = [q.data]), b.push(q);
      }, this.flush = function() {
        for (var q, $, Y, te, ce, De, Ue = 0, Ae, Je; b.length && b[0].nalUnitType !== "access_unit_delimiter_rbsp"; )
          b.shift();
        if (b.length === 0) {
          this.resetStream_(), this.trigger("done", "VideoSegmentStream");
          return;
        }
        if (q = Gt.groupNalsIntoFrames(b), Y = Gt.groupFramesIntoGops(q), Y[0][0].keyFrame || ($ = this.getGopForFusion_(b[0], m), $ ? (Ue = $.duration, Y.unshift($), Y.byteLength += $.byteLength, Y.nalCount += $.nalCount, Y.pts = $.pts, Y.dts = $.dts, Y.duration += $.duration) : Y = Gt.extendFirstKeyFrame(Y)), w.length) {
          var Ar;
          if (y.alignGopsAtEnd ? Ar = this.alignGopsAtEnd_(Y) : Ar = this.alignGopsAtStart_(Y), !Ar) {
            this.gopCache_.unshift({
              gop: Y.pop(),
              pps: m.pps,
              sps: m.sps
            }), this.gopCache_.length = Math.min(6, this.gopCache_.length), b = [], this.resetStream_(), this.trigger("done", "VideoSegmentStream");
            return;
          }
          xr.clearDtsInfo(m), Y = Ar;
        }
        xr.collectDtsInfo(m, Y), m.samples = Gt.generateSampleTable(Y), ce = _e.mdat(Gt.concatenateNalData(Y)), m.baseMediaDecodeTime = xr.calculateTrackBaseMediaDecodeTime(
          m,
          y.keepOriginalTimestamps
        ), this.trigger(
          "processedGopsInfo",
          Y.map(function(Kr) {
            return {
              byteLength: Kr.byteLength,
              dts: Kr.dts,
              pts: Kr.pts
            };
          })
        ), Ae = Y[0], Je = Y[Y.length - 1], this.trigger(
          "segmentTimingInfo",
          Gh(
            m.baseMediaDecodeTime,
            Ae.dts,
            Ae.pts,
            Je.dts + Je.duration,
            Je.pts + Je.duration,
            Ue
          )
        ), this.trigger("timingInfo", {
          end: Y[Y.length - 1].pts + Y[Y.length - 1].duration,
          start: Y[0].pts
        }), this.gopCache_.unshift({
          gop: Y.pop(),
          pps: m.pps,
          sps: m.sps
        }), this.gopCache_.length = Math.min(6, this.gopCache_.length), b = [], this.trigger("baseMediaDecodeTime", m.baseMediaDecodeTime), this.trigger("timelineStartInfo", m.timelineStartInfo), te = _e.moof(g, [m]), De = new Uint8Array(te.byteLength + ce.byteLength), g++, De.set(te), De.set(ce, te.byteLength), this.trigger("data", {
          boxes: De,
          track: m
        }), this.resetStream_(), this.trigger("done", "VideoSegmentStream");
      }, this.reset = function() {
        this.resetStream_(), b = [], this.gopCache_.length = 0, w.length = 0, this.trigger("reset");
      }, this.resetStream_ = function() {
        xr.clearDtsInfo(m), S = void 0, N = void 0;
      }, this.getGopForFusion_ = function(q) {
        var $ = 45e3, Y = 1e4, te = 1 / 0, ce, De, Ue, Ae, Je;
        for (Je = 0; Je < this.gopCache_.length; Je++)
          Ae = this.gopCache_[Je], Ue = Ae.gop, !(!(m.pps && fm(m.pps[0], Ae.pps[0])) || !(m.sps && fm(m.sps[0], Ae.sps[0]))) && (Ue.dts < m.timelineStartInfo.dts || (ce = q.dts - Ue.dts - Ue.duration, ce >= -Y && ce <= $ && (!De || te > ce) && (De = Ae, te = ce)));
        return De ? De.gop : null;
      }, this.alignGopsAtStart_ = function(q) {
        var $, Y, te, ce, De, Ue, Ae, Je;
        for (De = q.byteLength, Ue = q.nalCount, Ae = q.duration, $ = Y = 0; $ < w.length && Y < q.length && (te = w[$], ce = q[Y], te.pts !== ce.pts); ) {
          if (ce.pts > te.pts) {
            $++;
            continue;
          }
          Y++, De -= ce.byteLength, Ue -= ce.nalCount, Ae -= ce.duration;
        }
        return Y === 0 ? q : Y === q.length ? null : (Je = q.slice(Y), Je.byteLength = De, Je.duration = Ae, Je.nalCount = Ue, Je.pts = Je[0].pts, Je.dts = Je[0].dts, Je);
      }, this.alignGopsAtEnd_ = function(q) {
        var $, Y, te, ce, De, Ue;
        for ($ = w.length - 1, Y = q.length - 1, De = null, Ue = !1; $ >= 0 && Y >= 0; ) {
          if (te = w[$], ce = q[Y], te.pts === ce.pts) {
            Ue = !0;
            break;
          }
          if (te.pts > ce.pts) {
            $--;
            continue;
          }
          $ === w.length - 1 && (De = Y), Y--;
        }
        if (!Ue && De === null)
          return null;
        var Ae;
        if (Ue ? Ae = Y : Ae = De, Ae === 0)
          return q;
        var Je = q.slice(Ae), Ar = Je.reduce(
          function(Kr, Ma) {
            return Kr.byteLength += Ma.byteLength, Kr.duration += Ma.duration, Kr.nalCount += Ma.nalCount, Kr;
          },
          {
            byteLength: 0,
            duration: 0,
            nalCount: 0
          }
        );
        return Je.byteLength = Ar.byteLength, Je.duration = Ar.duration, Je.nalCount = Ar.nalCount, Je.pts = Je[0].pts, Je.dts = Je[0].dts, Je;
      }, this.alignGopsWith = function(q) {
        w = q;
      };
    }, Ui.prototype = new t(), Wt = function(m, y) {
      this.numberOfTracks = 0, this.metadataStream = y, m = m || {}, typeof m.remux < "u" ? this.remuxTracks = !!m.remux : this.remuxTracks = !0, typeof m.keepOriginalTimestamps == "boolean" ? this.keepOriginalTimestamps = m.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, Wt.prototype.init.call(this), this.push = function(g) {
        if (g.text)
          return this.pendingCaptions.push(g);
        if (g.frames)
          return this.pendingMetadata.push(g);
        this.pendingTracks.push(g.track), this.pendingBytes += g.boxes.byteLength, g.track.type === "video" && (this.videoTrack = g.track, this.pendingBoxes.push(g.boxes)), g.track.type === "audio" && (this.audioTrack = g.track, this.pendingBoxes.unshift(g.boxes));
      };
    }, Wt.prototype = new t(), Wt.prototype.flush = function(P) {
      var m = 0, y = {
        captionStreams: {},
        captions: [],
        info: {},
        metadata: []
      }, g, b, w, S = 0, N;
      if (this.pendingTracks.length < this.numberOfTracks) {
        if (P !== "VideoSegmentStream" && P !== "AudioSegmentStream")
          return;
        if (this.remuxTracks)
          return;
        if (this.pendingTracks.length === 0) {
          this.emittedTracks++, this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
          return;
        }
      }
      if (this.videoTrack ? (S = this.videoTrack.timelineStartInfo.pts, Mn.forEach(function(q) {
        y.info[q] = this.videoTrack[q];
      }, this)) : this.audioTrack && (S = this.audioTrack.timelineStartInfo.pts, Cn.forEach(function(q) {
        y.info[q] = this.audioTrack[q];
      }, this)), this.videoTrack || this.audioTrack) {
        for (this.pendingTracks.length === 1 ? y.type = this.pendingTracks[0].type : y.type = "combined", this.emittedTracks += this.pendingTracks.length, w = _e.initSegment(this.pendingTracks), y.initSegment = new Uint8Array(w.byteLength), y.initSegment.set(w), y.data = new Uint8Array(this.pendingBytes), N = 0; N < this.pendingBoxes.length; N++)
          y.data.set(this.pendingBoxes[N], m), m += this.pendingBoxes[N].byteLength;
        for (N = 0; N < this.pendingCaptions.length; N++)
          g = this.pendingCaptions[N], g.startTime = Ne.metadataTsToSeconds(
            g.startPts,
            S,
            this.keepOriginalTimestamps
          ), g.endTime = Ne.metadataTsToSeconds(
            g.endPts,
            S,
            this.keepOriginalTimestamps
          ), y.captionStreams[g.stream] = !0, y.captions.push(g);
        for (N = 0; N < this.pendingMetadata.length; N++)
          b = this.pendingMetadata[N], b.cueTime = Ne.metadataTsToSeconds(
            b.pts,
            S,
            this.keepOriginalTimestamps
          ), y.metadata.push(b);
        for (y.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", y), N = 0; N < y.captions.length; N++)
          g = y.captions[N], this.trigger("caption", g);
        for (N = 0; N < y.metadata.length; N++)
          b = y.metadata[N], this.trigger("id3Frame", b);
      }
      this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
    }, Wt.prototype.setRemux = function(P) {
      this.remuxTracks = P;
    }, un = function(m) {
      var y = this, g = !0, b, w;
      un.prototype.init.call(this), m = m || {}, this.baseMediaDecodeTime = m.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function() {
        var S = {};
        this.transmuxPipeline_ = S, S.type = "aac", S.metadataStream = new U.MetadataStream(), S.aacStream = new ba(), S.audioTimestampRolloverStream = new U.TimestampRolloverStream("audio"), S.timedMetadataTimestampRolloverStream = new U.TimestampRolloverStream("timed-metadata"), S.adtsStream = new me(), S.coalesceStream = new Wt(
          m,
          S.metadataStream
        ), S.headOfPipeline = S.aacStream, S.aacStream.pipe(S.audioTimestampRolloverStream).pipe(S.adtsStream), S.aacStream.pipe(S.timedMetadataTimestampRolloverStream).pipe(S.metadataStream).pipe(S.coalesceStream), S.metadataStream.on("timestamp", function(N) {
          S.aacStream.setTimestamp(N.timeStamp);
        }), S.aacStream.on("data", function(N) {
          N.type !== "timed-metadata" && N.type !== "audio" || S.audioSegmentStream || (w = w || {
            codec: "adts",
            timelineStartInfo: {
              baseMediaDecodeTime: y.baseMediaDecodeTime
            },
            type: "audio"
          }, S.coalesceStream.numberOfTracks++, S.audioSegmentStream = new Li(
            w,
            m
          ), S.audioSegmentStream.on(
            "log",
            y.getLogTrigger_("audioSegmentStream")
          ), S.audioSegmentStream.on(
            "timingInfo",
            y.trigger.bind(y, "audioTimingInfo")
          ), S.adtsStream.pipe(S.audioSegmentStream).pipe(S.coalesceStream), y.trigger("trackinfo", {
            hasAudio: !!w,
            hasVideo: !!b
          }));
        }), S.coalesceStream.on("data", this.trigger.bind(this, "data")), S.coalesceStream.on("done", this.trigger.bind(this, "done")), hm(this, S);
      }, this.setupTsPipeline = function() {
        var S = {};
        this.transmuxPipeline_ = S, S.type = "ts", S.metadataStream = new U.MetadataStream(), S.packetStream = new U.TransportPacketStream(), S.parseStream = new U.TransportParseStream(), S.elementaryStream = new U.ElementaryStream(), S.timestampRolloverStream = new U.TimestampRolloverStream(), S.adtsStream = new me(), S.h264Stream = new Ta(), S.captionStream = new U.CaptionStream(m), S.coalesceStream = new Wt(
          m,
          S.metadataStream
        ), S.headOfPipeline = S.packetStream, S.packetStream.pipe(S.parseStream).pipe(S.elementaryStream).pipe(S.timestampRolloverStream), S.timestampRolloverStream.pipe(S.h264Stream), S.timestampRolloverStream.pipe(S.adtsStream), S.timestampRolloverStream.pipe(S.metadataStream).pipe(S.coalesceStream), S.h264Stream.pipe(S.captionStream).pipe(S.coalesceStream), S.elementaryStream.on("data", function(N) {
          var q;
          if (N.type === "metadata") {
            for (q = N.tracks.length; q--; )
              !b && N.tracks[q].type === "video" ? (b = N.tracks[q], b.timelineStartInfo.baseMediaDecodeTime = y.baseMediaDecodeTime) : !w && N.tracks[q].type === "audio" && (w = N.tracks[q], w.timelineStartInfo.baseMediaDecodeTime = y.baseMediaDecodeTime);
            b && !S.videoSegmentStream && (S.coalesceStream.numberOfTracks++, S.videoSegmentStream = new Ui(
              b,
              m
            ), S.videoSegmentStream.on(
              "log",
              y.getLogTrigger_("videoSegmentStream")
            ), S.videoSegmentStream.on(
              "timelineStartInfo",
              function($) {
                w && !m.keepOriginalTimestamps && (w.timelineStartInfo = $, S.audioSegmentStream.setEarliestDts(
                  $.dts - y.baseMediaDecodeTime
                ));
              }
            ), S.videoSegmentStream.on(
              "processedGopsInfo",
              y.trigger.bind(y, "gopInfo")
            ), S.videoSegmentStream.on(
              "segmentTimingInfo",
              y.trigger.bind(y, "videoSegmentTimingInfo")
            ), S.videoSegmentStream.on(
              "baseMediaDecodeTime",
              function($) {
                w && S.audioSegmentStream.setVideoBaseMediaDecodeTime(
                  $
                );
              }
            ), S.videoSegmentStream.on(
              "timingInfo",
              y.trigger.bind(y, "videoTimingInfo")
            ), S.h264Stream.pipe(S.videoSegmentStream).pipe(S.coalesceStream)), w && !S.audioSegmentStream && (S.coalesceStream.numberOfTracks++, S.audioSegmentStream = new Li(
              w,
              m
            ), S.audioSegmentStream.on(
              "log",
              y.getLogTrigger_("audioSegmentStream")
            ), S.audioSegmentStream.on(
              "timingInfo",
              y.trigger.bind(y, "audioTimingInfo")
            ), S.audioSegmentStream.on(
              "segmentTimingInfo",
              y.trigger.bind(y, "audioSegmentTimingInfo")
            ), S.adtsStream.pipe(S.audioSegmentStream).pipe(S.coalesceStream)), y.trigger("trackinfo", {
              hasAudio: !!w,
              hasVideo: !!b
            });
          }
        }), S.coalesceStream.on("data", this.trigger.bind(this, "data")), S.coalesceStream.on("id3Frame", function(N) {
          N.dispatchType = S.metadataStream.dispatchType, y.trigger("id3Frame", N);
        }), S.coalesceStream.on(
          "caption",
          this.trigger.bind(this, "caption")
        ), S.coalesceStream.on("done", this.trigger.bind(this, "done")), hm(this, S);
      }, this.setBaseMediaDecodeTime = function(S) {
        var N = this.transmuxPipeline_;
        m.keepOriginalTimestamps || (this.baseMediaDecodeTime = S), w && (w.timelineStartInfo.dts = void 0, w.timelineStartInfo.pts = void 0, xr.clearDtsInfo(w), N.audioTimestampRolloverStream && N.audioTimestampRolloverStream.discontinuity()), b && (N.videoSegmentStream && (N.videoSegmentStream.gopCache_ = []), b.timelineStartInfo.dts = void 0, b.timelineStartInfo.pts = void 0, xr.clearDtsInfo(b), N.captionStream.reset()), N.timestampRolloverStream && N.timestampRolloverStream.discontinuity();
      }, this.setAudioAppendStart = function(S) {
        w && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(
          S
        );
      }, this.setRemux = function(S) {
        var N = this.transmuxPipeline_;
        m.remux = S, N && N.coalesceStream && N.coalesceStream.setRemux(S);
      }, this.alignGopsWith = function(S) {
        b && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(
          S
        );
      }, this.getLogTrigger_ = function(S) {
        var N = this;
        return function(q) {
          q.stream = S, N.trigger("log", q);
        };
      }, this.push = function(S) {
        if (g) {
          var N = Ea(S);
          N && this.transmuxPipeline_.type !== "aac" ? this.setupAacPipeline() : !N && this.transmuxPipeline_.type !== "ts" && this.setupTsPipeline(), g = !1;
        }
        this.transmuxPipeline_.headOfPipeline.push(S);
      }, this.flush = function() {
        g = !0, this.transmuxPipeline_.headOfPipeline.flush();
      }, this.endTimeline = function() {
        this.transmuxPipeline_.headOfPipeline.endTimeline();
      }, this.reset = function() {
        this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset();
      }, this.resetCaptions = function() {
        this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset();
      };
    }, un.prototype = new t();
    var wb = {
      AUDIO_PROPERTIES: Cn,
      AudioSegmentStream: Li,
      Transmuxer: un,
      VIDEO_PROPERTIES: Mn,
      VideoSegmentStream: Ui,
      // exported for testing
      generateSegmentTimingInfo: Gh
    }, Sb = function(m) {
      return m >>> 0;
    }, Cb = function(m) {
      return ("00" + m.toString(16)).slice(-2);
    }, Ol = {
      toHexString: Cb,
      toUnsigned: Sb
    }, Mb = function(m) {
      var y = "";
      return y += String.fromCharCode(m[0]), y += String.fromCharCode(m[1]), y += String.fromCharCode(m[2]), y += String.fromCharCode(m[3]), y;
    }, Sa = Mb, Db = Ol.toUnsigned, Pb = function P(m, y) {
      var g = [], b, w, S, N, q;
      if (!y.length)
        return null;
      for (b = 0; b < m.byteLength; )
        w = Db(
          m[b] << 24 | m[b + 1] << 16 | m[b + 2] << 8 | m[b + 3]
        ), S = Sa(m.subarray(b + 4, b + 8)), N = w > 1 ? b + w : m.byteLength, S === y[0] && (y.length === 1 ? g.push(m.subarray(b + 8, N)) : (q = P(m.subarray(b + 8, N), y.slice(1)), q.length && (g = g.concat(q)))), b = N;
      return g;
    }, Qt = Pb, Lb = Ol.toUnsigned, Rb = i.getUint64, Ib = function(m) {
      var y = {
        flags: new Uint8Array(m.subarray(1, 4)),
        version: m[0]
      };
      return y.version === 1 ? y.baseMediaDecodeTime = Rb(m.subarray(4)) : y.baseMediaDecodeTime = Lb(
        m[4] << 24 | m[5] << 16 | m[6] << 8 | m[7]
      ), y;
    }, dm = Ib, Ob = function(m) {
      return {
        degradationPriority: m[2] << 8 | m[3],
        dependsOn: m[0] & 3,
        hasRedundancy: (m[1] & 48) >>> 4,
        isDependedOn: (m[1] & 192) >>> 6,
        isLeading: (m[0] & 12) >>> 2,
        isNonSyncSample: m[1] & 1,
        paddingValue: (m[1] & 14) >>> 1
      };
    }, pm = Ob, Bb = function(m) {
      var y = {
        flags: new Uint8Array(m.subarray(1, 4)),
        samples: [],
        version: m[0]
      }, g = new DataView(m.buffer, m.byteOffset, m.byteLength), b = y.flags[2] & 1, w = y.flags[2] & 4, S = y.flags[1] & 1, N = y.flags[1] & 2, q = y.flags[1] & 4, $ = y.flags[1] & 8, Y = g.getUint32(4), te = 8, ce;
      for (b && (y.dataOffset = g.getInt32(te), te += 4), w && Y && (ce = {
        flags: pm(m.subarray(te, te + 4))
      }, te += 4, S && (ce.duration = g.getUint32(te), te += 4), N && (ce.size = g.getUint32(te), te += 4), $ && (y.version === 1 ? ce.compositionTimeOffset = g.getInt32(te) : ce.compositionTimeOffset = g.getUint32(te), te += 4), y.samples.push(ce), Y--); Y--; )
        ce = {}, S && (ce.duration = g.getUint32(te), te += 4), N && (ce.size = g.getUint32(te), te += 4), q && (ce.flags = pm(m.subarray(te, te + 4)), te += 4), $ && (y.version === 1 ? ce.compositionTimeOffset = g.getInt32(te) : ce.compositionTimeOffset = g.getUint32(te), te += 4), y.samples.push(ce);
      return y;
    }, mm = Bb, Fb = function(m) {
      var y = new DataView(m.buffer, m.byteOffset, m.byteLength), g = {
        flags: new Uint8Array(m.subarray(1, 4)),
        trackId: y.getUint32(4),
        version: m[0]
      }, b = g.flags[2] & 1, w = g.flags[2] & 2, S = g.flags[2] & 8, N = g.flags[2] & 16, q = g.flags[2] & 32, $ = g.flags[0] & 65536, Y = g.flags[0] & 131072, te;
      return te = 8, b && (te += 4, g.baseDataOffset = y.getUint32(12), te += 4), w && (g.sampleDescriptionIndex = y.getUint32(te), te += 4), S && (g.defaultSampleDuration = y.getUint32(te), te += 4), N && (g.defaultSampleSize = y.getUint32(te), te += 4), q && (g.defaultSampleFlags = y.getUint32(te)), $ && (g.durationIsEmpty = !0), !b && Y && (g.baseDataOffsetIsMoof = !0), g;
    }, vm = Fb, gm = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Wo;
    typeof window < "u" ? Wo = window : typeof gm < "u" ? Wo = gm : typeof self < "u" ? Wo = self : Wo = {};
    var jo = Wo, kb = _i.discardEmulationPreventionBytes, Nb = et.CaptionStream, Ub = function(m, y) {
      for (var g = m, b = 0; b < y.length; b++) {
        var w = y[b];
        if (g < w.size)
          return w;
        g -= w.size;
      }
      return null;
    }, Gb = function(m, y, g) {
      var b = new DataView(
        m.buffer,
        m.byteOffset,
        m.byteLength
      ), w = {
        logs: [],
        seiNals: []
      }, S, N, q, $;
      for (N = 0; N + 4 < m.length; N += q)
        if (q = b.getUint32(N), N += 4, !(q <= 0))
          switch (m[N] & 31) {
            case 6:
              var Y = m.subarray(N + 1, N + 1 + q), te = Ub(N, y);
              if (S = {
                data: Y,
                escapedRBSP: kb(Y),
                nalUnitType: "sei_rbsp",
                size: q,
                trackId: g
              }, te)
                S.pts = te.pts, S.dts = te.dts, $ = te;
              else if ($)
                S.pts = $.pts, S.dts = $.dts;
              else {
                w.logs.push({
                  level: "warn",
                  message: "We've encountered a nal unit without data at " + N + " for trackId " + g + ". See mux.js#223."
                });
                break;
              }
              w.seiNals.push(S);
              break;
          }
      return w;
    }, Vb = function(m, y, g) {
      var b = y, w = g.defaultSampleDuration || 0, S = g.defaultSampleSize || 0, N = g.trackId, q = [];
      return m.forEach(function($) {
        var Y = mm($), te = Y.samples;
        te.forEach(function(ce) {
          ce.duration === void 0 && (ce.duration = w), ce.size === void 0 && (ce.size = S), ce.trackId = N, ce.dts = b, ce.compositionTimeOffset === void 0 && (ce.compositionTimeOffset = 0), typeof b == "bigint" ? (ce.pts = b + jo.BigInt(ce.compositionTimeOffset), b += jo.BigInt(ce.duration)) : (ce.pts = b + ce.compositionTimeOffset, b += ce.duration);
        }), q = q.concat(te);
      }), q;
    }, Hb = function(m, y) {
      var g = Qt(m, ["moof", "traf"]), b = Qt(m, ["mdat"]), w = {}, S = [];
      return b.forEach(function(N, q) {
        var $ = g[q];
        S.push({
          mdat: N,
          traf: $
        });
      }), S.forEach(function(N) {
        var q = N.mdat, $ = N.traf, Y = Qt($, ["tfhd"]), te = vm(Y[0]), ce = te.trackId, De = Qt($, ["tfdt"]), Ue = De.length > 0 ? dm(De[0]).baseMediaDecodeTime : 0, Ae = Qt($, ["trun"]), Je, Ar;
        y === ce && Ae.length > 0 && (Je = Vb(Ae, Ue, te), Ar = Gb(q, Je, ce), w[ce] || (w[ce] = {
          logs: [],
          seiNals: []
        }), w[ce].seiNals = w[ce].seiNals.concat(
          Ar.seiNals
        ), w[ce].logs = w[ce].logs.concat(
          Ar.logs
        ));
      }), w;
    }, zb = function(m, y, g) {
      var b;
      if (y === null)
        return null;
      b = Hb(m, y);
      var w = b[y] || {};
      return {
        logs: w.logs,
        seiNals: w.seiNals,
        timescale: g
      };
    }, Wb = function() {
      var m = !1, y, g, b, w, S, N;
      this.isInitialized = function() {
        return m;
      }, this.init = function(q) {
        y = new Nb(), m = !0, N = q ? q.isPartial : !1, y.on("data", function($) {
          $.startTime = $.startPts / w, $.endTime = $.endPts / w, S.captions.push($), S.captionStreams[$.stream] = !0;
        }), y.on("log", function($) {
          S.logs.push($);
        });
      }, this.isNewInit = function(q, $) {
        return q && q.length === 0 || $ && typeof $ == "object" && Object.keys($).length === 0 ? !1 : b !== q[0] || w !== $[b];
      }, this.parse = function(q, $, Y) {
        var te;
        if (this.isInitialized()) {
          if (!$ || !Y)
            return null;
          if (this.isNewInit($, Y))
            b = $[0], w = Y[b];
          else if (b === null || !w)
            return g.push(q), null;
        } else return null;
        for (; g.length > 0; ) {
          var ce = g.shift();
          this.parse(ce, $, Y);
        }
        return te = zb(q, b, w), te && te.logs && (S.logs = S.logs.concat(te.logs)), te === null || !te.seiNals ? S.logs.length ? {
          captionStreams: [],
          captions: [],
          logs: S.logs
        } : null : (this.pushNals(te.seiNals), this.flushStream(), S);
      }, this.pushNals = function(q) {
        if (!this.isInitialized() || !q || q.length === 0)
          return null;
        q.forEach(function($) {
          y.push($);
        });
      }, this.flushStream = function() {
        if (!this.isInitialized())
          return null;
        N ? y.partialFlush() : y.flush();
      }, this.clearParsedCaptions = function() {
        S.captions = [], S.captionStreams = {}, S.logs = [];
      }, this.resetCaptionStream = function() {
        if (!this.isInitialized())
          return null;
        y.reset();
      }, this.clearAllCaptions = function() {
        this.clearParsedCaptions(), this.resetCaptionStream();
      }, this.reset = function() {
        g = [], b = null, w = null, S ? this.clearParsedCaptions() : S = {
          // CC1, CC2, CC3, CC4
          captionStreams: {},
          captions: [],
          logs: []
        }, this.resetCaptionStream();
      }, this.reset();
    }, jb = Wb, Bl = Ol.toUnsigned, qo = Ol.toHexString, qb = i.getUint64, ym, _m, bm, xm, Am, Vh;
    ym = function(m) {
      var y = {}, g = Qt(m, ["moov", "trak"]);
      return g.reduce(function(b, w) {
        var S, N, q, $, Y;
        return S = Qt(w, ["tkhd"])[0], !S || (N = S[0], q = N === 0 ? 12 : 20, $ = Bl(
          S[q] << 24 | S[q + 1] << 16 | S[q + 2] << 8 | S[q + 3]
        ), Y = Qt(w, ["mdia", "mdhd"])[0], !Y) ? null : (N = Y[0], q = N === 0 ? 12 : 20, b[$] = Bl(
          Y[q] << 24 | Y[q + 1] << 16 | Y[q + 2] << 8 | Y[q + 3]
        ), b);
      }, y);
    }, _m = function(m, y) {
      var g;
      g = Qt(y, ["moof", "traf"]);
      var b = g.reduce(function(w, S) {
        var N = Qt(S, ["tfhd"])[0], q = Bl(
          N[4] << 24 | N[5] << 16 | N[6] << 8 | N[7]
        ), $ = m[q] || 9e4, Y = Qt(S, ["tfdt"])[0], te = new DataView(Y.buffer, Y.byteOffset, Y.byteLength), ce;
        Y[0] === 1 ? ce = qb(Y.subarray(4, 12)) : ce = te.getUint32(4);
        var De;
        return typeof ce == "bigint" ? De = ce / jo.BigInt($) : typeof ce == "number" && !isNaN(ce) && (De = ce / $), De < Number.MAX_SAFE_INTEGER && (De = Number(De)), De < w && (w = De), w;
      }, 1 / 0);
      return typeof b == "bigint" || isFinite(b) ? b : 0;
    }, bm = function(m, y) {
      var g = Qt(y, ["moof", "traf"]), b = 0, w = 0, S;
      if (g && g.length) {
        var N = Qt(g[0], ["tfhd"])[0], q = Qt(g[0], ["trun"])[0], $ = Qt(g[0], ["tfdt"])[0];
        if (N) {
          var Y = vm(N);
          S = Y.trackId;
        }
        if ($) {
          var te = dm($);
          b = te.baseMediaDecodeTime;
        }
        if (q) {
          var ce = mm(q);
          ce.samples && ce.samples.length && (w = ce.samples[0].compositionTimeOffset || 0);
        }
      }
      var De = m[S] || 9e4;
      typeof b == "bigint" && (w = jo.BigInt(w), De = jo.BigInt(De));
      var Ue = (b + w) / De;
      return typeof Ue == "bigint" && Ue < Number.MAX_SAFE_INTEGER && (Ue = Number(Ue)), Ue;
    }, xm = function(m) {
      var y = Qt(m, ["moov", "trak"]), g = [];
      return y.forEach(function(b) {
        var w = Qt(b, ["mdia", "hdlr"]), S = Qt(b, ["tkhd"]);
        w.forEach(function(N, q) {
          var $ = Sa(N.subarray(8, 12)), Y = S[q], te, ce, De;
          $ === "vide" && (te = new DataView(Y.buffer, Y.byteOffset, Y.byteLength), ce = te.getUint8(0), De = ce === 0 ? te.getUint32(12) : te.getUint32(20), g.push(De));
        });
      }), g;
    }, Vh = function(m) {
      var y = m[0], g = y === 0 ? 12 : 20;
      return Bl(
        m[g] << 24 | m[g + 1] << 16 | m[g + 2] << 8 | m[g + 3]
      );
    }, Am = function(m) {
      var y = Qt(m, ["moov", "trak"]), g = [];
      return y.forEach(function(b) {
        var w = {}, S = Qt(b, ["tkhd"])[0], N, q;
        S && (N = new DataView(S.buffer, S.byteOffset, S.byteLength), q = N.getUint8(0), w.id = q === 0 ? N.getUint32(12) : N.getUint32(20));
        var $ = Qt(b, ["mdia", "hdlr"])[0];
        if ($) {
          var Y = Sa($.subarray(8, 12));
          Y === "vide" ? w.type = "video" : Y === "soun" ? w.type = "audio" : w.type = Y;
        }
        var te = Qt(b, ["mdia", "minf", "stbl", "stsd"])[0];
        if (te) {
          var ce = te.subarray(8);
          w.codec = Sa(ce.subarray(4, 8));
          var De = Qt(ce, [w.codec])[0], Ue, Ae;
          De && (/^[asm]vc[1-9]$/i.test(w.codec) ? (Ue = De.subarray(78), Ae = Sa(Ue.subarray(4, 8)), Ae === "avcC" && Ue.length > 11 ? (w.codec += ".", w.codec += qo(Ue[9]), w.codec += qo(Ue[10]), w.codec += qo(Ue[11])) : w.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(w.codec) ? (Ue = De.subarray(28), Ae = Sa(Ue.subarray(4, 8)), Ae === "esds" && Ue.length > 20 && Ue[19] !== 0 ? (w.codec += "." + qo(Ue[19]), w.codec += "." + qo(Ue[20] >>> 2 & 63).replace(/^0/, "")) : w.codec = "mp4a.40.2") : w.codec = w.codec.toLowerCase());
        }
        var Je = Qt(b, ["mdia", "mdhd"])[0];
        Je && (w.timescale = Vh(Je)), g.push(w);
      }), g;
    };
    var Tm = {
      compositionStartTime: bm,
      // export mp4 inspector's findBox and parseType for backwards compatibility
      findBox: Qt,
      getTimescaleFromMediaHeader: Vh,
      parseType: Sa,
      startTime: _m,
      timescale: ym,
      tracks: Am,
      videoTrackIds: xm
    }, Em = function(m) {
      var y = m[1] & 31;
      return y <<= 8, y |= m[2], y;
    }, Fl = function(m) {
      return !!(m[1] & 64);
    }, kl = function(m) {
      var y = 0;
      return (m[3] & 48) >>> 4 > 1 && (y += m[4] + 1), y;
    }, Xb = function(m, y) {
      var g = Em(m);
      return g === 0 ? "pat" : g === y ? "pmt" : y ? "pes" : null;
    }, Yb = function(m) {
      var y = Fl(m), g = 4 + kl(m);
      return y && (g += m[g] + 1), (m[g + 10] & 31) << 8 | m[g + 11];
    }, Qb = function(m) {
      var y = {}, g = Fl(m), b = 4 + kl(m);
      if (g && (b += m[b] + 1), !!(m[b + 5] & 1)) {
        var w, S, N;
        w = (m[b + 1] & 15) << 8 | m[b + 2], S = 3 + w - 4, N = (m[b + 10] & 15) << 8 | m[b + 11];
        for (var q = 12 + N; q < S; ) {
          var $ = b + q;
          y[(m[$ + 1] & 31) << 8 | m[$ + 2]] = m[$], q += ((m[$ + 3] & 15) << 8 | m[$ + 4]) + 5;
        }
        return y;
      }
    }, Kb = function(m, y) {
      var g = Em(m), b = y[g];
      switch (b) {
        case nt.H264_STREAM_TYPE:
          return "video";
        case nt.ADTS_STREAM_TYPE:
          return "audio";
        case nt.METADATA_STREAM_TYPE:
          return "timed-metadata";
        default:
          return null;
      }
    }, $b = function(m) {
      var y = Fl(m);
      if (!y)
        return null;
      var g = 4 + kl(m);
      if (g >= m.byteLength)
        return null;
      var b = null, w;
      return w = m[g + 7], w & 192 && (b = {}, b.pts = (m[g + 9] & 14) << 27 | (m[g + 10] & 255) << 20 | (m[g + 11] & 254) << 12 | (m[g + 12] & 255) << 5 | (m[g + 13] & 254) >>> 3, b.pts *= 4, b.pts += (m[g + 13] & 6) >>> 1, b.dts = b.pts, w & 64 && (b.dts = (m[g + 14] & 14) << 27 | (m[g + 15] & 255) << 20 | (m[g + 16] & 254) << 12 | (m[g + 17] & 255) << 5 | (m[g + 18] & 254) >>> 3, b.dts *= 4, b.dts += (m[g + 18] & 6) >>> 1)), b;
    }, Hh = function(m) {
      switch (m) {
        case 5:
          return "slice_layer_without_partitioning_rbsp_idr";
        case 6:
          return "sei_rbsp";
        case 7:
          return "seq_parameter_set_rbsp";
        case 8:
          return "pic_parameter_set_rbsp";
        case 9:
          return "access_unit_delimiter_rbsp";
        default:
          return null;
      }
    }, Zb = function(m) {
      for (var y = 4 + kl(m), g = m.subarray(y), b = 0, w = 0, S = !1, N; w < g.byteLength - 3; w++)
        if (g[w + 2] === 1) {
          b = w + 5;
          break;
        }
      for (; b < g.byteLength; )
        switch (g[b]) {
          case 0:
            if (g[b - 1] !== 0) {
              b += 2;
              break;
            } else if (g[b - 2] !== 0) {
              b++;
              break;
            }
            w + 3 !== b - 2 && (N = Hh(
              g[w + 3] & 31
            ), N === "slice_layer_without_partitioning_rbsp_idr" && (S = !0));
            do
              b++;
            while (g[b] !== 1 && b < g.length);
            w = b - 2, b += 3;
            break;
          case 1:
            if (g[b - 1] !== 0 || g[b - 2] !== 0) {
              b += 3;
              break;
            }
            N = Hh(g[w + 3] & 31), N === "slice_layer_without_partitioning_rbsp_idr" && (S = !0), w = b - 2, b += 3;
            break;
          default:
            b += 3;
            break;
        }
      return g = g.subarray(w), b -= w, w = 0, g && g.byteLength > 3 && (N = Hh(g[w + 3] & 31), N === "slice_layer_without_partitioning_rbsp_idr" && (S = !0)), S;
    }, Jb = {
      parsePat: Yb,
      parsePayloadUnitStartIndicator: Fl,
      parsePesTime: $b,
      parsePesType: Kb,
      parsePmt: Qb,
      parseType: Xb,
      videoPacketContainsKeyFrame: Zb
    }, xs = Jt.handleRollover, Ft = {};
    Ft.ts = Jb, Ft.aac = Dr;
    var Ca = Ne.ONE_SECOND_IN_TS, Qr = 188, ln = 71, ex = function(m, y) {
      for (var g = 0, b = Qr, w, S; b < m.byteLength; ) {
        if (m[g] === ln && m[b] === ln) {
          switch (w = m.subarray(g, b), S = Ft.ts.parseType(w, y.pid), S) {
            case "pat":
              y.pid = Ft.ts.parsePat(w);
              break;
            case "pmt":
              var N = Ft.ts.parsePmt(w);
              y.table = y.table || {}, Object.keys(N).forEach(function(q) {
                y.table[q] = N[q];
              });
              break;
          }
          g += Qr, b += Qr;
          continue;
        }
        g++, b++;
      }
    }, wm = function(m, y, g) {
      for (var b = 0, w = Qr, S, N, q, $, Y, te = !1; w <= m.byteLength; ) {
        if (m[b] === ln && (m[w] === ln || w === m.byteLength)) {
          switch (S = m.subarray(b, w), N = Ft.ts.parseType(S, y.pid), N) {
            case "pes":
              q = Ft.ts.parsePesType(S, y.table), $ = Ft.ts.parsePayloadUnitStartIndicator(S), q === "audio" && $ && (Y = Ft.ts.parsePesTime(S), Y && (Y.type = "audio", g.audio.push(Y), te = !0));
              break;
          }
          if (te)
            break;
          b += Qr, w += Qr;
          continue;
        }
        b++, w++;
      }
      for (w = m.byteLength, b = w - Qr, te = !1; b >= 0; ) {
        if (m[b] === ln && (m[w] === ln || w === m.byteLength)) {
          switch (S = m.subarray(b, w), N = Ft.ts.parseType(S, y.pid), N) {
            case "pes":
              q = Ft.ts.parsePesType(S, y.table), $ = Ft.ts.parsePayloadUnitStartIndicator(S), q === "audio" && $ && (Y = Ft.ts.parsePesTime(S), Y && (Y.type = "audio", g.audio.push(Y), te = !0));
              break;
          }
          if (te)
            break;
          b -= Qr, w -= Qr;
          continue;
        }
        b--, w--;
      }
    }, tx = function(m, y, g) {
      for (var b = 0, w = Qr, S, N, q, $, Y, te, ce, De, Ue = !1, Ae = {
        data: [],
        size: 0
      }; w < m.byteLength; ) {
        if (m[b] === ln && m[w] === ln) {
          switch (S = m.subarray(b, w), N = Ft.ts.parseType(S, y.pid), N) {
            case "pes":
              if (q = Ft.ts.parsePesType(S, y.table), $ = Ft.ts.parsePayloadUnitStartIndicator(S), q === "video" && ($ && !Ue && (Y = Ft.ts.parsePesTime(S), Y && (Y.type = "video", g.video.push(Y), Ue = !0)), !g.firstKeyFrame)) {
                if ($ && Ae.size !== 0) {
                  for (te = new Uint8Array(Ae.size), ce = 0; Ae.data.length; )
                    De = Ae.data.shift(), te.set(De, ce), ce += De.byteLength;
                  if (Ft.ts.videoPacketContainsKeyFrame(te)) {
                    var Je = Ft.ts.parsePesTime(te);
                    Je ? (g.firstKeyFrame = Je, g.firstKeyFrame.type = "video") : console.warn(
                      "Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself."
                    );
                  }
                  Ae.size = 0;
                }
                Ae.data.push(S), Ae.size += S.byteLength;
              }
              break;
          }
          if (Ue && g.firstKeyFrame)
            break;
          b += Qr, w += Qr;
          continue;
        }
        b++, w++;
      }
      for (w = m.byteLength, b = w - Qr, Ue = !1; b >= 0; ) {
        if (m[b] === ln && m[w] === ln) {
          switch (S = m.subarray(b, w), N = Ft.ts.parseType(S, y.pid), N) {
            case "pes":
              q = Ft.ts.parsePesType(S, y.table), $ = Ft.ts.parsePayloadUnitStartIndicator(S), q === "video" && $ && (Y = Ft.ts.parsePesTime(S), Y && (Y.type = "video", g.video.push(Y), Ue = !0));
              break;
          }
          if (Ue)
            break;
          b -= Qr, w -= Qr;
          continue;
        }
        b--, w--;
      }
    }, rx = function(m, y) {
      if (m.audio && m.audio.length) {
        var g = y;
        (typeof g > "u" || isNaN(g)) && (g = m.audio[0].dts), m.audio.forEach(function(S) {
          S.dts = xs(S.dts, g), S.pts = xs(S.pts, g), S.dtsTime = S.dts / Ca, S.ptsTime = S.pts / Ca;
        });
      }
      if (m.video && m.video.length) {
        var b = y;
        if ((typeof b > "u" || isNaN(b)) && (b = m.video[0].dts), m.video.forEach(function(S) {
          S.dts = xs(S.dts, b), S.pts = xs(S.pts, b), S.dtsTime = S.dts / Ca, S.ptsTime = S.pts / Ca;
        }), m.firstKeyFrame) {
          var w = m.firstKeyFrame;
          w.dts = xs(w.dts, b), w.pts = xs(w.pts, b), w.dtsTime = w.dts / Ca, w.ptsTime = w.pts / Ca;
        }
      }
    }, ix = function(m) {
      for (var y = !1, g = 0, b = null, w = null, S = 0, N = 0, q; m.length - N >= 3; ) {
        var $ = Ft.aac.parseType(m, N);
        switch ($) {
          case "timed-metadata":
            if (m.length - N < 10) {
              y = !0;
              break;
            }
            if (S = Ft.aac.parseId3TagSize(m, N), S > m.length) {
              y = !0;
              break;
            }
            w === null && (q = m.subarray(N, N + S), w = Ft.aac.parseAacTimestamp(q)), N += S;
            break;
          case "audio":
            if (m.length - N < 7) {
              y = !0;
              break;
            }
            if (S = Ft.aac.parseAdtsSize(m, N), S > m.length) {
              y = !0;
              break;
            }
            b === null && (q = m.subarray(N, N + S), b = Ft.aac.parseSampleRate(q)), g++, N += S;
            break;
          default:
            N++;
            break;
        }
        if (y)
          return null;
      }
      if (b === null || w === null)
        return null;
      var Y = Ca / b, te = {
        audio: [
          {
            dts: w,
            pts: w,
            type: "audio"
          },
          {
            dts: w + g * 1024 * Y,
            pts: w + g * 1024 * Y,
            type: "audio"
          }
        ]
      };
      return te;
    }, nx = function(m) {
      var y = {
        pid: null,
        table: null
      }, g = {};
      ex(m, y);
      for (var b in y.table)
        if (y.table.hasOwnProperty(b)) {
          var w = y.table[b];
          switch (w) {
            case nt.H264_STREAM_TYPE:
              g.video = [], tx(m, y, g), g.video.length === 0 && delete g.video;
              break;
            case nt.ADTS_STREAM_TYPE:
              g.audio = [], wm(m, y, g), g.audio.length === 0 && delete g.audio;
              break;
          }
        }
      return g;
    }, ax = function(m, y) {
      var g = Ft.aac.isLikelyAacData(m), b;
      return g ? b = ix(m) : b = nx(m), !b || !b.audio && !b.video ? null : (rx(b, y), b);
    }, sx = {
      inspect: ax,
      parseAudioPes_: wm
    }, ox = function(m, y) {
      y.on("data", function(g) {
        var b = g.initSegment;
        g.initSegment = {
          byteLength: b.byteLength,
          byteOffset: b.byteOffset,
          data: b.buffer
        };
        var w = g.data;
        g.data = w.buffer, m.postMessage(
          {
            action: "data",
            byteLength: w.byteLength,
            byteOffset: w.byteOffset,
            segment: g
          },
          [g.data]
        );
      }), y.on("done", function(g) {
        m.postMessage({
          action: "done"
        });
      }), y.on("gopInfo", function(g) {
        m.postMessage({
          action: "gopInfo",
          gopInfo: g
        });
      }), y.on("videoSegmentTimingInfo", function(g) {
        var b = {
          baseMediaDecodeTime: Ne.videoTsToSeconds(
            g.baseMediaDecodeTime
          ),
          end: {
            decode: Ne.videoTsToSeconds(g.end.dts),
            presentation: Ne.videoTsToSeconds(g.end.pts)
          },
          start: {
            decode: Ne.videoTsToSeconds(g.start.dts),
            presentation: Ne.videoTsToSeconds(g.start.pts)
          }
        };
        g.prependedContentDuration && (b.prependedContentDuration = Ne.videoTsToSeconds(g.prependedContentDuration)), m.postMessage({
          action: "videoSegmentTimingInfo",
          videoSegmentTimingInfo: b
        });
      }), y.on("audioSegmentTimingInfo", function(g) {
        var b = {
          baseMediaDecodeTime: Ne.videoTsToSeconds(
            g.baseMediaDecodeTime
          ),
          end: {
            decode: Ne.videoTsToSeconds(g.end.dts),
            presentation: Ne.videoTsToSeconds(g.end.pts)
          },
          start: {
            decode: Ne.videoTsToSeconds(g.start.dts),
            presentation: Ne.videoTsToSeconds(g.start.pts)
          }
        };
        g.prependedContentDuration && (b.prependedContentDuration = Ne.videoTsToSeconds(g.prependedContentDuration)), m.postMessage({
          action: "audioSegmentTimingInfo",
          audioSegmentTimingInfo: b
        });
      }), y.on("id3Frame", function(g) {
        m.postMessage({
          action: "id3Frame",
          id3Frame: g
        });
      }), y.on("caption", function(g) {
        m.postMessage({
          action: "caption",
          caption: g
        });
      }), y.on("trackinfo", function(g) {
        m.postMessage({
          action: "trackinfo",
          trackInfo: g
        });
      }), y.on("audioTimingInfo", function(g) {
        m.postMessage({
          action: "audioTimingInfo",
          audioTimingInfo: {
            end: Ne.videoTsToSeconds(g.end),
            start: Ne.videoTsToSeconds(g.start)
          }
        });
      }), y.on("videoTimingInfo", function(g) {
        m.postMessage({
          action: "videoTimingInfo",
          videoTimingInfo: {
            end: Ne.videoTsToSeconds(g.end),
            start: Ne.videoTsToSeconds(g.start)
          }
        });
      }), y.on("log", function(g) {
        m.postMessage({
          action: "log",
          log: g
        });
      });
    }, Sm = /* @__PURE__ */ function() {
      function P(y, g) {
        this.options = g || {}, this.self = y, this.init();
      }
      var m = P.prototype;
      return m.init = function() {
        this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new wb.Transmuxer(this.options), ox(this.self, this.transmuxer);
      }, m.pushMp4Captions = function(g) {
        this.captionParser || (this.captionParser = new jb(), this.captionParser.init());
        var b = new Uint8Array(
          g.data,
          g.byteOffset,
          g.byteLength
        ), w = this.captionParser.parse(
          b,
          g.trackIds,
          g.timescales
        );
        this.self.postMessage(
          {
            action: "mp4Captions",
            captions: w && w.captions || [],
            data: b.buffer,
            logs: w && w.logs || []
          },
          [b.buffer]
        );
      }, m.probeMp4StartTime = function(g) {
        var b = g.timescales, w = g.data, S = Tm.startTime(b, w);
        this.self.postMessage(
          {
            action: "probeMp4StartTime",
            data: w,
            startTime: S
          },
          [w.buffer]
        );
      }, m.probeMp4Tracks = function(g) {
        var b = g.data, w = Tm.tracks(b);
        this.self.postMessage(
          {
            action: "probeMp4Tracks",
            data: b,
            tracks: w
          },
          [b.buffer]
        );
      }, m.probeTs = function(g) {
        var b = g.data, w = g.baseStartTime, S = typeof w == "number" && !isNaN(w) ? w * Ne.ONE_SECOND_IN_TS : void 0, N = sx.inspect(b, S), q = null;
        N && (q = {
          hasAudio: N.audio && N.audio.length === 2 || !1,
          // each type's time info comes back as an array of 2 times, start and end
          hasVideo: N.video && N.video.length === 2 || !1
        }, q.hasVideo && (q.videoStart = N.video[0].ptsTime), q.hasAudio && (q.audioStart = N.audio[0].ptsTime)), this.self.postMessage(
          {
            action: "probeTs",
            data: b,
            result: q
          },
          [b.buffer]
        );
      }, m.clearAllMp4Captions = function() {
        this.captionParser && this.captionParser.clearAllCaptions();
      }, m.clearParsedMp4Captions = function() {
        this.captionParser && this.captionParser.clearParsedCaptions();
      }, m.push = function(g) {
        var b = new Uint8Array(
          g.data,
          g.byteOffset,
          g.byteLength
        );
        this.transmuxer.push(b);
      }, m.reset = function() {
        this.transmuxer.reset();
      }, m.setTimestampOffset = function(g) {
        var b = g.timestampOffset || 0;
        this.transmuxer.setBaseMediaDecodeTime(
          Math.round(Ne.secondsToVideoTs(b))
        );
      }, m.setAudioAppendStart = function(g) {
        this.transmuxer.setAudioAppendStart(
          Math.ceil(Ne.secondsToVideoTs(g.appendStart))
        );
      }, m.setRemux = function(g) {
        this.transmuxer.setRemux(g.remux);
      }, m.flush = function(g) {
        this.transmuxer.flush(), self.postMessage({
          action: "done",
          type: "transmuxed"
        });
      }, m.endTimeline = function() {
        this.transmuxer.endTimeline(), self.postMessage({
          action: "endedtimeline",
          type: "transmuxed"
        });
      }, m.alignGopsWith = function(g) {
        this.transmuxer.alignGopsWith(g.gopsToAlignWith.slice());
      }, P;
    }();
    self.onmessage = function(P) {
      if (P.data.action === "init" && P.data.options) {
        this.messageHandlers = new Sm(self, P.data.options);
        return;
      }
      this.messageHandlers || (this.messageHandlers = new Sm(self)), P.data && P.data.action && P.data.action !== "init" && this.messageHandlers[P.data.action] && this.messageHandlers[P.data.action](P.data);
    };
  })
), ED = tb(TD), wD = function(t, r, n) {
  var i = t.data.segment, a = i.type, s = i.initSegment, o = i.captions, u = i.captionStreams, l = i.metadata, c = i.videoFrameDtsTime, h = i.videoFramePtsTime;
  r.buffer.push({
    captionStreams: u,
    captions: o,
    metadata: l
  });
  var f = t.data.segment.boxes || {
    data: t.data.segment.data
  }, d = {
    // cast ArrayBuffer to TypedArray
    data: new Uint8Array(
      f.data,
      f.data.byteOffset,
      f.data.byteLength
    ),
    initSegment: new Uint8Array(
      s.data,
      s.byteOffset,
      s.byteLength
    ),
    type: a
  };
  typeof c < "u" && (d.videoFrameDtsTime = c), typeof h < "u" && (d.videoFramePtsTime = h), n(d);
}, SD = function(t) {
  var r = t.transmuxedData, n = t.callback;
  r.buffer = [], n(r);
}, CD = function(t, r) {
  r.gopInfo = t.data.gopInfo;
}, nb = function(t) {
  var r = t.transmuxer, n = t.bytes, i = t.audioAppendStart, a = t.gopsToAlignWith, s = t.remux, o = t.onData, u = t.onTrackInfo, l = t.onAudioTimingInfo, c = t.onVideoTimingInfo, h = t.onVideoSegmentTimingInfo, f = t.onAudioSegmentTimingInfo, d = t.onId3, p = t.onCaptions, _ = t.onDone, v = t.onEndedTimeline, x = t.onTransmuxerLog, E = t.isEndOfTimeline, M = {
    buffer: []
  }, C = E, R = function(I) {
    r.currentTransmux === t && (I.data.action === "data" && wD(I, M, o), I.data.action === "trackinfo" && u(I.data.trackInfo), I.data.action === "gopInfo" && CD(I, M), I.data.action === "audioTimingInfo" && l(I.data.audioTimingInfo), I.data.action === "videoTimingInfo" && c(I.data.videoTimingInfo), I.data.action === "videoSegmentTimingInfo" && h(I.data.videoSegmentTimingInfo), I.data.action === "audioSegmentTimingInfo" && f(I.data.audioSegmentTimingInfo), I.data.action === "id3Frame" && d([I.data.id3Frame], I.data.id3Frame.dispatchType), I.data.action === "caption" && p(I.data.caption), I.data.action === "endedtimeline" && (C = !1, v()), I.data.action === "log" && x(I.data.log), I.data.type === "transmuxed" && (C || (r.onmessage = null, SD({
      callback: _,
      transmuxedData: M
    }), ab(r))));
  };
  if (r.onmessage = R, i && r.postMessage({
    action: "setAudioAppendStart",
    appendStart: i
  }), Array.isArray(a) && r.postMessage({
    action: "alignGopsWith",
    gopsToAlignWith: a
  }), typeof s < "u" && r.postMessage({
    action: "setRemux",
    remux: s
  }), n.byteLength) {
    var B = n instanceof ArrayBuffer ? n : n.buffer, k = n instanceof ArrayBuffer ? 0 : n.byteOffset;
    r.postMessage(
      {
        action: "push",
        byteLength: n.byteLength,
        // To recreate the original typed-array, we need information
        // about what portion of the ArrayBuffer it was a view into
        byteOffset: k,
        // Send the typed-array of data as an ArrayBuffer so that
        // it can be sent as a "Transferable" and avoid the costly
        // memory copy
        data: B
      },
      [B]
    );
  }
  E && r.postMessage({
    action: "endTimeline"
  }), r.postMessage({
    action: "flush"
  });
}, ab = function(t) {
  t.currentTransmux = null, t.transmuxQueue.length && (t.currentTransmux = t.transmuxQueue.shift(), typeof t.currentTransmux == "function" ? t.currentTransmux() : nb(t.currentTransmux));
}, hg = function(t, r) {
  t.postMessage({
    action: r
  }), ab(t);
}, sb = function(t, r) {
  if (!r.currentTransmux) {
    r.currentTransmux = t, hg(r, t);
    return;
  }
  r.transmuxQueue.push(hg.bind(null, r, t));
}, MD = function(t) {
  sb("reset", t);
}, DD = function(t) {
  sb("endTimeline", t);
}, ob = function(t) {
  if (!t.transmuxer.currentTransmux) {
    t.transmuxer.currentTransmux = t, nb(t);
    return;
  }
  t.transmuxer.transmuxQueue.push(t);
}, PD = function(t) {
  var r = new ED();
  r.currentTransmux = null, r.transmuxQueue = [];
  var n = r.terminate;
  return r.terminate = function() {
    return r.currentTransmux = null, r.transmuxQueue.length = 0, n.call(r);
  }, r.postMessage({
    action: "init",
    options: t
  }), r;
}, Af = {
  createTransmuxer: PD,
  endTimeline: DD,
  reset: MD,
  transmux: ob
}, $c = function(t) {
  var r = t.transmuxer, n = t.endAction || t.action, i = t.callback, a = Bi({}, t, {
    callback: null,
    endAction: null,
    transmuxer: null
  }), s = function l(c) {
    c.data.action === n && (r.removeEventListener("message", l), c.data.data && (c.data.data = new Uint8Array(
      c.data.data,
      t.byteOffset || 0,
      t.byteLength || c.data.data.byteLength
    ), t.data && (t.data = c.data.data)), i(c.data));
  };
  if (r.addEventListener("message", s), t.data) {
    var o = t.data instanceof ArrayBuffer;
    a.byteOffset = o ? 0 : t.data.byteOffset, a.byteLength = t.data.byteLength;
    var u = [o ? t.data : t.data.buffer];
    r.postMessage(a, u);
  } else
    r.postMessage(a);
}, pn = {
  ABORTED: -102,
  FAILURE: 2,
  TIMEOUT: -101
}, yd = function(t) {
  t.forEach(function(r) {
    r.abort();
  });
}, LD = function(t) {
  return {
    bandwidth: t.bandwidth,
    bytesReceived: t.bytesReceived || 0,
    roundTripTime: t.roundTripTime || 0
  };
}, RD = function(t) {
  var r = t.target, n = Date.now() - r.requestTime, i = {
    bandwidth: 1 / 0,
    bytesReceived: 0,
    roundTripTime: n || 0
  };
  return i.bytesReceived = t.loaded, i.bandwidth = Math.floor(
    i.bytesReceived / i.roundTripTime * 8 * 1e3
  ), i;
}, om = function(t, r) {
  return r.timedout ? {
    code: pn.TIMEOUT,
    message: "HLS request timed-out at URL: " + r.uri,
    status: r.status,
    xhr: r
  } : r.aborted ? {
    code: pn.ABORTED,
    message: "HLS request aborted at URL: " + r.uri,
    status: r.status,
    xhr: r
  } : t ? {
    code: pn.FAILURE,
    message: "HLS request errored at URL: " + r.uri,
    status: r.status,
    xhr: r
  } : r.responseType === "arraybuffer" && r.response.byteLength === 0 ? {
    code: pn.FAILURE,
    message: "Empty HLS response at URL: " + r.uri,
    status: r.status,
    xhr: r
  } : null;
}, fg = function(t, r, n) {
  return function(i, a) {
    var s = a.response, o = om(i, a);
    if (o)
      return n(o, t);
    if (s.byteLength !== 16)
      return n(
        {
          code: pn.FAILURE,
          message: "Invalid HLS key at URL: " + a.uri,
          status: a.status,
          xhr: a
        },
        t
      );
    for (var u = new DataView(s), l = new Uint32Array([
      u.getUint32(0),
      u.getUint32(4),
      u.getUint32(8),
      u.getUint32(12)
    ]), c = 0; c < r.length; c++)
      r[c].bytes = l;
    return n(null, t);
  };
}, ub = function(t, r) {
  var n = ip(t.map.bytes);
  if (n !== "mp4") {
    var i = t.map.resolvedUri || t.map.uri;
    return r({
      code: pn.FAILURE,
      internal: !0,
      message: "Found unsupported " + (n || "unknown") + " container for initialization segment at URL: " + i
    });
  }
  $c({
    action: "probeMp4Tracks",
    callback: function(s) {
      var o = s.tracks, u = s.data;
      return t.map.bytes = u, o.forEach(function(l) {
        t.map.tracks = t.map.tracks || {}, !t.map.tracks[l.type] && (t.map.tracks[l.type] = l, typeof l.id == "number" && l.timescale && (t.map.timescales = t.map.timescales || {}, t.map.timescales[l.id] = l.timescale));
      }), r(null);
    },
    data: t.map.bytes,
    transmuxer: t.transmuxer
  });
}, ID = function(t) {
  var r = t.segment, n = t.finishProcessingFn;
  return function(i, a) {
    var s = om(i, a);
    if (s)
      return n(s, r);
    var o = new Uint8Array(a.response);
    if (r.map.key)
      return r.map.encryptedBytes = o, n(null, r);
    r.map.bytes = o, ub(r, function(u) {
      if (u)
        return u.xhr = a, u.status = a.status, n(u, r);
      n(null, r);
    });
  };
}, OD = function(t) {
  var r = t.segment, n = t.finishProcessingFn, i = t.responseType;
  return function(a, s) {
    var o = om(a, s);
    if (o)
      return n(o, r);
    var u = (
      // although responseText "should" exist, this guard serves to prevent an error being
      // thrown for two primary cases:
      // 1. the mime type override stops working, or is not implemented for a specific
      //    browser
      // 2. when using mock XHR libraries like sinon that do not allow the override behavior
      i === "arraybuffer" || !s.responseText ? s.response : xD(
        s.responseText.substring(r.lastReachedChar || 0)
      )
    );
    return r.stats = LD(s), r.key ? r.encryptedBytes = new Uint8Array(u) : r.bytes = new Uint8Array(u), n(null, r);
  };
}, BD = function(t) {
  var r = t.segment, n = t.bytes, i = t.trackInfoFn, a = t.timingInfoFn, s = t.videoSegmentTimingInfoFn, o = t.audioSegmentTimingInfoFn, u = t.id3Fn, l = t.captionsFn, c = t.isEndOfTimeline, h = t.endedTimelineFn, f = t.dataFn, d = t.doneFn, p = t.onTransmuxerLog, _ = r.map && r.map.tracks || {}, v = !!(_.audio && _.video), x = a.bind(null, r, "audio", "start"), E = a.bind(null, r, "audio", "end"), M = a.bind(null, r, "video", "start"), C = a.bind(null, r, "video", "end"), R = function() {
    return ob({
      audioAppendStart: r.audioAppendStart,
      bytes: n,
      gopsToAlignWith: r.gopsToAlignWith,
      onAudioSegmentTimingInfo: function(F) {
        o(F);
      },
      onAudioTimingInfo: function(F) {
        x && typeof F.start < "u" && (x(F.start), x = null), E && typeof F.end < "u" && E(F.end);
      },
      onCaptions: function(F) {
        l(r, [F]);
      },
      isEndOfTimeline: c,
      onData: function(F) {
        F.type = F.type === "combined" ? "video" : F.type, f(r, F);
      },
      onDone: function(F) {
        d && (F.type = F.type === "combined" ? "video" : F.type, d(null, r, F));
      },
      onTrackInfo: function(F) {
        i && (v && (F.isMuxed = !0), i(r, F));
      },
      onEndedTimeline: function() {
        h();
      },
      transmuxer: r.transmuxer,
      onId3: function(F, I) {
        u(r, F, I);
      },
      onTransmuxerLog: p,
      remux: v,
      onVideoSegmentTimingInfo: function(F) {
        s(F);
      },
      onVideoTimingInfo: function(F) {
        M && typeof F.start < "u" && (M(F.start), M = null), C && typeof F.end < "u" && C(F.end);
      }
    });
  };
  $c({
    action: "probeTs",
    baseStartTime: r.baseStartTime,
    callback: function(k) {
      r.bytes = n = k.data;
      var F = k.result;
      F && (i(r, {
        hasAudio: F.hasAudio,
        hasVideo: F.hasVideo,
        isMuxed: v
      }), i = null, F.hasAudio && !v && x(F.audioStart), F.hasVideo && M(F.videoStart), x = null, M = null), R();
    },
    data: n,
    transmuxer: r.transmuxer
  });
}, lb = function(t) {
  var r = t.segment, n = t.bytes, i = t.trackInfoFn, a = t.timingInfoFn, s = t.videoSegmentTimingInfoFn, o = t.audioSegmentTimingInfoFn, u = t.id3Fn, l = t.captionsFn, c = t.isEndOfTimeline, h = t.endedTimelineFn, f = t.dataFn, d = t.doneFn, p = t.onTransmuxerLog, _ = new Uint8Array(n);
  if (Dw(_)) {
    r.isFmp4 = !0;
    var v = r.map.tracks, x = {
      hasAudio: !!v.audio,
      hasVideo: !!v.video,
      isFmp4: !0
    };
    v.audio && v.audio.codec && v.audio.codec !== "enca" && (x.audioCodec = v.audio.codec), v.video && v.video.codec && v.video.codec !== "encv" && (x.videoCodec = v.video.codec), v.video && v.audio && (x.isMuxed = !0), i(r, x);
    var E = function(C) {
      f(r, {
        data: _,
        type: x.hasAudio && !x.isMuxed ? "audio" : "video"
      }), C && C.length && l(r, C), d(null, r, {});
    };
    $c({
      action: "probeMp4StartTime",
      callback: function(C) {
        var R = C.data, B = C.startTime;
        if (n = R.buffer, r.bytes = _ = R, x.hasAudio && !x.isMuxed && a(r, "audio", "start", B), x.hasVideo && a(r, "video", "start", B), !v.video || !R.byteLength || !r.transmuxer) {
          E();
          return;
        }
        $c({
          action: "pushMp4Captions",
          callback: function(F) {
            n = F.data.buffer, r.bytes = _ = F.data, F.logs.forEach(function(I) {
              p(
                X.mergeOptions(I, {
                  stream: "mp4CaptionParser"
                })
              );
            }), E(F.captions);
          },
          data: _,
          endAction: "mp4Captions",
          timescales: r.map.timescales,
          trackIds: [v.video.id],
          transmuxer: r.transmuxer
        });
      },
      data: _,
      timescales: r.map.timescales,
      transmuxer: r.transmuxer
    });
    return;
  }
  if (!r.transmuxer) {
    d(null, r, {});
    return;
  }
  if (typeof r.container > "u" && (r.container = ip(_)), r.container !== "ts" && r.container !== "aac") {
    i(r, {
      hasAudio: !1,
      hasVideo: !1
    }), d(null, r, {});
    return;
  }
  BD({
    audioSegmentTimingInfoFn: o,
    bytes: n,
    captionsFn: l,
    dataFn: f,
    doneFn: d,
    endedTimelineFn: h,
    id3Fn: u,
    isEndOfTimeline: c,
    segment: r,
    onTransmuxerLog: p,
    timingInfoFn: a,
    trackInfoFn: i,
    videoSegmentTimingInfoFn: s
  });
}, cb = function(t, r) {
  var n = t.id, i = t.key, a = t.encryptedBytes, s = t.decryptionWorker, o = function l(c) {
    if (c.data.source === n) {
      s.removeEventListener("message", l);
      var h = c.data.decrypted;
      r(
        new Uint8Array(
          h.bytes,
          h.byteOffset,
          h.byteLength
        )
      );
    }
  };
  s.addEventListener("message", o);
  var u;
  i.bytes.slice ? u = i.bytes.slice() : u = new Uint32Array(Array.prototype.slice.call(i.bytes)), s.postMessage(
    Q1({
      encrypted: a,
      iv: i.iv,
      key: u,
      source: n
    }),
    [a.buffer, u.buffer]
  );
}, FD = function(t) {
  var r = t.decryptionWorker, n = t.segment, i = t.trackInfoFn, a = t.timingInfoFn, s = t.videoSegmentTimingInfoFn, o = t.audioSegmentTimingInfoFn, u = t.id3Fn, l = t.captionsFn, c = t.isEndOfTimeline, h = t.endedTimelineFn, f = t.dataFn, d = t.doneFn, p = t.onTransmuxerLog;
  cb(
    {
      decryptionWorker: r,
      encryptedBytes: n.encryptedBytes,
      id: n.requestId,
      key: n.key
    },
    function(_) {
      n.bytes = _, lb({
        audioSegmentTimingInfoFn: o,
        bytes: n.bytes,
        captionsFn: l,
        dataFn: f,
        doneFn: d,
        endedTimelineFn: h,
        id3Fn: u,
        isEndOfTimeline: c,
        segment: n,
        onTransmuxerLog: p,
        timingInfoFn: a,
        trackInfoFn: i,
        videoSegmentTimingInfoFn: s
      });
    }
  );
}, kD = function(t) {
  var r = t.activeXhrs, n = t.decryptionWorker, i = t.trackInfoFn, a = t.timingInfoFn, s = t.videoSegmentTimingInfoFn, o = t.audioSegmentTimingInfoFn, u = t.id3Fn, l = t.captionsFn, c = t.isEndOfTimeline, h = t.endedTimelineFn, f = t.dataFn, d = t.doneFn, p = t.onTransmuxerLog, _ = 0, v = !1;
  return function(x, E) {
    if (!v) {
      if (x)
        return v = !0, yd(r), d(x, E);
      if (_ += 1, _ === r.length) {
        var M = function() {
          if (E.encryptedBytes)
            return FD({
              audioSegmentTimingInfoFn: o,
              captionsFn: l,
              dataFn: f,
              decryptionWorker: n,
              doneFn: d,
              endedTimelineFn: h,
              id3Fn: u,
              isEndOfTimeline: c,
              segment: E,
              onTransmuxerLog: p,
              timingInfoFn: a,
              trackInfoFn: i,
              videoSegmentTimingInfoFn: s
            });
          lb({
            audioSegmentTimingInfoFn: o,
            bytes: E.bytes,
            captionsFn: l,
            dataFn: f,
            doneFn: d,
            endedTimelineFn: h,
            id3Fn: u,
            isEndOfTimeline: c,
            segment: E,
            onTransmuxerLog: p,
            timingInfoFn: a,
            trackInfoFn: i,
            videoSegmentTimingInfoFn: s
          });
        };
        if (E.endOfAllRequests = Date.now(), E.map && E.map.encryptedBytes && !E.map.bytes)
          return cb(
            {
              decryptionWorker: n,
              encryptedBytes: E.map.encryptedBytes,
              // add -init to the "id" to differentiate between segment
              // and init segment decryption, just in case they happen
              // at the same time at some point in the future.
              id: E.requestId + "-init",
              key: E.map.key
            },
            function(C) {
              E.map.bytes = C, ub(E, function(R) {
                if (R)
                  return yd(r), d(R, E);
                M();
              });
            }
          );
        M();
      }
    }
  };
}, ND = function(t) {
  var r = t.loadendState, n = t.abortFn;
  return function(i) {
    var a = i.target;
    a.aborted && n && !r.calledAbortFn && (n(), r.calledAbortFn = !0);
  };
}, UD = function(t) {
  var r = t.segment, n = t.progressFn;
  return function(i) {
    var a = i.target;
    if (!a.aborted)
      return r.stats = X.mergeOptions(
        r.stats,
        RD(i)
      ), !r.stats.firstBytesReceivedAt && r.stats.bytesReceived && (r.stats.firstBytesReceivedAt = Date.now()), n(i, r);
  };
}, GD = function(t) {
  var r = t.xhr, n = t.xhrOptions, i = t.decryptionWorker, a = t.segment, s = t.abortFn, o = t.progressFn, u = t.trackInfoFn, l = t.timingInfoFn, c = t.videoSegmentTimingInfoFn, h = t.audioSegmentTimingInfoFn, f = t.id3Fn, d = t.captionsFn, p = t.isEndOfTimeline, _ = t.endedTimelineFn, v = t.dataFn, x = t.doneFn, E = t.onTransmuxerLog, M = [], C = kD({
    activeXhrs: M,
    audioSegmentTimingInfoFn: h,
    captionsFn: d,
    dataFn: v,
    decryptionWorker: i,
    doneFn: x,
    endedTimelineFn: _,
    id3Fn: f,
    isEndOfTimeline: p,
    onTransmuxerLog: E,
    timingInfoFn: l,
    trackInfoFn: u,
    videoSegmentTimingInfoFn: c
  });
  if (a.key && !a.key.bytes) {
    var R = [a.key];
    a.map && !a.map.bytes && a.map.key && a.map.key.resolvedUri === a.key.resolvedUri && R.push(a.map.key);
    var B = X.mergeOptions(n, {
      responseType: "arraybuffer",
      uri: a.key.resolvedUri
    }), k = fg(
      a,
      R,
      C
    ), F = r(B, k);
    M.push(F);
  }
  if (a.map && !a.map.bytes) {
    var I = a.map.key && (!a.key || a.key.resolvedUri !== a.map.key.resolvedUri);
    if (I) {
      var H = X.mergeOptions(n, {
        responseType: "arraybuffer",
        uri: a.map.key.resolvedUri
      }), Q = fg(
        a,
        [a.map.key],
        C
      ), ee = r(H, Q);
      M.push(ee);
    }
    var oe = X.mergeOptions(n, {
      headers: vd(a.map),
      responseType: "arraybuffer",
      uri: a.map.resolvedUri
    }), de = ID({
      finishProcessingFn: C,
      segment: a
    }), he = r(oe, de);
    M.push(he);
  }
  var fe = X.mergeOptions(n, {
    headers: vd(a),
    responseType: "arraybuffer",
    uri: a.part && a.part.resolvedUri || a.resolvedUri
  }), V = OD({
    finishProcessingFn: C,
    responseType: fe.responseType,
    segment: a
  }), G = r(fe, V);
  G.addEventListener(
    "progress",
    UD({
      audioSegmentTimingInfoFn: h,
      captionsFn: d,
      dataFn: v,
      endedTimelineFn: _,
      id3Fn: f,
      isEndOfTimeline: p,
      progressFn: o,
      segment: a,
      timingInfoFn: l,
      trackInfoFn: u,
      videoSegmentTimingInfoFn: c
    })
  ), M.push(G);
  var se = {};
  return M.forEach(function(re) {
    re.addEventListener(
      "loadend",
      ND({
        abortFn: s,
        loadendState: se
      })
    );
  }), function() {
    return yd(M);
  };
}, VD = nn("CodecUtils"), HD = function(t) {
  var r = t.attributes || {};
  if (r.CODECS)
    return cn(r.CODECS);
}, hb = function(t, r) {
  var n = r.attributes || {};
  return t && t.mediaGroups && t.mediaGroups.AUDIO && n.AUDIO && t.mediaGroups.AUDIO[n.AUDIO];
}, zD = function(t, r) {
  if (!hb(t, r))
    return !0;
  var n = r.attributes || {}, i = t.mediaGroups.AUDIO[n.AUDIO];
  for (var a in i)
    if (!i[a].uri && !i[a].playlists)
      return !0;
  return !1;
}, Zc = function(t) {
  var r = {};
  return t.forEach(function(n) {
    var i = n.mediaType, a = n.type, s = n.details;
    r[i] = r[i] || [], r[i].push(Ey("" + a + s));
  }), Object.keys(r).forEach(function(n) {
    if (r[n].length > 1) {
      VD(
        "multiple " + n + " codecs found as attributes: " + r[n].join(", ") + ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs."
      ), r[n] = null;
      return;
    }
    r[n] = r[n][0];
  }), r;
}, dg = function(t) {
  var r = 0;
  return t.audio && r++, t.video && r++, r;
}, du = function(t, r) {
  var n = r.attributes || {}, i = Zc(HD(r) || []);
  if (hb(t, r) && !i.audio && !zD(t, r)) {
    var a = Zc(
      fw(t, n.AUDIO) || []
    );
    a.audio && (i.audio = a.audio);
  }
  return i;
}, Kl = nn("PlaylistSelector"), pg = function(t) {
  if (!(!t || !t.playlist)) {
    var r = t.playlist;
    return JSON.stringify({
      bandwidth: t.bandwidth,
      codecs: r.attributes && r.attributes.CODECS || "",
      height: t.height,
      id: r.id,
      width: t.width
    });
  }
}, Jc = function(t, r) {
  if (!t)
    return "";
  var n = j.getComputedStyle(t);
  return n ? n[r] : "";
}, ks = function(t, r) {
  var n = t.slice();
  t.sort(function(i, a) {
    var s = r(i, a);
    return s === 0 ? n.indexOf(i) - n.indexOf(a) : s;
  });
}, um = function(t, r) {
  var n, i;
  return t.attributes.BANDWIDTH && (n = t.attributes.BANDWIDTH), n = n || j.Number.MAX_VALUE, r.attributes.BANDWIDTH && (i = r.attributes.BANDWIDTH), i = i || j.Number.MAX_VALUE, n - i;
}, WD = function(t, r) {
  var n, i;
  return t.attributes.RESOLUTION && t.attributes.RESOLUTION.width && (n = t.attributes.RESOLUTION.width), n = n || j.Number.MAX_VALUE, r.attributes.RESOLUTION && r.attributes.RESOLUTION.width && (i = r.attributes.RESOLUTION.width), i = i || j.Number.MAX_VALUE, n === i && t.attributes.BANDWIDTH && r.attributes.BANDWIDTH ? t.attributes.BANDWIDTH - r.attributes.BANDWIDTH : n - i;
}, fb = function(t, r, n, i, a, s) {
  if (t) {
    var o = {
      bandwidth: r,
      height: i,
      limitRenditionByPlayerDimensions: a,
      width: n
    }, u = t.playlists;
    li.isAudioOnly(t) && (u = s.getAudioTrackPlaylists_(), o.audioOnly = !0);
    var l = u.map(function(H) {
      var Q, ee = H.attributes && H.attributes.RESOLUTION && H.attributes.RESOLUTION.width, oe = H.attributes && H.attributes.RESOLUTION && H.attributes.RESOLUTION.height;
      return Q = H.attributes && H.attributes.BANDWIDTH, Q = Q || j.Number.MAX_VALUE, {
        bandwidth: Q,
        height: oe,
        playlist: H,
        width: ee
      };
    });
    ks(l, function(H, Q) {
      return H.bandwidth - Q.bandwidth;
    }), l = l.filter(function(H) {
      return !li.isIncompatible(H.playlist);
    });
    var c = l.filter(function(H) {
      return li.isEnabled(H.playlist);
    });
    c.length || (c = l.filter(function(H) {
      return !li.isDisabled(H.playlist);
    }));
    var h = c.filter(function(H) {
      return H.bandwidth * Pr.BANDWIDTH_VARIANCE < r;
    }), f = h[h.length - 1], d = h.filter(function(H) {
      return H.bandwidth === f.bandwidth;
    })[0];
    if (a === !1) {
      var p = d || c[0] || l[0];
      if (p && p.playlist) {
        var _ = "sortedPlaylistReps";
        return d && (_ = "bandwidthBestRep"), c[0] && (_ = "enabledPlaylistReps"), Kl(
          "choosing " + pg(p) + " using " + _ + " with options",
          o
        ), p.playlist;
      }
      return Kl("could not choose a playlist with options", o), null;
    }
    var v = h.filter(function(H) {
      return H.width && H.height;
    });
    ks(v, function(H, Q) {
      return H.width - Q.width;
    });
    var x = v.filter(function(H) {
      return H.width === n && H.height === i;
    });
    f = x[x.length - 1];
    var E = x.filter(function(H) {
      return H.bandwidth === f.bandwidth;
    })[0], M, C, R;
    E || (M = v.filter(function(H) {
      return H.width > n || H.height > i;
    }), C = M.filter(function(H) {
      return H.width === M[0].width && H.height === M[0].height;
    }), f = C[C.length - 1], R = C.filter(function(H) {
      return H.bandwidth === f.bandwidth;
    })[0]);
    var B;
    if (s.experimentalLeastPixelDiffSelector) {
      var k = v.map(function(H) {
        return H.pixelDiff = Math.abs(H.width - n) + Math.abs(H.height - i), H;
      });
      ks(k, function(H, Q) {
        return H.pixelDiff === Q.pixelDiff ? Q.bandwidth - H.bandwidth : H.pixelDiff - Q.pixelDiff;
      }), B = k[0];
    }
    var F = B || R || E || d || c[0] || l[0];
    if (F && F.playlist) {
      var I = "sortedPlaylistReps";
      return B ? I = "leastPixelDiffRep" : R ? I = "resolutionPlusOneRep" : E ? I = "resolutionBestRep" : d ? I = "bandwidthBestRep" : c[0] && (I = "enabledPlaylistReps"), Kl(
        "choosing " + pg(F) + " using " + I + " with options",
        o
      ), F.playlist;
    }
    return Kl("could not choose a playlist with options", o), null;
  }
}, mg = function() {
  var t = this.useDevicePixelRatio && j.devicePixelRatio || 1;
  return fb(
    this.playlists.master,
    this.systemBandwidth,
    parseInt(Jc(this.tech_.el(), "width"), 10) * t,
    parseInt(Jc(this.tech_.el(), "height"), 10) * t,
    this.limitRenditionByPlayerDimensions,
    this.masterPlaylistController_
  );
}, jD = function(t) {
  var r = -1, n = -1;
  if (t < 0 || t > 1)
    throw new Error("Moving average bandwidth decay must be between 0 and 1.");
  return function() {
    var i = this.useDevicePixelRatio && j.devicePixelRatio || 1;
    return r < 0 && (r = this.systemBandwidth, n = this.systemBandwidth), this.systemBandwidth > 0 && this.systemBandwidth !== n && (r = t * this.systemBandwidth + (1 - t) * r, n = this.systemBandwidth), fb(
      this.playlists.master,
      r,
      parseInt(Jc(this.tech_.el(), "width"), 10) * i,
      parseInt(Jc(this.tech_.el(), "height"), 10) * i,
      this.limitRenditionByPlayerDimensions,
      this.masterPlaylistController_
    );
  };
}, qD = function(t) {
  var r = t.master, n = t.currentTime, i = t.bandwidth, a = t.duration, s = t.segmentDuration, o = t.timeUntilRebuffer, u = t.currentTimeline, l = t.syncController, c = r.playlists.filter(function(_) {
    return !li.isIncompatible(_);
  }), h = c.filter(li.isEnabled);
  h.length || (h = c.filter(function(_) {
    return !li.isDisabled(_);
  }));
  var f = h.filter(
    li.hasAttribute.bind(null, "BANDWIDTH")
  ), d = f.map(function(_) {
    var v = l.getSyncPoint(
      _,
      a,
      u,
      n
    ), x = v ? 1 : 2, E = li.estimateSegmentRequestTime(
      s,
      i,
      _
    ), M = E * x - o;
    return {
      playlist: _,
      rebufferingImpact: M
    };
  }), p = d.filter(function(_) {
    return _.rebufferingImpact <= 0;
  });
  return ks(p, function(_, v) {
    return um(v.playlist, _.playlist);
  }), p.length ? p[0] : (ks(d, function(_, v) {
    return _.rebufferingImpact - v.rebufferingImpact;
  }), d[0] || null);
}, XD = function() {
  var t = this, r = this.playlists.master.playlists.filter(li.isEnabled);
  ks(r, function(i, a) {
    return um(i, a);
  });
  var n = r.filter(function(i) {
    return !!du(t.playlists.master, i).video;
  });
  return n[0] || null;
}, YD = function(t) {
  var r = 0, n;
  return t.bytes && (n = new Uint8Array(t.bytes), t.segments.forEach(function(i) {
    n.set(i, r), r += i.byteLength;
  })), n;
}, QD = function(t, r, n) {
  if (!t[n]) {
    r.trigger({
      name: "vhs-608",
      type: "usage"
    }), r.trigger({
      name: "hls-608",
      type: "usage"
    });
    var i = n;
    /^cc708_/.test(n) && (i = "SERVICE" + n.split("_")[1]);
    var a = r.textTracks().getTrackById(i);
    if (a)
      t[n] = a;
    else {
      var s = r.options_.vhs && r.options_.vhs.captionServices || {}, o = n, u = n, l = !1, c = s[i];
      c && (o = c.label, u = c.language, l = c.default), t[n] = r.addRemoteTextTrack(
        {
          // TODO: investigate why this doesn't seem to turn the caption on by default
          default: l,
          id: i,
          kind: "captions",
          label: o,
          language: u
        },
        !1
      ).track;
    }
  }
}, KD = function(t) {
  var r = t.inbandTextTracks, n = t.captionArray, i = t.timestampOffset;
  if (n) {
    var a = j.WebKitDataCue || j.VTTCue;
    n.forEach(function(s) {
      var o = s.stream;
      r[o].addCue(
        new a(
          s.startTime + i,
          s.endTime + i,
          s.text
        )
      );
    });
  }
}, $D = function(t) {
  Object.defineProperties(t.frame, {
    id: {
      get: function() {
        return X.log.warn(
          "cue.frame.id is deprecated. Use cue.value.key instead."
        ), t.value.key;
      }
    },
    privateData: {
      get: function() {
        return X.log.warn(
          "cue.frame.privateData is deprecated. Use cue.value.data instead."
        ), t.value.data;
      }
    },
    value: {
      get: function() {
        return X.log.warn(
          "cue.frame.value is deprecated. Use cue.value.data instead."
        ), t.value.data;
      }
    }
  });
}, ZD = function(t) {
  var r = t.inbandTextTracks, n = t.metadataArray, i = t.timestampOffset, a = t.videoDuration;
  if (n) {
    var s = j.WebKitDataCue || j.VTTCue, o = r.metadataTrack_;
    if (o && (n.forEach(function(d) {
      var p = d.cueTime + i;
      typeof p != "number" || j.isNaN(p) || p < 0 || !(p < 1 / 0) || d.frames.forEach(function(_) {
        var v = new s(
          p,
          p,
          _.value || _.url || _.data || ""
        );
        v.frame = _, v.value = _, $D(v), o.addCue(v);
      });
    }), !(!o.cues || !o.cues.length))) {
      for (var u = o.cues, l = [], c = 0; c < u.length; c++)
        u[c] && l.push(u[c]);
      var h = l.reduce(function(d, p) {
        var _ = d[p.startTime] || [];
        return _.push(p), d[p.startTime] = _, d;
      }, {}), f = Object.keys(h).sort(
        function(d, p) {
          return Number(d) - Number(p);
        }
      );
      f.forEach(function(d, p) {
        var _ = h[d], v = Number(f[p + 1]) || a;
        _.forEach(function(x) {
          x.endTime = v;
        });
      });
    }
  }
}, JD = function(t, r, n) {
  t.metadataTrack_ || (t.metadataTrack_ = n.addRemoteTextTrack(
    {
      kind: "metadata",
      label: "Timed Metadata"
    },
    !1
  ).track, t.metadataTrack_.inBandMetadataTrackDispatchType = r);
}, su = function(t, r, n) {
  var i, a;
  if (n && n.cues)
    for (i = n.cues.length; i--; )
      a = n.cues[i], a.startTime >= t && a.endTime <= r && n.removeCue(a);
}, eP = function(t) {
  var r = t.cues;
  if (r)
    for (var n = 0; n < r.length; n++) {
      for (var i = [], a = 0, s = 0; s < r.length; s++)
        r[n].startTime === r[s].startTime && r[n].endTime === r[s].endTime && r[n].text === r[s].text && (a++, a > 1 && i.push(r[s]));
      i.length && i.forEach(function(o) {
        return t.removeCue(o);
      });
    }
}, tP = function(t, r, n) {
  if (typeof r > "u" || r === null || !t.length)
    return [];
  var i = Math.ceil(
    (r - n + 3) * kc.ONE_SECOND_IN_TS
  ), a;
  for (a = 0; a < t.length && !(t[a].pts > i); a++)
    ;
  return t.slice(a);
}, rP = function(t, r, n) {
  if (!r.length)
    return t;
  if (n)
    return r.slice();
  var i = r[0].pts, a = 0;
  for (a; a < t.length && !(t[a].pts >= i); a++)
    ;
  return t.slice(0, a).concat(r);
}, iP = function(t, r, n, i) {
  for (var a = Math.ceil((r - i) * kc.ONE_SECOND_IN_TS), s = Math.ceil((n - i) * kc.ONE_SECOND_IN_TS), o = t.slice(), u = t.length; u-- && !(t[u].pts <= s); )
    ;
  if (u === -1)
    return o;
  for (var l = u + 1; l-- && !(t[l].pts <= a); )
    ;
  return l = Math.max(l, 0), o.splice(l, u - l + 1), o;
}, nP = function(t, r) {
  if (!t && !r || !t && r || t && !r)
    return !1;
  if (t === r)
    return !0;
  var n = Object.keys(t).sort(), i = Object.keys(r).sort();
  if (n.length !== i.length)
    return !1;
  for (var a = 0; a < n.length; a++) {
    var s = n[a];
    if (s !== i[a] || t[s] !== r[s])
      return !1;
  }
  return !0;
}, db = 22, aP = function(t, r, n) {
  r = r || [];
  for (var i = [], a = 0, s = 0; s < r.length; s++) {
    var o = r[s];
    if (t === o.timeline && (i.push(s), a += o.duration, a > n))
      return s;
  }
  return i.length === 0 ? 0 : i[i.length - 1];
}, Jo = 1, sP = 500, vg = function(t) {
  return typeof t == "number" && isFinite(t);
}, $l = 1 / 60, oP = function(t, r, n) {
  return t !== "main" || !r || !n ? null : !n.hasAudio && !n.hasVideo ? "Neither audio nor video found in segment." : r.hasVideo && !n.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !r.hasVideo && n.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null;
}, uP = function(t, r, n) {
  var i = r - Pr.BACK_BUFFER_LENGTH;
  t.length && (i = Math.max(i, t.start(0)));
  var a = r - n;
  return Math.min(a, i);
}, Ds = function(t) {
  var r = t.startOfSegment, n = t.duration, i = t.segment, a = t.part, s = t.playlist, o = s.mediaSequence, u = s.id, l = s.segments, c = l === void 0 ? [] : l, h = t.mediaIndex, f = t.partIndex, d = t.timeline, p = c.length - 1, _ = "mediaIndex/partIndex increment";
  t.getMediaInfoForTime ? _ = "getMediaInfoForTime (" + t.getMediaInfoForTime + ")" : t.isSyncRequest && (_ = "getSyncSegmentCandidate (isSyncRequest)"), t.independent && (_ += " with independent " + t.independent);
  var v = typeof f == "number", x = t.segment.uri ? "segment" : "pre-segment", E = v ? B1({
    preloadSegment: i
  }) - 1 : 0;
  return x + " [" + (o + h) + "/" + (o + p) + "]" + (v ? " part [" + f + "/" + E + "]" : "") + (" segment start/end [" + i.start + " => " + i.end + "]") + (v ? " part start/end [" + a.start + " => " + a.end + "]" : "") + (" startOfSegment [" + r + "]") + (" duration [" + n + "]") + (" timeline [" + d + "]") + (" selected by [" + _ + "]") + (" playlist [" + u + "]");
}, gg = function(t) {
  return t + "TimingInfo";
}, lP = function(t) {
  var r = t.segmentTimeline, n = t.currentTimeline, i = t.startOfSegment, a = t.buffered, s = t.overrideCheck;
  return !s && r === n ? null : r < n ? i : a.length ? a.end(a.length - 1) : i;
}, yg = function(t) {
  var r = t.timelineChangeController, n = t.currentTimeline, i = t.segmentTimeline, a = t.loaderType, s = t.audioDisabled;
  if (n === i)
    return !1;
  if (a === "audio") {
    var o = r.lastTimelineChange({
      type: "main"
    });
    return !o || o.to !== i;
  }
  if (a === "main" && s) {
    var u = r.pendingTimelineChange({
      type: "audio"
    });
    return !(u && u.to === i);
  }
  return !1;
}, cP = function(t) {
  var r = 0;
  return ["video", "audio"].forEach(function(n) {
    var i = t[n + "TimingInfo"];
    if (i) {
      var a = i.start, s = i.end, o;
      typeof a == "bigint" || typeof s == "bigint" ? o = j.BigInt(s) - j.BigInt(a) : typeof a == "number" && typeof s == "number" && (o = s - a), typeof o < "u" && o > r && (r = o);
    }
  }), typeof r == "bigint" && r < Number.MAX_SAFE_INTEGER && (r = Number(r)), r;
}, _g = function(t) {
  var r = t.segmentDuration, n = t.maxDuration;
  return r ? Math.round(r) > n + ya : !1;
}, hP = function(t, r) {
  if (r !== "hls")
    return null;
  var n = cP({
    audioTimingInfo: t.audioTimingInfo,
    videoTimingInfo: t.videoTimingInfo
  });
  if (!n)
    return null;
  var i = t.playlist.targetDuration, a = _g({
    maxDuration: i * 2,
    segmentDuration: n
  }), s = _g({
    maxDuration: i,
    segmentDuration: n
  }), o = "Segment with index " + t.mediaIndex + " " + ("from playlist " + t.playlist.id + " ") + ("has a duration of " + n + " ") + ("when the reported duration is " + t.duration + " ") + ("and the target duration is " + i + ". ") + "For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
  return a || s ? {
    message: o,
    severity: a ? "warn" : "info"
  } : null;
}, _d = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    if (a = e.call(this) || this, !n)
      throw new TypeError("Initialization settings are required");
    if (typeof n.currentTime != "function")
      throw new TypeError("No currentTime getter specified");
    if (!n.mediaSource)
      throw new TypeError("No MediaSource specified");
    return a.bandwidth = n.bandwidth, a.throughput = {
      count: 0,
      rate: 0
    }, a.roundTrip = NaN, a.resetStats_(), a.mediaIndex = null, a.partIndex = null, a.hasPlayed_ = n.hasPlayed, a.currentTime_ = n.currentTime, a.seekable_ = n.seekable, a.seeking_ = n.seeking, a.duration_ = n.duration, a.mediaSource_ = n.mediaSource, a.vhs_ = n.vhs, a.loaderType_ = n.loaderType, a.currentMediaInfo_ = void 0, a.startingMediaInfo_ = void 0, a.segmentMetadataTrack_ = n.segmentMetadataTrack, a.goalBufferLength_ = n.goalBufferLength, a.sourceType_ = n.sourceType, a.sourceUpdater_ = n.sourceUpdater, a.inbandTextTracks_ = n.inbandTextTracks, a.state_ = "INIT", a.timelineChangeController_ = n.timelineChangeController, a.shouldSaveSegmentTimingInfo_ = !0, a.parse708captions_ = n.parse708captions, a.useDtsForTimestampOffset_ = n.useDtsForTimestampOffset, a.captionServices_ = n.captionServices, a.experimentalExactManifestTimings = n.experimentalExactManifestTimings, a.checkBufferTimeout_ = null, a.error_ = void 0, a.currentTimeline_ = -1, a.pendingSegment_ = null, a.xhrOptions_ = null, a.pendingSegments_ = [], a.audioDisabled_ = !1, a.isPendingTimestampOffset_ = !1, a.gopBuffer_ = [], a.timeMapping_ = 0, a.safeAppend_ = X.browser.IE_VERSION >= 11, a.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, a.playlistOfLastInitSegment_ = {
      audio: null,
      video: null
    }, a.callQueue_ = [], a.loadQueue_ = [], a.metadataQueue_ = {
      caption: [],
      id3: []
    }, a.waitingOnRemove_ = !1, a.quotaExceededErrorRetryTimeout_ = null, a.activeInitSegmentId_ = null, a.initSegments_ = {}, a.cacheEncryptionKeys_ = n.cacheEncryptionKeys, a.keyCache_ = {}, a.decrypter_ = n.decrypter, a.syncController_ = n.syncController, a.syncPoint_ = {
      segmentIndex: 0,
      time: 0
    }, a.transmuxer_ = a.createTransmuxer_(), a.triggerSyncInfoUpdate_ = function() {
      return a.trigger("syncinfoupdate");
    }, a.syncController_.on("syncinfoupdate", a.triggerSyncInfoUpdate_), a.mediaSource_.addEventListener("sourceopen", function() {
      a.isEndOfStream_() || (a.ended_ = !1);
    }), a.fetchAtBuffer_ = !1, a.logger_ = nn("SegmentLoader[" + a.loaderType_ + "]"), Object.defineProperty(ze(a), "state", {
      get: function() {
        return this.state_;
      },
      set: function(o) {
        o !== this.state_ && (this.logger_(this.state_ + " -> " + o), this.state_ = o, this.trigger("statechange"));
      }
    }), a.sourceUpdater_.on("ready", function() {
      a.hasEnoughInfoToAppend_() && a.processCallQueue_();
    }), a.loaderType_ === "main" && a.timelineChangeController_.on("pendingtimelinechange", function() {
      a.hasEnoughInfoToAppend_() && a.processCallQueue_();
    }), a.loaderType_ === "audio" && a.timelineChangeController_.on("timelinechange", function() {
      a.hasEnoughInfoToLoad_() && a.processLoadQueue_(), a.hasEnoughInfoToAppend_() && a.processCallQueue_();
    }), a;
  }
  var r = t.prototype;
  return r.createTransmuxer_ = function() {
    return Af.createTransmuxer({
      alignGopsAtEnd: this.safeAppend_,
      captionServices: this.captionServices_,
      keepOriginalTimestamps: !0,
      parse708captions: this.parse708captions_,
      remux: !1
    });
  }, r.resetStats_ = function() {
    this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0;
  }, r.dispose = function() {
    this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && j.clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off();
  }, r.setAudio = function(i) {
    this.audioDisabled_ = !i, i ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_());
  }, r.abort = function() {
    if (this.state !== "WAITING") {
      this.pendingSegment_ && (this.pendingSegment_ = null);
      return;
    }
    this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_();
  }, r.abort_ = function() {
    this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, j.clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null;
  }, r.checkForAbort_ = function(i) {
    return this.state === "APPENDING" && !this.pendingSegment_ ? (this.state = "READY", !0) : !this.pendingSegment_ || this.pendingSegment_.requestId !== i;
  }, r.error = function(i) {
    return typeof i < "u" && (this.logger_("error occurred:", i), this.error_ = i), this.pendingSegment_ = null, this.error_;
  }, r.endOfStream = function() {
    this.ended_ = !0, this.transmuxer_ && Af.reset(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended");
  }, r.buffered_ = function() {
    var i = this.getMediaInfo_();
    if (!this.sourceUpdater_ || !i)
      return X.createTimeRanges();
    if (this.loaderType_ === "main") {
      var a = i.hasAudio, s = i.hasVideo, o = i.isMuxed;
      if (s && a && !this.audioDisabled_ && !o)
        return this.sourceUpdater_.buffered();
      if (s)
        return this.sourceUpdater_.videoBuffered();
    }
    return this.sourceUpdater_.audioBuffered();
  }, r.initSegmentForMap = function(i, a) {
    if (a === void 0 && (a = !1), !i)
      return null;
    var s = Kc(i), o = this.initSegments_[s];
    return a && !o && i.bytes && (this.initSegments_[s] = o = {
      byterange: i.byterange,
      bytes: i.bytes,
      resolvedUri: i.resolvedUri,
      timescales: i.timescales,
      tracks: i.tracks
    }), o || i;
  }, r.segmentKey = function(i, a) {
    if (a === void 0 && (a = !1), !i)
      return null;
    var s = K1(i), o = this.keyCache_[s];
    this.cacheEncryptionKeys_ && a && !o && i.bytes && (this.keyCache_[s] = o = {
      bytes: i.bytes,
      resolvedUri: i.resolvedUri
    });
    var u = {
      resolvedUri: (o || i).resolvedUri
    };
    return o && (u.bytes = o.bytes), u;
  }, r.couldBeginLoading_ = function() {
    return this.playlist_ && !this.paused();
  }, r.load = function() {
    if (this.monitorBuffer_(), !!this.playlist_) {
      if (this.state === "INIT" && this.couldBeginLoading_())
        return this.init_();
      !this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT" || (this.state = "READY");
    }
  }, r.init_ = function() {
    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
  }, r.playlist = function(i, a) {
    if (a === void 0 && (a = {}), !!i) {
      var s = this.playlist_, o = this.pendingSegment_;
      this.playlist_ = i, this.xhrOptions_ = a, this.state === "INIT" && (i.syncInfo = {
        mediaSequence: i.mediaSequence,
        time: 0
      }, this.loaderType_ === "main" && this.syncController_.setDateTimeMappingForStart(i));
      var u = null;
      if (s && (s.id ? u = s.id : s.uri && (u = s.uri)), this.logger_(
        "playlist update [" + u + " => " + (i.id || i.uri) + "]"
      ), this.trigger("syncinfoupdate"), this.state === "INIT" && this.couldBeginLoading_())
        return this.init_();
      if (!s || s.uri !== i.uri) {
        this.mediaIndex !== null && (i.endList ? this.resyncLoader() : this.resetLoader()), this.currentMediaInfo_ = void 0, this.trigger("playlistupdate");
        return;
      }
      var l = i.mediaSequence - s.mediaSequence;
      if (this.logger_("live window shift [" + l + "]"), this.mediaIndex !== null)
        if (this.mediaIndex -= l, this.mediaIndex < 0)
          this.mediaIndex = null, this.partIndex = null;
        else {
          var c = this.playlist_.segments[this.mediaIndex];
          if (this.partIndex && (!c.parts || !c.parts.length || !c.parts[this.partIndex])) {
            var h = this.mediaIndex;
            this.logger_(
              "currently processing part (index " + this.partIndex + ") no longer exists."
            ), this.resetLoader(), this.mediaIndex = h;
          }
        }
      o && (o.mediaIndex -= l, o.mediaIndex < 0 ? (o.mediaIndex = null, o.partIndex = null) : (o.mediaIndex >= 0 && (o.segment = i.segments[o.mediaIndex]), o.partIndex >= 0 && o.segment.parts && (o.part = o.segment.parts[o.partIndex]))), this.syncController_.saveExpiredSegmentInfo(s, i);
    }
  }, r.pause = function() {
    this.checkBufferTimeout_ && (j.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null);
  }, r.paused = function() {
    return this.checkBufferTimeout_ === null;
  }, r.resetEverything = function(i) {
    this.ended_ = !1, this.activeInitSegmentId_ = null, this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.resetLoader(), this.remove(0, 1 / 0, i), this.transmuxer_ && (this.transmuxer_.postMessage({
      action: "clearAllMp4Captions"
    }), this.transmuxer_.postMessage({
      action: "reset"
    }));
  }, r.resetLoader = function() {
    this.fetchAtBuffer_ = !1, this.resyncLoader();
  }, r.resyncLoader = function() {
    this.transmuxer_ && Af.reset(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.abort(), this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearParsedMp4Captions"
    });
  }, r.remove = function(i, a, s, o) {
    if (s === void 0 && (s = function() {
    }), o === void 0 && (o = !1), a === 1 / 0 && (a = this.duration_()), a <= i) {
      this.logger_("skipping remove because end ${end} is <= start ${start}");
      return;
    }
    if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
      this.logger_(
        "skipping remove because no source updater or starting media info"
      );
      return;
    }
    var u = 1, l = function() {
      u--, u === 0 && s();
    };
    (o || !this.audioDisabled_) && (u++, this.sourceUpdater_.removeAudio(i, a, l)), (o || this.loaderType_ === "main") && (this.gopBuffer_ = iP(
      this.gopBuffer_,
      i,
      a,
      this.timeMapping_
    ), u++, this.sourceUpdater_.removeVideo(i, a, l));
    for (var c in this.inbandTextTracks_)
      su(i, a, this.inbandTextTracks_[c]);
    su(i, a, this.segmentMetadataTrack_), l();
  }, r.monitorBuffer_ = function() {
    this.checkBufferTimeout_ && j.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = j.setTimeout(
      this.monitorBufferTick_.bind(this),
      1
    );
  }, r.monitorBufferTick_ = function() {
    this.state === "READY" && this.fillBuffer_(), this.checkBufferTimeout_ && j.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = j.setTimeout(
      this.monitorBufferTick_.bind(this),
      sP
    );
  }, r.fillBuffer_ = function() {
    if (!this.sourceUpdater_.updating()) {
      var i = this.chooseNextRequest_();
      i && (typeof i.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({
        from: this.currentTimeline_,
        to: i.timeline,
        type: this.loaderType_
      })), this.loadSegment_(i));
    }
  }, r.isEndOfStream_ = function(i, a, s) {
    if (i === void 0 && (i = this.mediaIndex), a === void 0 && (a = this.playlist_), s === void 0 && (s = this.partIndex), !a || !this.mediaSource_)
      return !1;
    var o = typeof i == "number" && a.segments[i], u = i + 1 === a.segments.length, l = !o || !o.parts || s + 1 === o.parts.length;
    return a.endList && this.mediaSource_.readyState === "open" && u && l;
  }, r.chooseNextRequest_ = function() {
    var i = this.buffered_(), a = sg(i) || 0, s = rm(i, this.currentTime_()), o = !this.hasPlayed_() && s >= 1, u = s >= this.goalBufferLength_(), l = this.playlist_.segments;
    if (!l.length || o || u)
      return null;
    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(
      this.playlist_,
      this.duration_(),
      this.currentTimeline_,
      this.currentTime_()
    );
    var c = {
      isSyncRequest: !this.syncPoint_,
      mediaIndex: null,
      partIndex: null,
      playlist: this.playlist_,
      startOfSegment: null
    };
    if (c.isSyncRequest)
      c.mediaIndex = aP(
        this.currentTimeline_,
        l,
        a
      );
    else if (this.mediaIndex !== null) {
      var h = l[this.mediaIndex], f = typeof this.partIndex == "number" ? this.partIndex : -1;
      c.startOfSegment = h.end ? h.end : a, h.parts && h.parts[f + 1] ? (c.mediaIndex = this.mediaIndex, c.partIndex = f + 1) : c.mediaIndex = this.mediaIndex + 1;
    } else {
      var d = li.getMediaInfoForTime({
        currentTime: this.fetchAtBuffer_ ? a : this.currentTime_(),
        experimentalExactManifestTimings: this.experimentalExactManifestTimings,
        playlist: this.playlist_,
        startTime: this.syncPoint_.time,
        startingPartIndex: this.syncPoint_.partIndex,
        startingSegmentIndex: this.syncPoint_.segmentIndex
      }), p = d.segmentIndex, _ = d.startTime, v = d.partIndex;
      c.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + a : "currentTime " + this.currentTime_(), c.mediaIndex = p, c.startOfSegment = _, c.partIndex = v;
    }
    var x = l[c.mediaIndex], E = x && typeof c.partIndex == "number" && x.parts && x.parts[c.partIndex];
    if (!x || typeof c.partIndex == "number" && !E)
      return null;
    if (typeof c.partIndex != "number" && x.parts && (c.partIndex = 0, E = x.parts[0]), !s && E && !E.independent)
      if (c.partIndex === 0) {
        var M = l[c.mediaIndex - 1], C = M.parts && M.parts.length && M.parts[M.parts.length - 1];
        C && C.independent && (c.mediaIndex -= 1, c.partIndex = M.parts.length - 1, c.independent = "previous segment");
      } else x.parts[c.partIndex - 1].independent && (c.partIndex -= 1, c.independent = "previous part");
    var R = this.mediaSource_ && this.mediaSource_.readyState === "ended";
    return c.mediaIndex >= l.length - 1 && R && !this.seeking_() ? null : this.generateSegmentInfo_(c);
  }, r.generateSegmentInfo_ = function(i) {
    var a = i.independent, s = i.playlist, o = i.mediaIndex, u = i.startOfSegment, l = i.isSyncRequest, c = i.partIndex, h = i.forceTimestampOffset, f = i.getMediaInfoForTime, d = s.segments[o], p = typeof c == "number" && d.parts[c], _ = {
      // unencrypted bytes of the segment
      bytes: null,
      // when a key is defined for this segment, the encrypted bytes
      encryptedBytes: null,
      // whether or not to update the SegmentLoader's state with this
      // segment's mediaIndex
      isSyncRequest: l,
      // The expected duration of the segment in seconds
      duration: p && p.duration || d.duration,
      // the segment's mediaIndex at the time it was requested
      mediaIndex: o,
      part: p,
      partIndex: p ? c : null,
      // the segment's playlist
      playlist: s,
      byteLength: 0,
      requestId: "segment-loader-" + Math.random(),
      // type of getMediaInfoForTime that was used to get this segment
      getMediaInfoForTime: f,
      // resolve the segment URL relative to the playlist
      uri: p && p.resolvedUri || d.resolvedUri,
      independent: a,
      startOfSegment: u,
      // retain the segment in case the playlist updates while doing an async process
      segment: d,
      // The timeline that the segment is in
      timeline: d.timeline,
      // The target timestampOffset for this segment when we append it
      // to the source buffer
      timestampOffset: null,
      transmuxer: this.transmuxer_
    }, v = typeof h < "u" ? h : this.isPendingTimestampOffset_;
    _.timestampOffset = this.timestampOffsetForSegment_({
      buffered: this.buffered_(),
      currentTimeline: this.currentTimeline_,
      overrideCheck: v,
      segmentTimeline: d.timeline,
      startOfSegment: u
    });
    var x = sg(this.sourceUpdater_.audioBuffered());
    return typeof x == "number" && (_.audioAppendStart = x - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (_.gopsToAlignWith = tP(
      this.gopBuffer_,
      // since the transmuxer is using the actual timing values, but the time is
      // adjusted by the timestmap offset, we must adjust the value here
      this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(),
      this.timeMapping_
    )), _;
  }, r.timestampOffsetForSegment_ = function(i) {
    return lP(i);
  }, r.earlyAbortWhenNeeded_ = function(i) {
    if (!(this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition
    // TODO: Replace using timeout with a boolean indicating whether this playlist is
    //       the lowestEnabledRendition.
    !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes
    !this.playlist_.attributes.BANDWIDTH) && !(Date.now() - (i.firstBytesReceivedAt || Date.now()) < 1e3)) {
      var a = this.currentTime_(), s = i.bandwidth, o = this.pendingSegment_.duration, u = li.estimateSegmentRequestTime(
        o,
        s,
        this.playlist_,
        i.bytesReceived
      ), l = R3(
        this.buffered_(),
        a,
        this.vhs_.tech_.playbackRate()
      ) - 1;
      if (!(u <= l)) {
        var c = qD({
          bandwidth: s,
          currentTime: a,
          currentTimeline: this.currentTimeline_,
          duration: this.duration_(),
          master: this.vhs_.playlists.master,
          segmentDuration: o,
          syncController: this.syncController_,
          timeUntilRebuffer: l
        });
        if (c) {
          var h = u - l, f = h - c.rebufferingImpact, d = 0.5;
          l <= ya && (d = 1), !(!c.playlist || c.playlist.uri === this.playlist_.uri || f < d) && (this.bandwidth = c.playlist.attributes.BANDWIDTH * Pr.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort"));
        }
      }
    }
  }, r.handleAbort_ = function(i) {
    this.logger_("Aborting " + Ds(i)), this.mediaRequestsAborted += 1;
  }, r.handleProgress_ = function(i, a) {
    this.earlyAbortWhenNeeded_(a.stats), !this.checkForAbort_(a.requestId) && this.trigger("progress");
  }, r.handleTrackInfo_ = function(i, a) {
    this.earlyAbortWhenNeeded_(i.stats), !this.checkForAbort_(i.requestId) && (this.checkForIllegalMediaSwitch(a) || (a = a || {}, nP(this.currentMediaInfo_, a) || (this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.startingMediaInfo_ = a, this.currentMediaInfo_ = a, this.logger_("trackinfo update", a), this.trigger("trackinfo")), !this.checkForAbort_(i.requestId) && (this.pendingSegment_.trackInfo = a, this.hasEnoughInfoToAppend_() && this.processCallQueue_())));
  }, r.handleTimingInfo_ = function(i, a, s, o) {
    if (this.earlyAbortWhenNeeded_(i.stats), !this.checkForAbort_(i.requestId)) {
      var u = this.pendingSegment_, l = gg(a);
      u[l] = u[l] || {}, u[l][s] = o, this.logger_("timinginfo: " + a + " - " + s + " - " + o), this.hasEnoughInfoToAppend_() && this.processCallQueue_();
    }
  }, r.handleCaptions_ = function(i, a) {
    var s = this;
    if (this.earlyAbortWhenNeeded_(i.stats), !this.checkForAbort_(i.requestId)) {
      if (a.length === 0) {
        this.logger_("SegmentLoader received no captions from a caption event");
        return;
      }
      var o = this.pendingSegment_;
      if (!o.hasAppendedData_) {
        this.metadataQueue_.caption.push(
          this.handleCaptions_.bind(this, i, a)
        );
        return;
      }
      var u = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(), l = {};
      a.forEach(function(c) {
        l[c.stream] = l[c.stream] || {
          captions: [],
          // 0 as an other value will be more than this
          endTime: 0,
          // Infinity, as any other value will be less than this
          startTime: 1 / 0
        };
        var h = l[c.stream];
        h.startTime = Math.min(
          h.startTime,
          c.startTime + u
        ), h.endTime = Math.max(
          h.endTime,
          c.endTime + u
        ), h.captions.push(c);
      }), Object.keys(l).forEach(function(c) {
        var h = l[c], f = h.startTime, d = h.endTime, p = h.captions, _ = s.inbandTextTracks_;
        s.logger_(
          "adding cues from " + f + " -> " + d + " for " + c
        ), QD(
          _,
          s.vhs_.tech_,
          c
        ), su(f, d, _[c]), KD({
          captionArray: p,
          inbandTextTracks: _,
          timestampOffset: u
        });
      }), this.transmuxer_ && this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  }, r.handleId3_ = function(i, a, s) {
    if (this.earlyAbortWhenNeeded_(i.stats), !this.checkForAbort_(i.requestId)) {
      var o = this.pendingSegment_;
      if (!o.hasAppendedData_) {
        this.metadataQueue_.id3.push(
          this.handleId3_.bind(this, i, a, s)
        );
        return;
      }
      var u = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
      JD(
        this.inbandTextTracks_,
        s,
        this.vhs_.tech_
      ), ZD({
        inbandTextTracks: this.inbandTextTracks_,
        metadataArray: a,
        timestampOffset: u,
        videoDuration: this.duration_()
      });
    }
  }, r.processMetadataQueue_ = function() {
    this.metadataQueue_.id3.forEach(function(i) {
      return i();
    }), this.metadataQueue_.caption.forEach(function(i) {
      return i();
    }), this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [];
  }, r.processCallQueue_ = function() {
    var i = this.callQueue_;
    this.callQueue_ = [], i.forEach(function(a) {
      return a();
    });
  }, r.processLoadQueue_ = function() {
    var i = this.loadQueue_;
    this.loadQueue_ = [], i.forEach(function(a) {
      return a();
    });
  }, r.hasEnoughInfoToLoad_ = function() {
    if (this.loaderType_ !== "audio")
      return !0;
    var i = this.pendingSegment_;
    return i ? this.getCurrentMediaInfo_() ? (
      // Technically, instead of waiting to load a segment on timeline changes, a segment
      // can be requested and downloaded and only wait before it is transmuxed or parsed.
      // But in practice, there are a few reasons why it is better to wait until a loader
      // is ready to append that segment before requesting and downloading:
      //
      // 1. Because audio and main loaders cross discontinuities together, if this loader
      //    is waiting for the other to catch up, then instead of requesting another
      //    segment and using up more bandwidth, by not yet loading, more bandwidth is
      //    allotted to the loader currently behind.
      // 2. media-segment-request doesn't have to have logic to consider whether a segment
      // is ready to be processed or not, isolating the queueing behavior to the loader.
      // 3. The audio loader bases some of its segment properties on timing information
      //    provided by the main loader, meaning that, if the logic for waiting on
      //    processing was in media-segment-request, then it would also need to know how
      //    to re-generate the segment information after the main loader caught up.
      !yg({
        audioDisabled: this.audioDisabled_,
        currentTimeline: this.currentTimeline_,
        loaderType: this.loaderType_,
        segmentTimeline: i.timeline,
        timelineChangeController: this.timelineChangeController_
      })
    ) : !0 : !1;
  }, r.getCurrentMediaInfo_ = function(i) {
    return i === void 0 && (i = this.pendingSegment_), i && i.trackInfo || this.currentMediaInfo_;
  }, r.getMediaInfo_ = function(i) {
    return i === void 0 && (i = this.pendingSegment_), this.getCurrentMediaInfo_(i) || this.startingMediaInfo_;
  }, r.getPendingSegmentPlaylist = function() {
    return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
  }, r.hasEnoughInfoToAppend_ = function() {
    if (!this.sourceUpdater_.ready() || this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_)
      return !1;
    var i = this.pendingSegment_, a = this.getCurrentMediaInfo_();
    if (!i || !a)
      return !1;
    var s = a.hasAudio, o = a.hasVideo, u = a.isMuxed;
    return !(o && !i.videoTimingInfo || s && !this.audioDisabled_ && !u && !i.audioTimingInfo || yg({
      audioDisabled: this.audioDisabled_,
      currentTimeline: this.currentTimeline_,
      loaderType: this.loaderType_,
      segmentTimeline: i.timeline,
      timelineChangeController: this.timelineChangeController_
    }));
  }, r.handleData_ = function(i, a) {
    if (this.earlyAbortWhenNeeded_(i.stats), !this.checkForAbort_(i.requestId)) {
      if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
        this.callQueue_.push(this.handleData_.bind(this, i, a));
        return;
      }
      var s = this.pendingSegment_;
      if (this.setTimeMapping_(s.timeline), this.updateMediaSecondsLoaded_(s.part || s.segment), this.mediaSource_.readyState !== "closed") {
        if (i.map && (i.map = this.initSegmentForMap(i.map, !0), s.segment.map = i.map), i.key && this.segmentKey(i.key, !0), s.isFmp4 = i.isFmp4, s.timingInfo = s.timingInfo || {}, s.isFmp4)
          this.trigger("fmp4"), s.timingInfo.start = s[gg(a.type)].start;
        else {
          var o = this.getCurrentMediaInfo_(), u = this.loaderType_ === "main" && o && o.hasVideo, l;
          u && (l = s.videoTimingInfo.start), s.timingInfo.start = this.trueSegmentStart_({
            audioTimingInfo: s.audioTimingInfo,
            currentStart: s.timingInfo.start,
            currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
            firstVideoFrameTimeForData: l,
            mediaIndex: s.mediaIndex,
            playlist: s.playlist,
            useVideoTimingInfo: u,
            videoTimingInfo: s.videoTimingInfo
          });
        }
        if (this.updateAppendInitSegmentStatus(s, a.type), this.updateSourceBufferTimestampOffset_(s), s.isSyncRequest) {
          this.updateTimingInfoEnd_(s), this.syncController_.saveSegmentTimingInfo({
            segmentInfo: s,
            shouldSaveTimelineMapping: this.loaderType_ === "main"
          });
          var c = this.chooseNextRequest_();
          if (c.mediaIndex !== s.mediaIndex || c.partIndex !== s.partIndex) {
            this.logger_("sync segment was incorrect, not appending");
            return;
          }
          this.logger_("sync segment was correct, appending");
        }
        s.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(s, a), a.type === "video" && this.vhs_.tech_.trigger({
          name: "vhs-segment",
          payload: {
            result: a,
            segmentInfo: s,
            simpleSegment: i
          },
          type: "vhs"
        });
      }
    }
  }, r.updateAppendInitSegmentStatus = function(i, a) {
    this.loaderType_ === "main" && typeof i.timestampOffset == "number" && // in the case that we're handling partial data, we don't want to append an init
    // segment for each chunk
    !i.changedTimestampOffset && (this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }), this.playlistOfLastInitSegment_[a] !== i.playlist && (this.appendInitSegment_[a] = !0);
  }, r.getInitSegmentAndUpdateState_ = function(i) {
    var a = i.type, s = i.initSegment, o = i.map, u = i.playlist;
    if (o) {
      var l = Kc(o);
      if (this.activeInitSegmentId_ === l)
        return null;
      s = this.initSegmentForMap(o, !0).bytes, this.activeInitSegmentId_ = l;
    }
    return s && this.appendInitSegment_[a] ? (this.playlistOfLastInitSegment_[a] = u, this.appendInitSegment_[a] = !1, this.activeInitSegmentId_ = null, s) : null;
  }, r.handleQuotaExceededError_ = function(i, a) {
    var s = this, o = i.segmentInfo, u = i.type, l = i.bytes, c = this.sourceUpdater_.audioBuffered(), h = this.sourceUpdater_.videoBuffered();
    c.length > 1 && this.logger_(
      "On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + Ba(c).join(", ")
    ), h.length > 1 && this.logger_(
      "On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + Ba(h).join(", ")
    );
    var f = c.length ? c.start(0) : 0, d = c.length ? c.end(c.length - 1) : 0, p = h.length ? h.start(0) : 0, _ = h.length ? h.end(h.length - 1) : 0;
    if (d - f <= Jo && _ - p <= Jo) {
      this.logger_(
        "On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. " + ("Appended byte length: " + l.byteLength + ", ") + ("audio buffer: " + Ba(c).join(", ") + ", ") + ("video buffer: " + Ba(h).join(", ") + ", ")
      ), this.error({
        excludeUntil: 1 / 0,
        message: "Quota exceeded error with append of a single segment of content"
      }), this.trigger("error");
      return;
    }
    this.waitingOnRemove_ = !0, this.callQueue_.push(
      this.appendToSourceBuffer_.bind(this, {
        bytes: l,
        segmentInfo: o,
        type: u
      })
    );
    var v = this.currentTime_(), x = v - Jo;
    this.logger_(
      "On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + x
    ), this.remove(
      0,
      x,
      function() {
        s.logger_(
          "On QUOTA_EXCEEDED_ERR, retrying append in " + Jo + "s"
        ), s.waitingOnRemove_ = !1, s.quotaExceededErrorRetryTimeout_ = j.setTimeout(
          function() {
            s.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), s.quotaExceededErrorRetryTimeout_ = null, s.processCallQueue_();
          },
          Jo * 1e3
        );
      },
      !0
    );
  }, r.handleAppendError_ = function(i, a) {
    var s = i.segmentInfo, o = i.type, u = i.bytes;
    if (a) {
      if (a.code === db) {
        this.handleQuotaExceededError_({
          bytes: u,
          segmentInfo: s,
          type: o
        });
        return;
      }
      this.logger_("Received non QUOTA_EXCEEDED_ERR on append", a), this.error(
        o + " append of " + u.length + "b failed for segment " + ("#" + s.mediaIndex + " in playlist " + s.playlist.id)
      ), this.trigger("appenderror");
    }
  }, r.appendToSourceBuffer_ = function(i) {
    var a = i.segmentInfo, s = i.type, o = i.initSegment, u = i.data, l = i.bytes;
    if (!l) {
      var c = [u], h = u.byteLength;
      o && (c.unshift(o), h += o.byteLength), l = YD({
        bytes: h,
        segments: c
      });
    }
    this.sourceUpdater_.appendBuffer(
      {
        bytes: l,
        segmentInfo: a,
        type: s
      },
      this.handleAppendError_.bind(this, {
        bytes: l,
        segmentInfo: a,
        type: s
      })
    );
  }, r.handleSegmentTimingInfo_ = function(i, a, s) {
    if (!(!this.pendingSegment_ || a !== this.pendingSegment_.requestId)) {
      var o = this.pendingSegment_.segment, u = i + "TimingInfo";
      o[u] || (o[u] = {}), o[u].transmuxerPrependedSeconds = s.prependedContentDuration || 0, o[u].transmuxedPresentationStart = s.start.presentation, o[u].transmuxedDecodeStart = s.start.decode, o[u].transmuxedPresentationEnd = s.end.presentation, o[u].transmuxedDecodeEnd = s.end.decode, o[u].baseMediaDecodeTime = s.baseMediaDecodeTime;
    }
  }, r.appendData_ = function(i, a) {
    var s = a.type, o = a.data;
    if (!(!o || !o.byteLength) && !(s === "audio" && this.audioDisabled_)) {
      var u = this.getInitSegmentAndUpdateState_({
        initSegment: a.initSegment,
        map: i.isFmp4 ? i.segment.map : null,
        playlist: i.playlist,
        type: s
      });
      this.appendToSourceBuffer_({
        data: o,
        initSegment: u,
        segmentInfo: i,
        type: s
      });
    }
  }, r.loadSegment_ = function(i) {
    var a = this;
    if (this.state = "WAITING", this.pendingSegment_ = i, this.trimBackBuffer_(i), typeof i.timestampOffset == "number" && this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearAllMp4Captions"
    }), !this.hasEnoughInfoToLoad_()) {
      this.loadQueue_.push(function() {
        var s = Bi({}, i, {
          forceTimestampOffset: !0
        });
        Bi(i, a.generateSegmentInfo_(s)), a.isPendingTimestampOffset_ = !1, a.updateTransmuxerAndRequestSegment_(i);
      });
      return;
    }
    this.updateTransmuxerAndRequestSegment_(i);
  }, r.updateTransmuxerAndRequestSegment_ = function(i) {
    var a = this;
    this.shouldUpdateTransmuxerTimestampOffset_(i.timestampOffset) && (this.gopBuffer_.length = 0, i.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({
      action: "reset"
    }), this.transmuxer_.postMessage({
      action: "setTimestampOffset",
      timestampOffset: i.timestampOffset
    }));
    var s = this.createSimplifiedSegmentObj_(i), o = this.isEndOfStream_(
      i.mediaIndex,
      i.playlist,
      i.partIndex
    ), u = this.mediaIndex !== null, l = i.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,
    // the first timeline
    i.timeline > 0, c = o || u && l;
    this.logger_("Requesting " + Ds(i)), s.map && !s.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }), i.abortRequests = GD({
      abortFn: this.handleAbort_.bind(this, i),
      audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(
        this,
        "audio",
        i.requestId
      ),
      captionsFn: this.handleCaptions_.bind(this),
      decryptionWorker: this.decrypter_,
      endedTimelineFn: function() {
        a.logger_("received endedtimeline callback");
      },
      progressFn: this.handleProgress_.bind(this),
      dataFn: this.handleData_.bind(this),
      segment: s,
      doneFn: this.segmentRequestFinished_.bind(this),
      xhr: this.vhs_.xhr,
      id3Fn: this.handleId3_.bind(this),
      xhrOptions: this.xhrOptions_,
      isEndOfTimeline: c,
      onTransmuxerLog: function(f) {
        var d = f.message, p = f.level, _ = f.stream;
        a.logger_(
          Ds(i) + " logged from transmuxer stream " + _ + " as a " + p + ": " + d
        );
      },
      timingInfoFn: this.handleTimingInfo_.bind(this),
      trackInfoFn: this.handleTrackInfo_.bind(this),
      videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(
        this,
        "video",
        i.requestId
      )
    });
  }, r.trimBackBuffer_ = function(i) {
    var a = uP(
      this.seekable_(),
      this.currentTime_(),
      this.playlist_.targetDuration || 10
    );
    a > 0 && this.remove(0, a);
  }, r.createSimplifiedSegmentObj_ = function(i) {
    var a = i.segment, s = i.part, o = {
      audioAppendStart: i.audioAppendStart,
      byterange: s ? s.byterange : a.byterange,
      gopsToAlignWith: i.gopsToAlignWith,
      part: i.part,
      requestId: i.requestId,
      resolvedUri: s ? s.resolvedUri : a.resolvedUri,
      transmuxer: i.transmuxer
    }, u = i.playlist.segments[i.mediaIndex - 1];
    if (u && u.timeline === a.timeline && (u.videoTimingInfo ? o.baseStartTime = u.videoTimingInfo.transmuxedDecodeEnd : u.audioTimingInfo && (o.baseStartTime = u.audioTimingInfo.transmuxedDecodeEnd)), a.key) {
      var l = a.key.iv || new Uint32Array([
        0,
        0,
        0,
        i.mediaIndex + i.playlist.mediaSequence
      ]);
      o.key = this.segmentKey(a.key), o.key.iv = l;
    }
    return a.map && (o.map = this.initSegmentForMap(a.map)), o;
  }, r.saveTransferStats_ = function(i) {
    this.mediaRequests += 1, i && (this.mediaBytesTransferred += i.bytesReceived, this.mediaTransferDuration += i.roundTripTime);
  }, r.saveBandwidthRelatedStats_ = function(i, a) {
    if (this.pendingSegment_.byteLength = a.bytesReceived, i < $l) {
      this.logger_(
        "Ignoring segment's bandwidth because its duration of " + i + (" is less than the min to record " + $l)
      );
      return;
    }
    this.bandwidth = a.bandwidth, this.roundTrip = a.roundTripTime;
  }, r.handleTimeout_ = function() {
    this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate"), this.trigger("timeout");
  }, r.segmentRequestFinished_ = function(i, a, s) {
    if (this.callQueue_.length) {
      this.callQueue_.push(
        this.segmentRequestFinished_.bind(this, i, a, s)
      );
      return;
    }
    if (this.saveTransferStats_(a.stats), !!this.pendingSegment_ && a.requestId === this.pendingSegment_.requestId) {
      if (i) {
        if (this.pendingSegment_ = null, this.state = "READY", i.code === pn.ABORTED)
          return;
        if (this.pause(), i.code === pn.TIMEOUT) {
          this.handleTimeout_();
          return;
        }
        this.mediaRequestsErrored += 1, this.error(i), this.trigger("error");
        return;
      }
      var o = this.pendingSegment_;
      this.saveBandwidthRelatedStats_(o.duration, a.stats), o.endOfAllRequests = a.endOfAllRequests, s.gopInfo && (this.gopBuffer_ = rP(
        this.gopBuffer_,
        s.gopInfo,
        this.safeAppend_
      )), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(o);
    }
  }, r.setTimeMapping_ = function(i) {
    var a = this.syncController_.mappingForTimeline(i);
    a !== null && (this.timeMapping_ = a);
  }, r.updateMediaSecondsLoaded_ = function(i) {
    typeof i.start == "number" && typeof i.end == "number" ? this.mediaSecondsLoaded += i.end - i.start : this.mediaSecondsLoaded += i.duration;
  }, r.shouldUpdateTransmuxerTimestampOffset_ = function(i) {
    return i === null ? !1 : this.loaderType_ === "main" && i !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && i !== this.sourceUpdater_.audioTimestampOffset();
  }, r.trueSegmentStart_ = function(i) {
    var a = i.currentStart, s = i.playlist, o = i.mediaIndex, u = i.firstVideoFrameTimeForData, l = i.currentVideoTimestampOffset, c = i.useVideoTimingInfo, h = i.videoTimingInfo, f = i.audioTimingInfo;
    if (typeof a < "u")
      return a;
    if (!c)
      return f.start;
    var d = s.segments[o - 1];
    return o === 0 || !d || typeof d.start > "u" || d.end !== u + l ? u : h.start;
  }, r.waitForAppendsToComplete_ = function(i) {
    var a = this.getCurrentMediaInfo_(i);
    if (!a) {
      this.error({
        blacklistDuration: 1 / 0,
        message: "No starting media returned, likely due to an unsupported media format."
      }), this.trigger("error");
      return;
    }
    var s = a.hasAudio, o = a.hasVideo, u = a.isMuxed, l = this.loaderType_ === "main" && o, c = !this.audioDisabled_ && s && !u;
    if (i.waitingOnAppends = 0, !i.hasAppendedData_) {
      !i.timingInfo && typeof i.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !0), i.timingInfo = {
        start: 0
      }, i.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(i), this.processMetadataQueue_()), this.checkAppendsDone_(i);
      return;
    }
    l && i.waitingOnAppends++, c && i.waitingOnAppends++, l && this.sourceUpdater_.videoQueueCallback(
      this.checkAppendsDone_.bind(this, i)
    ), c && this.sourceUpdater_.audioQueueCallback(
      this.checkAppendsDone_.bind(this, i)
    );
  }, r.checkAppendsDone_ = function(i) {
    this.checkForAbort_(i.requestId) || (i.waitingOnAppends--, i.waitingOnAppends === 0 && this.handleAppendsDone_());
  }, r.checkForIllegalMediaSwitch = function(i) {
    var a = oP(
      this.loaderType_,
      this.getCurrentMediaInfo_(),
      i
    );
    return a ? (this.error({
      blacklistDuration: 1 / 0,
      message: a
    }), this.trigger("error"), !0) : !1;
  }, r.updateSourceBufferTimestampOffset_ = function(i) {
    if (!(i.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has
    // priority, timing-wise, so we must wait
    typeof i.timingInfo.start != "number" || // already updated the timestamp offset for this segment
    i.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset
    this.loaderType_ !== "main")) {
      var a = !1;
      i.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
        audioTimingInfo: i.segment.audioTimingInfo,
        timingInfo: i.timingInfo,
        videoTimingInfo: i.segment.videoTimingInfo
      }), i.changedTimestampOffset = !0, i.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(i.timestampOffset), a = !0), i.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(i.timestampOffset), a = !0), a && this.trigger("timestampoffset");
    }
  }, r.getSegmentStartTimeForTimestampOffsetCalculation_ = function(i) {
    var a = i.videoTimingInfo, s = i.audioTimingInfo, o = i.timingInfo;
    return this.useDtsForTimestampOffset_ ? a && typeof a.transmuxedDecodeStart == "number" ? a.transmuxedDecodeStart : s && typeof s.transmuxedDecodeStart == "number" ? s.transmuxedDecodeStart : o.start : o.start;
  }, r.updateTimingInfoEnd_ = function(i) {
    i.timingInfo = i.timingInfo || {};
    var a = this.getMediaInfo_(), s = this.loaderType_ === "main" && a && a.hasVideo, o = s && i.videoTimingInfo ? i.videoTimingInfo : i.audioTimingInfo;
    o && (i.timingInfo.end = typeof o.end == "number" ? (
      // current example is the case of fmp4), so use the rough duration to calculate an
      // end time.
      o.end
    ) : o.start + i.duration);
  }, r.handleAppendsDone_ = function() {
    if (this.pendingSegment_ && this.trigger("appendsdone"), !this.pendingSegment_) {
      this.state = "READY", this.paused() || this.monitorBuffer_();
      return;
    }
    var i = this.pendingSegment_;
    this.updateTimingInfoEnd_(i), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({
      segmentInfo: i,
      shouldSaveTimelineMapping: this.loaderType_ === "main"
    });
    var a = hP(
      i,
      this.sourceType_
    );
    if (a && (a.severity === "warn" ? X.log.warn(a.message) : this.logger_(a.message)), this.recordThroughput_(i), this.pendingSegment_ = null, this.state = "READY", i.isSyncRequest && (this.trigger("syncinfoupdate"), !i.hasAppendedData_)) {
      this.logger_(
        "Throwing away un-appended sync request " + Ds(i)
      );
      return;
    }
    this.logger_("Appended " + Ds(i)), this.addSegmentMetadataCue_(i), this.fetchAtBuffer_ = !0, this.currentTimeline_ !== i.timeline && (this.timelineChangeController_.lastTimelineChange({
      from: this.currentTimeline_,
      to: i.timeline,
      type: this.loaderType_
    }), this.loaderType_ === "main" && !this.audioDisabled_ && this.timelineChangeController_.lastTimelineChange({
      from: this.currentTimeline_,
      to: i.timeline,
      type: "audio"
    })), this.currentTimeline_ = i.timeline, this.trigger("syncinfoupdate");
    var s = i.segment, o = i.part, u = s.end && this.currentTime_() - s.end > i.playlist.targetDuration * 3, l = o && o.end && this.currentTime_() - o.end > i.playlist.partTargetDuration * 3;
    if (u || l) {
      this.logger_(
        "bad " + (u ? "segment" : "part") + " " + Ds(i)
      ), this.resetEverything();
      return;
    }
    var c = this.mediaIndex !== null;
    c && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = i.mediaIndex, this.partIndex = i.partIndex, this.isEndOfStream_(
      i.mediaIndex,
      i.playlist,
      i.partIndex
    ) && this.endOfStream(), this.trigger("appended"), i.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_();
  }, r.recordThroughput_ = function(i) {
    if (i.duration < $l) {
      this.logger_(
        "Ignoring segment's throughput because its duration of " + i.duration + (" is less than the min to record " + $l)
      );
      return;
    }
    var a = this.throughput.rate, s = Date.now() - i.endOfAllRequests + 1, o = Math.floor(
      i.byteLength / s * 8 * 1e3
    );
    this.throughput.rate += (o - a) / ++this.throughput.count;
  }, r.addSegmentMetadataCue_ = function(i) {
    if (this.segmentMetadataTrack_) {
      var a = i.segment, s = a.start, o = a.end;
      if (!(!vg(s) || !vg(o))) {
        su(s, o, this.segmentMetadataTrack_);
        var u = j.WebKitDataCue || j.VTTCue, l = {
          bandwidth: i.playlist.attributes.BANDWIDTH,
          byteLength: i.byteLength,
          codecs: i.playlist.attributes.CODECS,
          custom: a.custom,
          dateTimeObject: a.dateTimeObject,
          dateTimeString: a.dateTimeString,
          end: o,
          playlist: i.playlist.id,
          resolution: i.playlist.attributes.RESOLUTION,
          start: s,
          timeline: i.timeline,
          uri: i.uri
        }, c = JSON.stringify(l), h = new u(s, o, c);
        h.value = l, this.segmentMetadataTrack_.addCue(h);
      }
    }
  }, t;
}(X.EventTarget);
function In() {
}
var pb = function(t) {
  return typeof t != "string" ? t : t.replace(/./, function(r) {
    return r.toUpperCase();
  });
}, fP = ["video", "audio"], bd = function(t, r) {
  var n = r[t + "Buffer"];
  return n && n.updating || r.queuePending[t];
}, dP = function(t, r) {
  for (var n = 0; n < r.length; n++) {
    var i = r[n];
    if (i.type === "mediaSource")
      return null;
    if (i.type === t)
      return n;
  }
  return null;
}, lm = function e(t, r) {
  if (r.queue.length !== 0) {
    var n = 0, i = r.queue[n];
    if (i.type === "mediaSource") {
      !r.updating() && r.mediaSource.readyState !== "closed" && (r.queue.shift(), i.action(r), i.doneFn && i.doneFn(), e("audio", r), e("video", r));
      return;
    }
    if (t !== "mediaSource" && !(!r.ready() || r.mediaSource.readyState === "closed" || bd(t, r))) {
      if (i.type !== t) {
        if (n = dP(t, r.queue), n === null)
          return;
        i = r.queue[n];
      }
      if (r.queue.splice(n, 1), r.queuePending[t] = i, i.action(t, r), !i.doneFn) {
        r.queuePending[t] = null, e(t, r);
        return;
      }
    }
  }
}, mb = function(t, r) {
  var n = r[t + "Buffer"], i = pb(t);
  n && (n.removeEventListener(
    "updateend",
    r["on" + i + "UpdateEnd_"]
  ), n.removeEventListener(
    "error",
    r["on" + i + "Error_"]
  ), r.codecs[t] = null, r[t + "Buffer"] = null);
}, hn = function(t, r) {
  return t && r && Array.prototype.indexOf.call(t.sourceBuffers, r) !== -1;
}, xi = {
  abort: function() {
    return function(t, r) {
      if (r.mediaSource.readyState === "open") {
        var n = r[t + "Buffer"];
        if (hn(r.mediaSource, n)) {
          r.logger_("calling abort on " + t + "Buffer");
          try {
            n.abort();
          } catch (i) {
            X.log.warn("Failed to abort on " + t + "Buffer", i);
          }
        }
      }
    };
  },
  addSourceBuffer: function(t, r) {
    return function(n) {
      var i = pb(t), a = ul(r);
      n.logger_(
        "Adding " + t + "Buffer with codec " + r + " to mediaSource"
      );
      var s = n.mediaSource.addSourceBuffer(a);
      s.addEventListener(
        "updateend",
        n["on" + i + "UpdateEnd_"]
      ), s.addEventListener(
        "error",
        n["on" + i + "Error_"]
      ), n.codecs[t] = r, n[t + "Buffer"] = s;
    };
  },
  appendBuffer: function(t, r, n) {
    return function(i, a) {
      var s = a[i + "Buffer"];
      if (hn(a.mediaSource, s)) {
        a.logger_(
          "Appending segment " + r.mediaIndex + "'s " + t.length + " bytes to " + i + "Buffer"
        );
        try {
          s.appendBuffer(t);
        } catch (o) {
          a.logger_(
            "Error with code " + o.code + " " + (o.code === db ? "(QUOTA_EXCEEDED_ERR) " : "") + ("when appending segment " + r.mediaIndex + " to " + i + "Buffer")
          ), a.queuePending[i] = null, n(o);
        }
      }
    };
  },
  callback: function(t) {
    return function(r, n) {
      t();
    };
  },
  changeType: function(t) {
    return function(r, n) {
      var i = n[r + "Buffer"], a = ul(t);
      hn(n.mediaSource, i) && n.codecs[r] !== t && (n.logger_(
        "changing " + r + "Buffer codec from " + n.codecs[r] + " to " + t
      ), i.changeType(a), n.codecs[r] = t);
    };
  },
  duration: function(t) {
    return function(r) {
      r.logger_("Setting mediaSource duration to " + t);
      try {
        r.mediaSource.duration = t;
      } catch (n) {
        X.log.warn("Failed to set media source duration", n);
      }
    };
  },
  endOfStream: function(t) {
    return function(r) {
      if (r.mediaSource.readyState === "open") {
        r.logger_(
          "Calling mediaSource endOfStream(" + (t || "") + ")"
        );
        try {
          r.mediaSource.endOfStream(t);
        } catch (n) {
          X.log.warn("Failed to call media source endOfStream", n);
        }
      }
    };
  },
  remove: function(t, r) {
    return function(n, i) {
      var a = i[n + "Buffer"];
      if (hn(i.mediaSource, a)) {
        i.logger_(
          "Removing " + t + " to " + r + " from " + n + "Buffer"
        );
        try {
          a.remove(t, r);
        } catch {
          i.logger_(
            "Remove " + t + " to " + r + " from " + n + "Buffer failed"
          );
        }
      }
    };
  },
  removeSourceBuffer: function(t) {
    return function(r) {
      var n = r[t + "Buffer"];
      if (mb(t, r), !!hn(r.mediaSource, n)) {
        r.logger_(
          "Removing " + t + "Buffer with codec " + r.codecs[t] + " from mediaSource"
        );
        try {
          r.mediaSource.removeSourceBuffer(n);
        } catch (i) {
          X.log.warn("Failed to removeSourceBuffer " + t + "Buffer", i);
        }
      }
    };
  },
  timestampOffset: function(t) {
    return function(r, n) {
      var i = n[r + "Buffer"];
      hn(n.mediaSource, i) && (n.logger_("Setting " + r + "timestampOffset to " + t), i.timestampOffset = t);
    };
  }
}, Ai = function(t) {
  var r = t.type, n = t.sourceUpdater, i = t.action, a = t.doneFn, s = t.name;
  n.queue.push({
    action: i,
    doneFn: a,
    name: s,
    type: r
  }), lm(r, n);
}, bg = function(t, r) {
  return function(n) {
    if (r.queuePending[t]) {
      var i = r.queuePending[t].doneFn;
      r.queuePending[t] = null, i && i(r[t + "Error_"]);
    }
    lm(t, r);
  };
}, vb = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var i;
    return i = e.call(this) || this, i.mediaSource = n, i.sourceopenListener_ = function() {
      return lm("mediaSource", ze(i));
    }, i.mediaSource.addEventListener("sourceopen", i.sourceopenListener_), i.logger_ = nn("SourceUpdater"), i.audioTimestampOffset_ = 0, i.videoTimestampOffset_ = 0, i.queue = [], i.queuePending = {
      audio: null,
      video: null
    }, i.delayedAudioAppendQueue_ = [], i.videoAppendQueued_ = !1, i.codecs = {}, i.onVideoUpdateEnd_ = bg(
      "video",
      ze(i)
    ), i.onAudioUpdateEnd_ = bg(
      "audio",
      ze(i)
    ), i.onVideoError_ = function(a) {
      i.videoError_ = a;
    }, i.onAudioError_ = function(a) {
      i.audioError_ = a;
    }, i.createdSourceBuffers_ = !1, i.initializedEme_ = !1, i.triggeredReady_ = !1, i;
  }
  var r = t.prototype;
  return r.initializedEme = function() {
    this.initializedEme_ = !0, this.triggerReady();
  }, r.hasCreatedSourceBuffers = function() {
    return this.createdSourceBuffers_;
  }, r.hasInitializedAnyEme = function() {
    return this.initializedEme_;
  }, r.ready = function() {
    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
  }, r.createSourceBuffers = function(i) {
    this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(i), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady());
  }, r.triggerReady = function() {
    this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready"));
  }, r.addSourceBuffer = function(i, a) {
    Ai({
      action: xi.addSourceBuffer(i, a),
      name: "addSourceBuffer",
      sourceUpdater: this,
      type: "mediaSource"
    });
  }, r.abort = function(i) {
    Ai({
      action: xi.abort(i),
      name: "abort",
      sourceUpdater: this,
      type: i
    });
  }, r.removeSourceBuffer = function(i) {
    if (!this.canRemoveSourceBuffer()) {
      X.log.error("removeSourceBuffer is not supported!");
      return;
    }
    Ai({
      action: xi.removeSourceBuffer(i),
      name: "removeSourceBuffer",
      sourceUpdater: this,
      type: "mediaSource"
    });
  }, r.canRemoveSourceBuffer = function() {
    return !X.browser.IE_VERSION && !X.browser.IS_FIREFOX && j.MediaSource && j.MediaSource.prototype && typeof j.MediaSource.prototype.removeSourceBuffer == "function";
  }, t.canChangeType = function() {
    return j.SourceBuffer && j.SourceBuffer.prototype && typeof j.SourceBuffer.prototype.changeType == "function";
  }, r.canChangeType = function() {
    return this.constructor.canChangeType();
  }, r.changeType = function(i, a) {
    if (!this.canChangeType()) {
      X.log.error("changeType is not supported!");
      return;
    }
    Ai({
      action: xi.changeType(a),
      name: "changeType",
      sourceUpdater: this,
      type: i
    });
  }, r.addOrChangeSourceBuffers = function(i) {
    var a = this;
    if (!i || typeof i != "object" || Object.keys(i).length === 0)
      throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
    Object.keys(i).forEach(function(s) {
      var o = i[s];
      if (!a.hasCreatedSourceBuffers())
        return a.addSourceBuffer(s, o);
      a.canChangeType() && a.changeType(s, o);
    });
  }, r.appendBuffer = function(i, a) {
    var s = this, o = i.segmentInfo, u = i.type, l = i.bytes;
    if (this.processedAppend_ = !0, u === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
      this.delayedAudioAppendQueue_.push([i, a]), this.logger_(
        "delayed audio append of " + l.length + " until video append"
      );
      return;
    }
    var c = a;
    if (Ai({
      action: xi.appendBuffer(
        l,
        o || {
          mediaIndex: -1
        },
        c
      ),
      doneFn: a,
      name: "appendBuffer",
      sourceUpdater: this,
      type: u
    }), u === "video") {
      if (this.videoAppendQueued_ = !0, !this.delayedAudioAppendQueue_.length)
        return;
      var h = this.delayedAudioAppendQueue_.slice();
      this.logger_("queuing delayed audio " + h.length + " appendBuffers"), this.delayedAudioAppendQueue_.length = 0, h.forEach(function(f) {
        s.appendBuffer.apply(s, f);
      });
    }
  }, r.audioBuffered = function() {
    return hn(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : X.createTimeRange();
  }, r.videoBuffered = function() {
    return hn(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : X.createTimeRange();
  }, r.buffered = function() {
    var i = hn(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null, a = hn(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
    return a && !i ? this.audioBuffered() : i && !a ? this.videoBuffered() : L3(this.audioBuffered(), this.videoBuffered());
  }, r.setDuration = function(i, a) {
    a === void 0 && (a = In), Ai({
      action: xi.duration(i),
      doneFn: a,
      name: "duration",
      sourceUpdater: this,
      type: "mediaSource"
    });
  }, r.endOfStream = function(i, a) {
    i === void 0 && (i = null), a === void 0 && (a = In), typeof i != "string" && (i = void 0), Ai({
      action: xi.endOfStream(i),
      doneFn: a,
      name: "endOfStream",
      sourceUpdater: this,
      type: "mediaSource"
    });
  }, r.removeAudio = function(i, a, s) {
    if (s === void 0 && (s = In), !this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
      s();
      return;
    }
    Ai({
      action: xi.remove(i, a),
      doneFn: s,
      name: "remove",
      sourceUpdater: this,
      type: "audio"
    });
  }, r.removeVideo = function(i, a, s) {
    if (s === void 0 && (s = In), !this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
      s();
      return;
    }
    Ai({
      action: xi.remove(i, a),
      doneFn: s,
      name: "remove",
      sourceUpdater: this,
      type: "video"
    });
  }, r.updating = function() {
    return !!(bd("audio", this) || bd("video", this));
  }, r.audioTimestampOffset = function(i) {
    return typeof i < "u" && this.audioBuffer && // no point in updating if it's the same
    this.audioTimestampOffset_ !== i && (Ai({
      action: xi.timestampOffset(i),
      name: "timestampOffset",
      sourceUpdater: this,
      type: "audio"
    }), this.audioTimestampOffset_ = i), this.audioTimestampOffset_;
  }, r.videoTimestampOffset = function(i) {
    return typeof i < "u" && this.videoBuffer && // no point in updating if it's the same
    this.videoTimestampOffset !== i && (Ai({
      action: xi.timestampOffset(i),
      name: "timestampOffset",
      sourceUpdater: this,
      type: "video"
    }), this.videoTimestampOffset_ = i), this.videoTimestampOffset_;
  }, r.audioQueueCallback = function(i) {
    this.audioBuffer && Ai({
      action: xi.callback(i),
      name: "callback",
      sourceUpdater: this,
      type: "audio"
    });
  }, r.videoQueueCallback = function(i) {
    this.videoBuffer && Ai({
      action: xi.callback(i),
      name: "callback",
      sourceUpdater: this,
      type: "video"
    });
  }, r.dispose = function() {
    var i = this;
    this.trigger("dispose"), fP.forEach(function(a) {
      i.abort(a), i.canRemoveSourceBuffer() ? i.removeSourceBuffer(a) : i[a + "QueueCallback"](function() {
        return mb(a, i);
      });
    }), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener(
      "sourceopen",
      this.sourceopenListener_
    ), this.off();
  }, t;
}(X.EventTarget), xg = function(t) {
  return decodeURIComponent(escape(String.fromCharCode.apply(null, t)));
}, Ag = new Uint8Array(
  `

`.split("").map(function(e) {
    return e.charCodeAt(0);
  })
), pP = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.call(
      this,
      "Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded."
    ) || this;
  }
  return t;
}(/* @__PURE__ */ Xf(Error)), mP = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return i === void 0 && (i = {}), a = e.call(this, n, i) || this, a.mediaSource_ = null, a.subtitlesTrack_ = null, a.loaderType_ = "subtitle", a.featuresNativeTextTracks_ = n.featuresNativeTextTracks, a.loadVttJs = n.loadVttJs, a.shouldSaveSegmentTimingInfo_ = !1, a;
  }
  var r = t.prototype;
  return r.createTransmuxer_ = function() {
    return null;
  }, r.buffered_ = function() {
    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length)
      return X.createTimeRanges();
    var i = this.subtitlesTrack_.cues, a = i[0].startTime, s = i[i.length - 1].startTime;
    return X.createTimeRanges([[a, s]]);
  }, r.initSegmentForMap = function(i, a) {
    if (a === void 0 && (a = !1), !i)
      return null;
    var s = Kc(i), o = this.initSegments_[s];
    if (a && !o && i.bytes) {
      var u = Ag.byteLength + i.bytes.byteLength, l = new Uint8Array(u);
      l.set(i.bytes), l.set(Ag, i.bytes.byteLength), this.initSegments_[s] = o = {
        byterange: i.byterange,
        bytes: l,
        resolvedUri: i.resolvedUri
      };
    }
    return o || i;
  }, r.couldBeginLoading_ = function() {
    return this.playlist_ && this.subtitlesTrack_ && !this.paused();
  }, r.init_ = function() {
    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
  }, r.track = function(i) {
    return typeof i > "u" ? this.subtitlesTrack_ : (this.subtitlesTrack_ = i, this.state === "INIT" && this.couldBeginLoading_() && this.init_(), this.subtitlesTrack_);
  }, r.remove = function(i, a) {
    su(i, a, this.subtitlesTrack_);
  }, r.fillBuffer_ = function() {
    var i = this, a = this.chooseNextRequest_();
    if (a) {
      if (this.syncController_.timestampOffsetForTimeline(a.timeline) === null) {
        var s = function() {
          i.state = "READY", i.paused() || i.monitorBuffer_();
        };
        this.syncController_.one("timestampoffset", s), this.state = "WAITING_ON_TIMELINE";
        return;
      }
      this.loadSegment_(a);
    }
  }, r.timestampOffsetForSegment_ = function() {
    return null;
  }, r.chooseNextRequest_ = function() {
    return this.skipEmptySegments_(
      e.prototype.chooseNextRequest_.call(this)
    );
  }, r.skipEmptySegments_ = function(i) {
    for (; i && i.segment.empty; ) {
      if (i.mediaIndex + 1 >= i.playlist.segments.length) {
        i = null;
        break;
      }
      i = this.generateSegmentInfo_({
        isSyncRequest: i.isSyncRequest,
        mediaIndex: i.mediaIndex + 1,
        playlist: i.playlist,
        startOfSegment: i.startOfSegment + i.duration
      });
    }
    return i;
  }, r.stopForError = function(i) {
    this.error(i), this.state = "READY", this.pause(), this.trigger("error");
  }, r.segmentRequestFinished_ = function(i, a, s) {
    var o = this;
    if (!this.subtitlesTrack_) {
      this.state = "READY";
      return;
    }
    if (this.saveTransferStats_(a.stats), !this.pendingSegment_) {
      this.state = "READY", this.mediaRequestsAborted += 1;
      return;
    }
    if (i) {
      i.code === pn.TIMEOUT && this.handleTimeout_(), i.code === pn.ABORTED ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1, this.stopForError(i);
      return;
    }
    var u = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(u.duration, a.stats), a.key && this.segmentKey(a.key, !0), this.state = "APPENDING", this.trigger("appending");
    var l = u.segment;
    if (l.map && (l.map.bytes = a.map.bytes), u.bytes = a.bytes, typeof j.WebVTT != "function" && typeof this.loadVttJs == "function") {
      this.state = "WAITING_ON_VTTJS", this.loadVttJs().then(
        function() {
          return o.segmentRequestFinished_(i, a, s);
        },
        function() {
          return o.stopForError({
            message: "Error loading vtt.js"
          });
        }
      );
      return;
    }
    l.requested = !0;
    try {
      this.parseVTTCues_(u);
    } catch (c) {
      this.stopForError({
        message: c.message
      });
      return;
    }
    if (this.updateTimeMapping_(
      u,
      this.syncController_.timelines[u.timeline],
      this.playlist_
    ), u.cues.length ? u.timingInfo = {
      end: u.cues[u.cues.length - 1].endTime,
      start: u.cues[0].startTime
    } : u.timingInfo = {
      end: u.startOfSegment + u.duration,
      start: u.startOfSegment
    }, u.isSyncRequest) {
      this.trigger("syncinfoupdate"), this.pendingSegment_ = null, this.state = "READY";
      return;
    }
    u.byteLength = u.bytes.byteLength, this.mediaSecondsLoaded += l.duration, u.cues.forEach(function(c) {
      o.subtitlesTrack_.addCue(
        o.featuresNativeTextTracks_ ? new j.VTTCue(c.startTime, c.endTime, c.text) : c
      );
    }), eP(this.subtitlesTrack_), this.handleAppendsDone_();
  }, r.handleData_ = function() {
  }, r.updateTimingInfoEnd_ = function() {
  }, r.parseVTTCues_ = function(i) {
    var a, s = !1;
    if (typeof j.WebVTT != "function")
      throw new pP();
    typeof j.TextDecoder == "function" ? a = new j.TextDecoder("utf8") : (a = j.WebVTT.StringDecoder(), s = !0);
    var o = new j.WebVTT.Parser(j, j.vttjs, a);
    if (i.cues = [], i.timestampmap = {
      LOCAL: 0,
      MPEGTS: 0
    }, o.oncue = i.cues.push.bind(i.cues), o.ontimestampmap = function(c) {
      i.timestampmap = c;
    }, o.onparsingerror = function(c) {
      X.log.warn("Error encountered when parsing cues: " + c.message);
    }, i.segment.map) {
      var u = i.segment.map.bytes;
      s && (u = xg(u)), o.parse(u);
    }
    var l = i.bytes;
    s && (l = xg(l)), o.parse(l), o.flush();
  }, r.updateTimeMapping_ = function(i, a, s) {
    var o = i.segment;
    if (a) {
      if (!i.cues.length) {
        o.empty = !0;
        return;
      }
      var u = i.timestampmap, l = u.MPEGTS / kc.ONE_SECOND_IN_TS - u.LOCAL + a.mapping;
      if (i.cues.forEach(function(f) {
        f.startTime += l, f.endTime += l;
      }), !s.syncInfo) {
        var c = i.cues[0].startTime, h = i.cues[i.cues.length - 1].startTime;
        s.syncInfo = {
          mediaSequence: s.mediaSequence + i.mediaIndex,
          time: Math.min(c, h - o.duration)
        };
      }
    }
  }, t;
}(_d), vP = function(t, r) {
  for (var n = t.cues, i = 0; i < n.length; i++) {
    var a = n[i];
    if (r >= a.adStartTime && r <= a.adEndTime)
      return a;
  }
  return null;
}, gP = function(t, r, n) {
  if (n === void 0 && (n = 0), !!t.segments)
    for (var i = n, a, s = 0; s < t.segments.length; s++) {
      var o = t.segments[s];
      if (a || (a = vP(r, i + o.duration / 2)), a) {
        if ("cueIn" in o) {
          a.endTime = i, a.adEndTime = i, i += o.duration, a = null;
          continue;
        }
        if (i < a.endTime) {
          i += o.duration;
          continue;
        }
        a.endTime += o.duration;
      } else if ("cueOut" in o && (a = new j.VTTCue(
        i,
        i + o.duration,
        o.cueOut
      ), a.adStartTime = i, a.adEndTime = i + parseFloat(o.cueOut), r.addCue(a)), "cueOutCont" in o) {
        var u = o.cueOutCont.split("/").map(parseFloat), l = u[0], c = u[1];
        a = new j.VTTCue(i, i + o.duration, ""), a.adStartTime = i - l, a.adEndTime = a.adStartTime + c, r.addCue(a);
      }
      i += o.duration;
    }
}, yP = 86400, Tg = [
  // Stategy "VOD": Handle the VOD-case where the sync-point is *always*
  //                the equivalence display-time 0 === segment-index 0
  {
    name: "VOD",
    run: function(t, r, n, i, a) {
      if (n !== 1 / 0) {
        var s = {
          partIndex: null,
          segmentIndex: 0,
          time: 0
        };
        return s;
      }
      return null;
    }
  },
  // Stategy "ProgramDateTime": We have a program-date-time tag in this playlist
  {
    name: "ProgramDateTime",
    run: function(t, r, n, i, a) {
      if (!Object.keys(t.timelineToDatetimeMappings).length)
        return null;
      var s = null, o = null, u = hd(r);
      a = a || 0;
      for (var l = 0; l < u.length; l++) {
        var c = r.endList || a === 0 ? l : u.length - (l + 1), h = u[c], f = h.segment, d = t.timelineToDatetimeMappings[f.timeline];
        if (!(!d || !f.dateTimeObject)) {
          var p = f.dateTimeObject.getTime() / 1e3, _ = p + d;
          if (f.parts && typeof h.partIndex == "number")
            for (var v = 0; v < h.partIndex; v++)
              _ += f.parts[v].duration;
          var x = Math.abs(a - _);
          if (o !== null && (x === 0 || o < x))
            break;
          o = x, s = {
            partIndex: h.partIndex,
            segmentIndex: h.segmentIndex,
            time: _
          };
        }
      }
      return s;
    }
  },
  // Stategy "Segment": We have a known time mapping for a timeline and a
  //                    segment in the current timeline with timing data
  {
    name: "Segment",
    run: function(t, r, n, i, a) {
      var s = null, o = null;
      a = a || 0;
      for (var u = hd(r), l = 0; l < u.length; l++) {
        var c = r.endList || a === 0 ? l : u.length - (l + 1), h = u[c], f = h.segment, d = h.part && h.part.start || f && f.start;
        if (f.timeline === i && typeof d < "u") {
          var p = Math.abs(a - d);
          if (o !== null && o < p)
            break;
          (!s || o === null || o >= p) && (o = p, s = {
            partIndex: h.partIndex,
            segmentIndex: h.segmentIndex,
            time: d
          });
        }
      }
      return s;
    }
  },
  // Stategy "Discontinuity": We have a discontinuity with a known
  //                          display-time
  {
    name: "Discontinuity",
    run: function(t, r, n, i, a) {
      var s = null;
      if (a = a || 0, r.discontinuityStarts && r.discontinuityStarts.length)
        for (var o = null, u = 0; u < r.discontinuityStarts.length; u++) {
          var l = r.discontinuityStarts[u], c = r.discontinuitySequence + u + 1, h = t.discontinuities[c];
          if (h) {
            var f = Math.abs(a - h.time);
            if (o !== null && o < f)
              break;
            (!s || o === null || o >= f) && (o = f, s = {
              partIndex: null,
              segmentIndex: l,
              time: h.time
            });
          }
        }
      return s;
    }
  },
  // Stategy "Playlist": We have a playlist with a known mapping of
  //                     segment index to display time
  {
    name: "Playlist",
    run: function(t, r, n, i, a) {
      if (r.syncInfo) {
        var s = {
          partIndex: null,
          segmentIndex: r.syncInfo.mediaSequence - r.mediaSequence,
          time: r.syncInfo.time
        };
        return s;
      }
      return null;
    }
  }
], _P = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var i;
    return i = e.call(this) || this, i.timelines = [], i.discontinuities = [], i.timelineToDatetimeMappings = {}, i.logger_ = nn("SyncController"), i;
  }
  var r = t.prototype;
  return r.getSyncPoint = function(i, a, s, o) {
    var u = this.runStrategies_(
      i,
      a,
      s,
      o
    );
    return u.length ? this.selectSyncPoint_(u, {
      key: "time",
      value: o
    }) : null;
  }, r.getExpiredTime = function(i, a) {
    if (!i || !i.segments)
      return null;
    var s = this.runStrategies_(
      i,
      a,
      i.discontinuitySequence,
      0
    );
    if (!s.length)
      return null;
    var o = this.selectSyncPoint_(s, {
      key: "segmentIndex",
      value: 0
    });
    return o.segmentIndex > 0 && (o.time *= -1), Math.abs(
      o.time + fu({
        defaultDuration: i.targetDuration,
        durationList: i.segments,
        endIndex: 0,
        startIndex: o.segmentIndex
      })
    );
  }, r.runStrategies_ = function(i, a, s, o) {
    for (var u = [], l = 0; l < Tg.length; l++) {
      var c = Tg[l], h = c.run(
        this,
        i,
        a,
        s,
        o
      );
      h && (h.strategy = c.name, u.push({
        strategy: c.name,
        syncPoint: h
      }));
    }
    return u;
  }, r.selectSyncPoint_ = function(i, a) {
    for (var s = i[0].syncPoint, o = Math.abs(
      i[0].syncPoint[a.key] - a.value
    ), u = i[0].strategy, l = 1; l < i.length; l++) {
      var c = Math.abs(
        i[l].syncPoint[a.key] - a.value
      );
      c < o && (o = c, s = i[l].syncPoint, u = i[l].strategy);
    }
    return this.logger_(
      "syncPoint for [" + a.key + ": " + a.value + "] chosen with strategy" + (" [" + u + "]: [time:" + s.time + ",") + (" segmentIndex:" + s.segmentIndex) + (typeof s.partIndex == "number" ? ",partIndex:" + s.partIndex : "") + "]"
    ), s;
  }, r.saveExpiredSegmentInfo = function(i, a) {
    var s = a.mediaSequence - i.mediaSequence;
    if (s > yP) {
      X.log.warn(
        "Not saving expired segment info. Media sequence gap " + s + " is too large."
      );
      return;
    }
    for (var o = s - 1; o >= 0; o--) {
      var u = i.segments[o];
      if (u && typeof u.start < "u") {
        a.syncInfo = {
          mediaSequence: i.mediaSequence + o,
          time: u.start
        }, this.logger_(
          "playlist refresh sync: [time:" + a.syncInfo.time + "," + (" mediaSequence: " + a.syncInfo.mediaSequence + "]")
        ), this.trigger("syncinfoupdate");
        break;
      }
    }
  }, r.setDateTimeMappingForStart = function(i) {
    if (this.timelineToDatetimeMappings = {}, i.segments && i.segments.length && i.segments[0].dateTimeObject) {
      var a = i.segments[0], s = a.dateTimeObject.getTime() / 1e3;
      this.timelineToDatetimeMappings[a.timeline] = -s;
    }
  }, r.saveSegmentTimingInfo = function(i) {
    var a = i.segmentInfo, s = i.shouldSaveTimelineMapping, o = this.calculateSegmentTimeMapping_(
      a,
      a.timingInfo,
      s
    ), u = a.segment;
    o && (this.saveDiscontinuitySyncInfo_(a), a.playlist.syncInfo || (a.playlist.syncInfo = {
      mediaSequence: a.playlist.mediaSequence + a.mediaIndex,
      time: u.start
    }));
    var l = u.dateTimeObject;
    u.discontinuity && s && l && (this.timelineToDatetimeMappings[u.timeline] = -(l.getTime() / 1e3));
  }, r.timestampOffsetForTimeline = function(i) {
    return typeof this.timelines[i] > "u" ? null : this.timelines[i].time;
  }, r.mappingForTimeline = function(i) {
    return typeof this.timelines[i] > "u" ? null : this.timelines[i].mapping;
  }, r.calculateSegmentTimeMapping_ = function(i, a, s) {
    var o = i.segment, u = i.part, l = this.timelines[i.timeline], c, h;
    if (typeof i.timestampOffset == "number")
      l = {
        mapping: i.startOfSegment - a.start,
        time: i.startOfSegment
      }, s && (this.timelines[i.timeline] = l, this.trigger("timestampoffset"), this.logger_(
        "time mapping for timeline " + i.timeline + ": " + ("[time: " + l.time + "] [mapping: " + l.mapping + "]")
      )), c = i.startOfSegment, h = a.end + l.mapping;
    else if (l)
      c = a.start + l.mapping, h = a.end + l.mapping;
    else
      return !1;
    return u && (u.start = c, u.end = h), (!o.start || c < o.start) && (o.start = c), o.end = h, !0;
  }, r.saveDiscontinuitySyncInfo_ = function(i) {
    var a = i.playlist, s = i.segment;
    if (s.discontinuity)
      this.discontinuities[s.timeline] = {
        accuracy: 0,
        time: s.start
      };
    else if (a.discontinuityStarts && a.discontinuityStarts.length)
      for (var o = 0; o < a.discontinuityStarts.length; o++) {
        var u = a.discontinuityStarts[o], l = a.discontinuitySequence + o + 1, c = u - i.mediaIndex, h = Math.abs(c);
        if (!this.discontinuities[l] || this.discontinuities[l].accuracy > h) {
          var f = void 0;
          c < 0 ? f = s.start - fu({
            defaultDuration: a.targetDuration,
            durationList: a.segments,
            endIndex: u,
            startIndex: i.mediaIndex
          }) : f = s.end + fu({
            defaultDuration: a.targetDuration,
            durationList: a.segments,
            endIndex: u,
            startIndex: i.mediaIndex + 1
          }), this.discontinuities[l] = {
            accuracy: h,
            time: f
          };
        }
      }
  }, r.dispose = function() {
    this.trigger("dispose"), this.off();
  }, t;
}(X.EventTarget), bP = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    var n;
    return n = e.call(this) || this, n.pendingTimelineChanges_ = {}, n.lastTimelineChanges_ = {}, n;
  }
  var r = t.prototype;
  return r.clearPendingTimelineChange = function(i) {
    this.pendingTimelineChanges_[i] = null, this.trigger("pendingtimelinechange");
  }, r.pendingTimelineChange = function(i) {
    var a = i.type, s = i.from, o = i.to;
    return typeof s == "number" && typeof o == "number" && (this.pendingTimelineChanges_[a] = {
      from: s,
      to: o,
      type: a
    }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[a];
  }, r.lastTimelineChange = function(i) {
    var a = i.type, s = i.from, o = i.to;
    return typeof s == "number" && typeof o == "number" && (this.lastTimelineChanges_[a] = {
      from: s,
      to: o,
      type: a
    }, delete this.pendingTimelineChanges_[a], this.trigger("timelinechange")), this.lastTimelineChanges_[a];
  }, r.dispose = function() {
    this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off();
  }, t;
}(X.EventTarget), xP = rb(
  ib(function() {
    var e = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function t(C, R, B) {
      return B = {
        exports: {},
        path: R,
        require: function(F, I) {
          return r(
            F,
            I ?? B.path
          );
        }
      }, C(B, B.exports), B.exports;
    }
    function r() {
      throw new Error(
        "Dynamic requires are not currently supported by @rollup/plugin-commonjs"
      );
    }
    var n = t(function(C) {
      function R(k, F) {
        for (var I = 0; I < F.length; I++) {
          var H = F[I];
          H.enumerable = H.enumerable || !1, H.configurable = !0, "value" in H && (H.writable = !0), Object.defineProperty(k, H.key, H);
        }
      }
      function B(k, F, I) {
        return F && R(k.prototype, F), I && R(k, I), k;
      }
      C.exports = B, C.exports.default = C.exports, C.exports.__esModule = !0;
    }), i = t(function(C) {
      function R(B, k) {
        return C.exports = R = Object.setPrototypeOf || function(I, H) {
          return I.__proto__ = H, I;
        }, C.exports.default = C.exports, C.exports.__esModule = !0, R(B, k);
      }
      C.exports = R, C.exports.default = C.exports, C.exports.__esModule = !0;
    }), a = t(function(C) {
      function R(B, k) {
        B.prototype = Object.create(k.prototype), B.prototype.constructor = B, i(B, k);
      }
      C.exports = R, C.exports.default = C.exports, C.exports.__esModule = !0;
    }), s = /* @__PURE__ */ function() {
      function C() {
        this.listeners = {};
      }
      var R = C.prototype;
      return R.on = function(k, F) {
        this.listeners[k] || (this.listeners[k] = []), this.listeners[k].push(F);
      }, R.off = function(k, F) {
        if (!this.listeners[k])
          return !1;
        var I = this.listeners[k].indexOf(F);
        return this.listeners[k] = this.listeners[k].slice(0), this.listeners[k].splice(I, 1), I > -1;
      }, R.trigger = function(k) {
        var F = this.listeners[k];
        if (F)
          if (arguments.length === 2)
            for (var I = F.length, H = 0; H < I; ++H)
              F[H].call(this, arguments[1]);
          else
            for (var Q = Array.prototype.slice.call(arguments, 1), ee = F.length, oe = 0; oe < ee; ++oe)
              F[oe].apply(this, Q);
      }, R.dispose = function() {
        this.listeners = {};
      }, R.pipe = function(k) {
        this.on("data", function(F) {
          k.push(F);
        });
      }, C;
    }();
    /* ! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
    function o(C) {
      return C.subarray(
        0,
        C.byteLength - C[C.byteLength - 1]
      );
    }
    /* ! @name aes-decrypter @version 3.1.3 @license Apache-2.0 */
    var u = function() {
      var R = [
        [[], [], [], [], []],
        [[], [], [], [], []]
      ], B = R[0], k = R[1], F = B[4], I = k[4], H, Q, ee, oe = [], de = [], he, fe, V, G, se, re;
      for (H = 0; H < 256; H++)
        de[(oe[H] = H << 1 ^ (H >> 7) * 283) ^ H] = H;
      for (Q = ee = 0; !F[Q]; Q ^= he || 1, ee = de[ee] || 1)
        for (G = ee ^ ee << 1 ^ ee << 2 ^ ee << 3 ^ ee << 4, G = G >> 8 ^ G & 255 ^ 99, F[Q] = G, I[G] = Q, V = oe[fe = oe[he = oe[Q]]], re = V * 16843009 ^ fe * 65537 ^ he * 257 ^ Q * 16843008, se = oe[G] * 257 ^ G * 16843008, H = 0; H < 4; H++)
          B[H][Q] = se = se << 24 ^ se >>> 8, k[H][G] = re = re << 24 ^ re >>> 8;
      for (H = 0; H < 5; H++)
        B[H] = B[H].slice(0), k[H] = k[H].slice(0);
      return R;
    }, l = null, c = /* @__PURE__ */ function() {
      function C(B) {
        l || (l = u()), this._tables = [
          [
            l[0][0].slice(),
            l[0][1].slice(),
            l[0][2].slice(),
            l[0][3].slice(),
            l[0][4].slice()
          ],
          [
            l[1][0].slice(),
            l[1][1].slice(),
            l[1][2].slice(),
            l[1][3].slice(),
            l[1][4].slice()
          ]
        ];
        var k, F, I, H = this._tables[0][4], Q = this._tables[1], ee = B.length, oe = 1;
        if (ee !== 4 && ee !== 6 && ee !== 8)
          throw new Error("Invalid aes key size");
        var de = B.slice(0), he = [];
        for (this._key = [de, he], k = ee; k < 4 * ee + 28; k++)
          I = de[k - 1], (k % ee === 0 || ee === 8 && k % ee === 4) && (I = H[I >>> 24] << 24 ^ H[I >> 16 & 255] << 16 ^ H[I >> 8 & 255] << 8 ^ H[I & 255], k % ee === 0 && (I = I << 8 ^ I >>> 24 ^ oe << 24, oe = oe << 1 ^ (oe >> 7) * 283)), de[k] = de[k - ee] ^ I;
        for (F = 0; k; F++, k--)
          I = de[F & 3 ? k : k - 4], k <= 4 || F < 4 ? he[F] = I : he[F] = Q[0][H[I >>> 24]] ^ Q[1][H[I >> 16 & 255]] ^ Q[2][H[I >> 8 & 255]] ^ Q[3][H[I & 255]];
      }
      var R = C.prototype;
      return R.decrypt = function(k, F, I, H, Q, ee) {
        var oe = this._key[1], de = k ^ oe[0], he = H ^ oe[1], fe = I ^ oe[2], V = F ^ oe[3], G, se, re, Ce = oe.length / 4 - 2, K, xe = 4, pe = this._tables[1], Re = pe[0], _e = pe[1], Le = pe[2], He = pe[3], dt = pe[4];
        for (K = 0; K < Ce; K++)
          G = Re[de >>> 24] ^ _e[he >> 16 & 255] ^ Le[fe >> 8 & 255] ^ He[V & 255] ^ oe[xe], se = Re[he >>> 24] ^ _e[fe >> 16 & 255] ^ Le[V >> 8 & 255] ^ He[de & 255] ^ oe[xe + 1], re = Re[fe >>> 24] ^ _e[V >> 16 & 255] ^ Le[de >> 8 & 255] ^ He[he & 255] ^ oe[xe + 2], V = Re[V >>> 24] ^ _e[de >> 16 & 255] ^ Le[he >> 8 & 255] ^ He[fe & 255] ^ oe[xe + 3], xe += 4, de = G, he = se, fe = re;
        for (K = 0; K < 4; K++)
          Q[(3 & -K) + ee] = dt[de >>> 24] << 24 ^ dt[he >> 16 & 255] << 16 ^ dt[fe >> 8 & 255] << 8 ^ dt[V & 255] ^ oe[xe++], G = de, de = he, he = fe, fe = V, V = G;
      }, C;
    }(), h = /* @__PURE__ */ function(C) {
      a(R, C);
      function R() {
        var k;
        return k = C.call(this, s) || this, k.jobs = [], k.delay = 1, k.timeout_ = null, k;
      }
      var B = R.prototype;
      return B.processJob_ = function() {
        this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null;
      }, B.push = function(F) {
        this.jobs.push(F), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay));
      }, R;
    }(s), f = function(R) {
      return R << 24 | (R & 65280) << 8 | (R & 16711680) >> 8 | R >>> 24;
    }, d = function(R, B, k) {
      var F = new Int32Array(
        R.buffer,
        R.byteOffset,
        R.byteLength >> 2
      ), I = new c(Array.prototype.slice.call(B)), H = new Uint8Array(R.byteLength), Q = new Int32Array(H.buffer), ee, oe, de, he, fe, V, G, se, re;
      for (ee = k[0], oe = k[1], de = k[2], he = k[3], re = 0; re < F.length; re += 4)
        fe = f(F[re]), V = f(F[re + 1]), G = f(F[re + 2]), se = f(F[re + 3]), I.decrypt(
          fe,
          V,
          G,
          se,
          Q,
          re
        ), Q[re] = f(Q[re] ^ ee), Q[re + 1] = f(Q[re + 1] ^ oe), Q[re + 2] = f(Q[re + 2] ^ de), Q[re + 3] = f(Q[re + 3] ^ he), ee = fe, oe = V, de = G, he = se;
      return H;
    }, p = /* @__PURE__ */ function() {
      function C(B, k, F, I) {
        var H = C.STEP, Q = new Int32Array(B.buffer), ee = new Uint8Array(B.byteLength), oe = 0;
        for (this.asyncStream_ = new h(), this.asyncStream_.push(
          this.decryptChunk_(
            Q.subarray(oe, oe + H),
            k,
            F,
            ee
          )
        ), oe = H; oe < Q.length; oe += H)
          F = new Uint32Array([
            f(Q[oe - 4]),
            f(Q[oe - 3]),
            f(Q[oe - 2]),
            f(Q[oe - 1])
          ]), this.asyncStream_.push(
            this.decryptChunk_(
              Q.subarray(oe, oe + H),
              k,
              F,
              ee
            )
          );
        this.asyncStream_.push(function() {
          I(null, o(ee));
        });
      }
      var R = C.prototype;
      return R.decryptChunk_ = function(k, F, I, H) {
        return function() {
          var Q = d(k, F, I);
          H.set(Q, k.byteOffset);
        };
      }, n(C, null, [
        {
          get: function() {
            return 32e3;
          },
          key: "STEP"
        }
      ]), C;
    }(), _;
    typeof window < "u" ? _ = window : typeof e < "u" ? _ = e : typeof self < "u" ? _ = self : _ = {};
    var v = _, x = function(R) {
      return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(R) : R && R.buffer instanceof ArrayBuffer;
    }, E = v.BigInt || Number;
    E("0x1"), E("0x100"), E("0x10000"), E("0x1000000"), E("0x100000000"), E("0x10000000000"), E("0x1000000000000"), E("0x100000000000000"), E("0x10000000000000000");
    var M = function(R) {
      var B = {};
      return Object.keys(R).forEach(function(k) {
        var F = R[k];
        x(F) ? B[k] = {
          byteLength: F.byteLength,
          byteOffset: F.byteOffset,
          bytes: F.buffer
        } : B[k] = F;
      }), B;
    };
    self.onmessage = function(C) {
      var R = C.data, B = new Uint8Array(
        R.encrypted.bytes,
        R.encrypted.byteOffset,
        R.encrypted.byteLength
      ), k = new Uint32Array(
        R.key.bytes,
        R.key.byteOffset,
        R.key.byteLength / 4
      ), F = new Uint32Array(
        R.iv.bytes,
        R.iv.byteOffset,
        R.iv.byteLength / 4
      );
      new p(B, k, F, function(I, H) {
        self.postMessage(
          M({
            decrypted: H,
            source: R.source
          }),
          [H.buffer]
        );
      });
    };
  })
), AP = tb(xP), TP = function(t) {
  var r = t.default ? "main" : "alternative";
  return t.characteristics && t.characteristics.indexOf(
    "public.accessibility.describes-video"
  ) >= 0 && (r = "main-desc"), r;
}, eh = function(t, r) {
  t.abort(), t.pause(), r && r.activePlaylistLoader && (r.activePlaylistLoader.pause(), r.activePlaylistLoader = null);
}, xd = function(t, r) {
  r.activePlaylistLoader = t, t.load();
}, EP = function(t, r) {
  return function() {
    var n = r.segmentLoaders, i = n[t], a = n.main, s = r.mediaTypes[t], o = s.activeTrack(), u = s.getActiveGroup(), l = s.activePlaylistLoader, c = s.lastGroup_;
    if (!(u && c && u.id === c.id) && (s.lastGroup_ = u, s.lastTrack_ = o, eh(i, s), !(!u || u.isMasterPlaylist))) {
      if (!u.playlistLoader) {
        l && a.resetEverything();
        return;
      }
      i.resyncLoader(), xd(u.playlistLoader, s);
    }
  };
}, wP = function(t, r) {
  return function() {
    var n = r.segmentLoaders[t], i = r.mediaTypes[t];
    i.lastGroup_ = null, n.abort(), n.pause();
  };
}, SP = function(t, r) {
  return function() {
    var n = r.masterPlaylistLoader, i = r.segmentLoaders, a = i[t], s = i.main, o = r.mediaTypes[t], u = o.activeTrack(), l = o.getActiveGroup(), c = o.activePlaylistLoader, h = o.lastTrack_;
    if (!(h && u && h.id === u.id) && (o.lastGroup_ = l, o.lastTrack_ = u, eh(a, o), !!l)) {
      if (l.isMasterPlaylist) {
        if (!u || !h || u.id === h.id)
          return;
        var f = r.vhs.masterPlaylistController_, d = f.selectPlaylist();
        if (f.media() === d)
          return;
        o.logger_(
          "track change. Switching master audio from " + h.id + " to " + u.id
        ), n.pause(), s.resetEverything(), f.fastQualityChange_(d);
        return;
      }
      if (t === "AUDIO") {
        if (!l.playlistLoader) {
          s.setAudio(!0), s.resetEverything();
          return;
        }
        a.setAudio(!0), s.setAudio(!1);
      }
      if (c === l.playlistLoader) {
        xd(l.playlistLoader, o);
        return;
      }
      a.track && a.track(u), a.resetEverything(), xd(l.playlistLoader, o);
    }
  };
}, th = {
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning (or error if the playlist is blacklisted) to
   *         console and switches back to default audio track.
   * @function onError.AUDIO
   */
  AUDIO: function(t, r) {
    return function() {
      var n = r.segmentLoaders[t], i = r.mediaTypes[t], a = r.blacklistCurrentPlaylist;
      eh(n, i);
      var s = i.activeTrack(), o = i.activeGroup(), u = (o.filter(function(h) {
        return h.default;
      })[0] || o[0]).id, l = i.tracks[u];
      if (s === l) {
        a({
          message: "Problem encountered loading the default audio track."
        });
        return;
      }
      X.log.warn(
        "Problem encountered loading the alternate audio track.Switching back to default."
      );
      for (var c in i.tracks)
        i.tracks[c].enabled = i.tracks[c] === l;
      i.onTrackChanged();
    };
  },
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning to console and disables the active subtitle track
   * @function onError.SUBTITLES
   */
  SUBTITLES: function(t, r) {
    return function() {
      var n = r.segmentLoaders[t], i = r.mediaTypes[t];
      X.log.warn(
        "Problem encountered loading the subtitle track.Disabling subtitle track."
      ), eh(n, i);
      var a = i.activeTrack();
      a && (a.mode = "disabled"), i.onTrackChanged();
    };
  }
}, Eg = {
  /**
   * Setup event listeners for audio playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.AUDIO
   */
  AUDIO: function(t, r, n) {
    if (r) {
      var i = n.tech, a = n.requestOptions, s = n.segmentLoaders[t];
      r.on("loadedmetadata", function() {
        var o = r.media();
        s.playlist(o, a), (!i.paused() || o.endList && i.preload() !== "none") && s.load();
      }), r.on("loadedplaylist", function() {
        s.playlist(r.media(), a), i.paused() || s.load();
      }), r.on("error", th[t](t, n));
    }
  },
  /**
   * Setup event listeners for subtitle playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.SUBTITLES
   */
  SUBTITLES: function(t, r, n) {
    var i = n.tech, a = n.requestOptions, s = n.segmentLoaders[t], o = n.mediaTypes[t];
    r.on("loadedmetadata", function() {
      var u = r.media();
      s.playlist(u, a), s.track(o.activeTrack()), (!i.paused() || u.endList && i.preload() !== "none") && s.load();
    }), r.on("loadedplaylist", function() {
      s.playlist(r.media(), a), i.paused() || s.load();
    }), r.on("error", th[t](t, n));
  }
}, CP = {
  /**
   * Setup PlaylistLoaders and AudioTracks for the audio groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.AUDIO
   */
  AUDIO: function(t, r) {
    var n = r.vhs, i = r.sourceType, a = r.segmentLoaders[t], s = r.requestOptions, o = r.master.mediaGroups, u = r.mediaTypes[t], l = u.groups, c = u.tracks, h = u.logger_, f = r.masterPlaylistLoader, d = Il(f.master);
    (!o[t] || Object.keys(o[t]).length === 0) && (o[t] = {
      main: {
        default: {
          default: !0
        }
      }
    }, d && (o[t].main.default.playlists = f.master.playlists));
    for (var p in o[t]) {
      l[p] || (l[p] = []);
      for (var _ in o[t][p]) {
        var v = o[t][p][_], x = void 0;
        if (d ? (h(
          "AUDIO group '" + p + "' label '" + _ + "' is a master playlist"
        ), v.isMasterPlaylist = !0, x = null) : i === "vhs-json" && v.playlists ? x = new Is(
          v.playlists[0],
          n,
          s
        ) : v.resolvedUri ? x = new Is(
          v.resolvedUri,
          n,
          s
        ) : v.playlists && i === "dash" ? x = new gd(
          v.playlists[0],
          n,
          s,
          f
        ) : x = null, v = X.mergeOptions(
          {
            id: _,
            playlistLoader: x
          },
          v
        ), Eg[t](t, v.playlistLoader, r), l[p].push(v), typeof c[_] > "u") {
          var E = new X.AudioTrack({
            default: v.default,
            enabled: !1,
            id: _,
            kind: TP(v),
            label: _,
            language: v.language
          });
          c[_] = E;
        }
      }
    }
    a.on("error", th[t](t, r));
  },
  /**
   * Setup TextTracks for the closed-caption groups
   *
   * @param {String} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize['CLOSED-CAPTIONS']
   */
  "CLOSED-CAPTIONS": function(t, r) {
    var n = r.tech, i = r.master.mediaGroups, a = r.mediaTypes[t], s = a.groups, o = a.tracks;
    for (var u in i[t]) {
      s[u] || (s[u] = []);
      for (var l in i[t][u]) {
        var c = i[t][u][l];
        if (/^(?:CC|SERVICE)/.test(c.instreamId)) {
          var h = n.options_.vhs && n.options_.vhs.captionServices || {}, f = {
            default: c.default && c.autoselect,
            instreamId: c.instreamId,
            label: l,
            language: c.language
          };
          if (h[f.instreamId] && (f = X.mergeOptions(
            f,
            h[f.instreamId]
          )), f.default === void 0 && delete f.default, s[u].push(
            X.mergeOptions(
              {
                id: l
              },
              c
            )
          ), typeof o[l] > "u") {
            var d = n.addRemoteTextTrack(
              {
                default: f.default,
                id: f.instreamId,
                kind: "captions",
                label: f.label,
                language: f.language
              },
              !1
            ).track;
            o[l] = d;
          }
        }
      }
    }
  },
  /**
   * Setup PlaylistLoaders and TextTracks for the subtitle groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.SUBTITLES
   */
  SUBTITLES: function(t, r) {
    var n = r.tech, i = r.vhs, a = r.sourceType, s = r.segmentLoaders[t], o = r.requestOptions, u = r.master.mediaGroups, l = r.mediaTypes[t], c = l.groups, h = l.tracks, f = r.masterPlaylistLoader;
    for (var d in u[t]) {
      c[d] || (c[d] = []);
      for (var p in u[t][d])
        if (!u[t][d][p].forced) {
          var _ = u[t][d][p], v = void 0;
          if (a === "hls")
            v = new Is(
              _.resolvedUri,
              i,
              o
            );
          else if (a === "dash") {
            var x = _.playlists.filter(function(M) {
              return M.excludeUntil !== 1 / 0;
            });
            if (!x.length)
              return;
            v = new gd(
              _.playlists[0],
              i,
              o,
              f
            );
          } else a === "vhs-json" && (v = new Is(
            // if the vhs-json object included the media playlist, use the media playlist
            // as provided, otherwise use the resolved URI to load the playlist
            _.playlists ? _.playlists[0] : _.resolvedUri,
            i,
            o
          ));
          if (_ = X.mergeOptions(
            {
              id: p,
              playlistLoader: v
            },
            _
          ), Eg[t](t, _.playlistLoader, r), c[d].push(_), typeof h[p] > "u") {
            var E = n.addRemoteTextTrack(
              {
                default: _.default && _.autoselect,
                id: p,
                kind: "subtitles",
                label: p,
                language: _.language
              },
              !1
            ).track;
            h[p] = E;
          }
        }
    }
    s.on("error", th[t](t, r));
  }
}, MP = function e(t, r) {
  for (var n = 0; n < t.length; n++)
    if (am(r, t[n]) || t[n].playlists && e(t[n].playlists, r))
      return !0;
  return !1;
}, DP = function(t, r) {
  return function(n) {
    var i = r.masterPlaylistLoader, a = r.mediaTypes[t].groups, s = i.media();
    if (!s)
      return null;
    var o = null;
    s.attributes[t] && (o = a[s.attributes[t]]);
    var u = Object.keys(a);
    if (!o)
      if (t === "AUDIO" && u.length > 1 && Il(r.master))
        for (var l = 0; l < u.length; l++) {
          var c = a[u[l]];
          if (MP(c, s)) {
            o = c;
            break;
          }
        }
      else a.main ? o = a.main : u.length === 1 && (o = a[u[0]]);
    return typeof n > "u" ? o : n === null || !o ? null : o.filter(function(h) {
      return h.id === n.id;
    })[0] || null;
  };
}, PP = {
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.AUDIO
   */
  AUDIO: function(t, r) {
    return function() {
      var n = r.mediaTypes[t].tracks;
      for (var i in n)
        if (n[i].enabled)
          return n[i];
      return null;
    };
  },
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.SUBTITLES
   */
  SUBTITLES: function(t, r) {
    return function() {
      var n = r.mediaTypes[t].tracks;
      for (var i in n)
        if (n[i].mode === "showing" || n[i].mode === "hidden")
          return n[i];
      return null;
    };
  }
}, LP = function(t, r) {
  var n = r.mediaTypes;
  return function() {
    var i = n[t].activeTrack();
    return i ? n[t].activeGroup(i) : null;
  };
}, RP = function(t) {
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(p) {
    CP[p](p, t);
  });
  var r = t.mediaTypes, n = t.masterPlaylistLoader, i = t.tech, a = t.vhs, s = t.segmentLoaders, o = s.AUDIO, u = s.main;
  ["AUDIO", "SUBTITLES"].forEach(function(p) {
    r[p].activeGroup = DP(p, t), r[p].activeTrack = PP[p](p, t), r[p].onGroupChanged = EP(p, t), r[p].onGroupChanging = wP(p, t), r[p].onTrackChanged = SP(p, t), r[p].getActiveGroup = LP(p, t);
  });
  var l = r.AUDIO.activeGroup();
  if (l) {
    var c = (l.filter(function(p) {
      return p.default;
    })[0] || l[0]).id;
    r.AUDIO.tracks[c].enabled = !0, r.AUDIO.onGroupChanged(), r.AUDIO.onTrackChanged();
    var h = r.AUDIO.getActiveGroup();
    h.playlistLoader ? (u.setAudio(!1), o.setAudio(!0)) : u.setAudio(!0);
  }
  n.on("mediachange", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(p) {
      return r[p].onGroupChanged();
    });
  }), n.on("mediachanging", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(p) {
      return r[p].onGroupChanging();
    });
  });
  var f = function() {
    r.AUDIO.onTrackChanged(), i.trigger({
      name: "vhs-audio-change",
      type: "usage"
    }), i.trigger({
      name: "hls-audio-change",
      type: "usage"
    });
  };
  i.audioTracks().addEventListener("change", f), i.remoteTextTracks().addEventListener("change", r.SUBTITLES.onTrackChanged), a.on("dispose", function() {
    i.audioTracks().removeEventListener("change", f), i.remoteTextTracks().removeEventListener("change", r.SUBTITLES.onTrackChanged);
  }), i.clearTracks("audio");
  for (var d in r.AUDIO.tracks)
    i.audioTracks().addTrack(r.AUDIO.tracks[d]);
}, IP = function() {
  var t = {};
  return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(r) {
    t[r] = {
      activeGroup: In,
      activePlaylistLoader: null,
      activeTrack: In,
      getActiveGroup: In,
      groups: {},
      lastTrack_: null,
      logger_: nn("MediaGroups[" + r + "]"),
      onGroupChanged: In,
      onTrackChanged: In,
      tracks: {}
    };
  }), t;
}, OP = 60 * 2, Pn, BP = [
  "mediaRequests",
  "mediaRequestsAborted",
  "mediaRequestsTimedout",
  "mediaRequestsErrored",
  "mediaTransferDuration",
  "mediaBytesTransferred",
  "mediaAppends"
], FP = function(t) {
  return this.audioSegmentLoader_[t] + this.mainSegmentLoader_[t];
}, kP = function(t) {
  var r = t.currentPlaylist, n = t.buffered, i = t.currentTime, a = t.nextPlaylist, s = t.bufferLowWaterLine, o = t.bufferHighWaterLine, u = t.duration, l = t.experimentalBufferBasedABR, c = t.log;
  if (!a)
    return X.log.warn(
      "We received no playlist to switch to. Please check your stream."
    ), !1;
  var h = "allowing switch " + (r && r.id || "null") + " -> " + a.id;
  if (!r)
    return c(h + " as current playlist is not set"), !0;
  if (a.id === r.id)
    return !1;
  var f = !!Rs(n, i).length;
  if (!r.endList)
    return !f && typeof r.partTargetDuration == "number" ? (c(
      "not " + h + " as current playlist is live llhls, but currentTime isn't in buffered."
    ), !1) : (c(h + " as current playlist is live"), !0);
  var d = rm(n, i), p = l ? Pr.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Pr.MAX_BUFFER_LOW_WATER_LINE;
  if (u < p)
    return c(
      h + " as duration < max low water line (" + u + " < " + p + ")"
    ), !0;
  var _ = a.attributes.BANDWIDTH, v = r.attributes.BANDWIDTH;
  if (_ < v && (!l || d < o)) {
    var x = h + " as next bandwidth < current bandwidth (" + _ + " < " + v + ")";
    return l && (x += " and forwardBuffer < bufferHighWaterLine (" + d + " < " + o + ")"), c(x), !0;
  }
  if ((!l || _ > v) && d >= s) {
    var E = h + " as forwardBuffer >= bufferLowWaterLine (" + d + " >= " + s + ")";
    return l && (E += " and next bandwidth > current bandwidth (" + _ + " > " + v + ")"), c(E), !0;
  }
  return c("not " + h + " as no switching criteria met"), !1;
}, NP = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n) {
    var i;
    i = e.call(this) || this;
    var a = n.src, s = n.handleManifestRedirects, o = n.withCredentials, u = n.tech, l = n.bandwidth, c = n.externVhs, h = n.useCueTags, f = n.blacklistDuration, d = n.enableLowInitialPlaylist, p = n.sourceType, _ = n.cacheEncryptionKeys, v = n.experimentalBufferBasedABR, x = n.experimentalLeastPixelDiffSelector, E = n.captionServices;
    if (!a)
      throw new Error(
        "A non-empty playlist URL or JSON manifest string is required"
      );
    var M = n.maxPlaylistRetries;
    (M === null || typeof M > "u") && (M = 1 / 0), Pn = c, i.experimentalBufferBasedABR = !!v, i.experimentalLeastPixelDiffSelector = !!x, i.withCredentials = o, i.tech_ = u, i.vhs_ = u.vhs, i.sourceType_ = p, i.useCueTags_ = h, i.blacklistDuration = f, i.maxPlaylistRetries = M, i.enableLowInitialPlaylist = d, i.useCueTags_ && (i.cueTagsTrack_ = i.tech_.addTextTrack("metadata", "ad-cues"), i.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), i.requestOptions_ = {
      handleManifestRedirects: s,
      maxPlaylistRetries: M,
      timeout: null,
      withCredentials: o
    }, i.on("error", i.pauseLoading), i.mediaTypes_ = IP(), i.mediaSource = new j.MediaSource(), i.handleDurationChange_ = i.handleDurationChange_.bind(
      ze(i)
    ), i.handleSourceOpen_ = i.handleSourceOpen_.bind(
      ze(i)
    ), i.handleSourceEnded_ = i.handleSourceEnded_.bind(
      ze(i)
    ), i.mediaSource.addEventListener(
      "durationchange",
      i.handleDurationChange_
    ), i.mediaSource.addEventListener("sourceopen", i.handleSourceOpen_), i.mediaSource.addEventListener("sourceended", i.handleSourceEnded_), i.seekable_ = X.createTimeRanges(), i.hasPlayed_ = !1, i.syncController_ = new _P(n), i.segmentMetadataTrack_ = u.addRemoteTextTrack(
      {
        kind: "metadata",
        label: "segment-metadata"
      },
      !1
    ).track, i.decrypter_ = new AP(), i.sourceUpdater_ = new vb(i.mediaSource), i.inbandTextTracks_ = {}, i.timelineChangeController_ = new bP();
    var C = {
      captionServices: E,
      currentTime: i.tech_.currentTime.bind(i.tech_),
      duration: function() {
        return i.duration();
      },
      bandwidth: l,
      goalBufferLength: function() {
        return i.goalBufferLength();
      },
      decrypter: i.decrypter_,
      mediaSource: i.mediaSource,
      hasPlayed: function() {
        return i.hasPlayed_;
      },
      parse708captions: n.parse708captions,
      cacheEncryptionKeys: _,
      vhs: i.vhs_,
      experimentalExactManifestTimings: n.experimentalExactManifestTimings,
      useDtsForTimestampOffset: n.useDtsForTimestampOffset,
      inbandTextTracks: i.inbandTextTracks_,
      seekable: function() {
        return i.seekable();
      },
      seeking: function() {
        return i.tech_.seeking();
      },
      sourceType: i.sourceType_,
      sourceUpdater: i.sourceUpdater_,
      syncController: i.syncController_,
      timelineChangeController: i.timelineChangeController_
    };
    i.masterPlaylistLoader_ = i.sourceType_ === "dash" ? new gd(a, i.vhs_, i.requestOptions_) : new Is(a, i.vhs_, i.requestOptions_), i.setupMasterPlaylistLoaderListeners_(), i.mainSegmentLoader_ = new _d(
      X.mergeOptions(C, {
        loaderType: "main",
        segmentMetadataTrack: i.segmentMetadataTrack_
      }),
      n
    ), i.audioSegmentLoader_ = new _d(
      X.mergeOptions(C, {
        loaderType: "audio"
      }),
      n
    ), i.subtitleSegmentLoader_ = new mP(
      X.mergeOptions(C, {
        featuresNativeTextTracks: i.tech_.featuresNativeTextTracks,
        loadVttJs: function() {
          return new Promise(function(k, F) {
            function I() {
              u.off("vttjserror", H), k();
            }
            function H() {
              u.off("vttjsloaded", I), F();
            }
            u.one("vttjsloaded", I), u.one("vttjserror", H), u.addWebVttScript_();
          });
        },
        loaderType: "vtt"
      }),
      n
    ), i.setupSegmentLoaderListeners_(), i.experimentalBufferBasedABR && (i.masterPlaylistLoader_.one("loadedplaylist", function() {
      return i.startABRTimer_();
    }), i.tech_.on("pause", function() {
      return i.stopABRTimer_();
    }), i.tech_.on("play", function() {
      return i.startABRTimer_();
    })), BP.forEach(function(B) {
      i[B + "_"] = FP.bind(
        ze(i),
        B
      );
    }), i.logger_ = nn("MPC"), i.triggeredFmp4Usage = !1, i.tech_.preload() === "none" ? (i.loadOnPlay_ = function() {
      i.loadOnPlay_ = null, i.masterPlaylistLoader_.load();
    }, i.tech_.one("play", i.loadOnPlay_)) : i.masterPlaylistLoader_.load(), i.timeToLoadedData__ = -1, i.mainAppendsToLoadedData__ = -1, i.audioAppendsToLoadedData__ = -1;
    var R = i.tech_.preload() === "none" ? "play" : "loadstart";
    return i.tech_.one(R, function() {
      var B = Date.now();
      i.tech_.one("loadeddata", function() {
        i.timeToLoadedData__ = Date.now() - B, i.mainAppendsToLoadedData__ = i.mainSegmentLoader_.mediaAppends, i.audioAppendsToLoadedData__ = i.audioSegmentLoader_.mediaAppends;
      });
    }), i;
  }
  var r = t.prototype;
  return r.mainAppendsToLoadedData_ = function() {
    return this.mainAppendsToLoadedData__;
  }, r.audioAppendsToLoadedData_ = function() {
    return this.audioAppendsToLoadedData__;
  }, r.appendsToLoadedData_ = function() {
    var i = this.mainAppendsToLoadedData_(), a = this.audioAppendsToLoadedData_();
    return i === -1 || a === -1 ? -1 : i + a;
  }, r.timeToLoadedData_ = function() {
    return this.timeToLoadedData__;
  }, r.checkABR_ = function(i) {
    i === void 0 && (i = "abr");
    var a = this.selectPlaylist();
    a && this.shouldSwitchToMedia_(a) && this.switchMedia_(a, i);
  }, r.switchMedia_ = function(i, a, s) {
    var o = this.media(), u = o && (o.id || o.uri), l = i.id || i.uri;
    u && u !== l && (this.logger_("switch media " + u + " -> " + l + " from " + a), this.tech_.trigger({
      name: "vhs-rendition-change-" + a,
      type: "usage"
    })), this.masterPlaylistLoader_.media(i, s);
  }, r.startABRTimer_ = function() {
    var i = this;
    this.stopABRTimer_(), this.abrTimer_ = j.setInterval(function() {
      return i.checkABR_();
    }, 250);
  }, r.stopABRTimer_ = function() {
    this.tech_.scrubbing && this.tech_.scrubbing() || (j.clearInterval(this.abrTimer_), this.abrTimer_ = null);
  }, r.getAudioTrackPlaylists_ = function() {
    var i = this.master(), a = i && i.playlists || [];
    if (!i || !i.mediaGroups || !i.mediaGroups.AUDIO)
      return a;
    var s = i.mediaGroups.AUDIO, o = Object.keys(s), u;
    if (Object.keys(this.mediaTypes_.AUDIO.groups).length)
      u = this.mediaTypes_.AUDIO.activeTrack();
    else {
      var l = s.main || o.length && s[o[0]];
      for (var c in l)
        if (l[c].default) {
          u = {
            label: c
          };
          break;
        }
    }
    if (!u)
      return a;
    var h = [];
    for (var f in s)
      if (s[f][u.label]) {
        var d = s[f][u.label];
        if (d.playlists && d.playlists.length)
          h.push.apply(h, d.playlists);
        else if (d.uri)
          h.push(d);
        else if (i.playlists.length)
          for (var p = 0; p < i.playlists.length; p++) {
            var _ = i.playlists[p];
            _.attributes && _.attributes.AUDIO && _.attributes.AUDIO === f && h.push(_);
          }
      }
    return h.length ? h : a;
  }, r.setupMasterPlaylistLoaderListeners_ = function() {
    var i = this;
    this.masterPlaylistLoader_.on("loadedmetadata", function() {
      var a = i.masterPlaylistLoader_.media(), s = a.targetDuration * 1.5 * 1e3;
      fd(
        i.masterPlaylistLoader_.master,
        i.masterPlaylistLoader_.media()
      ) ? i.requestOptions_.timeout = 0 : i.requestOptions_.timeout = s, a.endList && i.tech_.preload() !== "none" && (i.mainSegmentLoader_.playlist(a, i.requestOptions_), i.mainSegmentLoader_.load()), RP({
        blacklistCurrentPlaylist: i.blacklistCurrentPlaylist.bind(i),
        master: i.master(),
        masterPlaylistLoader: i.masterPlaylistLoader_,
        mediaTypes: i.mediaTypes_,
        requestOptions: i.requestOptions_,
        segmentLoaders: {
          AUDIO: i.audioSegmentLoader_,
          SUBTITLES: i.subtitleSegmentLoader_,
          main: i.mainSegmentLoader_
        },
        sourceType: i.sourceType_,
        tech: i.tech_,
        vhs: i.vhs_
      }), i.triggerPresenceUsage_(i.master(), a), i.setupFirstPlay(), !i.mediaTypes_.AUDIO.activePlaylistLoader || i.mediaTypes_.AUDIO.activePlaylistLoader.media() ? i.trigger("selectedinitialmedia") : i.mediaTypes_.AUDIO.activePlaylistLoader.one(
        "loadedmetadata",
        function() {
          i.trigger("selectedinitialmedia");
        }
      );
    }), this.masterPlaylistLoader_.on("loadedplaylist", function() {
      i.loadOnPlay_ && i.tech_.off("play", i.loadOnPlay_);
      var a = i.masterPlaylistLoader_.media();
      if (!a) {
        i.excludeUnsupportedVariants_();
        var s;
        if (i.enableLowInitialPlaylist && (s = i.selectInitialPlaylist()), s || (s = i.selectPlaylist()), !s || !i.shouldSwitchToMedia_(s))
          return;
        i.initialMedia_ = s, i.switchMedia_(i.initialMedia_, "initial");
        var o = i.sourceType_ === "vhs-json" && i.initialMedia_.segments;
        if (!o)
          return;
        a = i.initialMedia_;
      }
      i.handleUpdatedMediaPlaylist(a);
    }), this.masterPlaylistLoader_.on("error", function() {
      i.blacklistCurrentPlaylist(i.masterPlaylistLoader_.error);
    }), this.masterPlaylistLoader_.on("mediachanging", function() {
      i.mainSegmentLoader_.abort(), i.mainSegmentLoader_.pause();
    }), this.masterPlaylistLoader_.on("mediachange", function() {
      var a = i.masterPlaylistLoader_.media(), s = a.targetDuration * 1.5 * 1e3;
      fd(
        i.masterPlaylistLoader_.master,
        i.masterPlaylistLoader_.media()
      ) ? i.requestOptions_.timeout = 0 : i.requestOptions_.timeout = s, i.masterPlaylistLoader_.load(), i.mainSegmentLoader_.playlist(a, i.requestOptions_), i.mainSegmentLoader_.load(), i.tech_.trigger({
        bubbles: !0,
        type: "mediachange"
      });
    }), this.masterPlaylistLoader_.on("playlistunchanged", function() {
      var a = i.masterPlaylistLoader_.media();
      if (a.lastExcludeReason_ !== "playlist-unchanged") {
        var s = i.stuckAtPlaylistEnd_(a);
        s && (i.blacklistCurrentPlaylist({
          message: "Playlist no longer updating.",
          reason: "playlist-unchanged"
        }), i.tech_.trigger("playliststuck"));
      }
    }), this.masterPlaylistLoader_.on("renditiondisabled", function() {
      i.tech_.trigger({
        name: "vhs-rendition-disabled",
        type: "usage"
      }), i.tech_.trigger({
        name: "hls-rendition-disabled",
        type: "usage"
      });
    }), this.masterPlaylistLoader_.on("renditionenabled", function() {
      i.tech_.trigger({
        name: "vhs-rendition-enabled",
        type: "usage"
      }), i.tech_.trigger({
        name: "hls-rendition-enabled",
        type: "usage"
      });
    });
  }, r.handleUpdatedMediaPlaylist = function(i) {
    this.useCueTags_ && this.updateAdCues_(i), this.mainSegmentLoader_.playlist(i, this.requestOptions_), this.updateDuration(!i.endList), this.tech_.paused() || (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load());
  }, r.triggerPresenceUsage_ = function(i, a) {
    var s = i.mediaGroups || {}, o = !0, u = Object.keys(s.AUDIO);
    for (var l in s.AUDIO)
      for (var c in s.AUDIO[l]) {
        var h = s.AUDIO[l][c];
        h.uri || (o = !1);
      }
    o && (this.tech_.trigger({
      name: "vhs-demuxed",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-demuxed",
      type: "usage"
    })), Object.keys(s.SUBTITLES).length && (this.tech_.trigger({
      name: "vhs-webvtt",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-webvtt",
      type: "usage"
    })), Pn.Playlist.isAes(a) && (this.tech_.trigger({
      name: "vhs-aes",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-aes",
      type: "usage"
    })), u.length && Object.keys(s.AUDIO[u[0]]).length > 1 && (this.tech_.trigger({
      name: "vhs-alternate-audio",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-alternate-audio",
      type: "usage"
    })), this.useCueTags_ && (this.tech_.trigger({
      name: "vhs-playlist-cue-tags",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-playlist-cue-tags",
      type: "usage"
    }));
  }, r.shouldSwitchToMedia_ = function(i) {
    var a = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_, s = this.tech_.currentTime(), o = this.bufferLowWaterLine(), u = this.bufferHighWaterLine(), l = this.tech_.buffered();
    return kP({
      bufferHighWaterLine: u,
      bufferLowWaterLine: o,
      buffered: l,
      currentPlaylist: a,
      currentTime: s,
      duration: this.duration(),
      experimentalBufferBasedABR: this.experimentalBufferBasedABR,
      log: this.logger_,
      nextPlaylist: i
    });
  }, r.setupSegmentLoaderListeners_ = function() {
    var i = this;
    this.mainSegmentLoader_.on("bandwidthupdate", function() {
      i.checkABR_("bandwidthupdate"), i.tech_.trigger("bandwidthupdate");
    }), this.mainSegmentLoader_.on("timeout", function() {
      i.experimentalBufferBasedABR && i.mainSegmentLoader_.load();
    }), this.experimentalBufferBasedABR || this.mainSegmentLoader_.on("progress", function() {
      i.trigger("progress");
    }), this.mainSegmentLoader_.on("error", function() {
      i.blacklistCurrentPlaylist(i.mainSegmentLoader_.error());
    }), this.mainSegmentLoader_.on("appenderror", function() {
      i.error = i.mainSegmentLoader_.error_, i.trigger("error");
    }), this.mainSegmentLoader_.on("syncinfoupdate", function() {
      i.onSyncInfoUpdate_();
    }), this.mainSegmentLoader_.on("timestampoffset", function() {
      i.tech_.trigger({
        name: "vhs-timestamp-offset",
        type: "usage"
      }), i.tech_.trigger({
        name: "hls-timestamp-offset",
        type: "usage"
      });
    }), this.audioSegmentLoader_.on("syncinfoupdate", function() {
      i.onSyncInfoUpdate_();
    }), this.audioSegmentLoader_.on("appenderror", function() {
      i.error = i.audioSegmentLoader_.error_, i.trigger("error");
    }), this.mainSegmentLoader_.on("ended", function() {
      i.logger_("main segment loader ended"), i.onEndOfStream();
    }), this.mainSegmentLoader_.on("earlyabort", function(s) {
      i.experimentalBufferBasedABR || (i.delegateLoaders_("all", ["abort"]), i.blacklistCurrentPlaylist(
        {
          message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
        },
        OP
      ));
    });
    var a = function() {
      if (!i.sourceUpdater_.hasCreatedSourceBuffers())
        return i.tryToCreateSourceBuffers_();
      var o = i.getCodecsOrExclude_();
      o && i.sourceUpdater_.addOrChangeSourceBuffers(o);
    };
    this.mainSegmentLoader_.on("trackinfo", a), this.audioSegmentLoader_.on("trackinfo", a), this.mainSegmentLoader_.on("fmp4", function() {
      i.triggeredFmp4Usage || (i.tech_.trigger({
        name: "vhs-fmp4",
        type: "usage"
      }), i.tech_.trigger({
        name: "hls-fmp4",
        type: "usage"
      }), i.triggeredFmp4Usage = !0);
    }), this.audioSegmentLoader_.on("fmp4", function() {
      i.triggeredFmp4Usage || (i.tech_.trigger({
        name: "vhs-fmp4",
        type: "usage"
      }), i.tech_.trigger({
        name: "hls-fmp4",
        type: "usage"
      }), i.triggeredFmp4Usage = !0);
    }), this.audioSegmentLoader_.on("ended", function() {
      i.logger_("audioSegmentLoader ended"), i.onEndOfStream();
    });
  }, r.mediaSecondsLoaded_ = function() {
    return Math.max(
      this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded
    );
  }, r.load = function() {
    this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load();
  }, r.smoothQualityChange_ = function(i) {
    i === void 0 && (i = this.selectPlaylist()), this.fastQualityChange_(i);
  }, r.fastQualityChange_ = function(i) {
    var a = this;
    if (i === void 0 && (i = this.selectPlaylist()), i === this.masterPlaylistLoader_.media()) {
      this.logger_(
        "skipping fastQualityChange because new media is same as old"
      );
      return;
    }
    this.switchMedia_(i, "fast-quality"), this.mainSegmentLoader_.resetEverything(function() {
      X.browser.IE_VERSION || X.browser.IS_EDGE ? a.tech_.setCurrentTime(a.tech_.currentTime() + 0.04) : a.tech_.setCurrentTime(a.tech_.currentTime());
    });
  }, r.play = function() {
    if (!this.setupFirstPlay()) {
      this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load();
      var i = this.tech_.seekable();
      if (this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < i.start(0))
        return this.tech_.setCurrentTime(i.end(i.length - 1));
    }
  }, r.setupFirstPlay = function() {
    var i = this, a = this.masterPlaylistLoader_.media();
    if (!a || this.tech_.paused() || this.hasPlayed_)
      return !1;
    if (!a.endList) {
      var s = this.seekable();
      if (!s.length)
        return !1;
      if (X.browser.IE_VERSION && this.tech_.readyState() === 0)
        return this.tech_.one("loadedmetadata", function() {
          i.trigger("firstplay"), i.tech_.setCurrentTime(s.end(0)), i.hasPlayed_ = !0;
        }), !1;
      this.trigger("firstplay"), this.tech_.setCurrentTime(s.end(0));
    }
    return this.hasPlayed_ = !0, this.load(), !0;
  }, r.handleSourceOpen_ = function() {
    if (this.tryToCreateSourceBuffers_(), this.tech_.autoplay()) {
      var i = this.tech_.play();
      typeof i < "u" && typeof i.then == "function" && i.then(null, function(a) {
      });
    }
    this.trigger("sourceopen");
  }, r.handleSourceEnded_ = function() {
    if (this.inbandTextTracks_.metadataTrack_) {
      var i = this.inbandTextTracks_.metadataTrack_.cues;
      if (!(!i || !i.length)) {
        var a = this.duration();
        i[i.length - 1].endTime = isNaN(a) || Math.abs(a) === 1 / 0 ? Number.MAX_VALUE : a;
      }
    }
  }, r.handleDurationChange_ = function() {
    this.tech_.trigger("durationchange");
  }, r.onEndOfStream = function() {
    var i = this.mainSegmentLoader_.ended_;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      var a = this.mainSegmentLoader_.getCurrentMediaInfo_();
      !a || a.hasVideo ? i = i && this.audioSegmentLoader_.ended_ : i = this.audioSegmentLoader_.ended_;
    }
    i && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream());
  }, r.stuckAtPlaylistEnd_ = function(i) {
    var a = this.seekable();
    if (!a.length)
      return !1;
    var s = this.syncController_.getExpiredTime(
      i,
      this.duration()
    );
    if (s === null)
      return !1;
    var o = Pn.Playlist.playlistEnd(i, s), u = this.tech_.currentTime(), l = this.tech_.buffered();
    if (!l.length)
      return o - u <= dn;
    var c = l.end(l.length - 1);
    return c - u <= dn && o - c <= dn;
  }, r.blacklistCurrentPlaylist = function(i, a) {
    i === void 0 && (i = {});
    var s = i.playlist || this.masterPlaylistLoader_.media();
    if (a = a || i.blacklistDuration || this.blacklistDuration, !s) {
      this.error = i, this.mediaSource.readyState !== "open" ? this.trigger("error") : this.sourceUpdater_.endOfStream("network");
      return;
    }
    s.playlistErrors_++;
    var o = this.masterPlaylistLoader_.master.playlists, u = o.filter(Nh), l = u.length === 1 && u[0] === s;
    if (o.length === 1 && a !== 1 / 0)
      return X.log.warn(
        "Problem encountered with playlist " + s.id + ". Trying again since it is the only playlist."
      ), this.tech_.trigger("retryplaylist"), this.masterPlaylistLoader_.load(l);
    if (l) {
      var c = !1;
      o.forEach(function(x) {
        if (x !== s) {
          var E = x.excludeUntil;
          typeof E < "u" && E !== 1 / 0 && (c = !0, delete x.excludeUntil);
        }
      }), c && (X.log.warn(
        "Removing other playlists from the exclusion list because the last rendition is about to be excluded."
      ), this.tech_.trigger("retryplaylist"));
    }
    var h;
    s.playlistErrors_ > this.maxPlaylistRetries ? h = 1 / 0 : h = Date.now() + a * 1e3, s.excludeUntil = h, i.reason && (s.lastExcludeReason_ = i.reason), this.tech_.trigger("blacklistplaylist"), this.tech_.trigger({
      name: "vhs-rendition-blacklisted",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-rendition-blacklisted",
      type: "usage"
    });
    var f = this.selectPlaylist();
    if (!f) {
      this.error = "Playback cannot continue. No available working or supported playlists.", this.trigger("error");
      return;
    }
    var d = i.internal ? this.logger_ : X.log.warn, p = i.message ? " " + i.message : "";
    d(
      (i.internal ? "Internal problem" : "Problem") + " encountered with playlist " + s.id + "." + (p + " Switching to playlist " + f.id + ".")
    ), f.attributes.AUDIO !== s.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]), f.attributes.SUBTITLES !== s.attributes.SUBTITLES && this.delegateLoaders_("subtitle", ["abort", "pause"]), this.delegateLoaders_("main", ["abort", "pause"]);
    var _ = f.targetDuration / 2 * 1e3 || 5 * 1e3, v = typeof f.lastRequest == "number" && Date.now() - f.lastRequest <= _;
    return this.switchMedia_(
      f,
      "exclude",
      l || v
    );
  }, r.pauseLoading = function() {
    this.delegateLoaders_("all", ["abort", "pause"]), this.stopABRTimer_();
  }, r.delegateLoaders_ = function(i, a) {
    var s = this, o = [], u = i === "all";
    (u || i === "main") && o.push(this.masterPlaylistLoader_);
    var l = [];
    (u || i === "audio") && l.push("AUDIO"), (u || i === "subtitle") && (l.push("CLOSED-CAPTIONS"), l.push("SUBTITLES")), l.forEach(function(c) {
      var h = s.mediaTypes_[c] && s.mediaTypes_[c].activePlaylistLoader;
      h && o.push(h);
    }), ["main", "audio", "subtitle"].forEach(function(c) {
      var h = s[c + "SegmentLoader_"];
      h && (i === c || i === "all") && o.push(h);
    }), o.forEach(function(c) {
      return a.forEach(function(h) {
        typeof c[h] == "function" && c[h]();
      });
    });
  }, r.setCurrentTime = function(i) {
    var a = Rs(this.tech_.buffered(), i);
    if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media()) || !this.masterPlaylistLoader_.media().segments)
      return 0;
    if (a && a.length)
      return i;
    this.mainSegmentLoader_.resetEverything(), this.mainSegmentLoader_.abort(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.resetEverything(), this.audioSegmentLoader_.abort()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.resetEverything(), this.subtitleSegmentLoader_.abort()), this.load();
  }, r.duration = function() {
    if (!this.masterPlaylistLoader_)
      return 0;
    var i = this.masterPlaylistLoader_.media();
    return i ? i.endList ? this.mediaSource ? this.mediaSource.duration : Pn.Playlist.duration(i) : 1 / 0 : 0;
  }, r.seekable = function() {
    return this.seekable_;
  }, r.onSyncInfoUpdate_ = function() {
    var i;
    if (this.masterPlaylistLoader_) {
      var a = this.masterPlaylistLoader_.media();
      if (a) {
        var s = this.syncController_.getExpiredTime(a, this.duration());
        if (s !== null) {
          var o = this.masterPlaylistLoader_.master, u = Pn.Playlist.seekable(
            a,
            s,
            Pn.Playlist.liveEdgeDelay(o, a)
          );
          if (u.length !== 0 && !(this.mediaTypes_.AUDIO.activePlaylistLoader && (a = this.mediaTypes_.AUDIO.activePlaylistLoader.media(), s = this.syncController_.getExpiredTime(a, this.duration()), s === null || (i = Pn.Playlist.seekable(
            a,
            s,
            Pn.Playlist.liveEdgeDelay(o, a)
          ), i.length === 0)))) {
            var l, c;
            this.seekable_ && this.seekable_.length && (l = this.seekable_.end(0), c = this.seekable_.start(0)), i ? i.start(0) > u.end(0) || u.start(0) > i.end(0) ? this.seekable_ = u : this.seekable_ = X.createTimeRanges([
              [
                i.start(0) > u.start(0) ? i.start(0) : u.start(0),
                i.end(0) < u.end(0) ? i.end(0) : u.end(0)
              ]
            ]) : this.seekable_ = u, !(this.seekable_ && this.seekable_.length && this.seekable_.end(0) === l && this.seekable_.start(0) === c) && (this.logger_("seekable updated [" + I1(this.seekable_) + "]"), this.tech_.trigger("seekablechanged"));
          }
        }
      }
    }
  }, r.updateDuration = function(i) {
    if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), this.mediaSource.readyState !== "open") {
      this.updateDuration_ = this.updateDuration.bind(this, i), this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
      return;
    }
    if (i) {
      var a = this.seekable();
      if (!a.length)
        return;
      (isNaN(this.mediaSource.duration) || this.mediaSource.duration < a.end(a.length - 1)) && this.sourceUpdater_.setDuration(a.end(a.length - 1));
      return;
    }
    var s = this.tech_.buffered(), o = Pn.Playlist.duration(this.masterPlaylistLoader_.media());
    s.length > 0 && (o = Math.max(o, s.end(s.length - 1))), this.mediaSource.duration !== o && this.sourceUpdater_.setDuration(o);
  }, r.dispose = function() {
    var i = this;
    this.trigger("dispose"), this.decrypter_.terminate(), this.masterPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), ["AUDIO", "SUBTITLES"].forEach(function(a) {
      var s = i.mediaTypes_[a].groups;
      for (var o in s)
        s[o].forEach(function(u) {
          u.playlistLoader && u.playlistLoader.dispose();
        });
    }), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener(
      "durationchange",
      this.handleDurationChange_
    ), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener(
      "sourceended",
      this.handleSourceEnded_
    ), this.off();
  }, r.master = function() {
    return this.masterPlaylistLoader_.master;
  }, r.media = function() {
    return this.masterPlaylistLoader_.media() || this.initialMedia_;
  }, r.areMediaTypesKnown_ = function() {
    var i = !!this.mediaTypes_.AUDIO.activePlaylistLoader, a = !!this.mainSegmentLoader_.getCurrentMediaInfo_(), s = i ? !!this.audioSegmentLoader_.getCurrentMediaInfo_() : !0;
    return !(!a || !s);
  }, r.getCodecsOrExclude_ = function() {
    var i = this, a = {
      audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {},
      main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {}
    }, s = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
    a.video = a.main;
    var o = du(this.master(), s), u = {}, l = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    if (a.main.hasVideo && (u.video = o.video || a.main.videoCodec || pw), a.main.isMuxed && (u.video += "," + (o.audio || a.main.audioCodec || ev)), (a.main.hasAudio && !a.main.isMuxed || a.audio.hasAudio || l) && (u.audio = o.audio || a.main.audioCodec || a.audio.audioCodec || ev, a.audio.isFmp4 = a.main.hasAudio && !a.main.isMuxed ? a.main.isFmp4 : a.audio.isFmp4), !u.audio && !u.video) {
      this.blacklistCurrentPlaylist({
        blacklistDuration: 1 / 0,
        message: "Could not determine codecs for playlist.",
        playlist: s
      });
      return;
    }
    var c = function(x, E) {
      return x ? ec(E) : Jh(E);
    }, h = {}, f;
    if (["video", "audio"].forEach(function(v) {
      if (u.hasOwnProperty(v) && !c(a[v].isFmp4, u[v])) {
        var x = a[v].isFmp4 ? "browser" : "muxer";
        h[x] = h[x] || [], h[x].push(u[v]), v === "audio" && (f = x);
      }
    }), l && f && s.attributes.AUDIO) {
      var d = s.attributes.AUDIO;
      this.master().playlists.forEach(function(v) {
        var x = v.attributes && v.attributes.AUDIO;
        x === d && v !== s && (v.excludeUntil = 1 / 0);
      }), this.logger_(
        "excluding audio group " + d + " as " + f + ' does not support codec(s): "' + u.audio + '"'
      );
    }
    if (Object.keys(h).length) {
      var p = Object.keys(h).reduce(function(v, x) {
        return v && (v += ", "), v += x + ' does not support codec(s): "' + h[x].join(",") + '"', v;
      }, "") + ".";
      this.blacklistCurrentPlaylist({
        blacklistDuration: 1 / 0,
        internal: !0,
        message: p,
        playlist: s
      });
      return;
    }
    if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
      var _ = [];
      if (["video", "audio"].forEach(function(v) {
        var x = (cn(i.sourceUpdater_.codecs[v] || "")[0] || {}).type, E = (cn(u[v] || "")[0] || {}).type;
        x && E && x.toLowerCase() !== E.toLowerCase() && _.push(
          '"' + i.sourceUpdater_.codecs[v] + '" -> "' + u[v] + '"'
        );
      }), _.length) {
        this.blacklistCurrentPlaylist({
          blacklistDuration: 1 / 0,
          internal: !0,
          message: "Codec switching not supported: " + _.join(", ") + ".",
          playlist: s
        });
        return;
      }
    }
    return u;
  }, r.tryToCreateSourceBuffers_ = function() {
    if (!(this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) && this.areMediaTypesKnown_()) {
      var i = this.getCodecsOrExclude_();
      if (i) {
        this.sourceUpdater_.createSourceBuffers(i);
        var a = [i.video, i.audio].filter(Boolean).join(",");
        this.excludeIncompatibleVariants_(a);
      }
    }
  }, r.excludeUnsupportedVariants_ = function() {
    var i = this, a = this.master().playlists, s = [];
    Object.keys(a).forEach(function(o) {
      var u = a[o];
      if (s.indexOf(u.id) === -1) {
        s.push(u.id);
        var l = du(i.master, u), c = [];
        l.audio && !Jh(l.audio) && !ec(l.audio) && c.push("audio codec " + l.audio), l.video && !Jh(l.video) && !ec(l.video) && c.push("video codec " + l.video), l.text && l.text === "stpp.ttml.im1t" && c.push("text codec " + l.text), c.length && (u.excludeUntil = 1 / 0, i.logger_(
          "excluding " + u.id + " for unsupported: " + c.join(", ")
        ));
      }
    });
  }, r.excludeIncompatibleVariants_ = function(i) {
    var a = this, s = [], o = this.master().playlists, u = Zc(cn(i)), l = dg(u), c = u.video && cn(u.video)[0] || null, h = u.audio && cn(u.audio)[0] || null;
    Object.keys(o).forEach(function(f) {
      var d = o[f];
      if (!(s.indexOf(d.id) !== -1 || d.excludeUntil === 1 / 0)) {
        s.push(d.id);
        var p = [], _ = du(
          a.masterPlaylistLoader_.master,
          d
        ), v = dg(_);
        if (!(!_.audio && !_.video)) {
          if (v !== l && p.push(
            'codec count "' + v + '" !== "' + l + '"'
          ), !a.sourceUpdater_.canChangeType()) {
            var x = _.video && cn(_.video)[0] || null, E = _.audio && cn(_.audio)[0] || null;
            x && c && x.type.toLowerCase() !== c.type.toLowerCase() && p.push(
              'video codec "' + x.type + '" !== "' + c.type + '"'
            ), E && h && E.type.toLowerCase() !== h.type.toLowerCase() && p.push(
              'audio codec "' + E.type + '" !== "' + h.type + '"'
            );
          }
          p.length && (d.excludeUntil = 1 / 0, a.logger_(
            "blacklisting " + d.id + ": " + p.join(" && ")
          ));
        }
      }
    });
  }, r.updateAdCues_ = function(i) {
    var a = 0, s = this.seekable();
    s.length && (a = s.start(0)), gP(i, this.cueTagsTrack_, a);
  }, r.goalBufferLength = function() {
    var i = this.tech_.currentTime(), a = Pr.GOAL_BUFFER_LENGTH, s = Pr.GOAL_BUFFER_LENGTH_RATE, o = Math.max(a, Pr.MAX_GOAL_BUFFER_LENGTH);
    return Math.min(a + i * s, o);
  }, r.bufferLowWaterLine = function() {
    var i = this.tech_.currentTime(), a = Pr.BUFFER_LOW_WATER_LINE, s = Pr.BUFFER_LOW_WATER_LINE_RATE, o = Math.max(a, Pr.MAX_BUFFER_LOW_WATER_LINE), u = Math.max(
      a,
      Pr.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE
    );
    return Math.min(
      a + i * s,
      this.experimentalBufferBasedABR ? u : o
    );
  }, r.bufferHighWaterLine = function() {
    return Pr.BUFFER_HIGH_WATER_LINE;
  }, t;
}(X.EventTarget), UP = function(t, r, n) {
  return function(i) {
    var a = t.master.playlists[r], s = nm(a), o = Nh(a);
    return typeof i > "u" ? o : (i ? delete a.disabled : a.disabled = !0, i !== o && !s && (n(), i ? t.trigger("renditionenabled") : t.trigger("renditiondisabled")), i);
  };
}, GP = function(t, r, n) {
  var i = t.masterPlaylistController_, a = t.options_.smoothQualityChange, s = a ? "smooth" : "fast", o = i[s + "QualityChange_"].bind(i);
  if (r.attributes) {
    var u = r.attributes.RESOLUTION;
    this.width = u && u.width, this.height = u && u.height, this.bandwidth = r.attributes.BANDWIDTH, this.frameRate = r.attributes["FRAME-RATE"];
  }
  this.codecs = du(i.master(), r), this.playlist = r, this.id = n, this.enabled = UP(
    t.playlists,
    r.id,
    o
  );
}, VP = function(t) {
  t.representations = function() {
    var r = t.masterPlaylistController_.master(), n = Il(r) ? t.masterPlaylistController_.getAudioTrackPlaylists_() : r.playlists;
    return n ? n.filter(function(i) {
      return !nm(i);
    }).map(function(i, a) {
      return new GP(t, i, i.id);
    }) : [];
  };
}, wg = ["seeking", "seeked", "pause", "playing", "error"], HP = /* @__PURE__ */ function() {
  function e(r) {
    var n = this;
    this.masterPlaylistController_ = r.masterPlaylistController, this.tech_ = r.tech, this.seekable = r.seekable, this.allowSeeksWithinUnsafeLiveWindow = r.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = r.liveRangeSafeTimeDelta, this.media = r.media, this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.timer_ = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = nn("PlaybackWatcher"), this.logger_("initialize");
    var i = function() {
      return n.monitorCurrentTime_();
    }, a = function() {
      return n.monitorCurrentTime_();
    }, s = function() {
      return n.techWaiting_();
    }, o = function() {
      return n.cancelTimer_();
    }, u = this.masterPlaylistController_, l = ["main", "subtitle", "audio"], c = {};
    l.forEach(function(f) {
      c[f] = {
        reset: function() {
          return n.resetSegmentDownloads_(f);
        },
        updateend: function() {
          return n.checkSegmentDownloads_(f);
        }
      }, u[f + "SegmentLoader_"].on(
        "appendsdone",
        c[f].updateend
      ), u[f + "SegmentLoader_"].on(
        "playlistupdate",
        c[f].reset
      ), n.tech_.on(["seeked", "seeking"], c[f].reset);
    });
    var h = function(d) {
      ["main", "audio"].forEach(function(p) {
        u[p + "SegmentLoader_"][d]("appended", n.seekingAppendCheck_);
      });
    };
    this.seekingAppendCheck_ = function() {
      n.fixesBadSeeks_() && (n.consecutiveUpdates = 0, n.lastRecordedTime = n.tech_.currentTime(), h("off"));
    }, this.clearSeekingAppendCheck_ = function() {
      return h("off");
    }, this.watchForBadSeeking_ = function() {
      n.clearSeekingAppendCheck_(), h("on");
    }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", s), this.tech_.on(wg, o), this.tech_.on("canplay", a), this.tech_.one("play", i), this.dispose = function() {
      n.clearSeekingAppendCheck_(), n.logger_("dispose"), n.tech_.off("waiting", s), n.tech_.off(wg, o), n.tech_.off("canplay", a), n.tech_.off("play", i), n.tech_.off("seeking", n.watchForBadSeeking_), n.tech_.off("seeked", n.clearSeekingAppendCheck_), l.forEach(function(f) {
        u[f + "SegmentLoader_"].off(
          "appendsdone",
          c[f].updateend
        ), u[f + "SegmentLoader_"].off(
          "playlistupdate",
          c[f].reset
        ), n.tech_.off(["seeked", "seeking"], c[f].reset);
      }), n.checkCurrentTimeTimeout_ && j.clearTimeout(n.checkCurrentTimeTimeout_), n.cancelTimer_();
    };
  }
  var t = e.prototype;
  return t.monitorCurrentTime_ = function() {
    this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && j.clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = j.setTimeout(
      this.monitorCurrentTime_.bind(this),
      250
    );
  }, t.resetSegmentDownloads_ = function(n) {
    var i = this.masterPlaylistController_[n + "SegmentLoader_"];
    this[n + "StalledDownloads_"] > 0 && this.logger_(
      "resetting possible stalled download count for " + n + " loader"
    ), this[n + "StalledDownloads_"] = 0, this[n + "Buffered_"] = i.buffered_();
  }, t.checkSegmentDownloads_ = function(n) {
    var i = this.masterPlaylistController_, a = i[n + "SegmentLoader_"], s = a.buffered_(), o = I3(
      this[n + "Buffered_"],
      s
    );
    if (this[n + "Buffered_"] = s, o) {
      this.resetSegmentDownloads_(n);
      return;
    }
    this[n + "StalledDownloads_"]++, this.logger_(
      "found #" + this[n + "StalledDownloads_"] + " " + n + " appends that did not increase buffer (possible stalled download)",
      {
        buffered: Ba(s),
        playlistId: a.playlist_ && a.playlist_.id
      }
    ), !(this[n + "StalledDownloads_"] < 10) && (this.logger_(n + " loader stalled download exclusion"), this.resetSegmentDownloads_(n), this.tech_.trigger({
      name: "vhs-" + n + "-download-exclusion",
      type: "usage"
    }), n !== "subtitle" && i.blacklistCurrentPlaylist(
      {
        message: "Excessive " + n + " segment downloading detected."
      },
      1 / 0
    ));
  }, t.checkCurrentTime_ = function() {
    if (!(this.tech_.paused() || this.tech_.seeking())) {
      var n = this.tech_.currentTime(), i = this.tech_.buffered();
      if (this.lastRecordedTime === n && (!i.length || n + dn >= i.end(i.length - 1)))
        return this.techWaiting_();
      this.consecutiveUpdates >= 5 && n === this.lastRecordedTime ? (this.consecutiveUpdates++, this.waiting_()) : n === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0, this.lastRecordedTime = n);
    }
  }, t.cancelTimer_ = function() {
    this.consecutiveUpdates = 0, this.timer_ && (this.logger_("cancelTimer_"), clearTimeout(this.timer_)), this.timer_ = null;
  }, t.fixesBadSeeks_ = function() {
    var n = this.tech_.seeking();
    if (!n)
      return !1;
    var i = this.seekable(), a = this.tech_.currentTime(), s = this.afterSeekableWindow_(
      i,
      a,
      this.media(),
      this.allowSeeksWithinUnsafeLiveWindow
    ), o;
    if (s) {
      var u = i.end(i.length - 1);
      o = u;
    }
    if (this.beforeSeekableWindow_(i, a)) {
      var l = i.start(0);
      o = l + // if the playlist is too short and the seekable range is an exact time (can
      // happen in live with a 3 segment playlist), then don't use a time delta
      (l === i.end(0) ? 0 : dn);
    }
    if (typeof o < "u")
      return this.logger_(
        "Trying to seek outside of seekable at time " + a + " with " + ("seekable range " + I1(i) + ". Seeking to ") + (o + ".")
      ), this.tech_.setCurrentTime(o), !0;
    for (var c = this.masterPlaylistController_.sourceUpdater_, h = this.tech_.buffered(), f = c.audioBuffer ? c.audioBuffered() : null, d = c.videoBuffer ? c.videoBuffered() : null, p = this.media(), _ = p.partTargetDuration ? p.partTargetDuration : (p.targetDuration - ya) * 2, v = [f, d], x = 0; x < v.length; x++)
      if (v[x]) {
        var E = rm(v[x], a);
        if (E < _)
          return !1;
      }
    var M = Ql(h, a);
    return M.length === 0 ? !1 : (o = M.start(0) + dn, this.logger_(
      "Buffered region starts (" + M.start(0) + ") " + (" just beyond seek point (" + a + "). Seeking to " + o + ".")
    ), this.tech_.setCurrentTime(o), !0);
  }, t.waiting_ = function() {
    if (!this.techWaiting_()) {
      var n = this.tech_.currentTime(), i = this.tech_.buffered(), a = Rs(i, n);
      if (a.length && n + 3 <= a.end(0)) {
        this.cancelTimer_(), this.tech_.setCurrentTime(n), this.logger_(
          "Stopped at " + n + " while inside a buffered region " + ("[" + a.start(0) + " -> " + a.end(0) + "]. Attempting to resume ") + "playback by seeking to the current time."
        ), this.tech_.trigger({
          name: "vhs-unknown-waiting",
          type: "usage"
        }), this.tech_.trigger({
          name: "hls-unknown-waiting",
          type: "usage"
        });
        return;
      }
    }
  }, t.techWaiting_ = function() {
    var n = this.seekable(), i = this.tech_.currentTime();
    if (this.tech_.seeking() || this.timer_ !== null)
      return !0;
    if (this.beforeSeekableWindow_(n, i)) {
      var a = n.end(n.length - 1);
      return this.logger_(
        "Fell out of live window at time " + i + ". Seeking to " + ("live point (seekable end) " + a)
      ), this.cancelTimer_(), this.tech_.setCurrentTime(a), this.tech_.trigger({
        name: "vhs-live-resync",
        type: "usage"
      }), this.tech_.trigger({
        name: "hls-live-resync",
        type: "usage"
      }), !0;
    }
    var s = this.tech_.vhs.masterPlaylistController_.sourceUpdater_, o = this.tech_.buffered(), u = this.videoUnderflow_({
      audioBuffered: s.audioBuffered(),
      currentTime: i,
      videoBuffered: s.videoBuffered()
    });
    if (u)
      return this.cancelTimer_(), this.tech_.setCurrentTime(i), this.tech_.trigger({
        name: "vhs-video-underflow",
        type: "usage"
      }), this.tech_.trigger({
        name: "hls-video-underflow",
        type: "usage"
      }), !0;
    var l = Ql(o, i);
    if (l.length > 0) {
      var c = l.start(0) - i;
      return this.logger_(
        "Stopped at " + i + ", setting timer for " + c + ", seeking " + ("to " + l.start(0))
      ), this.cancelTimer_(), this.timer_ = setTimeout(
        this.skipTheGap_.bind(this),
        c * 1e3,
        i
      ), !0;
    }
    return !1;
  }, t.afterSeekableWindow_ = function(n, i, a, s) {
    if (s === void 0 && (s = !1), !n.length)
      return !1;
    var o = n.end(n.length - 1) + dn, u = !a.endList;
    return u && s && (o = n.end(n.length - 1) + a.targetDuration * 3), i > o;
  }, t.beforeSeekableWindow_ = function(n, i) {
    return !!(n.length && // can't fall before 0 and 0 seekable start identifies VOD stream
    n.start(0) > 0 && i < n.start(0) - this.liveRangeSafeTimeDelta);
  }, t.videoUnderflow_ = function(n) {
    var i = n.videoBuffered, a = n.audioBuffered, s = n.currentTime;
    if (i) {
      var o;
      if (i.length && a.length) {
        var u = Rs(i, s - 3), l = Rs(i, s), c = Rs(a, s);
        c.length && !l.length && u.length && (o = {
          end: c.end(0),
          start: u.end(0)
        });
      } else {
        var h = Ql(i, s);
        h.length || (o = this.gapFromVideoUnderflow_(i, s));
      }
      return o ? (this.logger_(
        "Encountered a gap in video from " + o.start + " to " + o.end + ". " + ("Seeking to current time " + s)
      ), !0) : !1;
    }
  }, t.skipTheGap_ = function(n) {
    var i = this.tech_.buffered(), a = this.tech_.currentTime(), s = Ql(i, a);
    this.cancelTimer_(), !(s.length === 0 || a !== n) && (this.logger_(
      "skipTheGap_:",
      "currentTime:",
      a,
      "scheduled currentTime:",
      n,
      "nextRange start:",
      s.start(0)
    ), this.tech_.setCurrentTime(s.start(0) + ya), this.tech_.trigger({
      name: "vhs-gap-skip",
      type: "usage"
    }), this.tech_.trigger({
      name: "hls-gap-skip",
      type: "usage"
    }));
  }, t.gapFromVideoUnderflow_ = function(n, i) {
    for (var a = P3(n), s = 0; s < a.length; s++) {
      var o = a.start(s), u = a.end(s);
      if (i - o < 4 && i - o > 2)
        return {
          end: u,
          start: o
        };
    }
    return null;
  }, e;
}(), zP = {
  errorInterval: 30,
  getSource: function(t) {
    var r = this.tech({
      IWillNotUseThisInPlugins: !0
    }), n = r.currentSource_ || this.currentSource();
    return t(n);
  }
}, WP = function e(t, r) {
  var n = 0, i = 0, a = X.mergeOptions(zP, r);
  t.ready(function() {
    t.trigger({
      name: "vhs-error-reload-initialized",
      type: "usage"
    }), t.trigger({
      name: "hls-error-reload-initialized",
      type: "usage"
    });
  });
  var s = function() {
    i && t.currentTime(i);
  }, o = function(f) {
    f != null && (i = t.duration() !== 1 / 0 && t.currentTime() || 0, t.one("loadedmetadata", s), t.src(f), t.trigger({
      name: "vhs-error-reload",
      type: "usage"
    }), t.trigger({
      name: "hls-error-reload",
      type: "usage"
    }), t.play());
  }, u = function() {
    if (Date.now() - n < a.errorInterval * 1e3) {
      t.trigger({
        name: "vhs-error-reload-canceled",
        type: "usage"
      }), t.trigger({
        name: "hls-error-reload-canceled",
        type: "usage"
      });
      return;
    }
    if (!a.getSource || typeof a.getSource != "function") {
      X.log.error(
        "ERROR: reloadSourceOnError - The option getSource must be a function!"
      );
      return;
    }
    return n = Date.now(), a.getSource.call(t, o);
  }, l = function h() {
    t.off("loadedmetadata", s), t.off("error", u), t.off("dispose", h);
  }, c = function(f) {
    l(), e(t, f);
  };
  t.on("error", u), t.on("dispose", l), t.reloadSourceOnError = c;
}, jP = function(t) {
  WP(this, t);
}, gb = "2.16.2", qP = "6.0.1", XP = "0.22.1", YP = "4.8.0", QP = "3.1.3", Fr = {
  INITIAL_PLAYLIST_SELECTOR: XD,
  Playlist: li,
  PlaylistLoader: Is,
  STANDARD_PLAYLIST_SELECTOR: mg,
  comparePlaylistBandwidth: um,
  comparePlaylistResolution: WD,
  lastBandwidthSelector: mg,
  movingAverageBandwidthSelector: jD,
  utils: nD,
  xhr: Y1()
};
Object.keys(Pr).forEach(function(e) {
  Object.defineProperty(Fr, e, {
    get: function() {
      return X.log.warn(
        "using Vhs." + e + " is UNSAFE be sure you know what you are doing"
      ), Pr[e];
    },
    set: function(r) {
      if (X.log.warn(
        "using Vhs." + e + " is UNSAFE be sure you know what you are doing"
      ), typeof r != "number" || r < 0) {
        X.log.warn(
          "value of Vhs." + e + " must be greater than or equal to 0"
        );
        return;
      }
      Pr[e] = r;
    }
  });
});
var yb = "videojs-vhs", _b = function(t, r) {
  for (var n = r.media(), i = -1, a = 0; a < t.length; a++)
    if (t[a].id === n.id) {
      i = a;
      break;
    }
  t.selectedIndex_ = i, t.trigger({
    selectedIndex: i,
    type: "change"
  });
}, KP = function(t, r) {
  r.representations().forEach(function(n) {
    t.addQualityLevel(n);
  }), _b(t, r.playlists);
};
Fr.canPlaySource = function() {
  return X.log.warn(
    "HLS is no longer a tech. Please remove it from your player's techOrder."
  );
};
var $P = function(t, r, n) {
  if (!t)
    return t;
  var i = {};
  r && r.attributes && r.attributes.CODECS && (i = Zc(cn(r.attributes.CODECS))), n && n.attributes && n.attributes.CODECS && (i.audio = n.attributes.CODECS);
  var a = ul(i.video), s = ul(i.audio), o = {};
  for (var u in t)
    o[u] = {}, s && (o[u].audioContentType = s), a && (o[u].videoContentType = a), r.contentProtection && r.contentProtection[u] && r.contentProtection[u].pssh && (o[u].pssh = r.contentProtection[u].pssh), typeof t[u] == "string" && (o[u].url = t[u]);
  return X.mergeOptions(t, o);
}, ZP = function(t, r) {
  return t.reduce(function(n, i) {
    if (!i.contentProtection)
      return n;
    var a = r.reduce(function(s, o) {
      var u = i.contentProtection[o];
      return u && u.pssh && (s[o] = {
        pssh: u.pssh
      }), s;
    }, {});
    return Object.keys(a).length && n.push(a), n;
  }, []);
}, JP = function(t) {
  var r = t.player, n = t.sourceKeySystems, i = t.audioMedia, a = t.mainPlaylists;
  if (!r.eme.initializeMediaKeys)
    return Promise.resolve();
  var s = i ? a.concat([i]) : a, o = ZP(
    s,
    Object.keys(n)
  ), u = [], l = [];
  return o.forEach(function(c) {
    l.push(
      new Promise(function(h, f) {
        r.tech_.one("keysessioncreated", h);
      })
    ), u.push(
      new Promise(function(h, f) {
        r.eme.initializeMediaKeys(
          {
            keySystems: c
          },
          function(d) {
            if (d) {
              f(d);
              return;
            }
            h();
          }
        );
      })
    );
  }), Promise.race([
    // If a session was previously created, these will all finish resolving without
    // creating a new session, otherwise it will take until the end of all license
    // requests, which is why the key session check is used (to make setup much faster).
    Promise.all(u),
    // Once a single session is created, the browser knows DRM will be used.
    Promise.race(l)
  ]);
}, eL = function(t) {
  var r = t.player, n = t.sourceKeySystems, i = t.media, a = t.audioMedia, s = $P(n, i, a);
  return s ? (r.currentSource().keySystems = s, s && !r.eme ? (X.log.warn(
    "DRM encrypted source cannot be decrypted without a DRM plugin"
  ), !1) : !0) : !1;
}, bb = function() {
  if (!j.localStorage)
    return null;
  var t = j.localStorage.getItem(yb);
  if (!t)
    return null;
  try {
    return JSON.parse(t);
  } catch {
    return null;
  }
}, tL = function(t) {
  if (!j.localStorage)
    return !1;
  var r = bb();
  r = r ? X.mergeOptions(r, t) : t;
  try {
    j.localStorage.setItem(
      yb,
      JSON.stringify(r)
    );
  } catch {
    return !1;
  }
  return r;
}, rL = function(t) {
  return t.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0 ? JSON.parse(t.substring(t.indexOf(",") + 1)) : t;
};
Fr.supportsNativeHls = function() {
  if (!Te || !Te.createElement)
    return !1;
  var e = Te.createElement("video");
  if (!X.getTech("Html5").isSupported())
    return !1;
  var t = [
    // Apple santioned
    "application/vnd.apple.mpegurl",
    // Apple sanctioned for backwards compatibility
    "audio/mpegurl",
    // Very common
    "audio/x-mpegurl",
    // Very common
    "application/x-mpegurl",
    // Included for completeness
    "video/x-mpegurl",
    "video/mpegurl",
    "application/mpegurl"
  ];
  return t.some(function(r) {
    return /maybe|probably/i.test(e.canPlayType(r));
  });
}();
Fr.supportsNativeDash = function() {
  return !Te || !Te.createElement || !X.getTech("Html5").isSupported() ? !1 : /maybe|probably/i.test(
    Te.createElement("video").canPlayType("application/dash+xml")
  );
}();
Fr.supportsTypeNatively = function(e) {
  return e === "hls" ? Fr.supportsNativeHls : e === "dash" ? Fr.supportsNativeDash : !1;
};
Fr.isSupported = function() {
  return X.log.warn(
    "HLS is no longer a tech. Please remove it from your player's techOrder."
  );
};
var iL = X.getComponent("Component"), cm = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a) {
    var s;
    if (s = e.call(
      this,
      i,
      X.mergeOptions(a.hls, a.vhs)
    ) || this, a.hls && Object.keys(a.hls).length && X.log.warn(
      "Using hls options is deprecated. Please rename `hls` to `vhs` in your options object."
    ), typeof a.initialBandwidth == "number" && (s.options_.bandwidth = a.initialBandwidth), s.logger_ = nn("VhsHandler"), i.options_ && i.options_.playerId) {
      var o = X(i.options_.playerId);
      o.hasOwnProperty("hls") || Object.defineProperty(o, "hls", {
        configurable: !0,
        get: function() {
          return X.log.warn(
            "player.hls is deprecated. Use player.tech().vhs instead."
          ), i.trigger({
            name: "hls-player-access",
            type: "usage"
          }), ze(s);
        }
      }), o.hasOwnProperty("vhs") || Object.defineProperty(o, "vhs", {
        configurable: !0,
        get: function() {
          return X.log.warn(
            "player.vhs is deprecated. Use player.tech().vhs instead."
          ), i.trigger({
            name: "vhs-player-access",
            type: "usage"
          }), ze(s);
        }
      }), o.hasOwnProperty("dash") || Object.defineProperty(o, "dash", {
        configurable: !0,
        get: function() {
          return X.log.warn(
            "player.dash is deprecated. Use player.tech().vhs instead."
          ), ze(s);
        }
      }), s.player_ = o;
    }
    if (s.tech_ = i, s.source_ = n, s.stats = {}, s.ignoreNextSeekingEvent_ = !1, s.setOptions_(), s.options_.overrideNative && i.overrideNativeAudioTracks && i.overrideNativeVideoTracks)
      i.overrideNativeAudioTracks(!0), i.overrideNativeVideoTracks(!0);
    else if (s.options_.overrideNative && (i.featuresNativeVideoTracks || i.featuresNativeAudioTracks))
      throw new Error(
        "Overriding native HLS requires emulated tracks. See https://git.io/vMpjB"
      );
    return s.on(
      Te,
      [
        "fullscreenchange",
        "webkitfullscreenchange",
        "mozfullscreenchange",
        "MSFullscreenChange"
      ],
      function(u) {
        var l = Te.fullscreenElement || Te.webkitFullscreenElement || Te.mozFullScreenElement || Te.msFullscreenElement;
        l && l.contains(s.tech_.el()) ? s.masterPlaylistController_.fastQualityChange_() : s.masterPlaylistController_.checkABR_();
      }
    ), s.on(s.tech_, "seeking", function() {
      if (this.ignoreNextSeekingEvent_) {
        this.ignoreNextSeekingEvent_ = !1;
        return;
      }
      this.setCurrentTime(this.tech_.currentTime());
    }), s.on(s.tech_, "error", function() {
      this.tech_.error() && this.masterPlaylistController_ && this.masterPlaylistController_.pauseLoading();
    }), s.on(s.tech_, "play", s.play), s;
  }
  var r = t.prototype;
  return r.setOptions_ = function() {
    var i = this;
    if (this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.handleManifestRedirects = this.options_.handleManifestRedirects !== !1, this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions !== !1, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.smoothQualityChange = this.options_.smoothQualityChange || !1, this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage < "u" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || !1, this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, typeof this.options_.blacklistDuration != "number" && (this.options_.blacklistDuration = 5 * 60), typeof this.options_.bandwidth != "number" && this.options_.useBandwidthFromLocalStorage) {
      var a = bb();
      a && a.bandwidth && (this.options_.bandwidth = a.bandwidth, this.tech_.trigger({
        name: "vhs-bandwidth-from-local-storage",
        type: "usage"
      }), this.tech_.trigger({
        name: "hls-bandwidth-from-local-storage",
        type: "usage"
      })), a && a.throughput && (this.options_.throughput = a.throughput, this.tech_.trigger({
        name: "vhs-throughput-from-local-storage",
        type: "usage"
      }), this.tech_.trigger({
        name: "hls-throughput-from-local-storage",
        type: "usage"
      }));
    }
    typeof this.options_.bandwidth != "number" && (this.options_.bandwidth = Pr.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Pr.INITIAL_BANDWIDTH, [
      "withCredentials",
      "useDevicePixelRatio",
      "limitRenditionByPlayerDimensions",
      "bandwidth",
      "smoothQualityChange",
      "customTagParsers",
      "customTagMappers",
      "handleManifestRedirects",
      "cacheEncryptionKeys",
      "playlistSelector",
      "initialPlaylistSelector",
      "experimentalBufferBasedABR",
      "liveRangeSafeTimeDelta",
      "experimentalLLHLS",
      "useNetworkInformationApi",
      "useDtsForTimestampOffset",
      "experimentalExactManifestTimings",
      "experimentalLeastPixelDiffSelector"
    ].forEach(function(s) {
      typeof i.source_[s] < "u" && (i.options_[s] = i.source_[s]);
    }), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
  }, r.src = function(i, a) {
    var s = this;
    if (i) {
      this.setOptions_(), this.options_.src = rL(this.source_.src), this.options_.tech = this.tech_, this.options_.externVhs = Fr, this.options_.sourceType = Cy(a), this.options_.seekTo = function(l) {
        s.tech_.setCurrentTime(l);
      }, this.options_.smoothQualityChange && X.log.warn(
        "smoothQualityChange is deprecated and will be removed in the next major version"
      ), this.masterPlaylistController_ = new NP(
        this.options_
      );
      var o = X.mergeOptions(
        {
          liveRangeSafeTimeDelta: dn
        },
        this.options_,
        {
          masterPlaylistController: this.masterPlaylistController_,
          media: function() {
            return s.masterPlaylistController_.media();
          },
          seekable: function() {
            return s.seekable();
          }
        }
      );
      this.playbackWatcher_ = new HP(o), this.masterPlaylistController_.on("error", function() {
        var l = X.players[s.tech_.options_.playerId], c = s.masterPlaylistController_.error;
        typeof c == "object" && !c.code ? c.code = 3 : typeof c == "string" && (c = {
          code: 3,
          message: c
        }), l.error(c);
      });
      var u = this.options_.experimentalBufferBasedABR ? Fr.movingAverageBandwidthSelector(0.55) : Fr.STANDARD_PLAYLIST_SELECTOR;
      this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : u.bind(this), this.masterPlaylistController_.selectInitialPlaylist = Fr.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.masterPlaylistController_.masterPlaylistLoader_, this.mediaSource = this.masterPlaylistController_.mediaSource, Object.defineProperties(this, {
        bandwidth: {
          get: function() {
            var c = this.masterPlaylistController_.mainSegmentLoader_.bandwidth, h = j.navigator.connection || j.navigator.mozConnection || j.navigator.webkitConnection, f = 1e7;
            if (this.options_.useNetworkInformationApi && h) {
              var d = h.downlink * 1e3 * 1e3;
              d >= f && c >= f ? c = Math.max(
                c,
                d
              ) : c = d;
            }
            return c;
          },
          set: function(c) {
            this.masterPlaylistController_.mainSegmentLoader_.bandwidth = c, this.masterPlaylistController_.mainSegmentLoader_.throughput = {
              count: 0,
              rate: 0
            };
          }
        },
        selectPlaylist: {
          get: function() {
            return this.masterPlaylistController_.selectPlaylist;
          },
          set: function(c) {
            this.masterPlaylistController_.selectPlaylist = c.bind(this);
          }
        },
        /**
         * `systemBandwidth` is a combination of two serial processes bit-rates. The first
         * is the network bitrate provided by `bandwidth` and the second is the bitrate of
         * the entire process after that - decryption, transmuxing, and appending - provided
         * by `throughput`.
         *
         * Since the two process are serial, the overall system bandwidth is given by:
         *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)
         */
        systemBandwidth: {
          get: function() {
            var c = 1 / (this.bandwidth || 1), h;
            this.throughput > 0 ? h = 1 / this.throughput : h = 0;
            var f = Math.floor(1 / (c + h));
            return f;
          },
          set: function() {
            X.log.error('The "systemBandwidth" property is read-only');
          }
        },
        throughput: {
          get: function() {
            return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;
          },
          set: function(c) {
            this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = c, this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;
          }
        }
      }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, {
        audioAppendsToLoadedData: {
          get: function() {
            return s.masterPlaylistController_.audioAppendsToLoadedData_() || 0;
          },
          enumerable: !0
        },
        bandwidth: {
          enumerable: !0,
          get: function() {
            return s.bandwidth || 0;
          }
        },
        appendsToLoadedData: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.appendsToLoadedData_() || 0;
          }
        },
        mediaAppends: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaAppends_() || 0;
          }
        },
        buffered: {
          enumerable: !0,
          get: function() {
            return Ba(s.tech_.buffered());
          }
        },
        mediaBytesTransferred: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaBytesTransferred_() || 0;
          }
        },
        currentSource: {
          enumerable: !0,
          get: function() {
            return s.tech_.currentSource_;
          }
        },
        mediaRequests: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaRequests_() || 0;
          }
        },
        currentTech: {
          enumerable: !0,
          get: function() {
            return s.tech_.name_;
          }
        },
        mediaRequestsAborted: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaRequestsAborted_() || 0;
          }
        },
        currentTime: {
          enumerable: !0,
          get: function() {
            return s.tech_.currentTime();
          }
        },
        mediaRequestsErrored: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mediaRequestsErrored_() || 0;
          }
        },
        duration: {
          enumerable: !0,
          get: function() {
            return s.tech_.duration();
          }
        },
        mediaRequestsTimedout: {
          get: function() {
            return s.masterPlaylistController_.mediaRequestsTimedout_() || 0;
          },
          enumerable: !0
        },
        mainAppendsToLoadedData: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.mainAppendsToLoadedData_() || 0;
          }
        },
        mediaTransferDuration: {
          get: function() {
            return s.masterPlaylistController_.mediaTransferDuration_() || 0;
          },
          enumerable: !0
        },
        master: {
          enumerable: !0,
          get: function() {
            return s.playlists.master;
          }
        },
        mediaSecondsLoaded: {
          get: function() {
            return s.masterPlaylistController_.mediaSecondsLoaded_() || 0;
          },
          enumerable: !0
        },
        playerDimensions: {
          enumerable: !0,
          get: function() {
            return s.tech_.currentDimensions();
          }
        },
        seekable: {
          enumerable: !0,
          get: function() {
            return Ba(s.tech_.seekable());
          }
        },
        timeToLoadedData: {
          enumerable: !0,
          get: function() {
            return s.masterPlaylistController_.timeToLoadedData_() || 0;
          }
        },
        timestamp: {
          enumerable: !0,
          get: function() {
            return Date.now();
          }
        },
        videoPlaybackQuality: {
          enumerable: !0,
          get: function() {
            return s.tech_.getVideoPlaybackQuality();
          }
        }
      }), this.tech_.one(
        "canplay",
        this.masterPlaylistController_.setupFirstPlay.bind(
          this.masterPlaylistController_
        )
      ), this.tech_.on("bandwidthupdate", function() {
        s.options_.useBandwidthFromLocalStorage && tL({
          bandwidth: s.bandwidth,
          throughput: Math.round(s.throughput)
        });
      }), this.masterPlaylistController_.on("selectedinitialmedia", function() {
        VP(s);
      }), this.masterPlaylistController_.sourceUpdater_.on(
        "createdsourcebuffers",
        function() {
          s.setupEme_();
        }
      ), this.on(this.masterPlaylistController_, "progress", function() {
        this.tech_.trigger("progress");
      }), this.on(this.masterPlaylistController_, "firstplay", function() {
        this.ignoreNextSeekingEvent_ = !0;
      }), this.setupQualityLevels_(), this.tech_.el() && (this.mediaSourceUrl_ = j.URL.createObjectURL(
        this.masterPlaylistController_.mediaSource
      ), this.tech_.src(this.mediaSourceUrl_));
    }
  }, r.createKeySessions_ = function() {
    var i = this, a = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    this.logger_("waiting for EME key session creation"), JP({
      audioMedia: a && a.media(),
      mainPlaylists: this.playlists.master.playlists,
      player: this.player_,
      sourceKeySystems: this.source_.keySystems
    }).then(function() {
      i.logger_("created EME key session"), i.masterPlaylistController_.sourceUpdater_.initializedEme();
    }).catch(function(s) {
      i.logger_("error while creating EME key session", s), i.player_.error({
        code: 3,
        message: "Failed to initialize media keys for EME"
      });
    });
  }, r.handleWaitingForKey_ = function() {
    this.logger_(
      "waitingforkey fired, attempting to create any new key sessions"
    ), this.createKeySessions_();
  }, r.setupEme_ = function() {
    var i = this, a = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader, s = eL({
      audioMedia: a && a.media(),
      media: this.playlists.media(),
      player: this.player_,
      sourceKeySystems: this.source_.keySystems
    });
    if (this.player_.tech_.on("keystatuschange", function(o) {
      if (o.status === "output-restricted") {
        var u = i.masterPlaylistController_.master();
        if (!(!u || !u.playlists)) {
          var l = [];
          if (u.playlists.forEach(function(h) {
            h && h.attributes && h.attributes.RESOLUTION && h.attributes.RESOLUTION.height >= 720 && (!h.excludeUntil || h.excludeUntil < 1 / 0) && (h.excludeUntil = 1 / 0, l.push(h));
          }), l.length) {
            var c;
            (c = X.log).warn.apply(
              c,
              [
                'DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.'
              ].concat(l)
            ), i.masterPlaylistController_.fastQualityChange_();
          }
        }
      }
    }), this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this), this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_), X.browser.IE_VERSION === 11 || !s) {
      this.masterPlaylistController_.sourceUpdater_.initializedEme();
      return;
    }
    this.createKeySessions_();
  }, r.setupQualityLevels_ = function() {
    var i = this, a = X.players[this.tech_.options_.playerId];
    !a || !a.qualityLevels || this.qualityLevels_ || (this.qualityLevels_ = a.qualityLevels(), this.masterPlaylistController_.on("selectedinitialmedia", function() {
      KP(i.qualityLevels_, i);
    }), this.playlists.on("mediachange", function() {
      _b(i.qualityLevels_, i.playlists);
    }));
  }, t.version = function() {
    return {
      "@videojs/http-streaming": gb,
      "aes-decrypter": QP,
      "m3u8-parser": YP,
      "mpd-parser": XP,
      "mux.js": qP
    };
  }, r.version = function() {
    return this.constructor.version();
  }, r.canChangeType = function() {
    return vb.canChangeType();
  }, r.play = function() {
    this.masterPlaylistController_.play();
  }, r.setCurrentTime = function(i) {
    this.masterPlaylistController_.setCurrentTime(i);
  }, r.duration = function() {
    return this.masterPlaylistController_.duration();
  }, r.seekable = function() {
    return this.masterPlaylistController_.seekable();
  }, r.dispose = function() {
    this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.masterPlaylistController_ && this.masterPlaylistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.player_ && (delete this.player_.vhs, delete this.player_.dash, delete this.player_.hls), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.tech_ && delete this.tech_.hls, this.mediaSourceUrl_ && j.URL.revokeObjectURL && (j.URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_), e.prototype.dispose.call(this);
  }, r.convertToProgramTime = function(i, a) {
    return hD({
      callback: a,
      playlist: this.masterPlaylistController_.media(),
      time: i
    });
  }, r.seekToProgramTime = function(i, a, s, o) {
    return s === void 0 && (s = !0), o === void 0 && (o = 2), fD({
      callback: a,
      pauseAfterSeek: s,
      playlist: this.masterPlaylistController_.media(),
      programTime: i,
      retryCount: o,
      seekTo: this.options_.seekTo,
      tech: this.options_.tech
    });
  }, t;
}(iL), gl = {
  VERSION: gb,
  canHandleSource: function(t, r) {
    r === void 0 && (r = {});
    var n = X.mergeOptions(X.options, r);
    return gl.canPlayType(t.type, n);
  },
  canPlayType: function(t, r) {
    var n = Cy(t);
    if (!n)
      return "";
    var i = gl.getOverrideNative(r), a = Fr.supportsTypeNatively(n), s = !a || i;
    return s ? "maybe" : "";
  },
  getOverrideNative: function(t) {
    t === void 0 && (t = {});
    var r = t, n = r.vhs, i = n === void 0 ? {} : n, a = r.hls, s = a === void 0 ? {} : a, o = !(X.browser.IS_ANY_SAFARI || X.browser.IS_IOS), u = i.overrideNative, l = u === void 0 ? o : u, c = s.overrideNative, h = c === void 0 ? !1 : c;
    return h || l;
  },
  handleSource: function(t, r, n) {
    n === void 0 && (n = {});
    var i = X.mergeOptions(X.options, n);
    return r.vhs = new cm(t, r, i), X.hasOwnProperty("hls") || Object.defineProperty(r, "hls", {
      configurable: !0,
      get: function() {
        return X.log.warn(
          "player.tech().hls is deprecated. Use player.tech().vhs instead."
        ), r.vhs;
      }
    }), r.vhs.xhr = Y1(), r.vhs.src(t.src, t.type), r.vhs;
  },
  name: "videojs-http-streaming"
}, nL = function() {
  return ec("avc1.4d400d,mp4a.40.2");
};
nL() && X.getTech("Html5").registerSourceHandler(gl, 0);
X.VhsHandler = cm;
Object.defineProperty(X, "HlsHandler", {
  configurable: !0,
  get: function() {
    return X.log.warn(
      "videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead."
    ), cm;
  }
});
X.VhsSourceHandler = gl;
Object.defineProperty(X, "HlsSourceHandler", {
  configurable: !0,
  get: function() {
    return X.log.warn(
      "videojs.HlsSourceHandler is deprecated. Use videojs.VhsSourceHandler instead."
    ), gl;
  }
});
X.Vhs = Fr;
Object.defineProperty(X, "Hls", {
  configurable: !0,
  get: function() {
    return X.log.warn("videojs.Hls is deprecated. Use videojs.Vhs instead."), Fr;
  }
});
X.use || (X.registerComponent("Hls", Fr), X.registerComponent("Vhs", Fr));
X.options.vhs = X.options.vhs || {};
X.options.hls = X.options.hls || {};
if (!X.getPlugin || !X.getPlugin("reloadSourceOnError")) {
  var aL = X.registerPlugin || X.plugin;
  aL("reloadSourceOnError", jP);
}
/* ! @name videojs-vr @version 1.7.2 @license Apache-2.0 */
j.THREE = Object.assign(j.THREE || {}, ew);
import("../chunks/OrbitControls.CLHBWz99.js");
import("../chunks/DeviceOrientationControls.CCdbZgfJ.js");
import("../chunks/VREffect.YVShY77P.js");
import("../chunks/VRControls.js_g1t8t.js");
var sL = j.THREE.OrbitControls, oL = j.THREE.VREffect, uL = j.THREE.VRControls, lL = j.THREE.DeviceOrientationControls, cL = "1.7.2";
function hL(e, t, r, n) {
  var i = e * t + r * n;
  if (i > 0.499) {
    var a = 2 * Math.atan2(e, n), s = Math.PI / 2, o = 0;
    return new z(s, o, a);
  }
  if (i < -0.499) {
    var u = -2 * Math.atan2(e, n), l = -Math.PI / 2, c = 0;
    return new z(l, c, u);
  }
  var h = e * e, f = t * t, d = r * r, p = Math.atan2(2 * t * n - 2 * e * r, 1 - 2 * f - 2 * d), _ = Math.asin(2 * i), v = Math.atan2(2 * e * n - 2 * t * r, 1 - 2 * h - 2 * d);
  return new z(_, v, p);
}
var fL = /* @__PURE__ */ function() {
  function e(r) {
    this.object = r.camera, this.domElement = r.canvas, this.orbit = new sL(this.object, this.domElement), this.speed = 0.5, this.orbit.target.set(0, 0, -1), this.orbit.enableZoom = !1, this.orbit.enablePan = !1, this.orbit.rotateSpeed = -this.speed, r.orientation && (this.orientation = new lL(this.object)), r.halfView && (this.orbit.minAzimuthAngle = -Math.PI / 4, this.orbit.maxAzimuthAngle = Math.PI / 4);
  }
  var t = e.prototype;
  return t.update = function() {
    if (this.orientation) {
      this.orientation.update();
      var n = this.orientation.object.quaternion, i = hL(n.x, n.y, n.z, n.w);
      typeof this.lastAngle_ > "u" && (this.lastAngle_ = i), this.orbit.rotateLeft(
        (this.lastAngle_.z - i.z) * (1 + this.speed)
      ), this.orbit.rotateUp(
        (this.lastAngle_.y - i.y) * (1 + this.speed)
      ), this.lastAngle_ = i;
    }
    this.orbit.update();
  }, t.dispose = function() {
    this.orbit.dispose(), this.orientation && this.orientation.dispose();
  }, e;
}(), dL = function() {
  var e = Te.createElement("video");
  return e.crossOrigin = "anonymous", e.hasAttribute("crossorigin");
}(), ac = [
  "360",
  "360_LR",
  "360_TB",
  "360_CUBE",
  "EAC",
  "EAC_LR",
  "NONE",
  "AUTO",
  "Sphere",
  "Cube",
  "equirectangular",
  "180"
], Tf = function(t) {
  if (t) {
    if (t = t.toString().trim(), /sphere/i.test(t))
      return "360";
    if (/cube/i.test(t))
      return "360_CUBE";
    if (/equirectangular/i.test(t))
      return "360";
    for (var r = 0; r < ac.length; r++)
      if (new RegExp("^" + ac[r] + "$", "i").test(t))
        return ac[r];
  }
}, pL = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this) || this, a.player = n, a.canvas = i, a.onMoveEnd = X.bind(
      ze(a),
      a.onMoveEnd
    ), a.onMoveStart = X.bind(
      ze(a),
      a.onMoveStart
    ), a.onMove = X.bind(ze(a), a.onMove), a.onControlBarMove = X.bind(
      ze(a),
      a.onControlBarMove
    ), a.player.controlBar.on(
      [
        "mousedown",
        "mousemove",
        "mouseup",
        "touchstart",
        "touchmove",
        "touchend"
      ],
      a.onControlBarMove
    ), a.oldReportUserActivity = a.player.reportUserActivity, a.player.reportUserActivity = function() {
    }, a.canvas.addEventListener("mousedown", a.onMoveStart), a.canvas.addEventListener("touchstart", a.onMoveStart), a.canvas.addEventListener("mousemove", a.onMove), a.canvas.addEventListener("touchmove", a.onMove), a.canvas.addEventListener("mouseup", a.onMoveEnd), a.canvas.addEventListener("touchend", a.onMoveEnd), a.shouldTogglePlay = !1, a;
  }
  var r = t.prototype;
  return r.togglePlay = function() {
    this.player.paused() ? this.player.play() : this.player.pause();
  }, r.onMoveStart = function(i) {
    if (!this.player.controls() || i.type === "mousedown" && !X.dom.isSingleLeftClick(i)) {
      this.shouldTogglePlay = !1;
      return;
    }
    this.shouldTogglePlay = !0, this.touchMoveCount_ = 0;
  }, r.onMoveEnd = function(i) {
    if (i.type === "touchend" && this.touchMoveCount_ < 10) {
      if (this.player.userActive() === !1) {
        this.player.userActive(!0);
        return;
      }
      this.player.userActive(!1);
      return;
    }
    this.shouldTogglePlay && i.type == "mouseup" && this.togglePlay();
  }, r.onMove = function(i) {
    this.touchMoveCount_++, this.shouldTogglePlay = !1;
  }, r.onControlBarMove = function(i) {
    this.player.userActive(!0);
  }, r.dispose = function() {
    this.canvas.removeEventListener("mousedown", this.onMoveStart), this.canvas.removeEventListener("touchstart", this.onMoveStart), this.canvas.removeEventListener("mousemove", this.onMove), this.canvas.removeEventListener("touchmove", this.onMove), this.canvas.removeEventListener("mouseup", this.onMoveEnd), this.canvas.removeEventListener("touchend", this.onMoveEnd), this.player.controlBar.off(
      [
        "mousedown",
        "mousemove",
        "mouseup",
        "touchstart",
        "touchmove",
        "touchend"
      ],
      this.onControlBarMove
    ), this.player.reportUserActivity = this.oldReportUserActivity;
  }, t;
}(X.EventTarget), mL = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i, a, s) {
    var o;
    o = e.call(this) || this;
    var u = X.mergeOptions(
      {
        ambisonicOrder: 1,
        // Safari uses the different AAC decoder than FFMPEG. The channel order is
        // The default 4ch AAC channel layout for FFMPEG AAC channel ordering.
        channelMap: X.browser.IS_SAFARI ? [2, 0, 1, 3] : [0, 1, 2, 3]
      },
      s
    );
    return o.videoElementSource = n.createMediaElementSource(a), o.foaRenderer = i.createFOARenderer(n, u), o.foaRenderer.initialize().then(
      function() {
        n.state === "suspended" && o.trigger({
          type: "audiocontext-suspended"
        }), o.videoElementSource.connect(o.foaRenderer.input), o.foaRenderer.output.connect(n.destination), o.initialized = !0, o.trigger({
          type: "omnitone-ready"
        });
      },
      function(l) {
        X.log.warn(
          "videojs-vr: Omnitone initializes failed with the following error: " + l + ")"
        );
      }
    ), o;
  }
  var r = t.prototype;
  return r.update = function(i) {
    this.initialized && this.foaRenderer.setRotationMatrixFromCamera(i.matrix);
  }, r.dispose = function() {
    this.initialized = !1, this.foaRenderer.setRenderingMode("bypass"), this.foaRenderer = null;
  }, t;
}(X.EventTarget), vL = X.getComponent("Button"), gL = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a;
    return a = e.call(this, n, i) || this, a.handleVrDisplayActivate_ = X.bind(
      ze(a),
      a.handleVrDisplayActivate_
    ), a.handleVrDisplayDeactivate_ = X.bind(
      ze(a),
      a.handleVrDisplayDeactivate_
    ), a.handleVrDisplayPresentChange_ = X.bind(
      ze(a),
      a.handleVrDisplayPresentChange_
    ), a.handleOrientationChange_ = X.bind(
      ze(a),
      a.handleOrientationChange_
    ), j.addEventListener(
      "orientationchange",
      a.handleOrientationChange_
    ), j.addEventListener(
      "vrdisplayactivate",
      a.handleVrDisplayActivate_
    ), j.addEventListener(
      "vrdisplaydeactivate",
      a.handleVrDisplayDeactivate_
    ), j.addEventListener(
      "vrdisplaypresentchange",
      a.handleVrDisplayPresentChange_
    ), X.browser.IS_ANDROID && a.on(n, "fullscreenchange", function() {
      n.isFullscreen() ? a.hide() : a.show();
    }), a;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-button-vr " + e.prototype.buildCSSClass.call(this);
  }, r.handleVrDisplayPresentChange_ = function() {
    !this.player_.vr().vrDisplay.isPresenting && this.active_ && this.handleVrDisplayDeactivate_(), this.player_.vr().vrDisplay.isPresenting && !this.active_ && this.handleVrDisplayActivate_();
  }, r.handleOrientationChange_ = function() {
    this.active_ && X.browser.IS_IOS && this.changeSize_();
  }, r.changeSize_ = function() {
    this.player_.width(j.innerWidth), this.player_.height(j.innerHeight), j.dispatchEvent(new j.Event("resize"));
  }, r.handleVrDisplayActivate_ = function() {
    X.browser.IS_IOS && (this.oldWidth_ = this.player_.currentWidth(), this.oldHeight_ = this.player_.currentHeight(), this.player_.enterFullWindow(), this.changeSize_()), this.active_ = !0;
  }, r.handleVrDisplayDeactivate_ = function() {
    X.browser.IS_IOS && (this.oldWidth_ && this.player_.width(this.oldWidth_), this.oldHeight_ && this.player_.height(this.oldHeight_), this.player_.exitFullWindow()), this.active_ = !1;
  }, r.handleClick = function(i) {
    this.active_ ? j.dispatchEvent(new j.Event("vrdisplaydeactivate")) : (!this.player_.hasStarted() && X.browser.IS_ANDROID && this.player_.play(), j.dispatchEvent(new j.Event("vrdisplayactivate")));
  }, r.dispose = function() {
    e.prototype.dispose.call(this), j.removeEventListener(
      "vrdisplayactivate",
      this.handleVrDisplayActivate_
    ), j.removeEventListener(
      "vrdisplaydeactivate",
      this.handleVrDisplayDeactivate_
    ), j.removeEventListener(
      "vrdisplaypresentchange",
      this.handleVrDisplayPresentChange_
    );
  }, t;
}(vL);
X.registerComponent("CardboardButton", gL);
var yL = X.getComponent("BigPlayButton"), _L = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var r = t.prototype;
  return r.buildCSSClass = function() {
    return "vjs-big-vr-play-button " + e.prototype.buildCSSClass.call(this);
  }, t;
}(yL);
X.registerComponent("BigVrPlayButton", _L);
var bL = {
  debug: !1,
  forceCardboard: !1,
  omnitone: !1,
  omnitoneOptions: {},
  projection: "AUTO"
}, Sg = {
  "web-vr-hls-cors-not-supported": {
    headline: "360 HLS video not supported on this device",
    message: "Your browser/device does not support HLS 360 video. See <a href='http://webvr.info'>http://webvr.info</a> for assistance.",
    type: "360_NOT_SUPPORTED"
  },
  "web-vr-not-supported": {
    headline: "360 not supported on this device",
    message: "Your browser does not support 360. See <a href='http://webvr.info'>http://webvr.info</a> for assistance.",
    type: "360_NOT_SUPPORTED"
  },
  "web-vr-out-of-date": {
    headline: "360 is out of date",
    message: "Your browser supports 360 but not the latest version. See <a href='http://webvr.info'>http://webvr.info</a> for more info.",
    type: "360_OUT_OF_DATE"
  }
}, xL = X.getPlugin("plugin"), xb = X.getComponent("Component"), Uh = /* @__PURE__ */ function(e) {
  Se(t, e);
  function t(n, i) {
    var a, s = X.mergeOptions(bL, i);
    return a = e.call(this, n, s) || this, a.options_ = s, a.player_ = n, a.bigPlayButtonIndex_ = n.children().indexOf(n.getChild("BigPlayButton")) || 0, a.videojsErrorsSupport_ = !!X.errors, a.videojsErrorsSupport_ && n.errors({
      errors: Sg
    }), X.browser.IE_VERSION || !dL ? (a.player_.on("loadstart", function() {
      a.triggerError_({
        code: "web-vr-not-supported",
        dismiss: !1
      });
    }), ze(a)) : (a.polyfill_ = new Zh({
      // do not show rotate instructions
      ROTATE_INSTRUCTIONS_DISABLED: !0
    }), a.polyfill_ = new Zh(), a.handleVrDisplayActivate_ = X.bind(
      ze(a),
      a.handleVrDisplayActivate_
    ), a.handleVrDisplayDeactivate_ = X.bind(
      ze(a),
      a.handleVrDisplayDeactivate_
    ), a.handleResize_ = X.bind(
      ze(a),
      a.handleResize_
    ), a.animate_ = X.bind(
      ze(a),
      a.animate_
    ), a.setProjection(a.options_.projection), a.on(
      n,
      "adstart",
      function() {
        return n.setTimeout(function() {
          if (!n.ads || !n.ads.videoElementRecycled()) {
            a.log(
              "video element not recycled for this ad, no need to reset"
            );
            return;
          }
          a.log("video element recycled for this ad, reseting"), a.reset(), a.one(n, "playing", a.init);
        });
      },
      1
    ), a.on(n, "loadedmetadata", a.init), a);
  }
  var r = t.prototype;
  return r.changeProjection_ = function(i) {
    var a = this;
    i = Tf(i), i || (i = "NONE");
    var s = {
      x: 0,
      y: 0,
      z: 0
    };
    if (this.scene && this.scene.remove(this.movieScreen), i === "AUTO") {
      if (this.player_.mediainfo && this.player_.mediainfo.projection && this.player_.mediainfo.projection !== "AUTO") {
        var o = Tf(
          this.player_.mediainfo.projection
        );
        return this.changeProjection_(o);
      }
      return this.changeProjection_("NONE");
    } else if (i === "360")
      this.movieGeometry = new ma(256, 32, 32), this.movieMaterial = new Er({
        map: this.videoTexture,
        overdraw: !0,
        side: Tr
      }), this.movieScreen = new dr(this.movieGeometry, this.movieMaterial), this.movieScreen.position.set(s.x, s.y, s.z), this.movieScreen.scale.x = -1, this.movieScreen.quaternion.setFromAxisAngle(
        {
          x: 0,
          y: 1,
          z: 0
        },
        -Math.PI / 2
      ), this.scene.add(this.movieScreen);
    else if (i === "360_LR" || i === "360_TB") {
      for (var u = new Bn(256, 32, 32), l = u.faceVertexUvs[0], c = 0; c < l.length; c++)
        for (var h = 0; h < 3; h++)
          i === "360_LR" ? l[c][h].x *= 0.5 : (l[c][h].y *= 0.5, l[c][h].y += 0.5);
      this.movieGeometry = new Ge().fromGeometry(u), this.movieMaterial = new Er({
        map: this.videoTexture,
        overdraw: !0,
        side: Tr
      }), this.movieScreen = new dr(this.movieGeometry, this.movieMaterial), this.movieScreen.scale.x = -1, this.movieScreen.quaternion.setFromAxisAngle(
        {
          x: 0,
          y: 1,
          z: 0
        },
        -Math.PI / 2
      ), this.movieScreen.layers.set(1), this.scene.add(this.movieScreen), u = new Bn(256, 32, 32), l = u.faceVertexUvs[0];
      for (var f = 0; f < l.length; f++)
        for (var d = 0; d < 3; d++)
          i === "360_LR" ? (l[f][d].x *= 0.5, l[f][d].x += 0.5) : l[f][d].y *= 0.5;
      this.movieGeometry = new Ge().fromGeometry(u), this.movieMaterial = new Er({
        map: this.videoTexture,
        overdraw: !0,
        side: Tr
      }), this.movieScreen = new dr(this.movieGeometry, this.movieMaterial), this.movieScreen.scale.x = -1, this.movieScreen.quaternion.setFromAxisAngle(
        {
          x: 0,
          y: 1,
          z: 0
        },
        -Math.PI / 2
      ), this.movieScreen.layers.set(2), this.scene.add(this.movieScreen);
    } else if (i === "360_CUBE") {
      this.movieGeometry = new ca(256, 256, 256), this.movieMaterial = new Er({
        map: this.videoTexture,
        overdraw: !0,
        side: Tr
      });
      var p = [
        new ue(0, 0.5),
        new ue(0.333, 0.5),
        new ue(0.333, 1),
        new ue(0, 1)
      ], _ = [
        new ue(0.333, 0.5),
        new ue(0.666, 0.5),
        new ue(0.666, 1),
        new ue(0.333, 1)
      ], v = [
        new ue(0.666, 0.5),
        new ue(1, 0.5),
        new ue(1, 1),
        new ue(0.666, 1)
      ], x = [
        new ue(0, 0),
        new ue(0.333, 0),
        new ue(0.333, 0.5),
        new ue(0, 0.5)
      ], E = [
        new ue(0.333, 0),
        new ue(0.666, 0),
        new ue(0.666, 0.5),
        new ue(0.333, 0.5)
      ], M = [
        new ue(0.666, 0),
        new ue(1, 0),
        new ue(1, 0.5),
        new ue(0.666, 0.5)
      ];
      this.movieGeometry.faceVertexUvs[0] = [], this.movieGeometry.faceVertexUvs[0][0] = [_[2], _[1], _[3]], this.movieGeometry.faceVertexUvs[0][1] = [_[1], _[0], _[3]], this.movieGeometry.faceVertexUvs[0][2] = [p[2], p[1], p[3]], this.movieGeometry.faceVertexUvs[0][3] = [p[1], p[0], p[3]], this.movieGeometry.faceVertexUvs[0][4] = [v[2], v[1], v[3]], this.movieGeometry.faceVertexUvs[0][5] = [v[1], v[0], v[3]], this.movieGeometry.faceVertexUvs[0][6] = [
        x[2],
        x[1],
        x[3]
      ], this.movieGeometry.faceVertexUvs[0][7] = [
        x[1],
        x[0],
        x[3]
      ], this.movieGeometry.faceVertexUvs[0][8] = [E[2], E[1], E[3]], this.movieGeometry.faceVertexUvs[0][9] = [E[1], E[0], E[3]], this.movieGeometry.faceVertexUvs[0][10] = [M[2], M[1], M[3]], this.movieGeometry.faceVertexUvs[0][11] = [M[1], M[0], M[3]], this.movieScreen = new dr(this.movieGeometry, this.movieMaterial), this.movieScreen.position.set(s.x, s.y, s.z), this.movieScreen.rotation.y = -Math.PI, this.scene.add(this.movieScreen);
    } else if (i === "180") {
      var C = new Bn(256, 32, 32, Math.PI, Math.PI);
      C.scale(-1, 1, 1);
      for (var R = C.faceVertexUvs[0], B = 0; B < R.length; B++)
        for (var k = 0; k < 3; k++)
          R[B][k].x *= 0.5;
      this.movieGeometry = new Ge().fromGeometry(C), this.movieMaterial = new Er({
        map: this.videoTexture,
        overdraw: !0
      }), this.movieScreen = new dr(this.movieGeometry, this.movieMaterial), this.movieScreen.layers.set(1), this.scene.add(this.movieScreen), C = new Bn(256, 32, 32, Math.PI, Math.PI), C.scale(-1, 1, 1), R = C.faceVertexUvs[0];
      for (var F = 0; F < R.length; F++)
        for (var I = 0; I < 3; I++)
          R[F][I].x *= 0.5, R[F][I].x += 0.5;
      this.movieGeometry = new Ge().fromGeometry(C), this.movieMaterial = new Er({
        map: this.videoTexture,
        overdraw: !0
      }), this.movieScreen = new dr(this.movieGeometry, this.movieMaterial), this.movieScreen.layers.set(2), this.scene.add(this.movieScreen);
    } else if (i === "EAC" || i === "EAC_LR") {
      var H = function(oe, de) {
        var he = 2;
        a.movieGeometry = new ca(256, 256, 256), a.movieMaterial = new Mi({
          fragmentShader: `
varying vec2 vUv;
uniform sampler2D mapped;
uniform vec2 faceWH;
uniform vec2 vidWH;
uniform float contCorrect;

const float PI = 3.1415926535897932384626433832795;

void main() {
  vec2 corner = vUv - mod(vUv, faceWH) + vec2(0, contCorrect / vidWH.y);

  vec2 faceWHadj = faceWH - vec2(0, contCorrect * 2. / vidWH.y);

  vec2 p = (vUv - corner) / faceWHadj - .5;
  vec2 q = 2. / PI * atan(2. * p) + .5;

  vec2 eUv = corner + q * faceWHadj;

  gl_FragColor = texture2D(mapped, eUv);
}`,
          overdraw: !0,
          side: Tr,
          uniforms: {
            contCorrect: {
              value: he
            },
            faceWH: {
              value: new ue(0.3333333333333333, 0.5).applyMatrix3(de)
            },
            mapMatrix: {
              value: oe
            },
            mapped: {
              value: a.videoTexture
            },
            vidWH: {
              value: new ue(
                a.videoTexture.image.videoWidth,
                a.videoTexture.image.videoHeight
              ).applyMatrix3(de)
            }
          },
          vertexShader: `
varying vec2 vUv;
uniform mat3 mapMatrix;

void main() {
  vUv = (mapMatrix * vec3(uv, 1.)).xy;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
}`
        });
        for (var fe = [
          new ue(0, 1 / 2),
          new ue(1 / 3, 1 / 2),
          new ue(1 / 3, 1),
          new ue(0, 1)
        ], V = [
          new ue(1 / 3, 1 / 2),
          new ue(2 / 3, 1 / 2),
          new ue(2 / 3, 1),
          new ue(1 / 3, 1)
        ], G = [
          new ue(2 / 3, 1 / 2),
          new ue(1, 1 / 2),
          new ue(1, 1),
          new ue(2 / 3, 1)
        ], se = [
          new ue(1 / 3, 0),
          new ue(1 / 3, 1 / 2),
          new ue(0, 1 / 2),
          new ue(0, 0)
        ], re = [
          new ue(1 / 3, 1 / 2),
          new ue(1 / 3, 0),
          new ue(2 / 3, 0),
          new ue(2 / 3, 1 / 2)
        ], Ce = [
          new ue(1, 0),
          new ue(1, 1 / 2),
          new ue(2 / 3, 1 / 2),
          new ue(2 / 3, 0)
        ], K = 0, xe = [fe, V, G, se, re, Ce]; K < xe.length; K++) {
          for (var pe = xe[K], Re = a.videoTexture.image.videoHeight, _e = 1, Le = 0, Ee = pe, He = Array.isArray(Ee), dt = 0, Ee = He ? Ee : Ee[Symbol.iterator](); ; ) {
            var ct;
            if (He) {
              if (dt >= Ee.length) break;
              ct = Ee[dt++];
            } else {
              if (dt = Ee.next(), dt.done) break;
              ct = dt.value;
            }
            var Bt = ct;
            Bt.y < _e && (_e = Bt.y), Bt.y > Le && (Le = Bt.y);
          }
          for (var yt = pe, Mt = Array.isArray(yt), Ht = 0, yt = Mt ? yt : yt[Symbol.iterator](); ; ) {
            var Gt;
            if (Mt) {
              if (Ht >= yt.length) break;
              Gt = yt[Ht++];
            } else {
              if (Ht = yt.next(), Ht.done) break;
              Gt = Ht.value;
            }
            var Et = Gt;
            Math.abs(Et.y - _e) < Number.EPSILON && (Et.y += he / Re), Math.abs(Et.y - Le) < Number.EPSILON && (Et.y -= he / Re), Et.x = Et.x / Re * (Re - he * 2) + he / Re;
          }
        }
        return a.movieGeometry.faceVertexUvs[0] = [], a.movieGeometry.faceVertexUvs[0][0] = [
          fe[2],
          fe[1],
          fe[3]
        ], a.movieGeometry.faceVertexUvs[0][1] = [
          fe[1],
          fe[0],
          fe[3]
        ], a.movieGeometry.faceVertexUvs[0][2] = [
          G[2],
          G[1],
          G[3]
        ], a.movieGeometry.faceVertexUvs[0][3] = [
          G[1],
          G[0],
          G[3]
        ], a.movieGeometry.faceVertexUvs[0][4] = [Ce[2], Ce[1], Ce[3]], a.movieGeometry.faceVertexUvs[0][5] = [Ce[1], Ce[0], Ce[3]], a.movieGeometry.faceVertexUvs[0][6] = [
          se[2],
          se[1],
          se[3]
        ], a.movieGeometry.faceVertexUvs[0][7] = [
          se[1],
          se[0],
          se[3]
        ], a.movieGeometry.faceVertexUvs[0][8] = [
          V[2],
          V[1],
          V[3]
        ], a.movieGeometry.faceVertexUvs[0][9] = [
          V[1],
          V[0],
          V[3]
        ], a.movieGeometry.faceVertexUvs[0][10] = [
          re[2],
          re[1],
          re[3]
        ], a.movieGeometry.faceVertexUvs[0][11] = [
          re[1],
          re[0],
          re[3]
        ], a.movieScreen = new dr(
          a.movieGeometry,
          a.movieMaterial
        ), a.movieScreen.position.set(s.x, s.y, s.z), a.movieScreen.rotation.y = -Math.PI, a.movieScreen;
      };
      if (i === "EAC")
        this.scene.add(H(new wr(), new wr()));
      else {
        var Q = new wr().set(0, 0.5, 0, 1, 0, 0, 0, 0, 1);
        H(
          new wr().set(0, -0.5, 0.5, 1, 0, 0, 0, 0, 1),
          Q
        ), this.movieScreen.layers.set(1), this.scene.add(this.movieScreen), H(
          new wr().set(0, -0.5, 1, 1, 0, 0, 0, 0, 1),
          Q
        ), this.movieScreen.layers.set(2), this.scene.add(this.movieScreen);
      }
    }
    this.currentProjection_ = i;
  }, r.triggerError_ = function(i) {
    if (this.videojsErrorsSupport_)
      this.player_.error(i);
    else {
      var a = Te.createElement("div");
      a.innerHTML = Sg[i.code].message;
      var s = a.textContent || a.innerText || "";
      this.player_.error({
        code: i.code,
        message: s
      });
    }
  }, r.log = function() {
    if (this.options_.debug) {
      for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)
        a[s] = arguments[s];
      a.forEach(function(o) {
        X.log("VR: ", o);
      });
    }
  }, r.handleVrDisplayActivate_ = function() {
    var i = this;
    this.vrDisplay && this.vrDisplay.requestPresent([
      {
        source: this.renderedCanvas
      }
    ]).then(function() {
      if (!(!i.vrDisplay.cardboardUI_ || !X.browser.IS_IOS)) {
        var a = [], s = function(l) {
          for (var c = 0; c < l.touches.length; c++)
            a.push(l.touches[c]);
        }, o = function(l) {
          a.length && (a.forEach(function(c) {
            var h = new j.MouseEvent("click", {
              clientX: c.clientX,
              clientY: c.clientY,
              screenX: c.screenX,
              screenY: c.screenY
            });
            i.renderedCanvas.dispatchEvent(h);
          }), a = []);
        };
        i.renderedCanvas.addEventListener(
          "touchstart",
          s
        ), i.renderedCanvas.addEventListener(
          "touchend",
          o
        ), i.iosRevertTouchToClick_ = function() {
          i.renderedCanvas.removeEventListener(
            "touchstart",
            s
          ), i.renderedCanvas.removeEventListener(
            "touchend",
            o
          ), i.iosRevertTouchToClick_ = null;
        };
      }
    });
  }, r.handleVrDisplayDeactivate_ = function() {
    !this.vrDisplay || !this.vrDisplay.isPresenting || (this.iosRevertTouchToClick_ && this.iosRevertTouchToClick_(), this.vrDisplay.exitPresent());
  }, r.requestAnimationFrame = function(i) {
    return this.vrDisplay ? this.vrDisplay.requestAnimationFrame(i) : this.player_.requestAnimationFrame(i);
  }, r.cancelAnimationFrame = function(i) {
    return this.vrDisplay ? this.vrDisplay.cancelAnimationFrame(i) : this.player_.cancelAnimationFrame(i);
  }, r.togglePlay_ = function() {
    this.player_.paused() ? this.player_.play() : this.player_.pause();
  }, r.animate_ = function() {
    if (this.initialized_) {
      if (this.getVideoEl_().readyState === this.getVideoEl_().HAVE_ENOUGH_DATA && this.videoTexture && (this.videoTexture.needsUpdate = !0), this.controls3d.update(), this.omniController && this.omniController.update(this.camera), this.effect.render(this.scene, this.camera), j.navigator.getGamepads)
        for (var i = j.navigator.getGamepads(), a = 0; a < i.length; ++a) {
          var s = i[a];
          if (!(!s || !s.timestamp || s.timestamp === this.prevTimestamps_[a])) {
            for (var o = 0; o < s.buttons.length; ++o)
              if (s.buttons[o].pressed) {
                this.togglePlay_(), this.prevTimestamps_[a] = s.timestamp;
                break;
              }
          }
        }
      this.camera.getWorldDirection(this.cameraVector), this.animationFrameId_ = this.requestAnimationFrame(this.animate_);
    }
  }, r.handleResize_ = function() {
    var i = this.player_.currentWidth(), a = this.player_.currentHeight();
    this.effect.setSize(i, a, !1), this.camera.aspect = i / a, this.camera.updateProjectionMatrix();
  }, r.setProjection = function(i) {
    if (!Tf(i)) {
      X.log.error(
        "videojs-vr: please pass a valid projection " + ac.join(", ")
      );
      return;
    }
    this.currentProjection_ = i, this.defaultProjection_ = i;
  }, r.init = function() {
    var i = this;
    if (this.reset(), this.camera = new or(
      75,
      this.player_.currentWidth() / this.player_.currentHeight(),
      1,
      1e3
    ), this.cameraVector = new z(), (this.currentProjection_ === "360_LR" || this.currentProjection_ === "360_TB" || this.currentProjection_ === "180" || this.currentProjection_ === "EAC_LR") && this.camera.layers.enable(1), this.scene = new Cu(), this.videoTexture = new pc(this.getVideoEl_()), this.videoTexture.generateMipmaps = !1, this.videoTexture.minFilter = Vr, this.videoTexture.magFilter = Vr, this.videoTexture.format = Wa, this.changeProjection_(this.currentProjection_), this.currentProjection_ === "NONE") {
      this.log("Projection is NONE, dont init"), this.reset();
      return;
    }
    this.player_.removeChild("BigPlayButton"), this.player_.addChild("BigVrPlayButton", {}, this.bigPlayButtonIndex_), this.player_.bigPlayButton = this.player_.getChild("BigVrPlayButton"), (this.options_.forceCardboard || X.browser.IS_ANDROID || X.browser.IS_IOS) && this.addCardboardButton_(), X.browser.IS_IOS && this.player_.controlBar && this.player_.controlBar.fullscreenToggle && this.player_.controlBar.fullscreenToggle.hide(), this.camera.position.set(0, 0, 0), this.renderer = new mh({
      alpha: !1,
      antialias: !0,
      clearColor: 16777215,
      devicePixelRatio: j.devicePixelRatio
    });
    var a = this.renderer.getContext("webgl"), s = a.texImage2D;
    a.texImage2D = function() {
      try {
        for (var l = arguments.length, c = new Array(l), h = 0; h < l; h++)
          c[h] = arguments[h];
        return s.apply(a, c);
      } catch (f) {
        throw i.reset(), i.player_.pause(), i.triggerError_({
          code: "web-vr-hls-cors-not-supported",
          dismiss: !1
        }), new Error(f);
      }
    }, this.renderer.setSize(
      this.player_.currentWidth(),
      this.player_.currentHeight(),
      !1
    ), this.effect = new oL(this.renderer), this.effect.setSize(
      this.player_.currentWidth(),
      this.player_.currentHeight(),
      !1
    ), this.vrDisplay = null, this.prevTimestamps_ = [], this.renderedCanvas = this.renderer.domElement, this.renderedCanvas.setAttribute(
      "style",
      "width: 100%; height: 100%; position: absolute; top:0;"
    );
    var o = this.getVideoEl_().style;
    if (this.player_.el().insertBefore(this.renderedCanvas, this.player_.el().firstChild), o.zIndex = "-1", o.opacity = "0", j.navigator.getVRDisplays ? (this.log("is supported, getting vr displays"), j.navigator.getVRDisplays().then(function(l) {
      if (l.length > 0 && (i.log("Displays found", l), i.vrDisplay = l[0], i.vrDisplay.isPolyfilled || (i.log("Real HMD found using VRControls", i.vrDisplay), i.addCardboardButton_(), i.controls3d = new uL(i.camera))), !i.controls3d) {
        i.log("no HMD found Using Orbit & Orientation Controls");
        var c = {
          camera: i.camera,
          canvas: i.renderedCanvas,
          // check if its a half sphere view projection
          halfView: i.currentProjection_ === "180",
          orientation: X.browser.IS_IOS || X.browser.IS_ANDROID || !1
        };
        i.options_.motionControls === !1 && (c.orientation = !1), i.controls3d = new fL(c), i.canvasPlayerControls = new pL(
          i.player_,
          i.renderedCanvas
        );
      }
      i.animationFrameId_ = i.requestAnimationFrame(
        i.animate_
      );
    })) : j.navigator.getVRDevices ? this.triggerError_({
      code: "web-vr-out-of-date",
      dismiss: !1
    }) : this.triggerError_({
      code: "web-vr-not-supported",
      dismiss: !1
    }), this.options_.omnitone) {
      var u = yh.getContext();
      this.omniController = new mL(
        u,
        this.options_.omnitone,
        this.getVideoEl_(),
        this.options_.omnitoneOptions
      ), this.omniController.one("audiocontext-suspended", function() {
        i.player.pause(), i.player.one("playing", function() {
          u.resume();
        });
      });
    }
    this.on(this.player_, "fullscreenchange", this.handleResize_), j.addEventListener(
      "vrdisplaypresentchange",
      this.handleResize_,
      !0
    ), j.addEventListener("resize", this.handleResize_, !0), j.addEventListener(
      "vrdisplayactivate",
      this.handleVrDisplayActivate_,
      !0
    ), j.addEventListener(
      "vrdisplaydeactivate",
      this.handleVrDisplayDeactivate_,
      !0
    ), this.initialized_ = !0, this.trigger("initialized");
  }, r.addCardboardButton_ = function() {
    this.player_.controlBar.getChild("CardboardButton") || this.player_.controlBar.addChild("CardboardButton", {});
  }, r.getVideoEl_ = function() {
    return this.player_.el().getElementsByTagName("video")[0];
  }, r.reset = function() {
    if (this.initialized_) {
      this.omniController && (this.omniController.off("audiocontext-suspended"), this.omniController.dispose(), this.omniController = void 0), this.controls3d && (this.controls3d.dispose(), this.controls3d = null), this.canvasPlayerControls && (this.canvasPlayerControls.dispose(), this.canvasPlayerControls = null), this.effect && (this.effect.dispose(), this.effect = null), j.removeEventListener("resize", this.handleResize_, !0), j.removeEventListener(
        "vrdisplaypresentchange",
        this.handleResize_,
        !0
      ), j.removeEventListener(
        "vrdisplayactivate",
        this.handleVrDisplayActivate_,
        !0
      ), j.removeEventListener(
        "vrdisplaydeactivate",
        this.handleVrDisplayDeactivate_,
        !0
      ), this.player_.getChild("BigPlayButton") || this.player_.addChild("BigPlayButton", {}, this.bigPlayButtonIndex_), this.player_.getChild("BigVrPlayButton") && this.player_.removeChild("BigVrPlayButton"), this.player_.getChild("CardboardButton") && this.player_.controlBar.removeChild("CardboardButton"), X.browser.IS_IOS && this.player_.controlBar && this.player_.controlBar.fullscreenToggle && this.player_.controlBar.fullscreenToggle.show();
      var i = this.getVideoEl_().style;
      i.zIndex = "", i.opacity = "", this.currentProjection_ = this.defaultProjection_, this.iosRevertTouchToClick_ && this.iosRevertTouchToClick_(), this.renderedCanvas && this.renderedCanvas.parentNode.removeChild(this.renderedCanvas), this.animationFrameId_ && this.cancelAnimationFrame(this.animationFrameId_), this.initialized_ = !1;
    }
  }, r.dispose = function() {
    e.prototype.dispose.call(this), this.reset();
  }, r.polyfillVersion = function() {
    return Zh.version;
  }, t;
}(xL);
Uh.prototype.setTimeout = xb.prototype.setTimeout;
Uh.prototype.clearTimeout = xb.prototype.clearTimeout;
Uh.VERSION = cL;
X.registerPlugin("vr", Uh);
/* ! @name videojs-contrib-quality-levels @version 4.0.0 @license Apache-2.0 */
class AL {
  /**
   * Creates a QualityLevel
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   */
  constructor(t) {
    let r = this;
    return r.id = t.id, r.label = r.id, r.width = t.width, r.height = t.height, r.bitrate = t.bandwidth, r.frameRate = t.frameRate, r.enabled_ = t.enabled, Object.defineProperty(r, "enabled", {
      /**
       * Get whether the QualityLevel is enabled.
       *
       * @return {boolean} True if the QualityLevel is enabled.
       */
      get() {
        return r.enabled_();
      },
      /**
       * Enable or disable the QualityLevel.
       *
       * @param {boolean} enable true to enable QualityLevel, false to disable.
       */
      set(n) {
        r.enabled_(n);
      }
    }), r;
  }
}
class rh extends X.EventTarget {
  /**
   * Creates a QualityLevelList.
   */
  constructor() {
    super();
    let t = this;
    return t.levels_ = [], t.selectedIndex_ = -1, Object.defineProperty(t, "selectedIndex", {
      get() {
        return t.selectedIndex_;
      }
    }), Object.defineProperty(t, "length", {
      get() {
        return t.levels_.length;
      }
    }), t[Symbol.iterator] = () => t.levels_.values(), t;
  }
  /**
   * Adds a quality level to the list.
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   * @return {QualityLevel} the QualityLevel added to the list
   * @method addQualityLevel
   */
  addQualityLevel(t) {
    let r = this.getQualityLevelById(t.id);
    if (r)
      return r;
    const n = this.levels_.length;
    return r = new AL(t), "" + n in this || Object.defineProperty(this, n, {
      get() {
        return this.levels_[n];
      }
    }), this.levels_.push(r), this.trigger({
      qualityLevel: r,
      type: "addqualitylevel"
    }), r;
  }
  /**
   * Removes a quality level from the list.
   *
   * @param {QualityLevel} qualityLevel The QualityLevel to remove from the list.
   * @return {QualityLevel|null} the QualityLevel removed or null if nothing removed
   * @method removeQualityLevel
   */
  removeQualityLevel(t) {
    let r = null;
    for (let n = 0, i = this.length; n < i; n++)
      if (this[n] === t) {
        r = this.levels_.splice(n, 1)[0], this.selectedIndex_ === n ? this.selectedIndex_ = -1 : this.selectedIndex_ > n && this.selectedIndex_--;
        break;
      }
    return r && this.trigger({
      qualityLevel: t,
      type: "removequalitylevel"
    }), r;
  }
  /**
   * Searches for a QualityLevel with the given id.
   *
   * @param {string} id The id of the QualityLevel to find.
   * @return {QualityLevel|null} The QualityLevel with id, or null if not found.
   * @method getQualityLevelById
   */
  getQualityLevelById(t) {
    for (let r = 0, n = this.length; r < n; r++) {
      const i = this[r];
      if (i.id === t)
        return i;
    }
    return null;
  }
  /**
   * Resets the list of QualityLevels to empty
   *
   * @method dispose
   */
  dispose() {
    this.selectedIndex_ = -1, this.levels_.length = 0;
  }
}
rh.prototype.allowedEvents_ = {
  addqualitylevel: "addqualitylevel",
  change: "change",
  removequalitylevel: "removequalitylevel"
};
for (const e in rh.prototype.allowedEvents_)
  rh.prototype["on" + e] = null;
var Ab = "4.0.0";
const TL = function(e) {
  const t = e.qualityLevels, r = new rh(), n = function() {
    r.dispose(), e.qualityLevels = t, e.off("dispose", n);
  };
  return e.on("dispose", n), e.qualityLevels = () => r, e.qualityLevels.VERSION = Ab, r;
}, Tb = function(e) {
  return TL(this, X.mergeOptions({}, e));
};
X.registerPlugin("qualityLevels", Tb);
Tb.VERSION = Ab;
var EL = Object.defineProperty, wL = Object.getOwnPropertyDescriptor, Ut = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? wL(t, r) : t, a = e.length - 1, s; a >= 0; a--)
    (s = e[a]) && (i = (n ? s(t, r, i) : s(i)) || i);
  return n && i && EL(t, r, i), i;
};
const SL = () => {
  const e = window.navigator && window.navigator.userAgent || "";
  return /Firefox/i.test(e);
};
let Pt = class extends ux {
  constructor() {
    super(...arguments), this.isLoaded = !1, this.isPlaying = !1, this.isError = !1, this.player = null, this.isFullscreen = !1, this.videoWidth = 0, this.videoHeight = 0, this._needScale = !1, this.src = "", this.type = "", this.poster = "", this.width = "", this.height = "", this.skeleton = !1, this.fallback = !1, this.showControls = !1, this.autoPlayTimeout = null, this._onPause = () => {
      this.isPlaying = !1, this.emit("cx-pause", {
        detail: this
      });
    }, this._onPlay = () => {
      this.isPlaying = !0, this.emit("cx-play", {
        detail: this
      });
    }, this._onTimeUpdate = () => {
      this.emit("cx-time-update", {
        detail: this
      });
    }, this._onEnded = () => {
      this.isPlaying = !1, this.emit("cx-ended", {
        detail: this
      });
    }, this._onSeeked = () => {
      this.emit("cx-seeked", {
        detail: this
      });
    }, this._onLoadedMetadata = () => {
      var e, t;
      this.isLoaded = !0, this.videoWidth = ((e = this.player) == null ? void 0 : e.videoWidth()) || 0, this.videoHeight = ((t = this.player) == null ? void 0 : t.videoHeight()) || 0, this.emit("cx-loaded-metadata", {
        detail: this
      });
    }, this._onError = () => {
      this.isLoaded = !0, this.emit("cx-error");
    }, this.onPlay = this._onPlay.bind(this), this.onPause = this._onPause.bind(this), this.onTimeUpdate = this._onTimeUpdate.bind(this), this.onEnded = this._onEnded.bind(this), this.onSeeked = this._onSeeked.bind(this), this.onLoadedMetadata = this._onLoadedMetadata.bind(this), this.onError = this._onError.bind(this);
  }
  get currentTime() {
    var e;
    return ((e = this.player) == null ? void 0 : e.currentTime()) || 0;
  }
  get duration() {
    var e;
    return ((e = this.player) == null ? void 0 : e.duration()) || 0;
  }
  addVideoEventListeners() {
    var e;
    (e = this.player) != null && e.el() && (this.player.on("play", this.onPlay), this.player.on("pause", this.onPause), this.player.on("timeupdate", this.onTimeUpdate), this.player.on("ended", this.onEnded), this.player.on("seeked", this.onSeeked), this.player.on("loadedmetadata", this.onLoadedMetadata), this.player.on("error", this.onError));
  }
  removeVideoEventListeners() {
    var e;
    (e = this.player) != null && e.el() && (this.player.off("play", this.onPlay), this.player.off("pause", this.onPause), this.player.off("timeupdate", this.onTimeUpdate), this.player.off("ended", this.onEnded), this.player.off("seeked", this.onSeeked), this.player.off("loadedmetadata", this.onLoadedMetadata), this.player.off("error", this.onError));
  }
  disconnectedCallback() {
    var t, r;
    if (super.disconnectedCallback(), this.removeVideoEventListeners(), !((t = this.player) != null && t.el()))
      return;
    const e = this.player;
    e != null && e.el() && !e.isDisposed() && (this.player = null), (r = e.isInPictureInPicture) != null && r.call(e) ? e.one("leavepictureinpicture", () => {
      e.dispose();
    }) : e.dispose();
  }
  attachSeekbar() {
    const e = this.videoJsContainer.getElementsByClassName("vjs-control-bar");
    e.length && e[0].before(this.seekbar);
  }
  setupVideoJsPlayer() {
    const e = {
      poster: this.poster,
      src: this.src,
      type: this.type
    }, t = {
      controlBar: {
        remainingTimeDisplay: !1,
        subsCapsButton: !1,
        volumePanel: { inline: !1 }
      },
      controls: this.showControls,
      fill: !0,
      inactivityTimeout: mx,
      loop: this.loop,
      poster: e.poster,
      responsive: !0,
      retryOnError: !0,
      sources: [e]
    };
    if (this.player)
      this.player.src(this.src), this.player.poster(this.poster), this.player.loop(this.loop), this.player.muted(this.muted), this.player.controls(this.showControls);
    else {
      const r = this.ownerDocument.createElement("video-js");
      r.classList.add("vjs-big-play-centered"), r.classList.add("vjs-main-video-player"), this.videoJsContainer.appendChild(r), this.player = X(r, t, () => {
        this.player.muted(this.muted), this.autoplay && (this.player.muted(!0), SL() ? (this.autoPlayTimeout && clearTimeout(this.autoPlayTimeout), this.autoPlayTimeout = window.setTimeout(() => {
          this.player.play();
        }, vx)) : this.player.play()), this.addVideoEventListeners(), this.attachSeekbar();
      });
    }
  }
  async handleSetupPlayer() {
    await this.videoJsContainerAsync, this.setupVideoJsPlayer();
  }
  handleSrcChange() {
    this.isLoaded = !1, this.src || (this.isLoaded = !0);
  }
  handleSizeChange() {
    let e = `${this.videoWidth}px`, t = `${this.videoHeight}px`;
    this.isLoaded ? this.width && this.height ? (e = this.width, t = this.height, this._needScale = !1) : (this._needScale = !0, !this.width && !this.height && (e = "100%", this.width = e)) : (e = this.width || "100%", t = this.height || "100%"), this.style.setProperty("--width", e), this.style.setProperty("--height", t);
  }
  handleResize() {
    if (!this._needScale)
      return;
    const e = this.parentElement;
    if (!e)
      return;
    const t = e.clientWidth, r = e.clientHeight;
    let n = t, i = r;
    const a = this.width.endsWith("%"), s = this.height.endsWith("%");
    if (this.width && !this.height) {
      if (a) {
        const o = parseFloat(this.width) / 100;
        n = t * o;
      } else
        n = parseFloat(this.width);
      i = this.videoWidth ? n * (this.videoHeight / this.videoWidth) : r;
    }
    if (!this.width && this.height) {
      if (s) {
        const o = parseFloat(this.height) / 100;
        i = r * o;
      } else
        i = parseFloat(this.height);
      n = this.videoHeight ? i * (this.videoWidth / this.videoHeight) : t;
    }
    this.style.setProperty(
      "--width",
      a ? this.width : `${n}px`
    ), this.style.setProperty(
      "--height",
      s ? this.height : `${i}px`
    );
  }
  play() {
    this.player && this.player.play();
  }
  pause() {
    this.player && this.player.pause();
  }
  seek(e) {
    this.player && this.player.currentTime(e);
  }
  render() {
    return Rm`<cx-resize-observer @cx-resize=${this.handleResize}>
      <div class=${Im({ container: !0 })}>
        <div part="video-js-container" id="video-js-container">
          <div part="seekbar" class="seekbar-container">
            <div
              part="progress-bar-container"
              class="progress-bar-container"
            ></div>
          </div>
        </div>
      </div>
      ${fx(
      this.skeleton && !this.isLoaded,
      () => Rm`
          <slot name="skeleton" part="skeleton">
            <div
              class=${Im({
        skeleton: !0
      })}
            >
              <cx-skeleton effect="sheen"></cx-skeleton>
            </div>
          </slot>
        `
    )}
    </cx-resize-observer>`;
  }
};
Pt.styles = [lx, gx];
Pt.dependencies = {
  "cx-resize-observer": dx,
  "cx-skeleton": px
};
Ut([
  ih("#video-js-container")
], Pt.prototype, "videoJsContainer", 2);
Ut([
  ih(".seekbar-container")
], Pt.prototype, "seekbar", 2);
Ut([
  hx("#video-js-container")
], Pt.prototype, "videoJsContainerAsync", 2);
Ut([
  ih("video")
], Pt.prototype, "videoElement", 2);
Ut([
  ih(".progress-bar-container")
], Pt.prototype, "progressBarContainer", 2);
Ut([
  Kn()
], Pt.prototype, "isLoaded", 2);
Ut([
  Kn()
], Pt.prototype, "isPlaying", 2);
Ut([
  Kn()
], Pt.prototype, "isError", 2);
Ut([
  Kn()
], Pt.prototype, "player", 2);
Ut([
  Kn()
], Pt.prototype, "isFullscreen", 2);
Ut([
  Kn()
], Pt.prototype, "videoWidth", 2);
Ut([
  Kn()
], Pt.prototype, "videoHeight", 2);
Ut([
  Kn()
], Pt.prototype, "_needScale", 2);
Ut([
  en({ reflect: !0, type: String })
], Pt.prototype, "src", 2);
Ut([
  en({ reflect: !0, type: String })
], Pt.prototype, "type", 2);
Ut([
  en({ reflect: !0, type: String })
], Pt.prototype, "poster", 2);
Ut([
  en({ reflect: !0, type: String })
], Pt.prototype, "width", 2);
Ut([
  en({ reflect: !0, type: String })
], Pt.prototype, "height", 2);
Ut([
  en({ reflect: !0, type: Boolean })
], Pt.prototype, "autoplay", 2);
Ut([
  en({ reflect: !0, type: Boolean })
], Pt.prototype, "loop", 2);
Ut([
  en({ reflect: !0, type: Boolean })
], Pt.prototype, "muted", 2);
Ut([
  en({ reflect: !0, type: Boolean })
], Pt.prototype, "skeleton", 2);
Ut([
  en({ reflect: !0, type: Boolean })
], Pt.prototype, "fallback", 2);
Ut([
  en({ attribute: "show-controls", reflect: !0, type: Boolean })
], Pt.prototype, "showControls", 2);
Ut([
  Kn()
], Pt.prototype, "autoPlayTimeout", 2);
Ut([
  Ad(["src", "poster", "loop", "autoplay", "showControls", "muted"])
], Pt.prototype, "handleSetupPlayer", 1);
Ut([
  Ad("src")
], Pt.prototype, "handleSrcChange", 1);
Ut([
  Ad(["width", "height", "videoWidth", "videoHeight", "isLoaded"])
], Pt.prototype, "handleSizeChange", 1);
Pt = Ut([
  cx("cx-video")
], Pt);
export {
  Pt as default,
  SL as isFirefox
};
